342826*07*apython14320*111*built_in.py#encoding='utf-8'
from apython.ex_func import *
class bcolors:
    OK = "[92m"  # GREEN
    WARNING = "[93m"  # YELLOW
    FAIL = "[91m"  # RED
    RESET = "[0m"  # RESET COLOR
def built_in_operator(obj,op):
    stype = str(type(obj))
    if stype=="<class 'str'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='format':return obj.format
        elif op=='encode':return obj.encode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='casefold':return obj.casefold
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='format_map':return obj.format_map
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdecimal':return obj.isdecimal
        elif op=='isdigit':return obj.isdigit
        elif op=='isidentifier':return obj.isidentifier
        elif op=='islower':return obj.islower
        elif op=='isnumeric':return obj.isnumeric
        elif op=='isprintable':return obj.isprintable
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'list'>":
        if op=='append':return obj.append
        elif op=='pop':return obj.pop
        elif op=='count':return obj.count
        elif op=='remove':return obj.remove
        elif op=='insert':return obj.insert
        elif op=='clear':return obj.clear
        elif op=='copy':return obj.copy
        elif op=='index':return obj.index
        elif op=='extend':return obj.extend
        elif op=='reverse':return obj.reverse
        elif op=='sort':return obj.sort
    elif stype=="<class 'tuple'>":
        if op=='index':return obj.index
        elif op=='count':return obj.count
    elif stype=="<class 'dict'>":
        if op=='pop':return obj.pop
        elif op=='get':return obj.get
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='keys':return obj.keys
        elif op=='fromkeys':return obj.fromkeys
        elif op=='items':return obj.items
        elif op=='popitem':return obj.popitem
        elif op=='setdefault':return obj.setdefault
        elif op=='values':return obj.values
    elif stype=="<class 'bytes'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='decode':return obj.decode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdigit':return obj.isdigit
        elif op=='islower':return obj.islower
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'set'>":
        if op=='pop':return obj.pop
        elif op=='add':return obj.add
        elif op=='remove':return obj.remove
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='difference':return obj.difference
        elif op=='difference_update':return obj.difference_update
        elif op=='discard':return obj.discard
        elif op=='intersection':return obj.intersection
        elif op=='intersection_update':return obj.intersection_update
        elif op=='isdisjoint':return obj.isdisjoint
        elif op=='issubset':return obj.issubset
        elif op=='issuperset':return obj.issuperset
        elif op=='symmetric_difference':return obj.symmetric_difference
        elif op=='symmetric_difference_update':return obj.symmetric_difference_update
        elif op=='union':return obj.union
    elif stype=="<class '_io.TextIOWrapper'>":
        if op=='write':return obj.write
        elif op=='tell':return obj.tell
        elif op=='read':return obj.read
        elif op=='close':return obj.close
        elif op=='seek':return obj.seek
        elif op=='fileno':return obj.fileno
        elif op=='flush':return obj.flush
        elif op=='isatty':return obj.isatty
        elif op=='readable':return obj.readable
        elif op=='readline':return obj.readline
        elif op=='readlines':return obj.readlines
        elif op=='seekable':return obj.seekable
        elif op=='truncate':return obj.truncate
        elif op=='writable':return obj.writable
        elif op=='writelines':return obj.writelines
        elif op=='__enter__':return obj.__enter__
        elif op=='__exit__':return obj.__exit__
    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>
        module_name=obj.module_name
        if module_name=="time":
            if op=='time':return time.time
            elif op=='sleep':return time.sleep
            elif op=='ctime':return time.ctime
            elif op=='localtime':return time.localtime
            elif op=='gmtime':return time.gmtime
            elif op=='mktime':return time.mktime
            elif op=='asctime':return time.asctime
            elif op=='strftime':return time.strftime
            elif op=='strptime':return time.strptime
        elif module_name=="math":
            if op=='pi':return math.pi
            elif op=='e':return math.e
            elif op=='ceil':return math.ceil
            elif op=='floor':return math.floor
            elif op=='copysign':return math.copysign
            elif op=='fabs':return math.fabs
            elif op=='fmod':return math.fmod
            elif op=='fsum':return math.fsum
            elif op=='gcd':return math.gcd
            elif op=='pow':return math.pow
            elif op=='sqrt':return math.sqrt
            elif op=='factorial':return math.factorial
            elif op=='degrees':return math.degrees
            elif op=='radians':return math.radians
            elif op=='sin':return math.sin
            elif op=='cos':return math.cos
            elif op=='tan':return math.tan
            elif op=='asin':return math.asin
            elif op=='acos':return math.acos
            elif op=='atan':return math.atan
            elif op=='exp':return math.exp
            elif op=='log':return math.log
            elif op=='log1p':return math.log1p
            elif op=='log2':return math.log2
            elif op=='log10':return math.log10
            elif op=='isclose':return math.isclose
            elif op=='isfinite':return math.isfinite
            elif op=='isinf':return math.isinf
            elif op=='isnan':return math.isnan
        elif module_name=="os":
            if op=='getcwd':return os.getcwd
            elif op=='listdir':return os.listdir
            elif op=='mkdir':return os.mkdir
            elif op=='chdir':return os.chdir
            elif op=='rmdir':return os.rmdir
            elif op=='open':return os.open
            elif op=='write':return os.write
            elif op=='rename':return os.rename
            elif op=='remove':return os.remove
            elif op=='stat':return os.stat
            elif op=='close':return os.close
            elif op=='path':return os.path
            elif op=='system':return os.system
            elif op=='walk':return os.walk
            elif op=='environ':return os.environ
            elif op=='_exit':return os._exit
        elif module_name=="os.path":
            if op=='isdir':return os.path.isdir
            elif op=='isfile':return os.path.isfile
            elif op=='abspath':return os.path.abspath
            elif op=='basename':return os.path.basename
            elif op=='dirname':return os.path.dirname
            elif op=='exists':return os.path.exists
            elif op=='getatime':return os.path.getatime
            elif op=='getmtime':return os.path.getmtime
            elif op=='getctime':return os.path.getctime
            elif op=='getsize':return os.path.getsize
            elif op=='isabs':return os.path.isabs
            elif op=='join':return os.path.join
            elif op=='realpath':return os.path.realpath
            elif op=='relpath':return os.path.relpath
            elif op=='samefile':return os.path.samefile
            elif op=='sameopenfile':return os.path.sameopenfile
            elif op=='samestat':return os.path.samestat
            elif op=='split':return os.path.split
            elif op=='splitext':return os.path.splitext
        elif module_name=="sys":
            if op=='argv':return sys.argv
            elif op=='platform':return sys.platform
            elif op=='version_info':return sys.version_info
            elif op=='path':return sys.path
            elif op=='stdin':return sys.stdin
            elif op=='stdout':return sys.stdout
            elif op=='stderr':return sys.stderr
            elif op=='displayhook':return sys.displayhook
            elif op=='exceptionhook':return sys.exceptionhook
            elif op=='setrecursionlimit':return sys.setrecursionlimit
            elif op=='setswitchinterval':return sys.setswitchinterval
            elif op=='settrace':return sys.settrace
            elif op=='setprofile':return sys.setprofile
        elif module_name=="random":
            if op=='seed':return random.seed
            elif op=='getstate':return random.getstate
            elif op=='setstate':return random.setstate
            elif op=='getrandbits':return random.getrandbits
            elif op=='randrange':return random.randrange
            elif op=='randint':return random.randint
            elif op=='choice':return random.choice
            elif op=='choices':return random.choices
            elif op=='shuffle':return random.shuffle
            elif op=='sample':return random.sample
            elif op=='random':return random.random
            elif op=='uniform':return random.uniform
            elif op=='triangular':return random.triangular
            elif op=='betavariate':return random.betavariate
            elif op=='expovariate':return random.expovariate
            elif op=='gammavariate':return random.gammavariate
            elif op=='gauss':return random.gauss
            elif op=='lognormvariate':return random.lognormvariate
            elif op=='normalvariate':return random.normalvariate
            elif op=='vonmisesvariate':return random.vonmisesvariate
            elif op=='paretovariate':return random.paretovariate
            elif op=='weibullvariate':return random.weibullvariate
        elif module_name=="socket":
            if op=='socket':return socket.socket
            elif op=='AF_INET':return socket.AF_INET
            elif op=='SOCK_STREAM':return socket.SOCK_STREAM
            elif op=='gethostname':return socket.gethostname
            elif op=='gethostbyname':return socket.gethostbyname
            elif op=='SOL_SOCKET':return socket.SOL_SOCKET
            elif op=='SO_REUSEADDR':return socket.SO_REUSEADDR
    obj_name=obj.__name__
    if op=="__name__":return obj_name
    if obj_name=="localtime":
        if op=='tm_year':return obj.tm_year
        elif op=='tm_mon':return obj.tm_mon
        elif op=='tm_mday':return obj.tm_mday
        elif op=='tm_hour':return obj.tm_hour
        elif op=='tm_min':return obj.tm_min
        elif op=='tm_sec':return obj.tm_sec
        elif op=='tm_wday':return obj.tm_wday
    elif obj_name=="socket":
        if op=='bind':return obj.bind
        elif op=='listen':return obj.listen
        elif op=='accept':return obj.accept
        elif op=='send':return obj.send
        elif op=='recv':return obj.recv
    print(f'{bcolors.FAIL}apython built_in error:\n    {obj} has no attribute {op} {bcolors.RESET}')
    raise Exception
15444*17*code.pyfrom apython.executer import Undefine
class Code:
    def __init__(self):
        self.tem=('AX','BX')
        self.clean()
    def clean(self):
        self.code=[]
        self.comments=[]
        self.simplify=0
        self.base_num=[]      #åŸºåº•æ•¸å€¼(ä¾æ“šæª”æ¡ˆ) #(namecode,[0,0,0])
        self.base_esp=-1
        self.file_ed=[]
        self.base=(0,0,0)
    def __apply_file(self,name):
        if name not in self.file_ed:
            self.file_ed.append(name)
        return self.file_ed.index(name)
    def add_newtab(self,name):
        namecode=self.__apply_file(name)
        self.base_num.append((namecode,[0]))
    def del_newtab(self):
        del self.base_num[-1]
    def add_tab(self):
        #print('add_tab')
        pass
       # self.base_num[self.base_esp][1].append(0)
    def del_tab(self):
        pass
        #print('del_tab')
      #  del self.base_num[self.base_esp][1][-1]
    def get_error_msg(self,row):    #ç²å–éŒ¯èª¤è¨Šæ¯
        if row<len(self.comments):
            cmt_n=self.comments[row][0][2]
            cmt=self.comments[cmt_n]
       #  print(self.comments[cmt_n-1],self.comments[cmt_n],self.comments[cmt_n+1])
            return {'file':self.file_ed[cmt[0][0]],'row':cmt[0][1],'code':cmt[1]}
        else:
            return {'file':'','row':row,'code':self.code[row]}
    def append(self,command,comment=None,simplify=0):
        if comment != None and comment[0]!='':
           # print(command,comment)
            cmt, row = comment
            self.base_num[self.base_esp][1][-1] = row
            real_row = sum(self.base_num[self.base_esp][1])  # å¯¦éš›åœ¨ç¨‹å¼ç¢¼ä¸­çš„è¡Œ
            namecode=self.base_num[self.base_esp][0]
            self.base = (namecode,real_row,len(self.comments))
            self.comments.append((self.base,cmt))     #(æª”æ¡ˆåç¨±ï¼Œç¬¬å¹¾è¡Œ)ï¼ŒåŸå§‹å‘½ä»¤
        if command=='':return
        if self.simplify==0 and simplify==0 and comment==None and len(self.code)>0 and type(command)==str and type(self.code[-1])==str:
            last=self.code[-1].split(' ')
            cmd=command.split(' ')
            if last[0]=='push' and cmd[0]=='pop':
                del self.code[-1]
                if last[1]!=cmd[1]:
                    self.code.append(f'mov {cmd[1]} {last[1]}')
            elif last[0] == 'pop' and cmd[0] == 'push' and last[1]==cmd[1]:
                del self.code[-1]
                if last[1] not in self.tem:
                    self.code.append(f'mov {last[1]} <esp+1>')
            elif last[0]=='mov' and cmd[0]=='push' and last[1]==cmd[1] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'push {last[2]}')
            elif last[0]=='pop' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'pop {cmd[1]}')
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[2]==cmd[1]:
                pass
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:      #ä¸‹ä¸€è¡Œå¯èƒ½æ˜¯åˆ¥äººè·³çš„ï¼Œå› æ­¤ç„¡æ³•ç°¡åŒ–
                del self.code[-1]
                self.code.append(f'mov {cmd[1]} {last[2]}')
            elif cmd[0] in ('add','sub') and cmd[2]=='0':
                pass
            else:
                self.code.append(command)
        else:
            self.code.append(command)
        if self.simplify>0:self.simplify-=1
        self.simplify+=simplify
        if len(self.code) > len(self.comments):
            self.comments.append((self.base, ''))
    def display(self,now_ip=-1):
        print('--------------------------------')
        Row=len(self.code)
        if now_ip<Row and now_ip!=-1 and now_ip<len(self.comments):
            now_row=self.comments[now_ip][0][2]
        else:now_row=Row
        for i in range(Row):
            statement=(' â— ' if now_ip == i else '   ')+str(i)+ ' ' * (4 - len(str(i)))+'|'+self.code[i]
            #if now_ip==i:
             #   statement="[93m"+statement+"[0m"
            space=' '*70
            cmt = self.comments[i]
            if cmt[1]!='':   #è¦matchåˆ°æ‰æœƒprint
                orig_code=(' â— ' if i== now_row else '   ')+str(cmt[0][1])+ ' ' * (4 - len(str(i)))+'| '+cmt[1]
            else:orig_code=''
            print(space+orig_code[:40]+'\r'+statement)
            if i>100:
                print('row more than 100')
                break
        print('--------------------------------')
    def parse_code(self,start_row=0,reset=True):                    #è§£æç‚ºé©åˆåŸ·è¡Œçš„æ ¼å¼
        def deal_string(codeline,k):  # kç‚º',"çš„ä½ç½®
            c = codeline[k]
            k+=1
            p = k
            while True:
                if codeline[k] == '\\':
                    k += 1
                elif codeline[k] == c:
                    break
                k += 1
            return c+codeline[p:k]+c,k
        def login_item(item):
            if item not in self.data_dict:
                if len(self.data)-self.data_n<100:
                    self.data+=[Undefine()]*1024
                self.data_dict[item]=self.data_n
                if item[0] in ('"',"'"):
                    string=item[1:-1]
                    if item[0]=='"':
                        rbox = {'\\n':'\n','\\r':'\r','\\t':'\t','\\a':'\a','\\b':'\b','\\f':'\f','\\v':'\v','\\"':'"','\\\'':'\'','\\\\':'\\'}
                        k,n=0,len(string)
                        text_box=[]
                        while k<n:
                            if string[k]=='\\' and string[k:k+2] in rbox:
                                text_box.append(rbox[string[k:k+2]])
                                k+=1
                            else:text_box.append(string[k])
                            k+=1
                        string=''.join(text_box)
                    self.data[self.data_n]=string
                elif item[0] in '0123456789-':
                    if '.' in item:self.data[self.data_n]=float(item)
                    else:self.data[self.data_n]=int(item)
                self.data_n+=1
            return self.data_dict[item]
        cmd_dict={'mov':(0,2),
                  '$mov':(1,3),               #$mov AX op BX  #AX+=BX
                  'oper':(2,3),               #oper AX op BX  #AX=AX+BX             #'add','sub','mul','div','pow','quo','rem','address'
                  'cmp':(3,2),                #ZR=AX-BX
                  'jmp':(4,1),               #jmp ip
                  '$jmp':(5,2),              #$jmp ip ">"  #ZRå¤§æ–¼0å‰‡è·³
                  'call':(6,1),              #å‘¼å«å‡½æ•¸
                  'push':(7,1),'pop':(8,1),
                  'tf':(9,3),                 #tf AX "ctn" BX    #åˆ¤æ–·çœŸå‡      'ctn','equ','Ctn','is',
                  'inc':(10,1),'dec':(11,1),
                  '$oper':(12,2),              #$oper AX "op" BX                       #'neg','NEG','not'
                  'ex_func':(13,3),           #ex_fuunc AX "str" BX  #AX=str(BX)       #'iter'
                  'try':(14,1),'finally':(15,1),'raise':(16,1),'error':(17,1),
                  'Generator':(18,-1),'Yield':(19,0),'fetch':(20,2),
                  'stop':(21,0),'end':(22,-1),
                  'byte':(23,2),'del':(24,3),'Function':(25,-1),
                  'global':(26,0),'namespace':(28,3),'pass':(26,0),     #globalä¸äºˆç†æœƒ
                  '*args':(29,3),'**kwargs':(30,3),'module':(31,2),
                  'type':(32,2),'name':(33,2),'repl_print':(34,1)}
        #-----------------------------------------------------
        if reset:
            self.data_dict={'AX':0,'BX':1,'CX':2,'DX':3,'ip':4,'esp':5,'sp':6,'ZR':7,'TF':8,
                       '*args':9,'**kwargs':10,'$Exception':11,
                       'True':12,'False':13,'None':14,'$Inheritance':15}
            self.data_n = len(tuple(self.data_dict))
            self.data=[None]*self.data_n
            self.data+=[Undefine()]*1024
            self.data[12]=True
            self.data[13]=False
            self.data[14]=None
            self.data[15]=None
            self.parse_codes=[]
        else:
            self.data_n = len(tuple(self.data_dict))                              #dataé–‹å§‹ç™»è¨˜çš„ä½ç½®
        #print('data_n:',self.data_n)
        ROW=len(self.code)-1
        start_row-=1
        #print('code:',self.code)
        #print('start_row:',start_row)
        while start_row<ROW:
            start_row+=1
            line=self.code[start_row]
            if line=='':          #lineç‚ºç©º
                self.parse_codes.append([26])     #ä¸äºˆç†æœƒç©ºline
                continue
            op=line.split(' ')[0]
            cmd=cmd_dict[op]
            deal = [cmd[0]]
            k=len(op)+1
            fetch_k=0
            while fetch_k<cmd[1] or (cmd[1]==-1 and k<len(line)):
                if line[k] in ('"',"'"):                       #å¿…å®šç‚ºå­—ä¸²
                    string,k=deal_string(line,k)          #kç‚º"çš„ä½ç½®
                    if fetch_k==1:
                        if op in ('$mov','oper'):
                            op_num=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='tf':
                            op_num = ('in','equ','Ctn','is').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='$oper':
                            op_num = ('not','-','~').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        else:
                            deal.append((0, login_item(string)))
                    else:
                        deal.append((0,login_item(string)))
                    k+=2
                elif line[k] in '0123456789-':                  #å¿…å®šç‚ºæ•¸å€¼
                    k2=k
                    while k2<len(line) and line[k2] in '-0123456789.':k2+=1
                    number=line[k:k2]
                    deal.append((0,login_item(number)))
                    k=k2+1
                elif line[k]=='[':                    #æ­¤è™•ç‚º[value]é¡å‹ï¼Œé variable[value] é¡å‹ï¼Œå› æ­¤[]ä¸­åªèƒ½æ˜¯int,dict,class
                    k2=line.index(']',k)
                    value=line[k+1:k2]
                    if value=='dict':                   #11:dict
                        deal.append((11,-1))
                    elif value=='class':                #13:class
                        deal.append((13,-1))
                    elif value=='func':                 #16:func
                        deal.append((16,-1))
                    else:                                #10:list
                        deal.append((10,int(value)))
                    k=k2+2
                elif line[k]=='(':             #è¦æ±‚[number]        #12:tuple
                    k2=line.index(')',k)
                    deal.append((12,int(line[k+1:k2])))   #tupleå®£å‘Š
                    k=k2+2
                else:
                    typebox=''
                    if line[k]=='<':
                        k2=line.index('>',k)
                        name=line[k+1:k2]
                        if '+' in name:
                            c=name.split('+')
                            result=[c[0],int(c[1])]
                        else:result=[name,0]
                        k2+=1
                        if result[0]=='esp':
                            typebox+='1'                                   #<esp+k>:1
                            result[0] = login_item(result[0])
                        else:
                            #result[0] = login_item(result[0])            #æ­¤è™•ä¸é€²è¡Œç™»è¨˜ï¼Œå› ç‚ºfunc_nameè¦ä½œç‚ºkeyä½¿ç”¨
                            typebox='2'                                   #<func+k>:2
                    else:                                                  #name:0
                        k2=k
                        while k2<len(line) and line[k2] not in '[ .':k2+=1
                        result=[line[k:k2]]
                        typebox+='0'
                        result[0] = login_item(result[0])
                    k=k2+1
                    #----------------
                    #[],{},()æŒ‡ä»¤

                    if k2 < len(line) and line[k2] == '.':             # ä»£è¡¨æ˜¯å­å±¬æ€§ï¼Œ'.':0
                        k2+=1
                        while k2 < len(line) and line[k2] not in '[ .': k2 += 1
                        attr=line[k:k2]
                        result.append(attr)
                        typebox+='0'
                        k=k2+1
                    if k2<len(line) and line[k2]=='[':                        #ä»£è¡¨æ˜¯ç´¢å¼•ï¼Œ[key]:1
                        if line[k2+1] in ('"', "'"):           #å…§å®¹æ˜¯å­—ä¸²
                            value, k3 = deal_string(line,k2+ 1)
                            result.append(login_item(value))
                            k3+=1            #k3ç§»å‹•åˆ°]çš„ä½ç½®
                        else:
                            k3=line.index(']',k2)
                            value=line[k2+1:k3]
                            result.append(login_item(value))
                        typebox += '1'
                        k=k3+2
                    if typebox=='0':                    #ç´”åå­—                #name
                        deal.append((0,result[0]))
                    elif typebox=='00':                                       #name.attr
                        deal.append((1,result[0],result[1]))
                    elif typebox=='01':                                       #name[key]
                        deal.append((2, result[0], result[1]))  # name[key]
                    elif typebox=='1':                                       #<esp+k>
                        deal.append((3, result[0], result[1]))
                    elif typebox=='10':                                       #<esp+k>.attr
                        deal.append((4,result[0],result[1],result[2]))
                    elif typebox=='11':                                       #<esp+k>[key]
                        deal.append((5,result[0],result[1],result[2]))
                    elif typebox=='2':                                       #<func+k>
                        deal.append((6, result[0], result[1]))
                    elif typebox=='20':                                       #<func+1>.attr
                        deal.append((7,result[0],result[1],result[2]))
                    elif typebox=='21':                                       #<func+k>[key]
                        deal.append((8,result[0],result[1],result[2]))
                fetch_k+=1
            self.parse_codes.append(deal)
        return self.parse_codes,self.data,self.data_dict
    def __len__(self):
        return len(self.code)
    def __getitem__(self, item):
        return self.code[item]
    def __setitem__(self, key, value):
        self.code[key]=value
    #def __delitem__(self, key):        #æœ¬ç¨‹å¼è‡ªå‹•å„ªåŒ–ï¼Œå‹¿del
     #   del self.code[key]8435*112*ebuilt_in.pyfrom os import system
built_in=\
{
    "<class 'str'>":
        {
            'attr':'',
            'example':"'hello'",
            'function':'join,count,split,index,format,encode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'list'>":
        {
            'attr':'',
            'example':"[1,2,3]",
            'function':'append,pop,count,remove,insert,clear,copy,index,extend,reverse,sort'
        },
    "<class 'tuple'>":
        {
            'attr':'',
            'example':"(1,5,9)",
            'function':'index,count'
        },
    "<class 'dict'>":
        {
            'attr':'',
            'example':"{1:2,3:4}",
            'function':'pop,get,copy,clear,update,keys,fromkeys,items,popitem,setdefault,values'
        },
    "<class 'bytes'>":
        {
            'attr':'',
            'example':"b'hell'",
            'function':'join,count,split,index,format,decode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'set'>":
        {
            'attr':'',
            'example':"{1,2,3,4}",
            'function':'pop,add,remove,copy,clear,update,difference,difference_update,discard,intersection,intersection_update,'
                       'isdisjoint,issubset,issuperset,symmetric_difference,symmetric_difference_update,union'
        },
    "<class '_io.TextIOWrapper'>":
        {
            'attr':'name,encoding,mode,buffer,closed,errors,line_buffering,newlines',
            'example':"open('newtext.txt','w')",
            'function':'write,tell,read,close,seek,fileno,flush,isatty,readable,readline,readlines,seekable,truncate,writable,writelines,'
                       '__enter__,__exit__'
        },
    "<class 'builtin_function_or_method'>":
        {
            'attr':'__name__',
            'example':"print",
            'function':''
        }
}
build_template='''
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\\nfrom apython.ex_func import *\\n")
    g.write('class bcolors:\\n    OK = "\033[92m"  # GREEN\\n    WARNING = "\033[93m"  # YELLOW\\n    FAIL = "\033[91m"  # RED\\n    RESET = "\033[0m"  # RESET COLOR\\n')
    g.write("def built_in_operator(obj,op):\\n    stype = str(type(obj))\\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\\n')
            else:
                g.write(f'    elif stype=="{stype}":\\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\\'{item}\\':return obj.{item}\\n')
                else:
                    g.write(f'        elif op==\\'{item}\\':return obj.{item}\\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\\n        module_name=obj.module_name\\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            else:
                g.write(f'            elif op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\\n')
        k += 1
    g.write('    obj_name=obj.__name__\\n    if op=="__name__":return obj_name\\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            else:
                g.write(f'        elif op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\\\n    {obj} has no attribute {op} {bcolors.RESET}')\\n    raise Exception\\n")
    g.close()
build()
'''
def test_and_build():
    f=open('test_error.txt','w',encoding='utf-8')
    f.write("#encoding='utf-8'\ndatas=[]")
    k=1
    for key in built_in:
        data=built_in[key]
        f.write(f'\ntype{k}="{key}"')
        f.write(f'\nexample{k}='+data['example'])
        f.write(f'\nabox{k}=[]')
        f.write(f'\nfbox{k}=[]')
        if data['attr'] != '':
            attrs = data['attr'].split(',')
            for item in attrs:
                f.write(f'\ntry:\n    abox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        if data['function']!='':
            functions = data['function'].split(',')
            for item in functions:
                f.write(f'\ntry:\n    fbox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        f.write(f'\ndatas.append((type{k},abox{k},fbox{k}))')
        k+=1
    f.write(build_template)
    f.close()
test_and_build()
system('py test_error.txt')41704*111*executer.pyfrom apython.built_in import *
class Undefine:
    def __init__(self):
        self.Fail = "[91m"
        self.RESET = "[0m"
    def __str__(self):
        return f'{self.Fail}<undefined>{self.RESET}'
class class_obj:
    def __init__(self,ram):
        self.ram=ram
        self.atype=None
        self.vars={}
        self.print_lock=0        #0:é€²è¡Œé‹ç®—ï¼Œ1:ç›´æ¥å›å‚³<The class obj>
    def __str__(self):
        if self.print_lock==0 and '__str__' in self.vars:
            return self.ram.call_obj_function(self,[],'__str__')
        return '<class_obj>'
    def __add__(self, other):
        if self.print_lock==0 and '__add__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__add__')
    def __sub__(self, other):
        if self.print_lock==0 and '__sub__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__sub__')
    def __len__(self):
        if self.print_lock==0 and '__len__' in self.vars:
            return self.ram.call_obj_function(self,[],'__len__')
    def __setitem__(self, key, value):
        if self.print_lock==0 and '__setitem__' in self.vars:
            return self.ram.call_obj_function(self,[key,value],'__setitem__')
    def __getitem__(self, item):
        if self.print_lock==0 and '__getitem__' in self.vars:
            return self.ram.call_obj_function(self,[item],'__getitem__')
    def __contains__(self, item):
        if self.print_lock == 0 and '__contains__' in self.vars:
            return self.ram.call_obj_function(self, [item], '__contains__')
    def __next__(self):
        if self.print_lock == 0 and '__next__' in self.vars:
            return self.ram.call_obj_function(self, [], '__next__')
        elif '__getitem__' in self.vars:
            self.error=False
            self.item_k += 1
            return self.__getitem__(self.item_k)
    def __iter__(self):
        self.item_k=-1
        if self.print_lock == 0 and '__iter__' in self.vars:
            return self.ram.call_obj_function(self, [], '__iter__')
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.print_lock == 0 and '__exit__' in self.vars:
            return self.ram.call_obj_function(self, [exc_type,exc_val,exc_tb], '__exit__')
    def __call__(self, *args, **kwargs):
        if self.print_lock == 0 and '__call__' in self.vars:
            return self.ram.call_obj_function(self, args, '__call__',kwargs)
    def __del__(self):
        if self.print_lock == 0 and '__del__' in self.vars:
            return self.ram.call_obj_function(self, [], '__del__')
    def __eq__(self, other):
        if self.print_lock == 0 and '__eq__' in self.vars:
            return self.ram.call_obj_function(self, [other], '__eq__')
class Func:
    def __init__(self,ram,ip,class_obj,func_var,stack_len,import_funcs):
        self.name='Function'
        self.atype='Function'
        self.ram=ram
        self.vars={'ip':ip,'class_obj':class_obj}
        self.stack_name=func_var
        self.stack_len=stack_len
        self.import_funcs=import_funcs
    def __str__(self):
        return str(self.name)
    def __call__(self, *args, **kwargs):                 #ç”±å…§éƒ¨æˆ–å¤–éƒ¨å‡½æ•¸(ex_function)å‘¼å«
        self.ram.data[self.ram.args_location] = args
        self.ram.data[self.ram.kwargs_location] = kwargs
        result=self.ram.func_run(self.vars['ip'],self.vars['class_obj'],self.stack_name,self.stack_len,self.import_funcs)    #ipå›ºå®šï¼Œclass_objå’Œex_boxéƒ½æ˜¯ä½å€å®šç¾©ï¼Œå› æ­¤ä¸ç”¨æ¥å—è¿”é‚„å€¼
        return result
class generator:
    def __init__(self,ram,start_ip,import_funcs):
        self.ram=ram
        self.next_ip=start_ip
        self.import_funcs = import_funcs
        #self.params=params
        #self.locals=locals
        self.ex_stack=[]                 #ç¨‹å¼ä¸­æ–·æ™‚å¯èƒ½æœ‰è¶…å‡ºçš„å †ç–Š
        #self.ex_box=ex_box                   #çˆ¶å‡½æ•¸å€‘çš„è³‡æ–™å…§å®¹ï¼Œ[(loc,stack),...]
        #self.orig_local_len=len(locals)
        #self.base_location=base_location
        self.enter=0                           #ç•¶enter=1æ™‚ï¼Œä»£è¡¨å·²ç¶“é­é‡äº†stopiteration
        self.next_lock=True                    #åœ¨sendå‰éœ€è¦å…ˆå•Ÿå‹•next
        self.send=False
        self.send_obj=None
        self.finally_box=[]                    #å¦‚æœç¨‹å¼åœ¨æœ‰finallyçš„tryä¸­è·³å‡ºï¼Œä¸¦ä¸”è‡ªå·±è¢«delï¼Œå‰‡ä¾åºåŸ·è¡Œfinallyboxä¸­çš„å…§å®¹
        def send(value):
            if not self.next_lock:
                self.send=True
                self.send_obj=value
                return self.__next()
            raise TypeError("can't send non-None value to a just-started generator")
        self.vars={'send':send}
    def __str__(self):
        return '<generator_obj>'
    def __getitem__(self, item):
        return self.__next()
    def __next__(self):
        self.next_lock=False
        if self.send:
            self.send_obj =None               #åœ¨å•Ÿç”¨sendä¹‹å¾Œï¼Œå¿…å®šè¦å‚³çµ¦AXå€¼
        return self.__next()
    def __next(self):
        if self.enter==1:    #ä»£è¡¨ä¹‹å‰é€²å…¥å»ä¹‹æ•—äº†
            raise StopIteration
        else:
            self.enter=1
            if not self.send:
                next_obj,self.ex_stack,yield_result,base_esp= self.ram.yield_run(self.next_ip,self.ex_stack, self.import_funcs)
            else:
                next_obj, self.ex_stack, yield_result, base_esp = self.ram.yield_run(self.next_ip, self.ex_stack,self.import_funcs,send_obj=self.send_obj)
             #print('å–å¾—çµæœ:',yield_result)
           # print('ex_stack',self.ex_stack)
            if next_obj!=None:
                self.next_ip,finally_box=next_obj
                for f_ip in finally_box:
                    if f_ip[0]>-1:
                        ex_stack_num=base_esp-f_ip[1]       #åŸºåº•å †ç–Šé‡èˆ‡é€²å…¥tryæ™‚å †ç–Šé‡çš„å·®
                        self.finally_box.append([f_ip[0],ex_stack_num])
                    else:
                        for fip in self.finally_box:          #åŒå€‹finallyå°±åˆªæ‰
                            if fip[0]==abs(f_ip[0]):
                                self.finally_box.remove(fip)
                                break
                self.enter=0
                return yield_result
            raise StopIteration
    def __del__(self):
       # print('del:',self.finally_box)
        for f_ip in self.finally_box:
           # print(f_ip)
            #å°‡å †ç–ŠåŒä½
            self.ram.data[self.ram.ip]= f_ip[0]+1
            # --------------------------------------------
            tem_stacks = {}
            for func_name in self.import_funcs:
                tem_stacks[func_name] = self.ram.func_stack[func_name]
                self.ram.func_stack[func_name] = self.import_funcs[func_name]
            for i in range(f_ip[1]):    #åŸå§‹localé‡+ex_stack
                self.ram.push(self.ex_stack[i])
            #self.ram.data[self.base_location] = self.ram.data[self.ram.esp]        #<stack_esp>
            self.ram.push(None)           #ç‚ºäº†ç¬¦åˆfinallyçš„å †ç–Šæ ¼å¼
            self.ram.push(1)
            # --------------------------------------------
            #self.ram.tf=1
            try:
                self.ram.one_run('finally yield run')
            except Exception as e:
                print(e)
            finally:
                for func_name in tem_stacks:
                    self.ram.func_stack[func_name] = tem_stacks[func_name]
         #   print('run finish')
def fetch_error(e):
    stype = str(type(e))
    k = stype.index("'")
    k2 = stype.index("'", k + 1)
    return stype[k + 1:k2]
def atype(obj):
    if type(obj)==class_obj:
        return obj.atype
    elif type(obj)==Func:
        return f"<class '__main__.{obj.name}'>"
    return type(obj)     #string,list,int,tuple,...
def aprint(*args,**kwargs):
    text_box=[]
    for obj in args:
        text_box.append(str(obj))
    text=' '.join(text_box)
    if 'end' in kwargs:
        total_output.append(text+kwargs['end'])
    else:
        total_output.append(text+'\n')
total_output=[]
built_in_functions=[abs,all,any,ascii,bin,bool,breakpoint,bytearray,bytes,callable,chr,classmethod,compile,complex,
                    delattr,dict,dir,divmod,enumerate,eval,exec,filter,float,format,frozenset,getattr,globals,hasattr,hash,hex,
                    id,input,int,isinstance,issubclass,iter,len,list,locals,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,
                    range,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,vars,zip]
Error_class=[NameError,IndexError,TypeError,SyntaxError,ValueError,KeyboardInterrupt,AssertionError,Exception,RecursionError,
             KeyError,ZeroDivisionError,AttributeError,IndentationError ,UnboundLocalError]
else_built_in=[StopIteration,StopAsyncIteration,SyntaxWarning,FileNotFoundError,ModuleNotFoundError]
bifs={
   # 'help':help,             #æ‰“åŒ…æˆexeæ™‚ï¼Œhelpæœƒç„¡æ•ˆ
    'IOError':IOError,
    'type':atype       #helpæ²’æœ‰name,IOErrorçš„nameç‚ºOSError
      }
for key in built_in_functions+Error_class+else_built_in:
    bifs[key.__name__]=key
class Executer:                                               #è¼‰å…¥ç¨‹å¼ç¢¼èˆ‡è¨˜æ†¶é«”
    def __init__(self,code):
        self.code=code
        self.ex_function=bifs.copy()
        self.run_layer=[]
        self.func_stack={}
    def set(self,var_name,value):
        location=self.data_dict[var_name]
        self.data[location]=value
    def push(self, value):
        self.esp_stack[self.data[self.esp]] = value
        self.data[self.esp]-= 1
    def pop(self):
        self.data[self.esp]+= 1
        return self.esp_stack[self.data[self.esp]]
    def login(self,var_name):
        if var_name in self.var_dict:
            return self.var_dict[var_name]
        self.var_dict[var_name]=self.used_size
        self.used_size+=1
        return self.used_size-1
    def get_var_location(self,var_name):
        return self.var_dict[var_name]
    def pushaw(self):
        for i in range(5):                                #å„²å­˜AX,BX,CX,DX,ipé€²å †ç–Š
            self.esp_stack[self.data[self.esp]]=self.data[i]
            self.data[self.esp]-=1
    def popaw(self):
        for i in range(5):                                #å›å¾©AX,BX,CX,DX,ipé€²å †ç–Š
            self.data[self.esp] += 1
            self.data[4-i]=self.esp_stack[self.data[self.esp]]
    def __setitem__(self,location, value):
     #   print(location,value)
        if location[0]==0:                                                       #name
            self.data[location[1]]=value
        elif location[0]==1:                                                        #name.attr
            self.data[location[1]].vars[location[2]]=value
        elif location[0]==2:                                                             #name[key]
            self.data[location[1]][self.data[location[2]]]=value
        #-----------------------------------------------------------------------------------------------
        elif location[0]==3:                                                             #<esp+k>
            self.esp_stack[self.data[location[1]]+location[2]]=value
        elif location[0]==4:                                                            #<esp+k>
            self.esp_stack[self.data[location[1]] + location[2]].vars[location[3]]=value
        elif location[0]==5:                                                              #<esp+k>[key]
            self.esp_stack[self.data[location[1]]+location[2]][self.data[location[3]]]=value
        # -----------------------------------------------------------------------------------------------
        elif location[0]==6:                                                             #<func+k>
            self.func_stack[location[1]][location[2]]=value
        elif location[0]==7:                                                            #<func+k>
            self.func_stack[location[1]][location[2]].vars[location[3]]=value
        elif location[0]==8:                                                              #<func+k>[key]
            self.func_stack[location[1]][location[2]][self.data[location[3]]]=value
    def call_obj_function(self,obj,args,funcname,kwargs=None):
        tem_esp=self.data[self.esp]
        if kwargs==None:kwargs={}
        self.pushaw()
        self.data[2] = len(args)                                           # CX=len(args)
        func=obj.vars[funcname]
        result=None
        try:
            result=func(*args,**kwargs)
        finally:
            self.popaw()
            self.data[self.esp]=tem_esp
        return result
    def yield_run(self,ip,ex_stack,import_funcs,send_obj=None):
        tem_ip=self.data[self.ip]
        self.data[self.ip]=ip
        #--------------------------------------------
        tem_stacks={}
        for func_name in import_funcs:
            tem_stacks[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        #--------------------------------------------
        tem_esp=self.data[self.esp]       #å„²å­˜ç›®å‰esp
        for ex_obj in ex_stack:
            self.push(ex_obj)
        #--------------------------------------------
        yield_result =None
        ok=False
        try:                                #æ­¤è™•runå¯èƒ½æœƒå™´StopIterationéŒ¯èª¤ï¼Œè‡³å°‘è¦å›æ”¶å †ç–Šã€é‚„åŸip
            self.data[0]=send_obj
            next_obj=self.__run('yield run')
            ok=True
        #--------------------------------------------
        finally:
            del self.run_layer[-1]          #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€é™¤å»yield run
            if ok:
                yield_result=self.data[0]            #ç²å–yieldçš„å€¼
            new_ex_stack=[]
            for i in range(tem_esp-self.data[self.esp]):
                new_ex_stack.insert(0,self.pop())
            # é‚„åŸçˆ¶å‡½æ•¸
            for func_name in tem_stacks:
                self.func_stack[func_name]=tem_stacks[func_name]
            #-------------------------------------------
            self.data[self.ip]=tem_ip
        return next_obj,new_ex_stack,yield_result,tem_esp
    def func_run(self,ip,class_obj,stack_name,stack_len,import_funcs):
        tem_ip = self.data[self.ip]  # ç•¶å‰ip
        tem_esp=self.data[self.esp]
        # --------------------------------------------
        tem_func_stack={}
        for func_name in import_funcs:
            tem_func_stack[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        if stack_name not in self.func_stack:            #è™•ç†å †ç–Šè³‡è¨Š
            self.func_stack[stack_name]=None
        tem_stack=self.func_stack[stack_name]
        # --------------------------------------------
       # self.push(len(self.code))  # æ¨å…¥æœ€å¾Œä¸€è¡Œï¼Œç¨‹å¼åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³æœ€å¾Œä¸€è¡Œ     #push ip
        #å»ºç«‹æ–°functionå †ç–Š
        func_stack=[0]*stack_len
        func_stack[0]=class_obj                 #ç¬¬0ä½ç½®ç‚ºclass_obj
        self.func_stack[stack_name]=func_stack
        #-------------------------------------------------------
        self.data[self.ip] = ip+ 1
        self.push(len(self.code))   #é€™æ¨£pop ipå°±æœƒç›´æ¥return
        result=None
        try:
            self.__run(f'Func<{ip}> run')
        #except Exception as e:
        #    print(e)
        #    raise e
        finally:
            result=self.data[0]
            del self.run_layer[-1]
            self.data[self.ip] = tem_ip
            # é‚„åŸçˆ¶å‡½æ•¸
            self.func_stack[stack_name]=tem_stack
            for func_name in import_funcs:
                self.func_stack[func_name] = tem_func_stack[func_name]
            self.data[self.esp]=tem_esp
        return result
    def __getitem__(self, location):
        #------------------------------------------------------------------------------------------------name
        if location[0] == 0:                                        # name
            return self.data[location[1]]
        elif location[0] == 1:                                       #name.attr
            obj = self.data[location[1]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[2] in obj.vars:
                    return obj.vars[location[2]]
                return self.undefined  # ç™¼ç”ŸéŒ¯èª¤
            elif type(obj)==Undefine:
                raise Exception(f'{self.inverse_data_dict[location[1]]} is undefined')
            elif type(obj)==Ex_module and location[2] in obj.vars:
                return obj.vars[location[2]]
            else:
                func=built_in_operator(obj, location[2])
                return func
        elif location[0] == 2:                                       # name[key]
            return self.data[location[1]][self.data[location[2]]]
        #------------------------------------------------------------------------------------------------<esp+k>
        elif location[0] == 3:                                       #<esp+k>
            return self.esp_stack[self.data[location[1]] + location[2]]
        elif location[0]==4:                                         #<esp+k>.attr
            obj = self.esp_stack[self.data[location[1]] + location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
                raise Exception(f'variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 5:                                         # <esp+k>[key]
            return self.esp_stack[self.data[location[1]] + location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------<func+k>
        elif location[0] == 6:                                       #<func+k>
            return self.func_stack[location[1]][location[2]]
        elif location[0]==7:                                         #<func+k>.attr
            obj =self.func_stack[location[1]][location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
               # ip=self.data[self.ip]
               # print('ip:',ip)
               # start_ip=ip-20
               # error_lines=self.code.code[start_ip:ip+10]
               # for i in range(30):
               #     print(start_ip+i,error_lines[i])
               # print('location:',location)
                raise Exception(f'this variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 8:                                         # <func+k>[key]
            return self.func_stack[location[1]][location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------[object]
        elif location[0]==10:                                          #list
            return [0]*location[1]
        elif location[0]==11:                                          #dict
            return {}
        elif location[0]==12:                                          #tuple
            return [0]*location[1]
        elif location[0] == 13:                                        #<class obj>
            self.class_objs.append(class_obj(self))
            return self.class_objs[-1]
    def __error_print(self,msg):
        Fail="[91m"
        RESET = "[0m"
        print(f'{Fail}{msg}{RESET}')
    def __ok_print(self,msg):
        OK="[92m"
        RESET = "[0m"
        print(f'{OK}{msg}{RESET}')
    def one_run(self,comment):
        self.__run(comment)
    def run(self,tf=0,stack_size=1024,comment='normal'):
        self.codes, self.data, self.data_dict = self.code.parse_code(start_row=0,reset=True)
        self.inverse_data_dict = {}
        for key in self.data_dict:
            self.inverse_data_dict[self.data_dict[key]] = key
        self.stack_size=stack_size
        self.esp_stack= [0] * stack_size
        #-------------------------------------------------------------
        self.set('esp', -1)  # è¨­å®šå †ç–ŠæŒ‡æ¨™
        self.set('ip',0)
        self.esp = self.data_dict['esp']
        self.ip = self.data_dict['ip']
        self.ZR = self.data_dict['ZR']
        self.TF = self.data_dict['TF']
        self.ER=self.data_dict['$Exception']
        self.data[self.ER]=0
        self.error_line=0        #ç™¼ç”ŸéŒ¯èª¤çš„line
        self.args_location = self.data_dict['*args']
        self.kwargs_location = self.data_dict['**kwargs']
        self.class_objs=[]
        self.func_stack={}
        self.undefined=Undefine()
        #--------------------------åˆå§‹åŒ–å¤–éƒ¨å‡½æ•¸
        for name in self.data_dict:
            if name in self.ex_function:
                self.data[self.data_dict[name]]=self.ex_function[name]
        self.normal_run(0,tf,comment)
    def REPL_run(self, row):
        total_output.clear()
        if row==0:
            self.run(0,1024,comment='REPL')
        else:
            self.data[0]=None
            self.codes, self.data, self.data_dict = self.code.parse_code(start_row=row,reset=False)
            for name in self.data_dict:
                if name in self.ex_function:
                    self.data[self.data_dict[name]] = self.ex_function[name]
            for key in self.data_dict:
                self.inverse_data_dict[self.data_dict[key]] = key
            self.normal_run(row,0,'REPL')
        return ''.join(total_output)
    def normal_run(self,row,tf,comment='normal'):
        self.tf=tf
        self.set('esp',-1)
        self.set('ip',row)
        try:
            self.__run(comment)
            if self.data[self.esp] == -1:
                if tf > 0:
                    self.__ok_print('\nç¨‹å¼çµæŸ--------')
            else:
                self.__error_print(f'ç¨‹å¼è­¦å‘Š:å †ç–Šæœªé‚„åŸ---------->   {self.data[self.esp]}')
        except Exception as e:
            if self.data[self.ER] == 0:  # éŒ¯èª¤ä¸æ˜¯ä¾†è‡ªtryï¼ŒéŒ¯èª¤ä¾†è‡ªæ­£å¸¸è¡Œ
                error_ip = self.data[self.ip]
            else:  # éŒ¯èª¤ä¾†è‡ªtry
                error_ip = self.error_line
            if comment!='REPL':
                msg = self.code.get_error_msg(error_ip)
                self.__error_print(f'\nTrackback:\nFILE: ' + msg['file'] + ',  line:' + str(+msg['row']))
                self.__error_print('   ' + msg['code'])
            error = str(e)
            if len(error) > 0: error = ': ' + error
            self.__error_print(fetch_error(e) + error)
            # print('--------------')
            if tf > 0:
                raise e
    def __run(self,run_comment):
        self.run_layer.append(run_comment)
        def obj_lock(lock):
            for obj in self.class_objs: obj.print_lock = lock
        def cpu_state():
            print('data: ', end='')
            for key in self.data_dict:
                if key[0] not in '"0123456789-' + "'" and key not in  ('None','True','False') and key not in self.ex_function:
                    # if type(key) != int and '"' != key[0] and "'" != key[0]:  # å»é™¤æ•¸å€¼å’Œå­—ä¸²
                    print(f'{key}:{self.data[self.data_dict[key]]}', end='  ')
                if key in ('TF', '**kwargs'): print('\n      ', end='')
                if key=='$Exception':print('\n      ', end='')
                if key=='$Inheritance':
                    print('\nè‡ªç”±è®Šæ•¸:\n      ',end='')
            stack_text = '\n\nstack:['
            stack_n = 7
            for i in range(25):
                obj = self.esp_stack[-i - 1]
                get = str(obj) + ','
                if i + 1 < abs(self.data[esp]):
                    stack_n += len(get)
                stack_text += get
            print(stack_text[:-1] + ']')
            print(' ' * stack_n + '^')
            for func_name in self.func_stack:
                print(f'{func_name}: {self.func_stack[func_name]}')
        def get_status():
            obj_lock(1)
            now_ip=self.data[ip]
            self.code.display(now_ip)
            cpu_state()
            print(f'run_layer:{self.run_layer}')
            if now_ip < len(self.codes):
                print('\næº–å‚™åŸ·è¡Œ:', self.code.code[now_ip], '                  å°æ‡‰:', self.codes[now_ip])
                print('-------------------------------')
            else:
                print('ç¨‹åºå·²çµæŸ\n')
            obj_lock(0)
        ip=self.ip
        esp=self.esp
        ZR=self.ZR
        TF=self.TF
        ER=self.ER
        args_location=self.args_location
        kwargs_location=self.kwargs_location
        finally_box=[]
        n=len(self.codes)
        while self.data[ip]<n:
            cmd=self.codes[self.data[ip]]
           # print(f'{self.data[ip]}   {self.code.code[self.data[ip]]}                       {cmd}')
            if self.tf==1:
                get_status()
                a=input()
                if a!='':
                    #print(f'AX:"{self.data[0]}"')
                    if len(a)<3:
                        self.tf=0.5
                    elif a=='asd':
                        print('åµéŒ¯!!--------')
                        self.tf=0.1
                    else:
                        self.__ok_print('ç¨‹å¼é–‹å§‹--------')
                        self.tf=0
            if self.tf==0.1:
                now_ip=self.data[ip]
                msg=' '*60+self.code.comments[now_ip]+f'\r       {self.code.code[now_ip]}\r{now_ip}'
                print(msg)
                #cpu_state()
            #------------------------------------------
            if cmd[0] ==0:#mov
                self[cmd[1]] = self[cmd[2]]
            elif cmd[0]==1: #$mov
                op=self[cmd[2]]
                if op==0:  #add
                    self[cmd[1]] += self[cmd[3]]
                elif op==1: #sub
                    self[cmd[1]] -= self[cmd[3]]
                elif op==2: #mul
                    self[cmd[1]] *= self[cmd[3]]
                elif op==3: #div
                    self[cmd[1]]/=self[cmd[3]]
                elif op==4: #pow
                    self[cmd[1]] **= self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] %= self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] //= self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]<<=self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]>>=self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] &= self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] ^= self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] |=self[cmd[3]]
            elif cmd[0]==2:  #oper
                op = self[cmd[2]]
                if op == 0:  # add
                    self[cmd[1]] =self[cmd[1]]+self[cmd[3]]
                elif op == 1:  # sub
                    self[cmd[1]] =self[cmd[1]]-self[cmd[3]]
                elif op == 2:  # mul
                    self[cmd[1]] =self[cmd[1]]* self[cmd[3]]
                elif op == 3:  # div
                    self[cmd[1]] =self[cmd[1]]/self[cmd[3]]
                elif op == 4:  # pow
                    self[cmd[1]] =self[cmd[1]]**self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] =self[cmd[1]]%self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] =self[cmd[1]]//self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]=self[cmd[1]]<<self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]=self[cmd[1]]>>self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] =self[cmd[1]]&self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] =self[cmd[1]]^self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] =self[cmd[1]] | self[cmd[3]]
            elif cmd[0] == 3:  # cmp ç›¸æ¸›
                self.data[ZR] = self[cmd[1]] - self[cmd[2]]
            elif cmd[0]==4: #jmp
                self.data[ip]=self[cmd[1]]
            elif cmd[0]==5: #$jmp
                op=self[cmd[2]]
                zr=self.data[ZR]
                tf=self.data[TF]
                if (op=='==' and  zr== 0) or (op=='!=' and zr != 0) or (op=='>=' and zr >= 0) or (
                        op=='<=' and zr <= 0) or (op=='>' and zr > 0) or (op=='<' and zr < 0):
                    self.data[ip] = self[cmd[1]]
                elif (op=='t' and tf) or (op=='f' and not tf):
                    self.data[ip] = self[cmd[1]]
            elif cmd[0]==6: #call
                jmp_ip=self[cmd[1]]
               # print('jmp:',jmp_ip)
                if jmp_ip==None:
                    jmp_ip=cmd[1][3]               #[mode,name,offset,key]ï¼Œå–å‡ºkey
                if type(jmp_ip)==Func:   #ä»£è¡¨è¦callå…§éƒ¨function
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    jmp_ip(*args,**kwargs)
                elif type(jmp_ip)==str:              #exfunction
                  #  print('exfunc')
                    args = self.data[args_location]
                    kwargs = self.data[kwargs_location]
                    tem_ip=self.data[ip]
                    self.data[0] = self.ex_function[jmp_ip](*args, **kwargs)  # å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                  #  print('get:',self.data[0])
                    self.data[ip]=tem_ip
                else:                                  #jmp_ipæ˜¯functionæœ¬èº«
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    tem_ip = self.data[self.ip]
                    #-------------------------------------------catch print
                    try:
                        call_func_name=jmp_ip.__name__
                    except:call_func_name=''
                    if call_func_name == 'print':
                        aprint(*args, **kwargs)
                    #-------------------------------------------
                    self.data[0]=jmp_ip(*args,**kwargs)            #å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                    self.data[self.ip] = tem_ip
            elif cmd[0] == 7:#push
                self.esp_stack[self.data[esp]]=self[cmd[1]]
                self.data[esp]-=1
            elif cmd[0] == 8:#pop
                self.data[esp] += 1
                self[cmd[1]]=self.esp_stack[self.data[esp]]
            elif cmd[0]==9:  #tfåˆ¤æ–·çœŸå‡
                event=self[cmd[2]]
                if event==0: #in
                    self.data[TF]=self[cmd[3]] in self[cmd[1]]
                elif event==1: #equ
                    self.data[TF]=self[cmd[3]]==self[cmd[1]]
                elif event ==2: # Ctn
                    self.data[TF] = self[cmd[3]] in self[cmd[1]].vars
                elif event ==3: # is
                    self.data[TF] = self[cmd[3]] is self[cmd[1]]
            elif cmd[0] == 10: #inc
                self[cmd[1]] += 1
            elif cmd[0] == 11:#dec
                self[cmd[1]] -= 1
            elif cmd[0]==12: #$oper
                op=self[cmd[2]]
                if op== 0:  # not
                    try:                                  #ç”¨tryæ˜¯æ€•ç‰©ä»¶ç„¡æ³•è½‰æ›:'NoneType' object cannot be interpreted as an integer
                        self[cmd[1]] = not self[cmd[1]]
                    except:
                        self[cmd[1]]=False
                elif op == 1:  #           è² æ•¸
                    self[cmd[1]] = -self[cmd[1]]
                elif op==2:  #          è£œæ•¸
                    self[cmd[1]] = ~self[cmd[1]]

            elif cmd[0]==13:                              #ex_func AX funcname BX
                tem_ip=self.data[ip]
                self[cmd[1]]=self.ex_function[self[cmd[2]]](self[cmd[3]])
                self.data[ip]=tem_ip
            elif cmd[0]==14: #--------------------------------------------------------------------------try
                error_ip=self[cmd[1]]
                if error_ip=='end':
                   # del self.run_layer[-1]                #tryæ­£å¸¸å¾Œæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return     #try end
                self.data[ip] += 1
                tem_esp=self.data[esp]           #å„²å­˜ç•¶å‰esp
                try:
                    self.__run(f'try {error_ip}')              #å¯èƒ½åœ¨å †ç–Šéç¨‹ä¸­æ–·
                                                               #å¯èƒ½å‡ºç¾yieldä¸­æ–·ï¼Œespè®Šå‹•
                except Exception as e:
                    self.error_line=self.data[ip]       #è¨»è¨˜ç™¼ç”ŸéŒ¯èª¤çš„ip
                    self.data[esp] = tem_esp  # é‚„åŸåŸæœ¬çš„esp
                    self.data[ER]=e
                    self.data[ip] = error_ip     #é‡åˆ°éŒ¯èª¤æ™‚ï¼Œè·³åˆ°åµéŒ¯ip
                del self.run_layer[-1]                   #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€del
            elif cmd[0]==15:  #finally
                f_ip=self[cmd[1]]
                finally_box.append((f_ip,self.data[self.esp]))
            elif cmd[0]==16: #raise
                raise self[cmd[1]]       #é€²å…¥exceptæœƒè‡ªå‹•delæ‰run_layer
            elif cmd[0]==17:  #error
                error=self[cmd[1]]
                if type(error)==list:
                    if Exception in error:
                        self.data[TF]=True
                    else:self.data[TF]=type(self.data[ER]) in error
                elif error==Exception:
                    self.data[TF]=True
                else:
                    self.data[TF] = type(self.data[ER])==error
            elif cmd[0]==18:  #Generator
                start_ip=self[cmd[2]]
                ex_k=3
                import_names={}   #(loc,stack)
                while ex_k<len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]
                    ex_k+=1
                self[cmd[1]]=generator(self,start_ip,import_names)
            elif cmd[0]==19:  #Yield
                if self.run_layer[-1]=='finally yield run':
                    raise Exception("Exception ignored in: <generator object>\nRuntimeError: generator ignored GeneratorExit")
               # del self.run_layer[-1]                    #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                return self.data[ip]+1,finally_box
            elif cmd[0] == 20:         #-------------------------------------------------------------- fetch
                tem_esp = self.data[esp]  # å„²å­˜ç•¶å‰esp
                tem_ip=self.data[ip]      #æš«å­˜ç•¶å‰ip
                try:
                    get=self[cmd[2]]
                    self[cmd[1]]=next(get)
                    self.data[TF]=True                 #æˆåŠŸ
                except StopIteration as e:                              #å› ç‚ºå‰é¢çš„tryæ²’æœ‰é™„åŠ run layerï¼Œæ­¤è™•exceptä¸æ¸…ç†ä»»ä½•run layer
                    self.data[TF]=False
                self.data[esp]=tem_esp
                self.data[ip]=tem_ip           #fetchçµæŸå¾Œç†è«–ä¸Šipä¸è®Š
            elif cmd[0]==21:  #stop
                print('ip---->',self.data[self.ip],'esp------>',self.data[self.esp])
              #  if self.tf!=1:
               #     get_status()
               # input()
               # self.tf=1
            elif cmd[0]==22:      #end
                command=self[cmd[1]]
                if command=='finally_yield' and self.run_layer[-1]=='finally yield run':
                   # del self.run_layer[-1]                                              #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return
                elif command=='Function':
                    func_name=self[cmd[2]]
                    if len(cmd)>3:
                        items_str = self[cmd[3]].split(',')
                        items = list(map(int, items_str))
                        for i in items:
                            self.func_stack[func_name][i]=None       #abort params
            elif cmd[0]==23:     #byte
                self[cmd[1]]=self[cmd[2]].encode()
               # del self[cmd[1]]
            elif cmd[0]==24:     #del
                op=self[cmd[1]]
                if op==0:    #åˆªé™¤å–®å…ƒç´ 
                    self[cmd[2]]=Undefine()
                elif op==1:  #åˆªé™¤AX[BX]
                    del self[cmd[2]][self[cmd[3]]]
                elif op==2:                         #åˆªé™¤  XXX.attr
                    del self[cmd[2]].vars[self[cmd[3]]]
            elif cmd[0]==25:     #Function
                func_ip=self[cmd[2]]
                func_class_obj=self[cmd[3]]
                func_stack_name=self[cmd[4]]
                func_stack_len=self[cmd[5]]
                ex_k = 6
                import_names= {}  #è¦åŒ¯å…¥çš„çˆ¶å‡½æ•¸åç¨±
                while ex_k < len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]         #åœ¨å®£å‘Šæ™‚å°±å„²å­˜ç•¶å‰å †ç–Šè³‡è¨Š
                    ex_k += 1
                self[cmd[1]] = Func(self, func_ip,func_class_obj,func_stack_name,func_stack_len,import_names)
            elif cmd[0]==26: #pass
                pass
            elif cmd[0]==28:   #namespace
                var_box=self[cmd[3]].split(',')
                var_k=0
                var_dict={}
                for name in var_box:
                    var_dict[name]=var_k
                    var_k+=1
                stack=[Undefine()]*var_k
                namespace_name=self[cmd[2]]
                self.func_stack[namespace_name]=stack
                self[cmd[1]]=Namespace_stack(self,namespace_name,var_dict)
            elif cmd[0]==29:  #*args
                self[cmd[1]]=self[cmd[2]][self[cmd[3]]:]
            elif cmd[0]==30:  #kwargs
                key_dict=self[cmd[2]]
                not_need=self[cmd[3]].split(',')
                void_dict={}
                for key in key_dict:
                    if key not in not_need:
                        void_dict[key]=key_dict[key]
                self[cmd[1]]=void_dict
            elif cmd[0] == 31:  # module
                self[cmd[1]]=Ex_module(self[cmd[2]])
            elif cmd[0]==32:   #type
                self[cmd[1]].atype=self[cmd[2]]
            elif cmd[0]==33:   #name
                self[cmd[1]].name=self[cmd[2]]
            elif cmd[0] == 34:  #repl_print
                item=self[cmd[1]]
                if item!=None:
                    print(item)
                    total_output.append(str(item))
            self.data[ip]+=1
            if -self.data[esp]>self.stack_size:
                raise RecursionError('maxinum recursion depth exceeded')
        #del self.run_layer[-1]       #delè®“__runçš„è«‹æ±‚è€…delæ‰å°±å¥½ï¼Œè‡ªå·±ä¸ç”¨del
        if self.tf>0:
            get_status()
class Ex_module:    #å¼•å…¥å¤–éƒ¨å‡½æ•¸
    def __init__(self,module_name):
        self.module_name=module_name
        self.__name__='Ex_module'
        self.vars={}
    def __str__(self):
        return self.module_name
    def __call__(self, *args, **kwargs):
        raise TypeError("'module' object is not callable")
class Namespace_stack:
    def __init__(self,ram,stack_name,var_dict):
        self.stack_name=stack_name
        self.vars=namespace_stack_var(ram,stack_name,var_dict)
    def __str__(self):
        return f'module "{self.stack_name}"'
class namespace_stack_var:
    def __init__(self,ram,stack_name,var_dict):
        self.ram = ram
        self.name = stack_name
        self.var_dict = var_dict
    def __contains__(self, item):
        return item in self.var_dict
    def __setitem__(self, key, value):
        if key in self.var_dict:
            self.ram.func_stack[self.name][self.var_dict[key]]=value
        else:
            #ç™»è¨˜æ–°å±¬æ€§
            now_length=len(self.ram.func_stack[self.name])
            self.var_dict[key]=now_length
            self.ram.func_stack[self.name].append(value)            #åµŒå…¥æœ€å¾Œä¸€å€‹
    def __getitem__(self, item):
        return self.ram.func_stack[self.name][self.var_dict[item]]1197*110*ex_func.pyimport time     #time,sleep,ctime,localtime(tm_year,tm_mon,tm_mday,tm_hour,tm_min,tm_sec,tm_wday),gmtime,mktime,asctime,strftime,strptime
import math     #pi,e,ceil,floor,copysign,fabs,fmod,fsum,gcd,pow,sqrt,factorial,degrees,radians,sin,cos,tan,asin,acos,atan,exp,log,log1p,log2,log10,isclose,isfinite,isinf,isnan
import os       #getcwd,listdir,mkdir,chdir,rmdir,open,write,rename,remove,stat,close,path,system,walk,environ,_exit
import os.path  #isdir,isfile,abspath,basename,dirname,exists,getatime,getmtime,getctime,getsize,isabs,join,realpath,relpath,samefile,sameopenfile,samestat,split,splitext
import sys      #argv,platform,version_info,path,stdin,stdout,stderr,displayhook,exceptionhook,setrecursionlimit,setswitchinterval,settrace,setprofile
import random   #seed,getstate,setstate,getrandbits,randrange,randint,choice,choices,shuffle,sample,random,uniform,triangular,betavariate,expovariate,gammavariate,gauss,lognormvariate,normalvariate,vonmisesvariate,paretovariate,weibullvariate
#import requests #delete,get,head,patch,post,put,request
import socket   #socket(bind,listen,accept,send,recv),AF_INET,SOCK_STREAM,gethostname,gethostbyname,SOL_SOCKET,SO_REUSEADDR63564*19*module.py#åŸºæœ¬å‹æ…‹:
class Integer:                         #æ•´æ•¸
    def __init__(self,number):
        self.number=int(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class Float:                          #æµ®æ•´æ•¸
    def __init__(self,number):
        self.number=float(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class String:                          #å­—ä¸²
    def __init__(self,text,change=True):    #change:è‡ªå‹•æ”¹è®Š\',\nç¬¦è™Ÿ
        self.text=text
        self.change=change
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        if self.change:
            self.location=f'"{self.text}"'
        else:
            self.location=f"'{self.text}'"
class Byte:                          #å­—ä¸²
    def __init__(self,text):
        self.text=text
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        codes.append(f'byte AX "{self.text}"')
        self.location=f'AX'
class Var_name:
    def __init__(self,name):           #è®Šæ•¸å
        self.name=name
    def __str__(self):
        return f'{self.name}'
#é€šç”¨è®Šæ•¸å‹æ…‹
class Namespace:
    def __init__(self,namespace=''):
        self.namespace=namespace
    def __str__(self):
        return f'{self.namespace}'
    def __eq__(self, other):
        return self.namespace==other
    def __contains__(self, item):
        return item in self.namespace
    def write(self,codes):
        if self.namespace!='':
            self.location=self.namespace
class Variable:
    def __init__(self,name,namespace):     #codelineæ˜¯æŸæ®µæŒ‡ç¨±è®Šæ•¸
        self.namespace=namespace
        self.name=name
    def __str__(self):
        return f'<var={self.name}>'
    def write(self,codes):
        if self.namespace!='':
            self.namespace.write(codes)
            self.location=f'{self.namespace.location}.{self.name}'
        else:self.location=self.name
class SubVariable:                          #å±¬æ€§æŒ‡ç¨±è®Šæ•¸
    def __init__(self,obj,attr):
        self.obj=obj                 #ä»»æ„ç‰©ä»¶
        self.attr=attr               #variable
    def __str__(self):
        return f'<obj={self.obj}  attr={self.attr}>'
    def write(self,codes):
        self.obj.write(codes)
        olocation=self.obj.location
        if '.' in olocation or '[' in olocation or olocation[0] in ('"',"'"):     #å¤ªé•·ï¼Œæˆ–æ˜¯å­—ä¸²
            codes.append(f'mov AX {self.obj.location}      ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²')
            self.location = f'AX.{self.attr.name}'
        else:self.location=f'{self.obj.location}.{self.attr.name}'
class Slice:
    def __init__(self,start_obj,end_obj,step_obj):
        self.start_obj=start_obj
        self.end_obj=end_obj
        self.step_obj=step_obj
    def __str__(self):
        return '<slice>'
    def write(self,codes):
        codes.append('push [3]')
        self.start_obj.write(codes)
        codes.append(f'mov <esp+1>[0] {self.start_obj.location}')
        self.end_obj.write(codes)
        codes.append(f'mov <esp+1>[1] {self.end_obj.location}')
        self.step_obj.write(codes)
        codes.append(f'mov <esp+1>[2] {self.step_obj.location}')
        codes.append('pop *args')
        codes.append('mov **kwargs [dict]')
        codes.append('call slice')
        self.location='AX'
class IndexVariable:
    def __init__(self,name,slice_obj):      #[a1:a2,a1:,a3...] => [(a1,a2),(a1,None),a3...]
        self.name=name
        self.slice_obj=slice_obj    #å–®å…ƒç´  or tuple
    def __str__(self):
        return f'<Index {self.name} slice={self.slice_obj}>'
    def write(self,codes):
        self.name.write(codes)
        codes.append(f'push {self.name.location}')
        self.slice_obj.write(codes)
        codes.append(f'mov BX {self.slice_obj.location}')
        codes.append('pop AX')
        self.location='AX[BX]'
#ä¸²åˆ—æ‰“åŒ…å‹æ…‹:
class List:
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        box=[]
        for obj in self.elements:
            box.append(str(obj))
        return '<List  '+','.join(box)+'>'
    def __getitem__(self, j):
        if j<len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append(f'mov AX [{len(self.elements)}]')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location='AX'
class Tuple:
    def __init__(self, elements):
        self.elements = elements
    def __str__(self):
        box = []
        for obj in self.elements:
            box.append(str(obj))
        return '<Tuple  ' + ','.join(box) + '>'
    def __getitem__(self, j):
        if j < len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self, codes):
        codes.append(f'mov AX ({len(self.elements)})')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location = 'AX'
class Dict:
    def __init__(self,elements):  #[(key,value),...]
        self.elements=elements
    def __str__(self):
        box=[]
        for key,value in self.elements:
            box.append(f'{key}:{value}')
        return '<Dict  '+','.join(box)+'>'
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append('push [dict]')
        for key,value in self.elements:
            key.write(codes)
            codes.append(f'push {key.location}')
            value.write(codes)
            codes.append(f'pop BX')
            codes.append(f'mov <esp+1>[BX] {value.location}')
        codes.append('pop AX')
        self.location = 'AX'
class Set:                           #é›†åˆ
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        return '<set>'
    def write(self,codes):
        _tuple=Tuple(self.elements)
        _tuple.write(codes)
        codes.append(f'ex_func AX "set" {_tuple.location}')
        self.location='AX'
#é«˜éšæ‰“åŒ…å‹æ…‹:
def is_number(num):
    try:
        e=float(num)
        return True
    except:return False
class Lambda:
    def __init__(self,params,return_obj,namespace):
        self.params=params                   #{key:value,...}
        self.return_obj=return_obj
        self.namespace=namespace
    def __str__(self):
        return '<lambda>'
    def write(self,codes):
        tem_name = f'&lambda_{len(codes)}'
        _return=Backtrack(self.return_obj,'return')
        block_info=Info('')
        for key in self.params:
            block_info.add_info('var',Variable(key,''))
        block_info.codelines.append(_return)
        _def=Def(tem_name,self.params,block_info,self.namespace)
        _def.write(codes)
        if self.namespace == '':
            self.location=tem_name
        else:
            self.namespace.write(codes)
            loc=f'{self.namespace.location}.{tem_name}'
        #    codes.append(f'mov {loc} {tem_name}')
            self.location=loc
class Def:                                            #å‡½æ•¸å®šç¾©å‹æ…‹
    def __init__(self,fname,params,block_info,namespace):
        self.name=fname
        self.params=params        #{key:value,...}
      #  print('my params:',params)
        self.namespace = namespace
        self.codelines=block_info.codelines
        self.local_vars = block_info.locals
        self.in_class='^' in self.namespace
        self.orig_lines=('',0)
    def __str__(self):
        text=f'<Def {self.name}'
        vtext=[]
        for obj in self.codelines:
            vtext.append(str(obj))
        text+='{'+''.join(vtext)+'}'
        return text
    def write(self,codes):
        def get_name(string):
            sp='.[ ;'
            k,n=0,len(string)
            while k<n:
                if string[k] in sp:
                    return string[:k],string[k:]
                k+=1
            return string,''
        if self.namespace!='':                                 #å®£å‘Šè‡ªå·±çš„ç¨‹å¼é–‹å§‹ä½å€(<class>,ip)
            self.namespace.write(codes)
            declare_func=[len(codes),'BX',len(codes)+2,self.namespace.location,0]
            codes.append(0)
            codes.append(f'mov {self.namespace.location}.{self.name} BX')
        else:
            declare_func = [len(codes),self.name, len(codes) + 1,None, 0]
            codes.append(0)
        codes.add_tab()
        skip_ip=len(codes)                      #ä¸Šä¸€è¡Œçš„ç¨‹å¼éœ€è¦è·³éè‡ªå·±
        codes.append(0)             #é¡å¤–1
        #ç¨‹å¼é–‹å§‹å‰æº–å‚™------------------------------------------------------------
        self.func_var=f'{self.name}_{skip_ip}'       #è‡ªå·±çš„å †ç–Š
       # codes.append(f'push {self.func_var}')        #å°‡è‡ªå·±ä¸Šæ¬¡çš„espå­˜èµ·ä¾†
        codes.append('push **kwargs')
        codes.append('push *args')
        #é–‹è™•è™•ç†åƒæ•¸
        i=0      #ç´¯è¨ˆä½¿ç”¨åƒæ•¸æ•¸é‡
        keybox=[]   #ç´¯è¨ˆä½¿ç”¨åƒæ•¸å
      #  print('#############')
       # print(self.params)
        #print('namespace:',self.namespace)
        class_obj=None
        params=tuple(self.params)
        for key in params:
            if self.in_class and class_obj==None:                 #è‹¥æ˜¯classï¼Œæ“·å–ç¬¬ä¸€å€‹åƒæ•¸
                class_obj=key
                continue
            if key[:2]=='**':   #ä»£è¡¨æ˜¯kwargs
                key_text=','.join(keybox)
                codes.append(f'**kwargs <esp+2>["{key[2:]}"] <esp+2> "{key_text}"')
                self.params[key[2:]]=self.params[key]
                del self.params[key]
                keybox.append(key[2:])
            elif key[0]=='*':
                codes.append(f'*args <esp+2>["{key[1:]}"] <esp+1> {i}')
                self.params[key[1:]] = self.params[key]
                del self.params[key]
                keybox.append(key[1:])
            else:
                keybox.append(key)
                codes.append('cmp CX 0')
                skip_param=len(codes)
                codes.append(0)
                codes.append(f'tf <esp+2> "in" "{key}"')     #æŸ¥çœ‹keyæ˜¯å¦åœ¨å·²æœ‰åƒæ•¸ä¸­
                skip_param2=len(codes)
                codes.append(0)
                self.params[key].write(codes)
                codes.append(f'mov <esp+2>["{key}"] {self.params[key].location}')
                codes.append(f'jmp {len(codes)+2}')
                codes[skip_param]=f'$jmp {len(codes)-1} "!="'
                codes.append(f'mov <esp+2>["{key}"] <esp+1>[{i}]')
                codes.append('dec CX')
                codes[skip_param2]=f'$jmp {len(codes)-1} "t"'
                i+=1
        #è¨ˆç®—éparamçš„localæ•¸é‡
        local_num = 0
        local_dict = {}
        for key in self.params:
            local_num+=1
            local_dict[key]=local_num             #å°‡è‡ªå·±åƒæ•¸åŠ å…¥
        for var in self.local_vars:
            if var not in self.params and var not in local_dict:
                local_num+=1
                local_dict[var]=local_num
        declare_func[4]=local_num+1
        codes[declare_func[0]]=f'Function {declare_func[1]} {declare_func[2]} {declare_func[3]} "{self.func_var}" {declare_func[4]}'    #æ–°å»ºé™£åˆ—[0,1,2,3,...]
        #--------------------------------------------------------------------åœ°é»(åå­—)ï¼Œipï¼Œclass_obj,local_num+1,...
        return_ips=[]
        #çœŸæ­£çš„ç¨‹å¼é–‹å§‹----------------------------------------------------------------------------------åƒæ•¸ç§»å‹•
        codes.append(f'')
        for key in self.params:
            if key!=class_obj:
                #if key[:2]=='**':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[2:]}"]')
                #elif key[0]=='*':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[1:]}"]')
                #else:
                codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key}"]')
        yield_ip = len(codes)
        codes.append(0)  # é€™è£¡é€²è¡Œ2é¸ä¸€ï¼Œä»¥ç¨‹å¼ä¸­æ˜¯å¦æœ‰yieldä½œç‚ºåˆ¤æ–·
        codes.append(0)
        # çœŸæ­£çš„ç¨‹å¼é–‹å§‹--------------------------------------------------------------------------------------
        have_yield=False
        p = len(codes)
        for obj in self.codelines:
            obj.write(codes)             #æ¯ä¸€æ®µvoid_codeéƒ½æ˜¯ç¨ç«‹çš„
        def save_gen(num):
            if len(add_Function)>0 and num not in add_Function[-1][1]:
                add_Function[-1][1].append(num)
            if len(add_Generator)>0 and num not in add_Generator[-1][1]:
                add_Generator[-1][1].append(num)
    #------------------------------------------------------------------------------------ç¨‹å¼çµ„æ…‹è¨­å®š
        def in_global(word):
            for items in global_words:
                if word in items:
                    return True
            return False
        add_Generator=[]            #å…§å®¹:(len(codes),)
        add_Function=[]         #è‡ªå·±æœ‰å“ªäº›å­æ¶µæ•¸?è¦åœ¨é€™äº›å­æ¶µæ•¸çš„æ¨™æŠ•æ¬„æ·»åŠ è‡ªå·±åƒæ•¸çš„å †ç–Šåç¨±
        global_words=[[]]      #ç•¶è‡ªå·±æˆ–å­æ¶µæ•¸å®£å‘Šglobalæ™‚ï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal__words=[]     #è‡ªå·±æ‰€å®£å‘Šçš„nonlocal wordï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal_ips=[]       #è‡ªèº«å®£å‘Šnonlocalæ™‚çš„ipï¼Œ
        not_abort=[]                         #ä¸å¯åœ¨ç¨‹å¼çµæŸå¾Œå¾å †ç–ŠéŠ·æ¯€çš„è®Šæ•¸ï¼ŒåŒ…å«add_Generator,add_Function
        def parse_line(line):
            box=[]
            k,n=0,len(line)
            while k<n:
                p=k
                if line[p] in ('"',"'"):
                    c=line[p]
                    k=p+1
                    while line[k]!=c:
                        if line[k]=='\\':k+=1
                        k+=1
                    k+=1
                while k<n and line[k]!=' ':k+=1
                box.append(line[p:k])
                k+=1
            return box
        for i in range(len(codes)-p):
            line=codes[p+i]
            if '"' in line or "'" in line:
                deal=parse_line(line)
            else:
                deal=line.split(' ')
            if deal[0]=='return':           #è™•ç†return
                return_ips.append(p+i)
                continue
            elif deal[0]=='global':
                global_words[-1].append(deal[1])           #è¨»è¨˜globalï¼Œé€²å…¥å…¶ä»–functionæ™‚ï¼Œä¸å¯é€²è¡Œåƒæ•¸æ›¿æ›
          #      print(p+i,deal[1])
            elif deal[0]=='nonlocal':          #è‡ªå·±æ¨™è¨˜çš„nonlocal
                nonlocal__words.append(deal[1])
                nonlocal_ips.append(p+i)
         #       print(p+i,deal[1])
            if deal[0] == 'yield':
                deal[0] ='Yield'     #å°‡yieldæ›æˆYieldè¡¨ç¤ºè¢«è™•ç†é
                have_yield=True
            elif deal[0]=='Function':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Function.append((p+i,[]))
                global_words.append([])
            elif deal[0]=='Generator':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Generator.append((p+i,[]))
            elif deal[0]=='end':
                if deal[1]=='"Function"':          #å„²å­˜çµæœ
                    f_row,items=add_Function[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort+=items                    #å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        func_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[f_row]=codes[f_row]+func_add_text
                  #  print('------------------item:',items)
                    del add_Function[-1]
                   # print(f'{self.name} before del:',global_words)
                    del global_words[-1]
                elif deal[1]=='"Generator"':          #å„²å­˜çµæœ
                    g_row,items=add_Generator[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort += items  # å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        gen_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[g_row]=codes[g_row]+gen_add_text
                    del add_Generator[-1]
                continue
            for j in range(len(deal)):                      #å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                if j==0 or deal[j]=='':continue
                if deal[j][0] in ('"',"'"):   #ä»£è¡¨æ˜¯å­—ä¸²
                    continue
                if deal[j][0]==';':     #ä»£è¡¨æ˜¯è¨»è§£
                    break
                var,back=get_name(deal[j])
                if not in_global(var) and var not in nonlocal__words:
                    if var == '': break
                    elif var==class_obj:
                        deal[j]=f'<{self.func_var}+0>'+back
                       # deal.append(f'        ;æ­¤ç‚ºclass obj')
                        save_gen(local_num+4)
                    elif var in self.params:                     #è‡ªå·±çš„åƒæ•¸
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
                    elif var in self.local_vars:
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
            codes[p+i]=' '.join(deal)
        need_abort=[]
        for i in range(local_num+1):
            if i not in not_abort:
                need_abort.append(str(i))
        #---------------------------------------------------------------æ¸…é™¤nonlocalï¼Œä»¥å…è¢«å…¶ä»–function(çˆ¶å‡½æ•¸)è®€å–
        for non_ip in nonlocal_ips:
            codes[non_ip]=''
        #----------------------------------------------------------------------------------------------------------
        # returnå¾Œç›´é”ç¨‹å¼çµæŸ
        endip = len(codes)
        if len(return_ips)>0 and return_ips[-1]==endip-1:
            for rip in return_ips:
                codes[rip]=f'jmp {endip-1}         ;returné»'
        else:
            for rip in return_ips:
                codes[rip]=f'jmp {endip}'
            if have_yield:
                codes.append('mov AX ""')
            else:
                codes.append('mov AX None')            #return None
        #é‚„åŸå †ç–Šï¼Œreturn_ipè·³åˆ°æ­¤
        if have_yield:             #å¦‚æœæœ‰yieldï¼Œå‰‡return AXï¼Œä¸¦ä¸”ç™¼ç”ŸéŒ¯èª¤
            stopiteration=FuncCall(Variable('StopIteration',''),List([Variable('AX','')]),Dict({}))
            _raise=Backtrack(stopiteration,'raise')
            _raise.write(codes)
            codes.append('stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡Œ')
         #   codes.append(f'$mov esp "+" 1      ;ç¢ºä¿å¾raiseå¾Œå¯é›¢é–‹')
          #  codes.append('pop ip')
            codes[yield_ip] = f'Generator AX {yield_ip + 2} "{self.func_var}"'  # Generatoråœ°é»ï¼Œå§‹ipï¼Œè¦å„²å­˜çš„å †ç–Šåç¨±
            codes[yield_ip + 1] = f'jmp {len(codes) - 1}      ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ip'  # è·³åˆ°pop ip
            codes.append('end "Generator"')  # çµ„è­¯å™¨èªè¨€ï¼Œçµ¦è‡ªå·±çœ‹çš„
        else:
            codes[yield_ip] = ''  # f'$mov esp "-" {local_num}'                                        #æ­£å¸¸æƒ…æ³
            codes[yield_ip + 1] = ''  # f'mov {self.func_var} esp'
        #----------------------------------------------------------------å¦‚æœæœ‰yieldï¼Œå‰‡ç›´æ¥è·³åˆ°pop ip
        codes.append(f'$mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸')
        if have_yield:
            codes.append(f'end "Function" "{self.func_var}"')           #å› ç‚ºé‚„è¦é€²ä¾†ï¼Œå› æ­¤ä¸åˆªé™¤è‡ªèº«ä»»ä½•è®Šæ•¸
        else:
            codes.append(f'end "Function" "{self.func_var}" '+'"'+','.join(need_abort)+'"')        #åœ¨é€™è£¡ä¹‹å¾Œå°±ä¸ç”¨å†æ›¿æ›è®Šæ•¸äº†
        codes.append('pop ip')       #pop ipè·³åˆ°ç¨‹å¼æœ€å¾Œä¸€è¡Œreturn
        codes.del_tab()
        codes[skip_ip]=f'jmp {len(codes)-1}           ;è·³éæ­¤å‡½æ•¸'
class FuncCall:                                       #å‡½æ•¸å‘¼å«å‹æ…‹
    def __init__(self,name,args,kwargs,s_args=None,s_kwargs=()):  #name,args,kwargséƒ½æ˜¯objå‹æ…‹
        self.name=name
        self.args=args
        self.kwargs=kwargs
        self.s_args=s_args
        self.s_kwargs=s_kwargs
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Call {self.name} args={self.args} kwargs={self.kwargs}>'
    def __getitem__(self, item):
        return IndexVariable(Variable('AX',''),Integer(item))
    def write(self,codes):
        def deal_cx_args_kwargs(args,call_name):
            codes.append(f'push {len(args)}        ;å„²å­˜CX')  # ä¸åŒ…å«ï¼Œå°±å…¨æ¨
            args.write(codes)
            codes.append(f'push {args.location}  ;ç‚ºcall {call_name} åšæº–å‚™', simplify=self.in_class)
            if self.s_args != None:
                self.s_args.write(codes)
                codes.append(f'ex_func AX "list" {self.s_args.location}')    #AXè½‰ç‚ºé™£åˆ—
                codes.append(f'ex_func BX "len" AX')     #BXç‚ºé™£åˆ—é•·åº¦
                codes.append('$mov <esp+2> "+" BX')       #åŸCXå¢åŠ 
                codes.append('$mov <esp+1> "+" AX')       #AXå¢åŠ 
            self.kwargs.write(codes)
            if len(self.s_kwargs)>0:
                codes.append(f'push {self.kwargs.location}')
                for s_kwargs in self.s_kwargs:
                    s_kwargs.write(codes)
                    codes.append('mov *args [1]')
                    codes.append(f'mov *args[0] {s_kwargs.location}')
                    codes.append('mov **kwargs [dict]')
                    codes.append('call <esp+1>.update')
                codes.append('pop **kwargs')
            else:
                codes.append(f'mov **kwargs {self.kwargs.location}')
            codes.append('pop *args')
            codes.append(f'pop CX     ;å–å›CX')  # æ‰¹æ¬¡è®“Defè¼‰å…¥åƒæ•¸
            if need_push_name:
                codes.append('pop AX')
                codes.append('call AX')
            else:
                codes.append(f'call {call_name}')
        codes.append('',self.orig_lines)
        self.name.write(codes)
        self.in_class = '^' in self.name.location       #function callçš„namespaceåŒ…å«åœ¨nameä¸­
        need_push_name=self.name.location[:2]=='AX' or '&' in self.name.location
        if need_push_name:codes.append(f'push {self.name.location}')
        if self.in_class:
            space,name=self.name.location.split('.')
            codes.append(f'tf {space} "Ctn" "{name}"')    #æŸ¥çœ‹æ­¤å‡½æ•¸æ˜¯å¦åŒ…å«nameé€™å€‹function
            jmp_if_true=len(codes)          #åŒ…å«å°±è·³
            codes.append(0)
            #---------------------------------------------------å› ç‚ºä¸åŒ…å«ï¼Œæ‰€ä»¥å‘¼å«å¤–éƒ¨function
            deal_cx_args_kwargs(self.args,name)
            jmp_leave=len(codes)
            codes.append(0)
            #-----------------------------------------------------------------æœ‰åŒ…å«ï¼Œæ¨args[1:]ä¸¦å‘¼å«
            codes[jmp_if_true]=f'$jmp {len(codes)-1} "t"'
            args=List(self.args.elements[1:])     #è‹¥åŒ…å«ï¼Œå°±åªæ¨[1:]
            deal_cx_args_kwargs(args,self.name.location)
            #-------------------------------------------------------é›¢é–‹
            codes[jmp_leave]=f'jmp {len(codes)-1}'
        else:                                                     #-----------------------------ä¸åœ¨classè£¡çš„æ­£å¸¸æ¨¡å¼ä¸­
            deal_cx_args_kwargs(self.args,self.name.location)
        self.location='AX'
class Backtrack:           #å›å‚³
    def __init__(self,value,cmd):
        self.A=value
        self.cmd=cmd
        self.orig_lines=('',0)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location!='AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'{self.cmd} AX',self.orig_lines)
        self.location='AX'
class Var_declare:                      #è®Šæ•¸çš„å„ç¨®å®£å‘Š
    def __init__(self,value,cmd):      #del,global,nonlocal
        self.value=value
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.value}>'
    def write(self,codes):
        self.value.write(codes)
        if self.cmd=='del':
            if '.' in self.value.location:     #XXX.attr
                class_obj,key=self.value.location.split('.')
                codes.append(f'del 2 {class_obj} "{key}"')
            elif self.value.location[:3]=='AX[':    #AX[BX]
                codes.append('del 1 AX BX')
            else:
                codes.append(f'del 0 {self.value.location} None')
        else:
            codes.append(f'{self.cmd} {self.value.location}')
class Try_Except:
    def __init__(self,try_codelines,except_objects,else_codelines=(),finally_codelines=(),namespace=''):   #except_dict:{error_term:(as_name,codelines) }
        self.try_codelines=try_codelines
        self.except_objects=except_objects
        self.else_codelines=else_codelines
        self.finally_codelines=finally_codelines               #å³ä½¿exceptæ²’æŠ“åˆ°éŒ¯èª¤ï¼Œä¹Ÿå¿…å®šæœƒåŸ·è¡Œï¼Œç„¶å¾Œæ‰ç”¢ç”ŸéŒ¯èª¤
        self.namespace=namespace
        self.orig_lines = []
    def __str__(self):
        return f'<Try Except>'
    def write(self,codes):
        ol=0
        to_finally_ip=len(codes)               #å®£å‘Šå¿…å®šå¾—è¦åŸ·è¡Œçš„finallyä½ç½®
        codes.append(0,self.orig_lines[ol])   #finally ip
        to_except_ip=len(codes)                                     #try error_ip
        codes.append(0)   #try except_ip
        #----------------------------------------------**åƒæ•¸è’é›†ç®±
        SD = {'continue': [], 'break': [], 'return': []}        #å…¨åŸŸè’é›†
        yield_box=[]                                            #åªè™•ç†tryä¸­çš„
        #----------------------------------------é–‹å§‹å¯«try
        start_p=len(codes)                                 #é–‹å§‹æª¢æŸ¥çš„åŸºåº•p
        codes.add_tab()
        for obj in self.try_codelines:
            obj.write(codes)
        codes.del_tab()
        ol+=1
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†tryä¸­yield
            cmd = codes[start_p+i].split(' ')[0]
            if cmd=='yield':
                yield_box.append(start_p+i)
        #----------------------------------------
        codes.append('try "end"')           #åœæ­¢try
        try_leave = len(codes)                               # -----------------è·³åˆ°else
        codes.append(0)
        #-----------------------------------------é–‹å§‹å¯«except
        if self.namespace!='':
            self.namespace.write(codes)
            ispace=f'{self.namespace.location}.'
        else:ispace=''
        e=0
        try_except_ip = f'try {len(codes) - 1}'
        try_push_0= []
        jmp_push_0=[]
        jmp_push_1 = []  # æ”¶é›†å¾exceptçµæŸé€šå¾€finallyçš„ip
        for i in range(len(self.except_objects)+1):            #(obj,as_name,codelines)
            if e==0:
                codes[to_except_ip]=try_except_ip
                e=1
            else:
                codes[to_except_ip] = f'$jmp {len(codes) - 1} "f"'
            if i<len(self.except_objects):
                codes.append('', self.orig_lines[ol])
                ol += 1
                error_data = self.except_objects[i]
                error_data[0].write(codes)
                codes.append(f'error {error_data[0].location}')
                to_except_ip=len(codes)
                codes.append(0)
                if error_data[1]!=None:            #ä»£è¡¨æœ‰as
                    codes.append(f'mov {ispace}{error_data[1]} $Exception')
                codes.append('mov $Exception 0')               #æ¸…ç©ºException
                #---------------------------------exceptå…§å®¹é–‹å§‹
                try_push_0.append(len(codes))
                codes.append(0)
                codes.add_tab()
                for obj in error_data[2]:
                    obj.write(codes)
                codes.del_tab()
                codes.append('try "end"')
                jmp_push_1.append(len(codes))
                codes.append(0)
            else:                     #åŸ·è¡Œåˆ°æ­¤ä»£è¡¨éŒ¯èª¤éƒ½æ²’æœ‰è¢«æŠ“åˆ°
                jmp_push_0.append(len(codes))              #ç›´æ¥è·³åˆ°push 0
                codes.append(0)
                #_raise=Raise(Variable('$Exception',''))
                #_raise.write(codes)
        # -------------------------------è™•ç†tryä¸­çš„yield
        for yield_ip in yield_box:
            codes[yield_ip]=f'jmp {len(codes)-1} ;è™•ç†tryä¸­çš„yield'
            codes.append('try "end"')
            codes.append('yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡')
            codes.append(try_except_ip)
            codes.append(f'jmp {yield_ip}     ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œ')
        #--------------------------------------------------é–‹å§‹å¯«else
        jmp_to_finally=[]
        codes[try_leave]=f'jmp {len(codes)-1}    ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°else'
        if len(self.else_codelines) > 0:
            codes.append('',self.orig_lines[ol])
            ol+=1
            codes.add_tab()
            try_push_0.append(len(codes))
            codes.append(0)
            for obj in self.else_codelines:
                obj.write(codes)
            codes.append('try "end"')
            codes.del_tab()
        push_1=len(codes)-1
        for jp0 in jmp_push_1:
            codes[jp0]=f'jmp {push_1}  ;è·³åˆ°push 1'
        codes.append('push None  ;æ¨å…¥None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 1     ;ä»£è¡¨æ­£å¸¸')
        jmp_to_finally.append(len(codes))
        codes.append(0)
        #-------------------------#è™•ç†continue,break,return
        stype_SD={}
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†try,except,elseä¸­çš„continue,break,return
            if type(codes[start_p+i])==str:
                cmd = codes[start_p+i].split(' ')[0]
                if cmd in SD:
                    SD[cmd].append(start_p+i)
        stype=2
        for key in SD:
            if len(SD[key])>0:
                jmp_ip = len(codes)-1
                for ip in SD[key]:
                    codes[ip]=f'jmp {jmp_ip}'
                if key=='return':
                    codes.append('push AX')
                else:
                    codes.append('push None')        #å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
                codes.append('try "end"')  # åœæ­¢try
                codes.append(f'push {stype}')
                jmp_to_finally.append(len(codes))
                codes.append(0)                       #jmp to_finally
                #é€²è¡Œè¨»å†Š
                stype_SD[stype]=key
                stype+=1
        #-------------------------æ”¶é›†æ‰€æœ‰éŒ¯èª¤é€²ä¾†è€…
        push_0= len(codes) - 1
        for tp0 in try_push_0:
            codes[tp0]=f'try {push_0}'
        for jp0 in jmp_push_0:
            codes[jp0]=f'jmp {push_0} ;push 0'
        codes.append('push None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 0')
        #--------------------------------------------------------------------------é–‹å§‹å¯«finally
        finally_ip=len(codes)-1
        codes[to_finally_ip]=f'finally {finally_ip}'
        for jtf in jmp_to_finally:
            codes[jtf]=f'jmp {finally_ip}    ;è·³åˆ°finally'
        codes.append(f'finally -{finally_ip}')
        finally_p=len(codes)
        if len(self.finally_codelines)>0:
            codes.append('push $Exception')        #å„²å­˜éŒ¯èª¤è¨Šæ¯
            codes.append('mov $Exception 0')
            codes.append('', self.orig_lines[ol])
            ol += 1
            codes.add_tab()
            for obj in self.finally_codelines:
                obj.write(codes)
            codes.del_tab()
          #  codes.append('pop $Exception')        #å–å›éŒ¯èª¤è¨Šæ¯
        #-------------------------------æŠ“å–finallyä¸­çš„continue(å¯¦éš›ä¸å‡ºç¾)ï¼Œbreakï¼Œreturn
        finally_events={'continue':[],'break':[],'return':[]}
        for i in range(len(codes)-finally_p):                    #---------------------------------è™•ç†tryä¸­yieldï¼Œå¼·åˆ¶æ·¨åŒ–ä¹‹å‰çš„æ•ˆæœ
            if type(codes[finally_p+i])==str:
                cmd = codes[finally_p+i].split(' ')[0]
                if cmd in finally_events:
                    finally_events[cmd].append(finally_p+i)
        #-------------------------------------è™•ç†ä¹‹å‰pushçš„é—œéµè©ï¼Œæ­¤è™•ç‚ºä¸­é–“æ²’æœ‰breakæˆ–returnä¸­æ–·çš„å¾ŒçºŒ
        if len(self.finally_codelines)>0:
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
        codes.append('pop AX')
        leave_SD={}
        for stype in stype_SD:
            codes.append(f'cmp AX {stype}')
            leave_SD[len(codes)]=stype_SD[stype]
            codes.append(0)
        codes.append('cmp AX 1')
        jmp_to_leave=len(codes)
        codes.append(0)
        codes.append('pop AX')                             #å¾0èµ°è‡³æ­¤ï¼Œé‚„åŸå †ç–Š
        _raise=Backtrack(Variable('$Exception', ''),'raise')
        _raise.write(codes)
        #--------------------------------
        for key in finally_events:            #å¾finallyä¸­breakæˆ–returnçš„äº‹ä»¶
            if len(finally_events[key])>0:
                jmp_ip=len(codes)-1
                for ip in finally_events[key]:
                    codes[ip]=f'jmp {jmp_ip}       ;è·³è‡³finallyä¸­çš„äº‹ä»¶:{key}'
                codes.append('$mov esp "+" 3')    #å»é™¤é—œéµè©ï¼Œç„¡è«–å…ˆå‰æ˜¯ç”šéº¼éƒ½ä¸é‡è¦(å›å‚³å€¼None,åˆ¤æ–·å€¼0,éŒ¯èª¤error)
                codes.append(key)
        #---------------------------------
        for lip in leave_SD:                        #å¾try,except,elseä¸­çš„continue,break,returnäº‹ä»¶
            codes[lip]=f'$jmp {len(codes)-1} "=="'                   #å¾2,3,4é›¢é–‹è‡³æ­¤
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
            codes.append('pop AX')                     #é‚„åŸAXå †ç–Š
            codes.append(leave_SD[lip])
        #--------------------------------
        codes[jmp_to_leave]=f'$jmp {len(codes)-1} "=="'            #å¾1é›¢é–‹è‡³æ­¤
        codes.append('pop AX')                          #é‚„åŸAXå †ç–Š
        codes.append('end "finally_yield"')
class With:
    def __init__(self,call_obj,orig_as_name,as_name,with_codelines,namespace):
        self.call_obj=call_obj
        self.orig_as_name=orig_as_name
        self.as_name=as_name
        self.with_codelines=with_codelines
        self.namespace=namespace
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<with>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        codes.add_tab()
        self.orig_as_name.write(codes)
        self.call_obj.write(codes)    #å®šç¾©å¥½åƒæ•¸argså’Œkwargsï¼Œpush ip,call (<class>,ip)
        codes.append(f'mov {self.orig_as_name.location} {self.call_obj.location}')
       # codes.append('stop')
        _enter_call=FuncCall(Variable(f'{self.orig_as_name.location}.__enter__',''),List([]),Dict({}))       #æœƒå…ˆpush ipå†callï¼Œæ•…é¡åˆ¥ä½ç½®ç‚º<esp+2>
        _enter_call.write(codes)
        if self.as_name!=None:                          #as_nameç²å–__enter__æ‰€å›å‚³çš„æ±è¥¿
            codes.append(f'push {_enter_call.location}')
            self.as_name.write(codes)
            codes.append(f'pop {self.as_name.location}')
        #--------------------------------------------------------------------
        try_codelines=self.with_codelines
        except_objects=[]
        else_codelines = []            #ç•¶å‰å †ç–Š:<class_obj>,(finallyçš„returnç‰©ä»¶),stype,æ­¤functionæ‰€pushçš„ipï¼Œæ•…è¦å‘¼å«ä½ç½®ç‚º<esp+4>
        _exit_call = FuncCall(Variable(f'{self.orig_as_name.location}.__exit__', ''), List([TFN(None), TFN(None), TFN(None)]), Dict({}))
        finally_codelines =[_exit_call]
        _try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines)
        _try_except.orig_lines=[('',0),('',0),('',0)]
        _try_except.write(codes)
        codes.del_tab()
        #codes.append('inc esp     ;é‚„åŸwithçš„<class_objç‰©ä»¶>')
class Stop:
    def __init__(self):
        pass
    def __str__(self):
        return '<$stop>'
    def write(self,codes):
        codes.append('stop')
class Command:
    def __init__(self,cmd_list):
        self.cmd_list=cmd_list
    def __str__(self):
        return f'<cmd_list>'
    def write(self,codes):
        for cmd in self.cmd_list:
            codes.append(cmd)
class sub_if_else:
    def __init__(self,event,true_item,false_item):           # A if B else C
        self.event=event
        self.true_item=true_item
        self.false_item=false_item
    def __str__(self):
        return f'<A if else B>'
    def write(self,codes):
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        jne_false=len(codes)
        codes.append(0)
        self.true_item.write(codes)
        if self.true_item.location!='AX':
            codes.append(f'mov AX {self.true_item.location}   ;true item')
        leave_ip=len(codes)
        codes.append(0)
        codes[jne_false]=f'$jmp {len(codes)-1} "!="   ;è·³åˆ°false'
#        print('false item:',self.false_item)
        self.false_item.write(codes)
 #       print('location:',self.false_item.location)
        if self.false_item.location!='AX':
            codes.append(f'mov AX {self.false_item.location}   ;false item',simplify=1)   #ä¸‹ä¸€è¡Œå¯èƒ½æœƒmov item AXï¼Œæœƒè¢«ç°¡åŒ–å°è‡´éŒ¯èª¤
        codes[leave_ip]=f'jmp {len(codes)-1}   ;é›¢é–‹sub_if_else'
        self.location='AX'
class If_else:                                        #if,elseå‹æ…‹
    def __init__(self,if_items,else_codelines):     #if_items=[[event_obj,codelines],...]
        self.if_items=if_items
        self.else_codelines=else_codelines
        self.orig_lines=[]
    def __str__(self):
        text=[f'if {self.if_items[0][0]}:']
        for obj in self.if_items[0][1]:text.append(str(obj))
        for i in self.if_items[1:]:
            text.append(f'elif {i[0]}:')
            for obj in i[1]:text.append(str(obj))
        if len(self.else_codelines)>0:
            text.append('else:')
            for obj in self.else_codelines:text.append(str(obj))
        return ''.join(text)
    def write(self,codes):
        need_set_end=[]
        ol=0
        for event,block in self.if_items:
            codes.append('',self.orig_lines[ol])
            ol+=1
            event.write(codes)          #é€²è¡Œæ¢ä»¶é‹ç®—
            codes.append(f'cmp {event.location} 1')
            codes.add_tab()
            jip=len(codes)
            codes.append(0)                         #jneæ¢ä»¶è¢«å¦å®šæ™‚è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·
            for obj in block:obj.write(codes)       #æ¢ä»¶æˆç«‹å‰‡ç¹¼çºŒåŸ·è¡Œ
            need_set_end.append(len(codes))         #åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³åº•éƒ¨
            codes.append(0)
            codes[jip]=f'$jmp {len(codes)-1} "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·'          #ä¸‹ä¸€å¥åˆ¤æ–·çš„ä½ç½®
            codes.del_tab()
        if len(self.else_codelines)>0:
            codes.append('',self.orig_lines[ol])
            codes.add_tab()
            for obj in self.else_codelines:obj.write(codes)               #çµæŸåŸ·è¡Œ
            codes.del_tab()
        for ip in need_set_end:
            codes[ip]=f'jmp {len(codes)-1}        ;è·³è‡³åº•éƒ¨'           #è¨­å®šåº•éƒ¨
class While:                                          #whileå‹æ…‹
    def __init__(self,event,codelines,else_codelines):
        self.event=event
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return f'event:{self.event} do:{self.codelines}'
    def write(self,codes):
        again_ip=len(codes)
        codes.append('',self.orig_lines)
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        codes.add_tab()
        out_ip=len(codes)
        codes.append(0)          #ä¸æ˜¯Trueï¼Œè·³å‡ºè¿´åœˆ
        break_box=[]
        for obj in self.codelines:
            p=len(codes)
            obj.write(codes)
            for i in range(len(codes)-p):
                cmd=codes[p+i].split(' ')[0]
                if cmd=='continue':
                    codes[p+i]=f'jmp {again_ip-1}'     #continueè·³å›é–‹é ­
                elif cmd=='break':
                    break_box.append(p+i)
        codes.append(f'jmp {again_ip-1}               ;continueé‡ä¾†')     #é‡ä¾†
        #----------------------------------------
        to_else_ip=len(codes)-1
        codes[out_ip]=f'$jmp {to_else_ip} "!="'              #åœ¨whileåˆ¤å®šç‚ºFalseæ™‚ï¼Œè·³åˆ°else
        for obj in self.else_codelines:
            obj.write(codes)
        #----------------------------------------
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip]=f'jmp {break_ip}          ;breakå‡º'
        codes.del_tab()
class sub_for_loop:
    def __init__(self,express,vnames,base_obj,if_obj,is_list):
        self.express=express
        self.vnames=vnames
        self.base_obj=base_obj
        self.if_obj=if_obj
        self.is_list=is_list
    def __str__(self):
        return '<sub for loop>'
    def write(self,codes):
        _yield=Backtrack(self.express,'yield')        #expresséè³¦å€¼è®Šæ•¸ï¼Œä¸ç”¨è¨»å†Š
        if self.if_obj!=None:
            _if=If_else([[self.if_obj,[_yield]]],[])
            _if.orig_lines=[('',0),('',0),('',0)]
            _for_loop=For_loop(self.vnames,self.base_obj,[_if],[])
        else:
           # print(self.vnames)
          #  print(self.base_obj)
            _for_loop = For_loop(self.vnames, self.base_obj, [_yield],[])
        info = Info('')
        for var in self.vnames:
            info.add_info('var', var)
        info.write(_for_loop,('',0))
        id=len(codes)
        fDef=Def(f'&generator_{id}',{},info,'')      #functionæœ¬èº«ä¸æœƒè¢«å…¶ä»–ç‰©ä»¶å‘¼å«ï¼Œä¸éœ€è¦namespaceï¼Œ&ä»¥len(codes)ä½œç‚ºæ¨™èªŒï¼Œä¸æœƒæ‰¾éŒ¯
        fDef.write(codes)
        codes.append('push 0        ;å„²å­˜CX')
        codes.append('push [0]')
        codes.append('mov **kwargs [dict]')
        codes.append('pop *args')
        codes.append('pop CX     ;å–å›CX')
        codes.append(f'call &generator_{id}')
#        fcall=FuncCall(Variable(f'&generator_{id}',''),List([]),Dict({}))
 #       fcall.write(codes)
        if self.is_list:
            codes.append(f'ex_func AX "list" AX')
        self.location='AX'
class For_loop:                                       #for,loopå‹æ…‹
    def __init__(self,vnames,base_obj,codelines,else_codelines):                 #varuables=[name1,name2,...]
        self.vnames=vnames
        self.base_obj=base_obj
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return '<For loop>'
    def write(self,codes):
        self.base_obj.write(codes)
        #base_obj_name=f'&base_obj_{len(codes)}'
        codes.append(f'ex_func AX "iter" {self.base_obj.location}',self.orig_lines)                        #å°‡base_objè½‰ç‚ºiterå­˜èµ·ä¾†
        codes.add_tab()
        codes.append('push AX')
       # codes.append('stop')
        #-------------------------------
        again_ip=len(codes)                           #æ¯ä¸€åœˆçš„èµ·å§‹é»
        codes.append(f'fetch AX <esp+1>')                                           #å¾base_objå–å‡ºä¸€å€‹å€¼åˆ°AXï¼Œå–å‡ºæˆåŠŸæ™‚TF=1ï¼Œå¦å‰‡TF=0
        leave_ip=len(codes)                             #æ¯”è¼ƒç™¼ç¾ç„¡æ³•å–å‡ºæ±è¥¿è·³å‡º
        codes.append(0)
        if len(self.vnames)==1:                                  #é–‹å§‹åˆ†é…åƒæ•¸
            self.vnames[0].write(codes)
            codes.append(f'mov {self.vnames[0].location} AX')
        else:
            #codes.append('mov AX <esp+3>[CX]')
            for i in range(len(self.vnames)):
                self.vnames[i].write(codes)
                codes.append(f'mov {self.vnames[i].location} AX[{i}]')
        #---------------------------------------------------------å‡½æ•¸é–‹å§‹
        break_box = []
        return_box=[]
        for obj in self.codelines:
            p = len(codes)
            obj.write(codes)
            for i in range(len(codes) - p):
                cmd = codes[p + i].split(' ')[0]
                if cmd == 'continue':
                    codes[p + i] = f'jmp {again_ip - 1}'  # continueè·³å›é–‹é ­
                elif cmd == 'break':
                    break_box.append(p + i)
                elif cmd=='return':                   #æ­¤æ™‚è¦returnçš„ç‰©ä»¶å·²ç¶“å­˜åœ¨AX
                    return_box.append(p+i)
        codes.append(f'jmp {again_ip-1}')
        #-------------------------------------è¿´åœˆçµæŸ
        if len(return_box)>0:
            return_leave_ip=len(codes)                      #æ‰€æœ‰returnéƒ½è·³åˆ°é€™è£¡
            for r_ip in return_box:
                codes[r_ip]=f'jmp {return_leave_ip-1}'
            codes.append('inc esp')                       #é‚„åŸå †ç–Š
            codes.append('return AX')                       #è£œè¶³return
        #-------------------------------------breakæˆ–æ­£å¸¸é›¢é–‹åˆ°æ­¤
        out_ip=len(codes)-1
        codes[leave_ip] = f'$jmp {out_ip} "f"'                  # ç„¡æ³•å–å‡ºæ±è¥¿æ™‚ï¼Œtf=0ï¼Œè·³è‡³else
        for obj in self.else_codelines:
            obj.write(codes)
        #--------------------------------                   #ä¸­é€”breakçš„ç›´æ¥è·³å‡º
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip] = f'jmp {break_ip}          ;breakå‡ºè¿´åœˆ'
        codes.append('inc esp')                                     #é‚„åŸå †ç–Š
        codes.del_tab()
class Mark:                    #æ¨™èªŒ
    def __init__(self,mark):
        self.mark=mark
    def __str__(self):
        return f'<mark {self.mark}>'
    def write(self,codes):
        codes.append(self.mark)
class Pass:
    def __init__(self):
        pass
    def __str__(self):
        return '<pass>'
    def write(self,codes):
        pass
class TFN:                 #True,False,None
    def __init__(self,value):
        self.value=value
    def __str__(self):
        return f'<{self.value}>'
    def write(self,codes):
        self.location=self.value
class Class:
    def __init__(self,name,info,namespace,class_esp,father=None):
        self.name=name
        self.functions=info.funcs
        #for func_key in self.functions:
         #   self.functions[func_key].in_class=True
        self.codelines=info.codelines
        self.namespace=namespace
        self.class_esp=class_esp
        self.father=father
        self.orig_lines=('',0)
    def __str__(self):
        return f'<class {self.name}>'
    def write(self,codes):
        #codes.append('mov BX [func]',self.orig_lines)
       # set_ip=len(codes)
       # codes.append(0)
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'Function BX {len(codes) + 3} {self.namespace.location} "{self.class_esp}" 1', self.orig_lines)
            class_param=f'{self.namespace.location}.{self.name}'
            codes.append(f'mov {class_param} BX')
        else:
            class_param=self.name
            codes.append(f'Function {class_param} {len(codes) + 2} None "{self.class_esp}" 1', self.orig_lines)  # åœ°é»(åå­—)ï¼Œipï¼Œclass_obj
        codes.append(f'name {class_param} "<class \'__main__.{self.name}\'>"')     #è¨»å†Šé¡åˆ¥åç¨±
        codes.add_tab()
        skip_class_ip=len(codes)
        codes.append(0)                                           #è·³éè‡ªå·±
        #------------------------------------------------------
        codes.append('tf $Inheritance "equ" None')          #åˆ¤æ–·å‘¼å«è‡ªå·±çš„äººæ˜¯å¦è¦ç¹¼æ‰¿è‡ªå·±ï¼Œç”¨equå› ç‚ºæ€•inheritanceç‚ºundefined
        codes.append(f'$jmp {len(codes)+3} "t"')        #jt ip 'f'
        codes.append(f'mov <{self.class_esp}> $Inheritance')
        codes.append('push 1')              #è¦ç¹¼æ‰¿
        codes.append(f'jmp {len(codes)+2}')
        codes.append(f'mov <{self.class_esp}> [class]')
        codes.append('push 0')
        codes.append('mov $Inheritance None')      #æ¸…ç©ºç¹¼æ‰¿
        # ------------------------------------------------------å„²å­˜CX,args,kwargs
        codes.append('push CX')
        codes.append('push *args')
        codes.append('push **kwargs')  # å…ˆå°‡å®£å‘Šç”¨çš„argså’Œkwargså„²å­˜èµ·ä¾†
        #--------------------------------------------------------
        if self.father!=None:
            if type(self.father)==Tuple:
                deal=self.father.elements
            else:deal=[self.father]
           # print(deal)
            for father in deal:
                #-----------------------------åœ¨çˆ¶å‡½æ•¸writeå‰è¦å…ˆpush cx,args,kwargs
                father.write(codes)
                #------------------------------åœ¨callçˆ¶å‡½æ•¸å‰å…ˆå–å›åƒæ•¸
                codes.append('mov **kwargs <esp+1>')
                codes.append('mov *args <esp+2>')
                codes.append('mov CX <esp+3>')
                #------------------------------
                codes.append(f'mov $Inheritance <{self.class_esp}>')
                codes.append(f'call {father.location}')
        #------------------------------------------------------
        codes.append(f'type <{self.class_esp}> {class_param}')     #è¨»å†Šè‡ªå·±çš„é¡åˆ¥
        #é€²è¡Œå€åŸŸç‰©ä»¶å®£å‘Š
        for obj in self.codelines:
            obj.write(codes)
        #-------------------------------------------------------
        #åœ¨æ‰€æœ‰å‡½æ•¸å®£å‘ŠçµæŸå¾Œï¼Œå¦‚æœè‡ªå·±æœ‰å»ºç«‹__init__ï¼Œå°±é€²å…¥
        codes.append(f'mov AX <{self.class_esp}>')  # å–å›è‡ªå·±class
        codes.append('pop **kwargs')
        codes.append('pop *args')
        codes.append('pop CX')
        #----------------------------------------
        codes.append('pop BX')           #å–å›ç¹¼æ‰¿åˆ¤æ–·
        codes.append('cmp BX 1')         #åˆ¤æ–·æ˜¯å¦ç¹¼æ‰¿
        leave_init_ip=len(codes)
        codes.append(0)           #å¦‚æœè¦ç¹¼æ‰¿ï¼Œå°±è·³éinitã€‚$jmp ip "t"
        #----------------------------------------
        codes.append('tf AX "Ctn" "__init__"')             #æ˜¯å¦åŒ…å«__init__é€™å€‹å®£å‘Š?
        codes.append(f'$jmp {len(codes)+1} "t"')                 #å¦‚æœåŒ…å«initå°±call
        skip_init_ip=len(codes)
        codes.append(0)
        codes.append('call AX.__init__')
        codes.append(f'mov AX <{self.class_esp}>')                   #å–å›è‡ªå·±
        #------------------------------------------------------
        end=len(codes)-1
        codes[leave_init_ip]=f'$jmp {end} "=="'
        codes[skip_init_ip]=f'jmp {end}'
        codes.append(f'end "Function" "{self.class_esp}"')
        codes.append('pop ip')      #å›å»ç¨‹å¼çš„å®£å‘Šè™•
        #----------------------------------------------------------
        codes[skip_class_ip] = f'jmp {len(codes) - 1}'
        self.location='AX'
        codes.del_tab()
#è³‡æ–™ç§»è½‰å‹æ…‹
def two_object_write(A,B,codes):
    A.write(codes)
    if A.location[:3] == 'AX.' or A.location=='AX':  # Aç‚ºsubvariable
        codes.append('push AX')
        B.write(codes)
        codes.append(f'mov BX {B.location}')
        codes.append('pop AX')
        blocation = 'BX'
    elif A.location[:3] == 'AX[':  # Aç‚ºindexvariableï¼Œlocationå¿…ç‚ºAX[BX]
        codes.append('push AX')
        codes.append('push BX')
        B.write(codes)
        codes.append(f'mov DX {B.location}')
        codes.append('pop BX')
        codes.append('pop AX')
        blocation = 'DX'
    else:  # æ­£å¸¸æƒ…æ³
        B.write(codes)
        blocation = B.location
    return blocation
#class Mov:
#    def __init__(self,A,B,op='='):
#        self.A=A
#        self.B=B
##        cmd={'+=':'add','-=':'sub','*=':'mul','/=':'div','%=':'quo','//=':'rem','**=':'pow',
# #            '<<=':'shl','>>=':'shr','&=':'and','^=':'xor','|=':'or'}
#        if op=='=':
#            self.ctype=0
#            self.cmd='mov'
#        else:
#            self.ctype=1
#            self.cmd=op[:-1]     #å°‡ç­‰è™Ÿå»é™¤
#        self.orig_lines = ('', 0)
#    def __str__(self):
#        return f'<{self.cmd} {self.A} {self.B}>'
#    def write(self,codes):
#        codes.append('',self.orig_lines)
#        blocation=two_object_write(self.A,self.B,codes)
#        if self.ctype == 0:
#            codes.append(f'mov {self.A.location} {blocation}')
#        elif self.ctype == 1:
#            codes.append(f'$mov {self.A.location} "{self.cmd}" {blocation}')
class Multiple_Mov:
    def __init__(self,obj_list,target,op):
        self.obj_list=obj_list
        self.target=target
        if op == '=':
            self.ctype = 0
            self.cmd = 'mov'
        else:
            self.ctype = 1
            self.cmd = op[:-1]  # å°‡ç­‰è™Ÿå»é™¤
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<Multiple mov>'
    def write(self,codes):
        codes.append('', self.orig_lines)
        self.target.write(codes)
        codes.append(f'push {self.target.location}')
        for obj in self.obj_list:
            if type(obj) in (Tuple,List):
                for i in range(len(obj)):
                    obj[i].write(codes)
                    if self.ctype == 0:
                        codes.append(f'mov {obj[i].location} <esp+1>[{i}]')
                    elif self.ctype == 1:
                        codes.append(f'$mov {obj[i].location} "{self.cmd}" <esp+1>[{i}]')
            else:
                obj.write(codes)
                if self.ctype == 0:
                    codes.append(f'mov {obj.location} <esp+1>')
                elif self.ctype == 1:
                    codes.append(f'$mov {obj.location} "{self.cmd}" <esp+1>')
        codes.append('inc esp')          #é‚„åŸå †ç–Š
#é‹ç®—å‹æ…‹
class Oper:
    def __init__(self,A,B,symbol):
        self.A=A
        self.B=B
        self.symbol=symbol#{'+':'add','-':'sub','*':'mul','/':'div','**':'pow','%':'quo','//':'rem','<<':'shl','>>':'shr','&':'and','^':'xor','|':'or'}[symbol]
       # self.oper=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(symbol)
    def __str__(self):
        return f'<{self.A} {self.symbol} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'push {self.A.location}')
        self.B.write(codes)
        codes.append(f'oper <esp+1> "{self.symbol}" {self.B.location}')
        codes.append('pop AX')
        self.location = 'AX'
#é‚è¼¯é‹ç®—ç¬¦
class Tf:   #çœŸå‡åˆ¤æ–·å¼
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
       # self.oper=('in','equ','Ctn','is').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
       # print('tf:  ',self.A,self.B,self.cmd)
        blocation=two_object_write(self.A,self.B,codes)
        codes.append(f'tf {self.A.location} "{self.cmd}" {blocation}')    #Bæ˜¯å¦cmdåœ¨A
        codes.append('mov AX TF')
        self.location='AX'
class AndOr:
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'cmp {self.A.location} 1')          #ç›¸åŒå°±ç¹¼çºŒï¼Œå¦å‰‡è·³è‡³mov AX 0
        jip=len(codes)
        codes.append(0)
        self.B.write(codes)
        codes.append(f'cmp {self.B.location} 1')           #å¤±æ•—å°±è·³è‡³mov AX 0
        lip = len(codes)
        codes.append(0)
        if self.cmd=='and':       #å…©é‚Šéƒ½è¦Trueï¼Œjip,lipç‚ºFalseæ™‚è·³åˆ°0
            codes.append('mov AX 1')
            codes.append(f'jmp {len(codes)+1}')          #æˆåŠŸå°±è·³émov AX 0
            to_false=len(codes)-1
            codes.append('mov AX 0', simplify=1)
            codes[jip]=f'$jmp {to_false} "!="'
            codes[lip]=f'$jmp {to_false} "!="'
        elif self.cmd=='or':       #å…©é‚Šéƒ½è¦Falseï¼Œjip,lipç‚ºTrueæ™‚è·³åˆ°1
            codes.append('mov AX 0')
            codes.append(f'jmp {len(codes) + 1}')  # å¤±æ•—å°±è·³émov AX 1
            to_true = len(codes) - 1
            codes.append('mov AX 1', simplify=1)
            codes[jip] = f'$jmp {to_true} "=="'
            codes[lip] = f'$jmp {to_true} "=="'
        self.location='AX'
class Deny:       #å¦å®šoperator
    def __init__(self,A,cmd):
        self.A=A
        self.cmd=cmd
        #self.oper=('not','-','~').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location != 'AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'$oper AX "{self.cmd}"')
        self.location = 'AX'
#çœŸå‡åˆ¤æ–·ç¬¦
class Bool:
    def __init__(self,enequalbox):     #enebox=[var,==,var,!=,var...]
        self.enebox=enequalbox
    def __str__(self):
        text=''
        for i in self.enebox:
            text+=str(i)
        return text
    def write(self,codes):
        k=0
        self.enebox[0].write(codes)           #è¨ˆç®—ç¬¬ä¸€å€‹
        codes.append(f'push {self.enebox[0].location}')        #å°‡çµæœå­˜èµ·ä¾†
        need_set_end=[]
        need_set_tf=[]
        cmp_dict={'==':'f','!=':'t','>':'<=','<':'>=','>=':'<','<=':'>'}            #å¦å®šæ™‚è·³é›¢ç¬¦
        while k<len(self.enebox)-1:
            self.enebox[k+2].write(codes)             #è¨ˆç®—ç¬¬äºŒå€‹
            codes.append('pop DX')           #å°‡ç¬¬ä¸€å€‹çš„çµæœæ”¾åœ¨DX  (ä¸Šä¸€å€‹çš„çµæœå¯èƒ½åœ¨AX,AX[BX],xxx.attr)
            if self.enebox[k+1] in ('==','!='):
                codes.append(f'tf DX "equ" {self.enebox[k + 2].location}')
                need_set_tf.append((len(codes),cmp_dict[self.enebox[k+1]]))
            else:
                codes.append(f'cmp DX {self.enebox[k+2].location}')       #å°‡ç¬¬äºŒå€‹çš„å€¼èˆ‡ç¬¬ä¸€å€‹
                need_set_end.append((len(codes),cmp_dict[self.enebox[k+1]]))              #Trueå°±ç¹¼çºŒæ¯”è¼ƒä¸‹å»ï¼ŒFalseå‰‡è·³è‡³mov AX 0
            codes.append(0)                            #è‹¥æ¯”è¼ƒçµæœç‚ºFalseå‰‡è·³é›¢
            if k+3<len(self.enebox):
                codes.append(f'push {self.enebox[k+2].location}')        #å°‡ç¬¬äºŒå€‹çµæœçš„å€¼å­˜èµ·ä¾†
            k+=2
        codes.append('mov AX True')                         #ç•¶æ¢ä»¶æˆåŠŸåˆ°æœ€å¾Œï¼Œè¨­ç½®AXç‚º1
        codes.append(f'jmp {len(codes)+1}')                                     #è·³émov AX 0æŒ‡ä»¤
        end = len(codes)-1  # æ‰€æœ‰ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤è¡Œ
        codes.append('mov AX False',simplify=1)                #ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤ï¼Œè¨­ç‚ºFalse
        for i in need_set_end:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
        for i in need_set_tf:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
       # codes.append('dec esp')                       #å †ç–ŠæŒ‡æ¨™å›å»ä¸€å€‹
        self.location='AX'
#ç‰¹æ®ŠåŠŸèƒ½å‡½æ•¸
class Assert:
    def __init__(self,event,msg):
        self.event=event
        self.msg=msg
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<assert {self.event}, {self.msg}>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        not_event=Deny(self.event,'not')
        assertionerror = FuncCall(Variable('AssertionError', ''), List([self.msg]), Dict({}))
        _raise = Backtrack(assertionerror, 'raise')
        if_obj=If_else([[not_event,[_raise]]],[])
        if_obj.orig_lines=[('',0)]
        if_obj.write(codes)
class STR:
    def __init__(self,obj):
        self.obj=obj
    def __str__(self):
        return f'<STR: {self.obj}>'
    def write(self,codes):
        self.obj.write(codes)
        codes.append(f'ex_func AX "str" {self.obj.location}')
        self.location='AX'
#------------------------------------------------------------------ç¨‹å¼è³‡è¨Š
class Info:                             #ç”¨ä¾†è¨˜éŒ„parse_blockè³‡è¨Š
    def __init__(self,namespace):
        self.locals=[]
        self.vars={}
        self.funcs={}       #fname:fDef
        self.classes={}
        self.codelines=[]
        self.namespace=namespace
    def add_info(self,type,obj):
        if type=='var':
            self.vars[obj.name]=obj
        elif type=='func':
            self.funcs[obj.name]=obj
        elif type=='class':
            self.classes[obj.name]=obj
        if obj.name not in self.locals:
            self.locals.append(obj.name)
    def update(self,info):
        self.locals+=info.locals
        self.vars.update(info.vars)
        self.funcs.update(info.funcs)
        self.classes.update(info.classes)
    def write(self,codeline,orig_codelines):
        def deal_orig(orig_codeline):
            box = []
            for obj in orig_codeline:
                if type(obj)==int:
                    box.append(' '*obj)
                else:box.append(str(obj)+' ')
            return ''.join(box)
        self.codelines.append(codeline)
        #if type(orig_codelines)==list:
        #    nbox=[]
        #    for line in orig_codelines:
        #        nbox.append((deal_orig(line[0]),line[1]))
        #else:nbox=(deal_orig(orig_codelines[0]),orig_codelines[1])
        codeline.orig_lines=orig_codelines14*111*newtext.txt59891*110*package.py#æ‰“åŒ…ç¨‹å¼ç¢¼
from os import listdir,getcwd,chdir
from os.path import isdir,isfile
from apython.code import Code
from apython.module import *

def parse_code(code):  # æ‰“åŒ…ç¨‹å¼ç¢¼ç‚º[codeline_1,codeline_2,...]
    def hex_to_int(hex):
        string='0123456789abcdef'
        total,base=0,1
        for i in range(len(hex)):
            total+=string.index(hex[-i-i])*base
            base*=16
        return str(total)
    def deal_string(k,change=True):  # kç‚º',"çš„ä½ç½®
        c = code[k]
        k += 1
        p = k
        while True:
            c2=code[k]
            if c2=='\n':
                cline[0]+=1   #é¡å¤–åŠ ä¸€è¡Œ
            if c2 == '\\':
                k += 1
            elif c2 == c:
                break
            k += 1
        get_text=code[p:k]
       # print('c:',c,change)
        if (c=="'" and not change) or (c=='"' and change):      #ä»£è¡¨å…§å®¹æ‹¬è™Ÿç‚º"ï¼Œèˆ‡stringä¸€æ¨£
            return String(get_text,change=change),k
        elif c == "'" and change:
            text = []
            ck, n = 0, len(get_text)
            while ck < n:
                if get_text[ck]=='"':
                    text.append('\\')
                if get_text[ck]=='\\':
                    text.append(get_text[ck])
                    ck += 1
                text.append(get_text[ck])
                ck += 1
            return String(''.join(text),change=change), k
        elif c=='"' and not change:      #è£¡é¢å¯èƒ½æœ‰"
            text=[]
            ck,n=0,len(get_text)
            while ck<n:
                if get_text[ck]=='"':
                    text.append('\\')
                text.append(get_text[ck])
                if get_text[ck]=='\\':
                    text.append('\\')
                ck+=1
            return String(''.join(text)),k
    key_word=['def','while','for','in','if','elif','else','class','break','continue','return',':','and','not','or',
              'True','False','None','from','import','as','is','with','raise','try','except','finally','yield',
              'lambda','del','global','nonlocal','assert','$stop']        #ç„¡æ³•è¢«ç•¶æˆè®Šæ•¸çš„å…ƒç´ ï¼Œ$stopæ˜¯apythonèªè¨€
    data_dict = {'AX': 0, 'BX': 1, 'CX': 2, 'DX': 3, 'ip': 4, 'esp': 5, 'sp': 6, 'ZR': 7, 'TF': 8}      #codeä¸­çš„ç¦ç”¨é—œéµå­—åç¨±
    k, n = 0, len(code)
    codelines = []
    in_brackets=0
    in_lambda=0
    orig_code=code.split('\n')
    cline=[1]         #æ­¤ç‚ºçœŸå¯¦è¡Œ
    codeline = [(0,cline[0],orig_code[cline[0]-1])]                   #0ä»£è¡¨å‰ç½®ç©ºæ ¼æ•¸é‡,lineç‚ºç¬¬å¹¾è¡Œ,å¾Œæ–¹ç‚ºåŸå§‹ç¨‹å¼
    while k < n:
      #  print('codeline:',codeline)
      #  input()
        c = code[k]
        if c in '0123456789':  # ä»£è¡¨æ­¤ç‚ºæ•¸å€¼
            p = k
            numbers = '0123456789.xabcdefXABCDEF'
            while k < n:
                if code[k] in numbers:
                    k += 1
                else:
                    break
            number=code[p:k].lower()
            if number[:2]=='0x':
                number=hex_to_int(number[2:])
            if '.' in number:codeline.append(Float(number))
            else:codeline.append(Integer(number))
            k -= 1
        elif c in '+-*/,()[]{}!=%:><.&^|~':  # é‹ç®—å–®å…ƒç´ 
            if k+2<n:
                c3=code[k:k+3]
                if c3 in ('**=','//=','>>=','<<='):
                    codeline.append(c3)
                    k += 3
                    continue
            if k+1<n:
                c2=code[k:k+2]
                if c2 in ('+=','-=','*=','/=','==','!=','**','>','<','>=','<=','%=','//','>>','<<','&=','^=','|='):
                    codeline.append(c2)
                    k += 2
                    continue
            codeline.append(c)
            if c in ('(','[','{'):in_brackets+=1
            elif c in (')',']','}'):in_brackets-=1
            if c==':' and in_brackets==0: #-----------------------------------------------------------è™•ç†å†’è™Ÿ
                if in_lambda>0:
                    in_lambda-=1
                else:
                    try:
                        q=code.index('\n',k)        #å¦‚æœæ‰¾ä¸åˆ°\nä»£è¡¨æ˜¯æœ€å¾Œä¸€è¡Œäº†
                    except:q=len(code)
                    if q-k>1:
                        codelines.append(codeline)
                        #cline+=1                    #åœ¨åŒä¸€è¡Œï¼Œclineä¸åŠ ä¸€
                       # print('codeline:',codeline)
                        codeline = [(codeline[0][0]+4,cline[0],orig_code[cline[0]-1])]   #[(ç©ºæ ¼æ•¸,ç¬¬å¹¾è¡Œ,åŸå§‹ç¨‹å¼),...]
                        k+=1
                        while code[k]==' ':k+=1
                        k-=1
        elif c == '#':  # ç•¥éè¨»è§£
            while k < n and code[k] != '\n':
                k += 1
            k -= 1
        elif c in ('"', "'"):  # å­—ä¸²
            string,k=deal_string(k)
            if len(codeline)>0 and type(codeline[-1])==String:    #é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == '\n':    #å¦‚æœin_bracketsï¼Œå‰‡å¿½ç•¥\n
            cline[0]+=1
            if in_brackets==0:
                if len(codeline)>1:
                    codelines.append(codeline)
                codeline = []
                # -----------------------------è¨ˆç®—ä¸‹ä¸€è¡Œçš„ç©ºæ ¼ï¼Œå³ä¾¿æ²’æœ‰ç©ºæ ¼ä¹Ÿéœ€è¦
                k += 1
                if k < n:
                    space_num=0             #ç©ºæ ¼æ•¸é‡
                    while k < n and code[k] == ' ':
                        k += 1
                        space_num+=1
                    codeline.append((space_num,cline[0],orig_code[cline[0]-1]))       #æ¯å€‹[]çš„ç¬¬ä¸€å€‹ç‚ºç©ºæ ¼æ•¸é‡
                k -= 1
        elif c == 'r' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k += 1
            string, k = deal_string(k,change=False)
            if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == 'b' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k+=1
            string,k=deal_string(k)
            if len(codeline) > 0 and type(codeline[-1]) == Byte:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(Byte(string.text))
        elif c=='f' and k+1<n and code[k+1] in ('"',"'"):          #ä»£è¡¨æ˜¯f'aaa{bbb}aaa'é¡å‹
           # print('é€™è£¡2')
            codeline.append('(')
            symbol=code[k+1]
            q=k+2
            while code[q] != symbol or code[q-1]=='\\':
                q += 1
            get=code[k+2:q]
           # print('getç‚º:',get)
            sn=len(get)
            sk=0
            textbox = []
            while sk<sn:
                if get[sk]=='\n':
                    cline[0]+=1
                if get[sk]=='{':
                    if get[sk+1]=='{':
                        textbox.append('{')
                        sk+=1
                    else:                                   #å…§åµŒè®Šæ•¸
                        #å…ˆå„²å­˜å…ˆå‰çš„
                        if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                            codeline.append('+')
                        codeline.append(String(''.join(textbox)))
                        textbox=[]
                        sk+=1
                        p=sk
                        #ç´¢å¼•è‡³ä¸‹ä¸€å€‹"}"
                        slock=0            #å­—ä¸²é–
                        c=1                #{é–
                        while c>0:
                            sc = get[sk]
                            if slock==0:
                                if sc=='{':
                                    c+=1
                                elif sc=='}':
                                    c-=1
                                elif sc in ("'",'"'):      #å•Ÿå‹•å­—ä¸²é–ï¼Œé–‹å§‹å¿½ç•¥{}
                                    slock=sc
                            else:
                                if sc==slock and get[sk-1]!='\\':    #è§£é™¤å­—ä¸²é–
                                    slock=0
                            sk+=1
                        sk-=1                 #ç‚ºäº†è®“get[sk]å®šä½åœ¨"}"
                        vartext=get[p:sk]        #ç›®å‰get[sk]=="}"
                        sub_codeline=parse_code(vartext)[0][1:]        #ç†è«–ä¸Šåªæœ‰ä¸€è¡Œï¼Œå»é™¤æœ€å‰æ–¹çš„0
                        codeline+=['+',Var_name('$str'),'(']+sub_codeline+[')','+']
                elif get[sk]=='}' and get[sk:sk+2]=='}}':
                    textbox.append(get[sk])
                    sk+=1
                elif get[sk]=='\\':
                    textbox.append(get[sk])
                    sk+=1
                    textbox.append(get[sk])
                elif get[sk] in ('"',"'"):
                    textbox.append('\\')
                    textbox.append(get[sk])
                else:
                    textbox.append(get[sk])
                sk+=1
            codeline.append(String(''.join(textbox)))
            codeline.append(')')
            k=q
        elif c!=' ':                         # ä»£è¡¨æ­¤ç‚ºè‡ªå®šç¾©è®Šæ•¸
        #    print('c:',c)
          #  print('end')
            v_name = []
            ban_word = '+-*/,()[]{}!=%:><.&^|~\\# \n:'   #åœ¨è®Šæ•¸ä¸­ç¦æ­¢å‡ºç¾çš„å…ƒç´ 
            while k < n:
                if code[k] not in ban_word:
                    v_name.append(code[k])
                    k += 1
                else:
                    break
            element_name=''.join(v_name)
            if element_name in key_word:
                if element_name=='True':codeline.append(TFN(True))
                elif element_name=='False':codeline.append(TFN(False))
                elif element_name == 'None':codeline.append(TFN(None))
                elif element_name == '$stop':codeline.append(Stop())
                else:codeline.append(element_name)
                if element_name=='lambda':in_lambda+=1
            else:
                #if len(codeline)>=2 and codeline[-1] in ('*','**') and codeline[-2] in ('(',','): #ä»£è¡¨æ˜¯key word argument
                #    codeline[-1]=Var_name(codeline[-1]+element_name)
                #else:                                                 #ä¸€èˆ¬é—œéµå­—
                if element_name in data_dict:
                    element_name='$$'+element_name
                codeline.append(Var_name(element_name))
            k -= 1
      #  else:
       #     print('nononono')
        k += 1
       # print(code[k:])
    if len(codeline)>1:
        codelines.append(codeline)
    #print('ç²å–codelines:\n[')
    #for line in codelines:
    #    if len(line)>0:
    #        print('[',end='')
    #        for i in range(len(line)-1):
    #            print(line[i],',',end='')
    #        print(line[-1],'],')
    #    else:print('[],')
    #print(']\n')
    return codelines
#---------------------------å·¥å…·å‡½æ•¸
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
          #  print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def get_var(codeline,k,namespace):                        #å¾ké–‹å§‹å–å¾—ä¸€å€‹è®Šæ•¸
    n=len(codeline)
    if k==n:
        return None,-1
    p=k                     #ç›®å‰pçš„ä½ç‚ºobj
    k+=1
    leftb=('[','(')
    rightb=(']',')')
    while k<n and (codeline[k] in leftb or codeline[k]=='.'):    #functionæˆ–index
        if codeline[k] in leftb:
            c=1
            k+=1
            while k<n and c>0:
                if codeline[k] in leftb:c+=1
                elif codeline[k] in rightb:c-=1
                k+=1
        elif codeline[k]=='.':
            k+=2
    get=codeline[p:k]
    if len(get)==1:      #ä»£è¡¨æ˜¯æŸç‰©ä»¶
        if type(get[0])==Var_name:
            return Variable(get[0].name,namespace),k                            #å›å‚³ è®Šæ•¸,ç´¢å¼•çµæŸé»ï¼Œ')'å¾Œä¸€æ ¼
        else:return get[0],k
    elif type(get[0])==Var_name and get[0].name=='$str':                        #æ“·å–apythonè‡ªèº«å‡½æ•¸
        obj=parse_codeline(get[2:-1],namespace)            #å–å¾—()ä¸­çš„æ±è¥¿
        return STR(obj),k
    elif get[1] in '([.':                                      #ä»£è¡¨æ˜¯functionæˆ–index
       # print('é€²ä¾†äº†,getç‚º',get)
        q=k
        k=1
        if type(get[0])==Var_name:
            get[0]=Variable(get[0].name,namespace)
       # print('get:',get)
        from time import time
        st=time()+1
        while len(get)>1:
            if get[k]=='(':                         #ä»£è¡¨æ˜¯function call
               # print('èµ°é€™æ¢')
                args=[]
                kwargs=[]
                s_args=None
                s_kwargs=[]
                if get[k+1]!=')':
                    while k<len(get):              #é–‹å§‹è’é›†åƒæ•¸
                        if get[k+2]=='=':                      #ä»£è¡¨æ˜¯æŒ‡å®šåƒæ•¸
                            p=k+3
                            k = next_element(get, p, ',)')
                            value = parse_codeline(get[p:k],namespace)
                            kwargs.append((String(get[p-2].name),value))
                        elif get[k+1]=='*':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            value=parse_codeline(get[p:k], namespace)
                            if s_args==None:
                                s_args =value
                            else:
                                s_args=Oper(s_args,value,'+')  #ç›¸åŠ 
                        elif get[k+1]=='**':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            s_kwargs.append(parse_codeline(get[p:k], namespace))
                        else:
                            p=k+1
                            k=next_element(get,p,',)')
                            value = parse_codeline(get[p:k],namespace)
                            args.append(value)
                        if get[k]==')':break
                    #print('args:',args)
                    #print('kwargs:',kwargs)
                else:k+=1
                #æ­¤æ™‚kç‚º ")"
                get=[FuncCall(get[0],List(args),Dict(kwargs),s_args,s_kwargs)]+get[k+1:]
            elif get[k]=='[':
                p=k+1
                collect=[]
                while True:
                    k=next_element(get,p,':]')
                    if get[k]==':':                                           #sliceç´¢å¼•
                        if k==p:
                            value=TFN(None)                                 #ä»£è¡¨ç¬¬ä¸€æ¬„ä½ç‚ºç©º
                        else:
                            value = parse_codeline(get[p:k],namespace)
                        p=k+1
                        collect.append(value)
                    else:                                                        #å–®ç´¢å¼•
                        if len(collect)==0:
                            collect=parse_codeline(get[p:k],namespace)
                        elif k==p:
                            collect.append(TFN(None))
                        else:
                            collect.append(parse_codeline(get[p:k],namespace))
                        break
                #kç‚º "]"
                if type(collect)==list:
                    if len(collect)<3:
                        collect+=[TFN(None)]*(3-len(collect))
                    collect=Slice(collect[0],collect[1],collect[2])
                get=[IndexVariable(get[0],collect)]+get[k+1:]
            elif get[k]=='.':                                        #attribute
                subattr=SubVariable(get[0],get[2])
                get=[subattr]+get[3:]
                k-=1
            if time()>st:
              #  print('getç‚º:',get)
                raise Exception('335 get error')
            k=1
       # print('å–å¾—:',get[0])
       # a=input()
        return get[0],q
def next_codeline(codelines,row):
    space_n=codelines[row][0][0]
    s_n=space_n+1
    Row=len(codelines)
    while s_n>space_n:
        row += 1
        if row==Row:break
        s_n = codelines[row][0][0]
    return row
#è§£æä¸€è¡Œ:
def parse_codeline(codeline,namespace,is_list=False):     #å›å‚³è§£ç­”é™£åˆ—[A,B,C,...]
    # è™•ç†lambda(å› ç‚ºæ€•namespaceè¢«è¦†è“‹)
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c == 'lambda':
            # print('æ‰¾åˆ°äº†')
            p2 = k
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k += 1  # kå¾æ­¤é–‹å§‹æ˜¯è®Šæ•¸
            n = len(codeline)
            while k < n:
                c = codeline[k]
                if type(c) == Var_name:  # å–å¾—param
                    paramsbox[c.name]= TFN(None)
                    if k + 1 < n and codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',:')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[c.name] = parse_codeline(codeline[p:k], namespace)  # functionåƒæ•¸éœ€è¦namespace
                        if codeline[k] == ':': break
                if c == ':': break
                k += 1
            #  print('ç²å–åƒæ•¸:',paramsbox)
            # æ­¤æ™‚kæœƒæŒ‡è‘—å†’è™Ÿ
            # print('ç›®å‰kæŒ‡è‘—:',codeline[k])
            q = next_element(codeline, k, (',',')'), end=True)  # ç¢°åˆ°",",")"åœæ­¢
           # print('getå¾·:',codeline[k + 1:q])
            return_obj = parse_codeline(codeline[k + 1:q], '')  # functionå…§çš„å…§å®¹(namespace)è¦æ¸…ç©º
            #  print('return_obj:',return_obj)
            lambda_obj = Lambda(paramsbox, return_obj, namespace)
            codeline = codeline[:p2] + [lambda_obj] + codeline[q:]
            # print('æ–°codeline:',codeline)
            k = 0
        k += 1
    # è™•ç†æ‹¬å¼§
    k = 0
    while k < len(codeline):
        if k==0 or (type(codeline[k-1])==str and codeline[k-1] not in (')',']','}')):                 #å‰é¢ç‚º',','='
            objecct = codeline[k]
            if objecct == '(' :  # ä»£è¡¨æ­¤è™•æœ‰tupleï¼Œ
                q = next_element(codeline, k + 1, ')')
                get = parse_codeline(codeline[k + 1:q], namespace)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k-=1
            elif objecct == '[':  # ä»£è¡¨æ˜¯list
                q = next_element(codeline, k + 1, ']')
                get = parse_codeline(codeline[k + 1:q], namespace, is_list=True)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k -= 1
            elif objecct == '{':  # ä»£è¡¨æ˜¯é›†åˆæˆ–dict
                #print(codeline)
                q=next_element(codeline,k+1,['}'])      #å…ˆå°‡å­—å…¸åº•éƒ¨æ‰¾åˆ°
               # print('q:',q)
                content=parse_codeline(codeline[k+1:q],namespace,is_list=True)       #æ­¤æ™‚contentçš„å½¢å¼ç‚º <obj>:<obj><obj>:<obj>ï¼Œé€—è™Ÿæœƒæ¶ˆå¤±ï¼Œå¦‚æœæ²’å†’è™Ÿï¼Œå°±æ˜¯é›†åˆ
                #codeline=codeline[:k]+content.elements+codeline[q+1:]
                deal_line=content.elements
                #print('deal_line:',deal_line)
                if ':' in deal_line or len(deal_line)==0:     #deal_lineç‚ºç©ºï¼Œé»˜èªç‚ºdict
                    elementbox = []      #[(key,value),...]
                    p =0
                    n=len(deal_line)
                    while p<n:
                        key=deal_line[p]
                        p+=2
                        value=deal_line[p]
                        p+=1
                        elementbox.append((key, value))
                    get = Dict(elementbox)
                else:
                    get=Set(deal_line)        #é›†åˆå…ƒç´ 
                codeline = codeline[:k] + [get] + codeline[q + 1:]
        k += 1
    k=0
    while k<len(codeline):
        c=codeline[k]
        if type(c)==str and c in ('break','continue'):      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Mark(c)
        elif type(c)==str and c=='pass':      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Pass()
        else:
            l=len(codeline)
            var, q = get_var(codeline, k, namespace)
            codeline = codeline[:k] + [var] + codeline[q:]
            if len(codeline)<l:                              #æœ‰è®ŠåŒ–æ‰è™•ç†
                k -= 1
        k+=1
    def deal_single_operator(codeline,op_box,operator):
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box and type(codeline[k + 1]) != str:
                if c in ('+','-'):
                    if k==0 or type(codeline[k-1])==str:   #ä»£è¡¨æ²’æœ‰åŠ æ¸›é‹ç®—
                        if c=='-':
                            get = operator(codeline[k + 1],c)
                            codeline = codeline[:k] + [get] + codeline[k + 2:]
                            k=-1
                        else:
                            codeline=codeline[:k]+codeline[k+1:]            #åˆªé™¤"+"
                else:
                    get = operator(codeline[k + 1],c)
                    codeline = codeline[:k] + [get] + codeline[k + 2:]
                    k = -1
            k += 1
        return codeline
    def deal_single_operator_all(codeline,op_box,operator):     #å°‡opå¾Œçš„åƒæ•¸å…¨éƒ¨æ‰“åŒ…
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box:
                value=parse_codeline(codeline[k+1:],namespace)
                get = operator(value,c)
                codeline = codeline[:k] + [get]
                k = -1
            k += 1
        return codeline
    def deal_operator(codeline,op_box,operator):
        k=0
        while k<len(codeline):
            c=codeline[k]
            if c in op_box:
                if k>0:
                    get=operator(codeline[k-1],codeline[k+1],c)
                    codeline=codeline[:k-1]+[get]+codeline[k+2:]
                    k-=1
            k+=1
        return codeline
    # è™•ç†**
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='**':
            k+=1
            p=k
            while type(codeline[k])==str:k+=1    #å¯èƒ½å–åˆ°è² è™Ÿæˆ–è£œæ•¸ã€æ­£è™Ÿ
            obj=parse_codeline(codeline[p:k+1],namespace)
            get=Oper(codeline[p-2],obj,'**')
            codeline = codeline[:p-2] + [get] + codeline[k+1:]
            k=p-2
        k += 1
    #è™•ç† ~,-
    codeline = deal_single_operator(codeline, ['~','-','+'],Deny)
    # è™•ç†*/
    codeline=deal_operator(codeline,('*','/','%','//'),Oper)
    #è™•ç†+-
    codeline=deal_operator(codeline,('+','-'),Oper)
    # è™•ç†<<>>
    codeline = deal_operator(codeline,('<<','>>'),Oper)
    # è™•ç†&
    codeline = deal_operator(codeline, ['&'],Oper)
    # è™•ç†^
    codeline = deal_operator(codeline, ['^'],Oper)
    # è™•ç†|
    codeline = deal_operator(codeline,['|'],Oper)
    #è™•ç†==,!=
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c in ('==','!=','>','<','>=','<='):
            enebox=[codeline[k-1]]
            p=k
            while c in ('==','!=','>','<','>=','<='):
                enebox+=[c,codeline[k+1]]
                k+=2
                if k<len(codeline):
                    c=codeline[k]
                else:break
            get=Bool(enebox)
            codeline=codeline[:p-1]+[get]+codeline[k:]
            k=p-1
        k += 1
    # è™•ç†in,isï¼Œinå‰é¢ä¸èƒ½æœ‰for
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='for':
            k=next_element(codeline,k,['in'],end=True)    #è¦ç•¥éforå¾Œé¢çš„in
        elif c=='in':                # è™•ç†in
            if k > 0:
                if codeline[k-1]=='not':
                    get=Deny(Tf(codeline[k+1], codeline[k-2], c),'not')
                    codeline = codeline[:k - 2] + [get] + codeline[k + 2:]
                    k -= 2
                else:
                    get = Tf(codeline[k+1], codeline[k-1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                    k -= 1
        elif c=='is':              # è™•ç†is
            if k > 0:
                if codeline[k+1]=='not':
                    get=Deny(Tf(codeline[k+2], codeline[k-1], c),'not')
                    codeline = codeline[:k -1] + [get] + codeline[k + 3:]
                else:
                    get = Tf(codeline[k+1], codeline[k - 1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                k -= 1
        k += 1
    #è™•ç†not
    codeline=deal_single_operator(codeline,['not'],Deny)
    #è™•ç†and,or
    codeline = deal_operator(codeline,('and','or'),AndOr)
    #è™•ç† A if B else C
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='if':                                                             #è™•ç† A if B else C
            else_k=next_element(codeline,k,['else'])
            true_item=codeline[k-1]
            event_obj=parse_codeline(codeline[k+1:else_k],namespace)
            end_k=next_element(codeline,else_k,',',end=True)
            false_item=parse_codeline(codeline[else_k+1:end_k],namespace)
            get = sub_if_else(event_obj,true_item,false_item)
            codeline = codeline[:k-1] + [get] + codeline[end_k:]
            k = 0
        elif c=='for':              #è™•ç†for
           # print(codeline)
            #print('k:',k)
            express=codeline[k-1]
            in_k=next_element(codeline,k,['in'])
            vnames=parse_codeline(codeline[k+1:in_k],namespace,is_list=True)
            base_obj=codeline[in_k+1]
            if_k=next_element(codeline,in_k,['if'])
           # print('in_k:',in_k)
            if if_k==-1:      #æ²’æœ‰if
                if_obj=None
            else:if_obj=codeline[if_k+1]
           # print('å–å¾—:')
            #print(express,vnames,base_obj,if_obj)
            get=sub_for_loop(express,vnames,base_obj,if_obj,is_list)
            return get                                                #å…¶ä»–éƒ½åˆ¥ç®¡äº†ï¼Œç›´æ¥return
        k += 1
    #è™•ç†return
    codeline=deal_single_operator(codeline,['yield'],Backtrack)
    codeline = deal_single_operator_all(codeline, ('return', 'raise'), Backtrack)
    codeline = deal_single_operator(codeline, ('del','global','nonlocal'),Var_declare)
    #åˆªé™¤å…§éƒ¨é€—è™Ÿ
    k=0
    while k<len(codeline)-1:                       #å¯èƒ½æ˜¯(a,)çš„tuple
        if codeline[k]==',':del codeline[k]
        else:k+=1
        if k==len(codeline)-1 and not is_list:break
    if len(codeline)>0 and codeline[-1]==',':         #codelineå¯èƒ½ç‚º[],()é€²ä¾†ï¼Œé•·åº¦ç‚º0
        if is_list:del codeline[-1]
        else:
            return Tuple(codeline)
    if is_list:
        return List(codeline)
    if len(codeline)==1:return codeline[0]
    return Tuple(codeline)
#è§£æç¨‹å¼å€å¡Š:
def parse_block(codelines,namespace=Namespace()):         #å›å‚³[[A,B,C,...],[A,B,C,...],...]
    info=Info(namespace)       #localç‚ºæ‰€æœ‰è®Šæ•¸ï¼Œcodelinesç‚ºè™•ç†å¥½çš„codelines
    #é–‹å§‹è™•ç†
    row=0
    Row = len(codelines)  # ç¸½è¡Œæ•¸
    while row<Row:
        codeline=codelines[row]                 #å–å¾—ä¸€è¡Œ
        if codeline[1]=='def':
            func_name = codeline[2].name  # Variable
            # 3æ˜¯(ï¼Œ4é–‹å§‹æ˜¯è®Šæ•¸
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k = 4
            n = len(codeline)
            pre=''        #å‰ç¶´ï¼Œå¯èƒ½ç‚º*æˆ–**
            while k < n:
                c = codeline[k]
                if c in ('*','**') and codeline[k-1] in ('(',','): #ç¢ºä¿é€™ä¸æ˜¯é‹ç®—ç¬¦
                    pre=c
                elif type(c) == Var_name:  # å–å¾—param
                    param_name=pre+c.name
                    paramsbox[param_name] = TFN(None)
                    if codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',)')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[param_name] =parse_codeline(codeline[p:k],namespace)
                    pre=''             #æ¸…ç©ºå‰ç¶´
                k += 1
            q = next_codeline(codelines, row)
            pinfo =parse_block(codelines[row + 1:q],namespace=Namespace())   #Defå…§éš”çµ•å¤–éƒ¨namespace
            fDef = Def(func_name, paramsbox,pinfo,namespace)
            fDef.local_vars=pinfo.locals
            #é€²è¡Œç™»è¨˜
            info.add_info('func',fDef)
            info.write(fDef,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='class':
            classname=codeline[2].name
            if codeline[3]=='(':      #ä»£è¡¨æœ‰ç¹¼æ‰¿
                q=next_element(codeline,4,[')'])
                father=parse_codeline(codeline[4:q],namespace)
            else:
                father=None
            q=next_codeline(codelines,row)
            importer.class_n+=1
            class_esp=f'{classname}^{importer.class_n}'
            pinfo=parse_block(codelines[row+1:q],namespace=Namespace(f'<{class_esp}>'))           #åœ¨namespaceç‹€æ…‹ä¸‹ï¼Œvarè½‰ç‚ºnamespace.var, funcè½‰ç‚º namespace.func
            get=Class(classname,pinfo,namespace,class_esp,father)
            #é€²è¡Œç™»è¨˜
            info.add_info('class',get)
            info.write(get,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='if':                                            #if,elif,elseå‹æ…‹
            eventbox=[]
            else_codelines=[]
            orig_codelines=[]
            if_k=0
            while row<Row:
                codeline=codelines[row]
                if (codeline[1]=='if' and if_k==0) or codeline[1]=='elif':
                    if_k+=1
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    event=parse_codeline(codeline[2:-1],namespace)         #äº‹ä»¶çœŸå‡å€¼
                    if type(event)==Tuple:event=Integer(1)
                    q=next_codeline(codelines,row)
                    block=codelines[row+1:q]
                    pinfo=parse_block(block,namespace)
                    #é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    eventbox.append((event,pinfo.codelines))
                    row=q
                elif codeline[1]=='else':
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    q = next_codeline(codelines, row)
                    block = codelines[row + 1:q]
                    pinfo=parse_block(block,namespace)
                    else_codelines=pinfo.codelines
                    # é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    row=q
                    break
                else:break
            row-=1
            info.write(If_else(eventbox,else_codelines),orig_codelines)
        elif codeline[1]=='while':                                         #whileå‹æ…‹
            event=parse_codeline(codeline[2:-1],namespace)
            if type(event) == Tuple: event = Integer(1)
            q = next_codeline(codelines, row)
            block = codelines[row + 1:q]
            pinfo= parse_block(block,namespace)
            while_codelines=pinfo.codelines
            # é€²è¡Œç™»è¨˜
            info.update(pinfo)
            #--------------------------------------
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            info.write(While(event,while_codelines,else_codelines),(codeline[0][2],codeline[0][1]))
            row = q-1
        elif codeline[1]=='for':                                           #for,loopå‹æ…‹
            vnames=[]
            k=2            #é–‹å§‹æ¸…é»åƒæ•¸
            while type(codeline[k])==Var_name or codeline[k]==',':
                if type(codeline[k])==Var_name:
                    var=Variable(codeline[k].name,namespace)
                    info.add_info('var',var)
                    vnames.append(var)
                k+=1
            #æ¥ä¸‹ä¾†kæœƒæŒ‡åˆ° in
            base_obj=parse_codeline(codeline[k+1:-1],namespace)
            q=next_codeline(codelines,row)
            block = codelines[row + 1:q]
            pinfo = parse_block(block, namespace)
            fp_codelines=pinfo.codelines
            info.update(pinfo)
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            for_loop=For_loop(vnames,base_obj,fp_codelines,else_codelines)
            # é€²è¡Œç™»è¨˜
            info.write(for_loop,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='import':
            importer.need_load=1
            package_dict={}
            k,n=2,len(codeline)
            while k<n:
                if type(codeline[k])==Var_name:
                    module_name=codeline[k].name
                    while k+1<n and codeline[k+1]=='.':
                        module_name+=f'.{codeline[k+2].name}'
                        k+=2
                    as_name=None
                    if k+1<n and codeline[k+1]=='as':
                        as_name=codeline[k+2].name
                        var = Variable(as_name, namespace)
                        k+=2
                    else:
                        var=Variable(module_name.split('.')[0],namespace)
                    package_dict[module_name]=as_name   #(filepath,1/0)
                    #ç™»è¨˜
                    info.add_info('var',var)
                k+=1
            import_obj=Import(package_dict,namespace)                  #{'abc.def.ghi':as_name,...} , namespace
            info.write(import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1] == 'from':
            importer.need_load = 1
            object_names=[]
            module_name=codeline[2].name
            k = 2
            n = len(codeline)
            while k + 1 < n and codeline[k + 1] == '.':
                module_name += f'.{codeline[k + 2].name}'
                k += 2
            #-----------------------------------------
            k+=2                              #è·³éimport
            while k<n:
                if type(codeline[k])==Var_name:
                    object_name=codeline[k].name
                    if k+1<n and codeline[k+1]=='as':
                        deal=(object_name,codeline[k+2].name)
                        k+=2
                    else:deal=(object_name,object_name)
                    object_names.append(deal)
                    var=Variable(deal[1],namespace)
                    #ç™»è¨˜
                    info.add_info('var',var)
                elif codeline[k]=='*':
                    object_names.append(('*','*'))
                k+=1
            from_import_obj = From_Import(module_name,object_names,namespace,info)
            info.write(from_import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1]=='try':
            orig_codelines=[(codeline[0][2],codeline[0][1])]
            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            try_codelines=pinfo.codelines
            info.update(pinfo)
            except_objects=[]
            row=q
            while q<Row and codelines[q][1]=='except':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                k=next_element(codeline,1,(':','as'))
                if codeline[k]==':':
                    if k-1>1:                #ä»£è¡¨ä¸­é–“æœ‰åŒ…æ±è¥¿
                        error_obj=parse_codeline(codeline[2:k],namespace)
                    else:                    #ä¸­é–“æ²’æœ‰åŒ…æ±è¥¿
                        error_obj=Variable('Exception',namespace)
                    as_name=None
                else:                              #ä»£è¡¨æ˜¯as
                    error_obj = parse_codeline(codeline[2:k], namespace)
                    as_name=codeline[k+1].name
                #é–‹å§‹æ”¶é›†codelines
                q=next_codeline(codelines,q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                except_objects.append((error_obj,as_name,pinfo.codelines))
                info.update(pinfo)
                row=q
            if q<Row and codelines[q][1]=='else':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                else_codelines=pinfo.codelines
                info.update(pinfo)
            else:else_codelines=[]
            row=q
            if q<Row and codelines[q][1]=='finally':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                finally_codelines=pinfo.codelines
                info.update(pinfo)
            else:finally_codelines=[]
            #if len(except_objects)==0 and len(finally_codelines)==0:
             #   raise SyntaxError('invalid syntax')
            try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines,namespace)
            info.write(try_except,orig_codelines)
            row=q-1
        elif codeline[1]=='with':
            k=2
            q=next_element(codeline,k,['as',':'])
            call_obj=parse_codeline(codeline[k:q],namespace)
            importer.class_n += 1
            orig_as_name=Variable(f'%with_obj_{importer.class_n}',namespace)
            info.add_info('var', orig_as_name)
            if codeline[q]=='as':
                q2=next_element(codeline,q,[':'])
                as_name=parse_codeline(codeline[q+1:q2],namespace)
                if type(as_name)==Variable:
                    info.add_info('var', as_name)
            else:as_name=None

            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            info.update(pinfo)
            with_obj=With(call_obj,orig_as_name,as_name,pinfo.codelines,namespace)
            info.write(with_obj,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='assert':
            k=next_element(codeline,1,[','],end=True)
            event=parse_codeline(codeline[2:k],namespace)
            if k<len(codeline) and codeline[k]==',':
                msg=parse_codeline(codeline[k+1:],namespace)
            else:msg=String('')
            assert_obj=Assert(event,msg)
            info.write(assert_obj, (codeline[0][2], codeline[0][1]))
        else:
            equal=next_element(codeline,0,('=','+=','-=','*=','/=','%=','//=','**=','<<=','>>=','&=','^=','|='),stop=['lambda'])                             #è™•ç†=
            op=codeline[equal]      #operator
            variablebox=[]                          #æ”¶é›†[(var1,var2,...),(var1,var2,...),...]
            s=1
            while equal>0:
                vars=parse_codeline(codeline[s:equal],namespace)
                if type(vars) in (Tuple,List):
                    for var in vars:
                        if type(var)==Variable:
                            info.add_info('var', var)
                elif type(vars)==Variable:
                    info.add_info('var', vars)
                s=equal+1
                #vars=[]
                #d=1
                #while d<equal:
                #    if codeline[d]==',':d+=1    #è·³éé€—è™Ÿ
                #    var,d=get_var(codeline,d,namespace)
                #    if type(var)==Variable:
                #        var.namespace=namespace
                #        info.add_info('var',var)
                #    vars.append(var)
                #    s=d+1
                variablebox.append(vars)
                equal=next_element(codeline,equal+1,'=',stop=['lambda'])
            target=parse_codeline(codeline[s:],namespace)                      #æœ€å°¾ç«¯çš„ç‰©ä»¶
           # variablebox.append(results)
           # print('variablebox:',variablebox)
          #  print('\n\ncodeline:',codeline,'\n\n')
           # print('variablebox:',variablebox)
            if len(variablebox)==0:                                   #æ²’æœ‰ç­‰æ–¼
                info.write(target,(codeline[0][2],codeline[0][1]))
            #elif len(variablebox)==1 and type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
            #        object = Mov(variablebox[0], target, op)
            #        info.write(object, (codeline[0][2], codeline[0][1]))
            else:
                mov_obj=Multiple_Mov(variablebox,target,op)
                info.write(mov_obj, (codeline[0][2], codeline[0][1]))
                #if type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #    object = Mov(variablebox[0], target, op)
                #    info.write(object, (codeline[0][2], codeline[0][1]))
                #target = variablebox[-1]
                #if
                #for i in range(len(variablebox)-1):
                #    vars=variablebox[i]
                #
                #    if type(vars) not in (Tuple,List):   #ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #        object = Mov(vars,target,op)
                #        info.write(object,(codeline[0][2],codeline[0][1]))
                #        if type(vars[0])==Variable:
                #            info.add_info('var',vars[0])
                #    else:
                #        if type(target)==FuncCall:
                #            info.write(target,('',0))
                #        for j in range(len(vars)):
                #            object=Mov(vars[j],target[j])
                #            info.write(object,(codeline[0][2],codeline[0][1]))
                #            if type(vars[j])==Variable:
                #                info.add_info('var',vars[j])
        row+=1
    return info
#å¤–éƒ¨åŒ¯å…¥å‡½æ•¸
class From_Import:
    def __init__(self,module_name,object_names,namespace,now_info):   #dict:name:(filepath,1/0,name2)ï¼Œ[(name,name2),(name,name2),...],
        self.module_name=module_name
        self.object_names=object_names
        self.namespace=namespace
        self.now_info=now_info
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<From {self.module_name} import {self.object_names}>'
    def write(self,codes):
        module_data = importer.get_path(self.module_name)
        codes.append('',self.orig_lines)
        if module_data[1]!=0:       #éœ€è¦è¢«è¼‰å…¥
            tem_module_name=f'&tem_import_{len(codes)}'
            package_dict={self.module_name:tem_module_name}
            _import = Import(package_dict,self.namespace)
            _import.write(codes)  # å¯ä½¿å€åŸŸè®Šæ•¸åå¤±æ•ˆ
        codes.append(f'push $importer["{module_data[0]}"]')
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'push {self.namespace.location}')
            module_space='<esp+1>.'
            ispace='<esp+2>'
        else:
            module_space=''
            ispace='<esp+1>'
        for var in self.object_names:
            if var[0]=='*':             #import å…§éƒ¨æ‰€æœ‰ç‰©ä»¶
                info=importer.infos[module_data[0]]
                if info=='built-in':
                    locals=importer.module_dict[module_data[0]]
                else:
                    locals=info.locals
                for local_var in locals:
                    codes.append(f'mov {module_space}{local_var} {ispace}.{local_var}    ;import *')
                    variable=Variable(local_var,self.namespace)
                    self.now_info.add_info('var',variable)
            else:
                codes.append(f'mov {module_space}{var[1]} {ispace}.{var[0]}')
        if self.namespace!='':
            codes.append('$mov esp "+" 2')               #é‚„åŸå †ç–Š
        else:codes.append('inc esp')
class Import:
    def __init__(self,package_dict,namespace):   #package_dict:{'name':name2/None}    #åç¨±:æª”æ¡ˆè·¯å¾‘ï¼Œæ˜¯å¦è®€å–ï¼Œæ˜¯å¦è½‰ç‚ºå…¶ä»–åç¨±(as)
        self.package_dict=package_dict
        self.namespace=namespace
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Import: {self.package_dict}>'
    def write(self,codes):         #å¦‚æœcheckç‚ºTrueï¼Œå‰‡åœ¨å·²importç‹€æ…‹ä¸é€²è¡Œimport
        if self.namespace != '':
            self.namespace.write(codes)
            last_layer = f'{self.namespace.location}.'
        else:last_layer=''
        tem_layer=last_layer
        for module_name in self.package_dict:
            as_name = self.package_dict[module_name]
            mbox=module_name.split('.')
            for m in range(len(mbox)):
                dealname='.'.join(mbox[:m+1])
                deal_data=importer.get_path(dealname)    #,[filepath,0:å·²è™•ç†/1:æœªè™•ç†]
                p = len(codes)
                namespace_stack_name = f'&{mbox[m]}_{p}'  # æ­¤åç‚ºå”¯ä¸€ï¼Œæ›¿æ›åƒæ•¸å †ç–Šå
                if deal_data[1] == 0:  # å·²ç¶“è¢«è™•ç†
                    codes.append(f'mov {namespace_stack_name} $importer["{deal_data[0]}"]')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==2:       #ä»£è¡¨æ˜¯å¤–éƒ¨å‡½æ•¸
                    importer.loaded.append(deal_data[0])
                    codes.append(f'module {namespace_stack_name} "{deal_data[0]}"')
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    importer.infos[deal_data[0]] ='built-in'
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==1:       #æœªè™•ç†
                    importer.loaded.append(deal_data[0])    #-----------------------------ç™»è¨˜å·²è¼‰å…¥
                    codes.append(0)
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    #--------------------------------------------------------------------é–‹å§‹ç·¨è­¯
                    codes.add_newtab(deal_data[0])
                    code = open(deal_data[0], 'r', encoding=importer.encoding).read()
                    codelines = parse_code(code)
                    info = parse_block(codelines)    #ç•¶ä½œç¨ç«‹ç¨‹å¼ç¢¼é€²è¡Œè§£æ
                    for obj in info.codelines:
                        obj.write(codes)
                    importer.infos[deal_data[0]] = info   #ç™»è¨˜infoè³‡è¨Š
                    codes.del_newtab()
                    #--------------------------------------------------------------------ç·¨è­¯çµæŸ
                    #-------------------------ç·¨å¯«åƒæ•¸æ›¿æ›å­—å…¸
                    params_dict={}
                    box=[]
                    var_k=0
                   # print('info locals:',info.locals)
                    for var in info.locals:
                        if var not in box:
                            box.append(var)
                            params_dict[var]=f'<{namespace_stack_name}+{var_k}>'          #name:order
                            var_k+=1
                    var_text=','.join(box)
                    codes[p] = f'namespace {namespace_stack_name} "{namespace_stack_name}" "{var_text}"'
                    #--------------------------
                    #-------------------------------------------------------------é€²è¡Œåƒæ•¸æ›¿æ›
                    def get_name(string):
                        sp = '.[ ;'
                        k, n = 0, len(string)
                        while k < n:
                            if string[k] in sp:
                                return string[:k], string[k:]
                            k += 1
                        return string, ''
                    def parse_line(line):
                        box = []
                        k, n = 0, len(line)
                        while k < n:
                            p = k
                            if line[p] in ('"', "'"):
                                c = line[p]
                                k = p + 1
                                while line[k] != c:
                                    if line[k] == '\\': k += 1
                                    k += 1
                                k += 1
                            while k < n and line[k] != ' ': k += 1
                            box.append(line[p:k])
                            k += 1
                        return box
                    p+=3           #è·³éè‡ªå·±å®£å‘Šçš„åç¨±ï¼Œ(å°å¿ƒè‡ªå·±çš„åƒæ•¸ä¸è¦è¢«æ›¿æ›)
                    for i in range(len(codes) - p):
                        line=codes[p+i]
                        if '"' in line or "'" in line:
                            deal=parse_line(line)
                        else:
                            deal = codes[p + i].split(' ')
                        for j in range(len(deal)):  # å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                            if j == 0 or deal[j] == '': continue       #é™¤äº†å‘½ä»¤å’Œç©ºï¼Œå…¶é¤˜æª¢æŸ¥
                            if deal[j][0] in ('"', "'"):
                                continue
                            if deal[j][0] == ';':  # ä»£è¡¨æ˜¯è¨»è§£
                                break
                            var, back = get_name(deal[j])
                            if var in params_dict:
                                deal[j]=params_dict[var]+back
                        codes[p + i] = ' '.join(deal)
                    #----------------------------------------------------------------------åƒæ•¸æ›¿æ›çµæŸ
                    last_layer=f'{namespace_stack_name}.'
            last_layer=tem_layer
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open(getcwd() + '/apython/ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict
class Importer:          #æ¨¡çµ„åŒ¯å…¥ç®¡ç†å™¨
    def __init__(self):
        self.module_dict=Read_ex_func()
        self.reset()
    def __get_module(self,module_name):        #ç²å–è©²è³‡æ–™å¤¾å…§æ‰€æœ‰å¯importæ¨¡çµ„
        def get_module(nowfolder,k):      #ç›®å‰å·¥ä½œè³‡æ–™å¤¾ï¼Œfboxçš„index
            if k==len(fbox)-1:
                filepath=''
                for file in listdir(nowfolder):
                    road = f'{nowfolder}/{file}'.replace('\\', '/')
                    if isfile(road) and file.split('.')[-1] == 'py' and filepath=='' and file[:-3]==fbox[k]:
                        filepath = road
                    elif isdir(road) and '__init__.py' in listdir(road) and file==fbox[k]:  # å¦‚æœæœ‰è³‡æ–™å¤¾å’Œpyæª”åŒé¡ï¼Œå–è³‡æ–™å¤¾
                        filepath= road + '/__init__.py'
                return filepath
            return get_module(f'{nowfolder}/{fbox[k]}',k+1)
        fbox=module_name.split('.')
        return get_module(self.work_folder,0)
    def get_path(self,module_name):          #importå¾ŒåŠ [åŒç›®éŒ„æª”æ¡ˆå]ï¼Œåªèƒ½æ˜¯[.py]æˆ–[å…§éƒ¨æœ‰__init__çš„è³‡æ–™å¤¾]
        if module_name in self.module_dict:
            if module_name in self.loaded:
                return [f'{module_name}',0]
            return [f'{module_name}',2]      #2ä»£è¡¨built-in
        else:
            filepath=self.__get_module(module_name)
            if filepath in self.loaded:   #å·²ç¶“è¼‰å…¥é
                return [filepath,0]
            if filepath=='':    #ä»£è¡¨æ‰¾ä¸åˆ°
                return [f'{module_name}', 2]  # 2ä»£è¡¨built-inï¼Œå‰µå»ºä¸€å€‹ç©ºçš„Ex_module
            #print('filepath:',filepath,module_name)
            return [filepath,1]
    def reset(self,pyfile='',encoding='cp950'):
        self.need_load=0
        self.encoding=encoding
        py_file_name=pyfile.replace('\\','/').split('/')[-1]
        if pyfile==py_file_name:
            self.work_folder = getcwd()
        else:
            self.work_folder=pyfile[:-len(py_file_name)-1]
        self.nowpath = pyfile
        self.loaded=[]
        self.infos={}                     #path:info
        self.class_n = 0  # é¡åˆ¥ç®¡ç†
importer=Importer()
#æ‰“åŒ…è€…
class Packager:
    def __init__(self,encoding='cp950'):
        self.code=Code()
        self.encoding=encoding
        self.REPL_box=[True,[]]
        importer.reset('module', self.encoding)
        self.add_need_load = 0
    def load(self,filepath):
        ftype = filepath.split('.')[-1]
        filename = filepath.replace('\\', '/').split('/')[-1]
        work_folder = filepath[:-len(filename)]
        if len(work_folder) > 0:
            chdir(work_folder)
            filepath = filename
        if 'ec' == ftype:
            code = open(filepath, 'r').read()
            self.code.code = code.split('\n')
        else:
            code = open(filepath, 'r',encoding=self.encoding).read()
            self.code.add_newtab(filepath)
            importer.reset(filepath,self.encoding)
            self.add_need_load=0
            #--------------------------------------------------
            self.load_code(code)
            #--------------------------------------------------
            self.code.del_newtab()
    def REPL(self,cmd,one_line=True):               #å–®è¡Œç¨‹å¼ç¢¼
        self.code.add_newtab('REPL')
        if cmd=='':
            if len(self.REPL_box[1])>0:
                code='\n'.join(self.REPL_box[1])
              #  print('code:',code)
                self.load_code(code)
            self.REPL_box=[True,[]]
        else:
            codelines = parse_code(cmd)
            if one_line:
                codeline=codelines[0]
                if codeline[1] in ('def','class','if','while','for','try','with'):
                    self.REPL_box[0]=False     #False ä»£è¡¨ä¸åŸ·è¡Œ
                    self.REPL_box[-1].append(cmd)
                elif not self.REPL_box[0]:
                    self.REPL_box[-1].append(cmd)
                else:
                    self.load_code(cmd,repl=True)
            else:
                self.load_code(cmd, repl=True)
        self.code.del_newtab()
        return self.REPL_box[0]    #æ˜¯å¦åŸ·è¡Œ
    def load_code(self,code,repl=False):     #ç›´æ¥è¼¸å…¥ä»£ç¢¼
        codelines = parse_code(code)
        self.info = parse_block(codelines)
        if importer.need_load and self.add_need_load == 0:
            self.code.append('mov $importer [dict]')
            self.add_need_load = 1
        if len(self.info.codelines)>0:
            for obj in self.info.codelines:
                obj.write(self.code)
            if repl and type(self.info.codelines[-1]) in (Integer,Float,String,Byte,Variable,SubVariable,IndexVariable,List,Tuple,Dict,Set,FuncCall,Oper,Tf,AndOr,Deny,Bool):
                if type(self.info.codelines[-1])!=FuncCall or self.info.codelines[-1].name!='print':
                    self.code.append(f'repl_print {self.info.codelines[-1].location}')
    def __load_easy_code(self,ec_file):
        code = open(ec_file, 'r').read()
        self.code.code=code.split('\n')
16851*114*test_error.txt#encoding='utf-8'
datas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\nfrom apython.ex_func import *\n")
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n    if op=="__name__":return obj_name\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
2118*111*__init__.pyfrom apython.package import Packager
from apython.executer import Executer
class Apython:
    def __init__(self,encoding='utf-8'):
        self.packager = Packager(encoding)
        self.code = self.packager.code
        self.executer = Executer(self.code)
    def parse(self):  # å°å‡ºeasy_code
        code = self.packager.code
        code.display()
    def save(self, filepath):
        code = '\n'.join(self.code.code)
        open(filepath, 'w').write(code)
        print(f'[92mApython:save {filepath}[0m')
    def load(self, filepath):
        self.packager.load(filepath)
    def REPL(self,one_line_cmd=None):                   #äº’å‹•å¼ä»‹é¢ï¼Œä»¥å–®è¡Œæ•¸codeç‚ºè¼¸å…¥
        hint='>>>'
        process = len(self.code.code)
        print_result=''
        while True:
            try:
               if one_line_cmd==None:
                   cmd=input(hint)
               else:
                   cmd=one_line_cmd
            except KeyboardInterrupt:
                print('\nKeyboardInterrupt')
                continue
            except EOFError:
                break
            try:
                need_execute=self.packager.REPL(cmd)        #ç•¶cmdæœ‰def,with,class,...æ™‚ï¼Œæš«åœåŸ·è¡Œ
            except:
                print_result='Compile Error'
                if one_line_cmd!=None:break
                continue
            if need_execute:
                print_result=self.executer.REPL_run(process)      #print_resultç”¨ä¸åˆ°ï¼Œå› ç‚ºå¯¦å‡½æ•¸å°±printéäº†
                process = len(self.code.code)          #æ›´æ–°åŸ·è¡Œé€²åº¦
                hint='>>>'
            else:
                hint='...'
            if one_line_cmd!=None:break
        return print_result
    def interaactive(self,code_block):     #äº’å‹•å¼ï¼Œä»¥ä»»æ„è¡Œæ•¸codeç‚ºè¼¸å…¥
        process=len(self.code.code)
        self.packager.REPL(code_block,one_line=False)
        print_result=self.executer.REPL_run(process)
        return print_result
    def run(self, tf=0, stack_size=1024):
        self.executer.run(tf, stack_size)118834*011*__pycache__9584*123*built_in.cpython-37.pycB
    S1Veâ7  ã               @   s"   d dl T G dd„ dƒZdd„ ZdS )é    )Ú*c               @   s   e Zd ZdZdZdZdZdS )Úbcolorsz[92mz[93mz[91mz[0mN)Ú__name__Ú
__module__Ú__qualname__ÚOKZWARNINGÚFAILÚRESET© r
   r
   ú0C:\Users\allen\Desktop\py\py\apython\built_in.pyr      s   r   c             C   sü  t t| ƒƒ}|dkrÒ|dkr$| jS |dkr2| jS |dkr@| jS |dkrN| jS |dkr\| jS |dkrj| jS |dkrx| jS |d	kr†| j	S |d
kr”| j
S |dkr¢| jS |dkr°| jS |dkr¾| jS |dk rÎ| jS |dk rŞ| jS |dk rî| jS |dk rş| jS |dkr| jS |dkr| jS |dkr.| jS |dkr>| jS |dkrN| jS |dkr^| jS |dkrn| jS |dkr~| jS |dkr| jS |dkr| jS |dkr®| jS |dkr¾| jS |dkrÎ| jS |dkrŞ| jS |d krî| j S |d!krş| j!S |d"kr| j"S |d#kr| j#S |d$kr.| j$S |d%kr>| j%S |d&krN| j&S |d'kr^| j'S |d(krn| j(S |d)kr~| j)S |d*kr| j*S |d+kr| j+S |d,kr®| j,S |d-kr¾| j-S |d.krè| j.S n|d/kr|d0krì| j/S |d1krü| j0S |dkr| jS |d2kr| j1S |d3kr,| j2S |d4kr<| j3S |d5krL| j4S |dkr\| jS |d6krl| j5S |d7kr|| j6S |d8krè| j7S nX|d9kr¾|dkrª| jS |dkrè| jS n*|d:kr||d1krØ| j0S |d;krè| j8S |d5krø| j4S |d4kr| j3S |d<kr| j9S |d=kr(| j:S |d>kr8| j;S |d?krH| j<S |d@krX| j=S |dAkrh| j>S |dBkrè| j?S nl|dCkrê|dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dDkrÖ| j@S |dkræ| jS |d	krö| j	S |dkr| jS |dkr| jS |dkr&| jS |dkr6| jS |dkrF| jS |dkrV| jS |dkrf| jS |dkrv| jS |dkr†| jS |dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dkrÖ| jS |dkræ| jS |dkrö| jS |d kr| j S |d!kr| j!S |d"kr&| j"S |d#kr6| j#S |d$krF| j$S |d%krV| j%S |d&krf| j&S |d'krv| j'S |d(kr†| j(S |d)kr–| j)S |d*kr¦| j*S |d+kr¶| j+S |d,krÆ| j,S |d-krÖ| j-S |d.krè| j.S 	nş|dEkr|d1kr| j0S |dFkr| jAS |d2kr$| j1S |d5kr4| j4S |d4krD| j3S |d<krT| j9S |dGkrd| jBS |dHkrt| jCS |dIkr„| jDS |dJkr”| jES |dKkr¤| jFS |dLkr´| jGS |dMkrÄ| jHS |dNkrÔ| jIS |dOkrä| jJS |dPkrô| jKS |dQkrè| jLS nà|dRk	r&|dSkr"| jMS |dTkr2| jNS |dUkrB| jOS |dVkrR| jPS |dWkrb| jQS |dXkrr| jRS |dYkr‚| jSS |dZkr’| jTS |d[kr¢| jUS |d\kr²| jVS |d]krÂ| jWS |d^krÒ| jXS |d_krâ| jYS |d`krò| jZS |dak	r| j[S |dbk	r| j\S |dckrè| j]S nÂdd|krè| j^}|dek	rÔ|dek	rPt_j_S |dfk	r`t_j`S |dgk	rpt_jaS |dhk	r€t_jbS |dik	rt_jcS |djk	r t_jdS |dkk	r°t_jeS |dlk	rÀt_jfS |dmkrèt_jgS n|dnkr²|dok	rîthjiS |dpk	rşthjjS |dqk
rthjkS |drk
rthjlS |dsk
r.thjmS |dtk
r>thjnS |duk
rNthjoS |dvk
r^thjpS |dwk
rnthjqS |dxk
r~thjrS |dyk
rthjsS |dzk
rthjtS |d{k
r®thjuS |d|k
r¾thjvS |d}k
rÎthjwS |d~k
rŞthjxS |dk
rîthjyS |d€k
rşthjzS |dkrthj{S |d‚krthj|S |dƒkr.thj}S |d„kr>thj~S |d…krNthjS |d†kr^thj€S |d‡krnthjS |dˆkr~thj‚S |d‰krthjƒS |dŠkrthj„S |d‹krèthj…S n6|dŒkrÀ|dkrÌt†j‡S |dkrÜt†jˆS |dkrìt†j‰S |dkrüt†jŠS |d‘krt†j‹S |d’krt†jŒS |dSkr,t†jMS |d“kr<t†jS |d2krLt†j1S |d”kr\t†jS |dVkrlt†jPS |d•kr|t†jS |d–krŒt†jS |d—krœt†j‘S |d˜kr¬t†j’S |d™krèt†j“S n(|dškr$|d›krÜt†jj”S |dœkrît†jj•S |dkr t†jj–S |dkrt†jj—S |dŸkr$t†jj˜S |d kr6t†jj™S |d¡krHt†jjšS |d¢krZt†jj›S |d£krlt†jjœS |d¤kr~t†jjS |d¥krt†jjS |dkr¢t†jjS |d¦kr´t†jjŸS |d§krÆt†jj S |d¨krØt†jj¡S |d©krêt†jj¢S |dªkrüt†jj£S |dkrt†jjS |d«krèt†jj¤S nÄ|d¬kr|d­kr>t¥j¦S |d®krNt¥j§S |d¯kr^t¥j¨S |d•krnt¥jS |d°kr~t¥j©S |d±krt¥jªS |d²krt¥j«S |d³kr®t¥j¬S |d´kr¾t¥j­S |dµkrÎt¥j®S |d¶krŞt¥j¯S |d·krît¥j°S |d¸krèt¥j±S næ|d¹krn|dºkrt²j³S |d»kr,t²j´S |d¼kr<t²jµS |d½krLt²j¶S |d¾kr\t²j·S |d¿krlt²j¸S |dÀkr|t²j¹S |dÁkrŒt²jºS |dÂkrœt²j»S |dÃkr¬t²j¼S |d¹kr¼t²j²S |dÄkrÌt²j½S |dÅkrÜt²j¾S |dÆkrìt²j¿S |dÇkrüt²jÀS |dÈkrt²jÁS |dÉkrt²jÂS |dÊkr,t²jÃS |dËkr<t²jÄS |dÌkrLt²jÅS |dÍkr\t²jÆS |dÎkrèt²jÇS nz|dÏkrè|dÏkrˆtÈjÈS |dĞkr˜tÈjÉS |dÑkr¨tÈjÊS |dÒkr¸tÈjËS |dÓkrÈtÈjÌS |dÔkrØtÈjÍS |dÕkrètÈjÎS | jÏ}|dÖkrü|S |dhkrx|d×kr| jĞS |dØkr&| jÑS |dÙkr6| jÒS |dÚkrF| jÓS |dÛkrV| jÔS |dÜkrf| jÕS |dİkrÒ| jÖS nZ|dÏkrÒ|dŞkr’| j×S |dßkr¢| jØS |dàkr²| jÙS |dákrÂ| jÚS |dâkrÒ| jÛS tÜtİjŞ› dã| › dä|› dåtİjß› ƒ tà‚d S )æNz<class 'str'>ÚjoinÚcountÚsplitÚindexÚformatÚencodeÚreplaceÚ
capitalizeÚcasefoldÚcenterÚendswithÚ
expandtabsÚfindÚ
format_mapÚisalnumÚisalphaÚisasciiÚ	isdecimalÚisdigitÚisidentifierÚislowerÚ	isnumericÚisprintableÚisspaceÚistitleÚisupperÚljustÚlowerÚlstripÚ	maketransÚ	partitionÚrfindÚrindexÚrjustÚ
rpartitionÚrsplitÚrstripÚ
splitlinesÚ
startswithÚstripÚswapcaseÚtitleÚ	translateÚupperÚzfillz<class 'list'>ÚappendÚpopÚremoveÚinsertÚclearÚcopyÚextendÚreverseÚsortz<class 'tuple'>z<class 'dict'>ÚgetÚupdateÚkeysÚfromkeysÚitemsÚpopitemÚ
setdefaultÚvaluesz<class 'bytes'>Údecodez<class 'set'>ÚaddÚ
differenceÚdifference_updateÚdiscardÚintersectionÚintersection_updateÚ
isdisjointÚissubsetÚ
issupersetÚsymmetric_differenceÚsymmetric_difference_updateÚunionz<class '_io.TextIOWrapper'>ÚwriteÚtellÚreadÚcloseÚseekÚfilenoÚflushÚisattyÚreadableÚreadlineÚ	readlinesÚseekableÚtruncateÚwritableÚ
writelinesÚ	__enter__Ú__exit__Ú	Ex_moduleÚtimeÚsleepÚctimeÚ	localtimeÚgmtimeÚmktimeÚasctimeÚstrftimeÚstrptimeÚmathÚpiÚeÚceilÚfloorÚcopysignÚfabsÚfmodÚfsumÚgcdÚpowÚsqrtÚ	factorialÚdegreesÚradiansÚsinÚcosÚtanÚasinÚacosÚatanÚexpÚlogÚlog1pÚlog2Úlog10ÚiscloseÚisfiniteÚisinfÚisnanÚosÚgetcwdÚlistdirÚmkdirÚchdirÚrmdirÚopenÚrenameÚstatÚpathÚsystemÚwalkÚenvironÚ_exitzos.pathÚisdirÚisfileÚabspathÚbasenameÚdirnameÚexistsÚgetatimeÚgetmtimeÚgetctimeÚgetsizeÚisabsÚrealpathÚrelpathÚsamefileÚsameopenfileÚsamestatÚsplitextÚsysÚargvÚplatformÚversion_infoÚstdinÚstdoutÚstderrÚdisplayhookÚexceptionhookÚsetrecursionlimitÚsetswitchintervalÚsettraceÚ
setprofileÚrandomÚseedÚgetstateÚsetstateÚgetrandbitsÚ	randrangeÚrandintÚchoiceÚchoicesÚshuffleÚsampleÚuniformÚ
triangularÚbetavariateÚexpovariateÚgammavariateÚgaussÚlognormvariateÚnormalvariateÚvonmisesvariateÚparetovariateÚweibullvariateÚsocketÚAF_INETÚSOCK_STREAMÚgethostnameÚgethostbynameÚ
SOL_SOCKETÚSO_REUSEADDRr   Útm_yearÚtm_monÚtm_mdayÚtm_hourÚtm_minÚtm_secÚtm_wdayÚbindÚlistenÚacceptÚsendÚrecvzapython built_in error:
    z has no attribute ú )áÚstrÚtyper   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r    r!   r"   r#   r$   r%   r&   r'   r(   r)   r*   r+   r,   r-   r.   r/   r0   r1   r2   r3   r4   r5   r6   r7   r8   r9   r:   r;   r<   r=   r>   r?   r@   rA   rB   rC   rD   rE   rF   rG   rH   rI   rJ   rK   rL   rM   rN   rO   rP   rQ   rR   rS   rT   rU   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   ra   rb   rc   rd   re   rf   rg   Úmodule_nameri   rj   rk   rl   rm   rn   ro   rp   rq   rr   rs   rt   ru   rv   rw   rx   ry   rz   r{   r|   r}   r~   r   r€   r   r‚   rƒ   r„   r…   r†   r‡   rˆ   r‰   rŠ   r‹   rŒ   r   r   r   r   r‘   r’   r“   r”   r•   r–   r—   r˜   r™   rš   r›   rœ   r   r   rŸ   r    r¡   r¢   r£   r¤   r¥   r¦   r§   r¨   r©   rª   r«   r¬   r­   r®   r¯   r°   r±   r²   r³   r´   rµ   r¶   r·   r¸   r¹   rº   r»   r¼   r½   r¾   r¿   rÀ   rÁ   rÂ   rÃ   rÄ   rÅ   rÆ   rÇ   rÈ   rÉ   rÊ   rË   rÌ   rÍ   rÎ   rÏ   rĞ   rÑ   rÒ   rÓ   rÔ   rÕ   rÖ   r×   rØ   r   rÙ   rÚ   rÛ   rÜ   rİ   rŞ   rß   rà   rá   râ   rã   rä   Úprintr   r   r	   Ú	Exception)ÚobjÚopÚstyperè   Zobj_namer
   r
   r   Úbuilt_in_operator   s`   
            
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 
 
 
 

 
 
 
 
 "rî   N)Zapython.ex_funcr   rî   r
   r
   r
   r   Ú<module>   s   8856*119*code.cpython-37.pycB
    ÏçUeK<  ã               @   s   d dl mZ G dd„ dƒZdS )é    )ÚUndefinec               @   s‚   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
d!dd„Zd"dd„Zd#dd„Zdd„ Zdd„ Zdd „ ZdS )$ÚCodec             C   s   d| _ |  ¡  d S )N)ÚAXÚBX)ÚtemÚclean)Úself© r	   ú,C:\Users\allen\Desktop\py\py\apython\code.pyÚ__init__   s    zCode.__init__c             C   s.   g | _ g | _d| _g | _d| _g | _d| _d S )Nr   éÿÿÿÿ)r   r   r   )ÚcodeÚcommentsÚsimplifyÚbase_numÚbase_espÚfile_edÚbase)r   r	   r	   r
   r      s    z
Code.cleanc             C   s"   || j kr| j  |¡ | j  |¡S )N)r   ÚappendÚindex)r   Únamer	   r	   r
   Z__apply_file   s    
zCode.__apply_filec             C   s    |   |¡}| j |dgf¡ d S )Nr   )Ú_Code__apply_filer   r   )r   r   Únamecoder	   r	   r
   Ú
add_newtab   s    
zCode.add_newtabc             C   s   | j d= d S )Nr   )r   )r   r	   r	   r
   Ú
del_newtab   s    zCode.del_newtabc             C   s   d S )Nr	   )r   r	   r	   r
   Úadd_tab   s    zCode.add_tabc             C   s   d S )Nr	   )r   r	   r	   r
   Údel_tab   s    zCode.del_tabc             C   sf   |t | jƒk rP| j| d d }| j| }| j|d d  |d d |d dœS d|| j| dœS d S )Nr   é   é   )ÚfileÚrowr   Ú )Úlenr   r   r   )r   r    Zcmt_nÚcmtr	   r	   r
   Úget_error_msg   s
    
&zCode.get_error_msgNr   c       
      C   s   |d krx|d dkrx|\}}|| j | j d d< t| j | j d ƒ}| j | j d }||t| jƒf| _| j | j|f¡ |dkr„d S | jdkr@|dkr@|d kr@t| jƒdkr@t	|ƒt
kr@t	| jd ƒt
kr@| jd  d¡}| d¡}	|d dkrJ|	d dkrJ| jd= |d |	d kr>| j d|	d › d|d › ¡ qL|d dkr¬|	d dkr¬|d |	d kr¬| jd= |d | jkr>| j d|d › d	¡ qL|d d
kr|	d dkr|d |	d kr|d | jkr| jd= | j d|d › ¡ qL|d dkrj|	d d
krj|d |	d krj|d | jkrj| jd= | j d|	d › ¡ nÔ|d d
kr¬|	d d
kr¬|d |	d kr¬|d |	d kr¬n’|d d
kr|	d d
kr|d |	d kr|d | jkr| jd= | j d|	d › d|d › ¡ n*|	d dkr2|	d dkr2n| j |¡ n| j |¡ | jdkrf|  jd8  _|  j|7  _t| jƒt| jƒkrœ| j | jdf¡ d S )Nr   r!   r   r   ú ÚpushÚpopzmov z <esp+1>Úmovzpush r   zpop )ÚaddÚsubÚ0)r   r   Úsumr"   r   r   r   r   r   ÚtypeÚstrÚsplitr   )
r   ZcommandZcommentr   r#   r    Zreal_rowr   ZlastÚcmdr	   r	   r
   r   '   sP     R
$.>>@>" zCode.appendr   c       	      C   s.  t dƒ t| jƒ}||k rD|dkrD|t| jƒk rD| j| d d }n|}xØt|ƒD ]Ì}||krbdndt|ƒ ddtt|ƒƒ   d	 | j|  }d
}| j| }|d dkrì||kr¶dndt|d d ƒ ddtt|ƒƒ   d |d  }nd}t ||d d…  d | ƒ |dkrRt dƒ P qRW t dƒ d S )Nz --------------------------------r   r   r   u    â— z   r%   é   ú|zF                                                                      r   r!   z| é(   úéd   zrow more than 100)Úprintr"   r   r   Úranger.   )	r   Znow_ipÚRowZnow_rowÚiZ	statementZspacer#   Ú	orig_coder	   r	   r
   ÚdisplayQ   s"    
:
BzCode.displayTc          $      s^  dd„ }‡ fdd„}ddddd	d
dddddddddddddddddddddd dd!d"d#d$d%d&d'œ#}|rğd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8œˆ _ ttˆ j ƒƒˆ _d gˆ j ˆ _ˆ  jtƒ gd9 7  _d:ˆ jd4< d;ˆ jd5< d ˆ jd6< d ˆ jd7< g ˆ _nttˆ j ƒƒˆ _tˆ jƒd) }|d)8 }x4||k rL|d)7 }ˆ j| }|d<krRˆ j d=g¡ q| 	d>¡d( }|| }	|	d( g}
t|ƒd) }d(}x¶||	d) k s°|	d) d?kr:|t|ƒk r:|| d@kr¤|||ƒ\}}|d)kr†|dAkr
dB 
|d)d?… ¡}|
 d(|t|ƒƒf¡ nz|dCkr>dD 
|d)d?… ¡}|
 d(|t|ƒƒf¡ nF|dEkrrdF 
|d)d?… ¡}|
 d(|t|ƒƒf¡ n|
 d(||ƒf¡ n|
 d(||ƒf¡ |d*7 }nŠ|| dGkr|}x*|t|ƒk rà|| dHkrà|d)7 }q¸W |||… }|
 d(||ƒf¡ |d) }n"|| dIkr–| 
dJ|¡}||d) |… }|dKkrL|
 dL¡ n>|dMkrb|
 dN¡ n(|dOkrx|
 dP¡ n|
 d2t|ƒf¡ |d* }n˜|| dQkrÚ| 
dR|¡}|
 d4t||d) |… ƒf¡ |d* }nTd<}|| dSkrp| 
dT|¡}||d) |… }dU|kr2| 	dU¡}|d( t|d) ƒg}n|d(g}|d)7 }|d( dVkrj|dW7 }||d( ƒ|d(< ndX}nV|}x*|t|ƒk r|| dYkr|d)7 }qvW |||… g}|dZ7 }||d( ƒ|d(< |d) }|t|ƒk rD|| d[krD|d)7 }x*|t|ƒk r|| dYkr|d)7 }qôW |||… }| |¡ |dZ7 }|d) }|t|ƒk rÖ|| dIkrÖ||d)  d@krœ|||d) ƒ\}}| ||ƒ¡ |d)7 }n*| 
dJ|¡}||d) |… }| ||ƒ¡ |dW7 }|d* }|dZkrö|
 d(|d( f¡ n8|d\kr|
 d)|d( |d) f¡ n|d]kr@|
 d*|d( |d) f¡ nî|dWkrd|
 d+|d( |d) f¡ nÊ|d^kr|
 d,|d( |d) |d* f¡ n |d_kr¸|
 d-|d( |d) |d* f¡ nv|dXkrÜ|
 d.|d( |d) f¡ nR|d`kr|
 d/|d( |d) |d* f¡ n(|dakr.|
 d0|d( |d) |d* f¡ |d)7 }q†W ˆ j |
¡ qW ˆ jˆ jˆ j fS )bNc             S   s^   | | }|d7 }|}x0| | dkr,|d7 }n| | |kr:P |d7 }qW || ||…  | |fS )Nr   ú\r	   )ÚcodelineÚkÚcÚpr	   r	   r
   Údeal_stringf   s    
z$Code.parse_code.<locals>.deal_stringc                sh  | ˆ j kr^tˆ jƒˆ j dk r6ˆ  jtƒ gd 7  _ˆ jˆ j | < | d dkr| dd… }| d dkrdd	d
ddddddddœ
}dt|ƒ }}g }xf||k rü|| dkrä|||d … |krä| ||||d …  ¡ |d7 }n| || ¡ |d7 }q˜W d |¡}|ˆ jˆ j< n:| d dkrPd| kr@t| ƒˆ jˆ j< nt| ƒˆ jˆ j< ˆ  jd7  _ˆ j |  S )Nr5   i   r   )ú"ú'r   r   rB   Ú
r4   ú	úúúúrC   r<   )
z\nz\rz\tz\az\bz\fz\vz\"z\'z\\r   r!   z0123456789-Ú.)	Ú	data_dictr"   ÚdataÚdata_nr   r   ÚjoinÚfloatÚint)ÚitemÚstringZrboxr>   ÚnZtext_box)r   r	   r
   Ú
login_itemq   s0    
 


 z#Code.parse_code.<locals>.login_item)r   r   )r   é   )r   rU   )rU   r   )r1   r   )é   r   )é   r   )é   r   )é   r   )é	   rU   )é
   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   rU   )é   rU   )é   rU   )é   r   )é    r   )é!   r   )é"   r   )#r(   z$movÚoperZcmpZjmpz$jmpZcallr&   r'   ÚtfZincZdecz$operZex_funcÚtryÚfinallyÚraiseÚerrorÚ	GeneratorZYieldZfetchÚstopÚendZbyteÚdelZFunctionÚglobalÚ	namespaceÚpassz*argsz**kwargsÚmoduler-   r   Z
repl_printr   r   r   rU   r1   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   )r   r   ÚCXÚDXÚipÚespÚspÚZRÚTFz*argsz**kwargsz
$ExceptionÚTrueÚFalseÚNonez$Inheritancei   TFr!   rk   r%   r   )rB   rC   )z$movrs   )ú+ú-Ú*ú/z**ú%z//z<<z>>ú&ú^r2   rt   )ÚinZequZCtnÚisz$oper)ÚnotrŒ   ú~z0123456789-z-0123456789.ú[ú]Údict)r\   r   Úclass)r^   r   Úfunc)ra   r   ú(ú)ú<ú>r‹   r„   Ú1Ú2z[ .r+   rJ   Z00Z01Z10Z11Z20Z21)rK   r"   ÚtuplerM   rL   r   Zparse_codesr   r   r/   r   r.   rP   )r   Z	start_rowÚresetrA   rT   Zcmd_dictZROWÚlineÚopr0   Údealr>   Zfetch_krR   Zop_numZk2ÚnumberÚvalueZtypeboxr   r?   ÚresultÚattrZk3r	   )r   r
   Ú
parse_codee   s    






.



 




  






 
 

 
zCode.parse_codec             C   s
   t | jƒS )N)r"   r   )r   r	   r	   r
   Ú__len__$  s    zCode.__len__c             C   s
   | j | S )N)r   )r   rQ   r	   r	   r
   Ú__getitem__&  s    zCode.__getitem__c             C   s   || j |< d S )N)r   )r   Úkeyr§   r	   r	   r
   Ú__setitem__(  s    zCode.__setitem__)Nr   )r   )r   T)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r$   r   r;   rª   r«   r¬   r®   r	   r	   r	   r
   r      s   
*

 @r   N)Úapython.executerr   r   r	   r	   r	   r
   Ú<module>   s   25415*123*executer.cpython-37.pycB
    ƒ8leÚ¢  ã            B   @   sz  d dl T G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZd
d„ Zdd„ Zdd„ Zg Ze	e
eeeeeeeeeeeeeeeeeeeeee e!e"e#e$e%e&e'e(e)e*e+e,e-e.e/e0e1e2e3e4e5e6e7e8e9e:e;e<e=e>e?e@eAeBeCeDeEeFeGeHeIeJgBZKeLeMeNeOePeQeReSeTeUeVeWeXeYgZZe[e\e]e^e_gZ`eaedœZbx eKeZ e` D ]Zcecebecjd< q*W G dd„ dƒZeG dd„ dƒZfG dd„ dƒZgG dd„ dƒZhdS )é    )Ú*c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚUndefinec             C   s   d| _ d| _d S )Nz[91mz[0m)ÚFailÚRESET)Úself© r   ú0C:\Users\allen\Desktop\py\py\apython\executer.pyÚ__init__   s    zUndefine.__init__c             C   s   | j › d| j› S )Nz<undefined>)r   r   )r   r   r   r   Ú__str__   s    zUndefine.__str__N)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r      s   r   c               @   s|   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zdd„ Zdd„ Zdd„ Zdd„ Zdd„ ZdS )Ú	class_objc             C   s   || _ d | _i | _d| _d S )Nr   )ÚramÚatypeÚvarsÚ
print_lock)r   r   r   r   r   r	   	   s    zclass_obj.__init__c             C   s(   | j dkr$d| jkr$| j | g d¡S dS )Nr   r
   z<class_obj>)r   r   r   Úcall_obj_function)r   r   r   r   r
      s    zclass_obj.__str__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__add__)r   r   r   r   )r   Úotherr   r   r   r      s    zclass_obj.__add__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__sub__)r   r   r   r   )r   r   r   r   r   r      s    zclass_obj.__sub__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__len__)r   r   r   r   )r   r   r   r   r      s    zclass_obj.__len__c             C   s,   | j dkr(d| jkr(| j | ||gd¡S d S )Nr   Ú__setitem__)r   r   r   r   )r   ÚkeyÚvaluer   r   r   r      s    zclass_obj.__setitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__getitem__)r   r   r   r   )r   Úitemr   r   r   r      s    zclass_obj.__getitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__contains__)r   r   r   r   )r   r   r   r   r   r   !   s    zclass_obj.__contains__c             C   sR   | j dkr$d| jkr$| j | g d¡S d| jkrNd| _|  jd7  _|  | j¡S d S )Nr   Ú__next__r   Fé   )r   r   r   r   ÚerrorÚitem_kr   )r   r   r   r   r   $   s    
zclass_obj.__next__c             C   s.   d| _ | jdkr*d| jkr*| j | g d¡S | S )Néÿÿÿÿr   Ú__iter__)r!   r   r   r   r   )r   r   r   r   r#   +   s    zclass_obj.__iter__c             C   s.   | j dkr*d| jkr*| j | |||gd¡S d S )Nr   Ú__exit__)r   r   r   r   )r   Úexc_typeZexc_valZexc_tbr   r   r   r$   0   s    zclass_obj.__exit__c             O   s*   | j dkr&d| jkr&| j | |d|¡S d S )Nr   Ú__call__)r   r   r   r   )r   ÚargsÚkwargsr   r   r   r&   3   s    zclass_obj.__call__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__del__)r   r   r   r   )r   r   r   r   r)   6   s    zclass_obj.__del__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__eq__)r   r   r   r   )r   r   r   r   r   r*   9   s    zclass_obj.__eq__N)r   r   r   r	   r
   r   r   r   r   r   r   r   r#   r$   r&   r)   r*   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFuncc             C   s4   d| _ d| _|| _||dœ| _|| _|| _|| _d S )NÚFunction)Úipr   )Únamer   r   r   Ú
stack_nameÚ	stack_lenÚimport_funcs)r   r   r-   r   Zfunc_varr0   r1   r   r   r   r	   =   s    zFunc.__init__c             C   s
   t | jƒS )N)Ústrr.   )r   r   r   r   r
   E   s    zFunc.__str__c             O   sJ   || j j| j j< || j j| j j< | j  | jd | jd | j| j| j¡}|S )Nr-   r   )	r   ÚdataÚargs_locationÚkwargs_locationÚfunc_runr   r/   r0   r1   )r   r'   r(   Úresultr   r   r   r&   G   s    &zFunc.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r+   <   s   r+   c               @   s<   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ ZdS )Ú	generatorc                sP   |ˆ _ |ˆ _|ˆ _g ˆ _dˆ _dˆ _dˆ _d ˆ _g ˆ _‡ fdd„}d|iˆ _	d S )Nr   TFc                s&   ˆ j sdˆ _| ˆ _ˆ  ¡ S tdƒ‚d S )NTz5can't send non-None value to a just-started generator)Ú	next_lockÚsendÚsend_objÚ_generator__nextÚ	TypeError)r   )r   r   r   r:   \   s
    z generator.__init__.<locals>.sendr:   )
r   Únext_ipr1   Úex_stackÚenterr9   r:   r;   Úfinally_boxr   )r   r   Ústart_ipr1   r:   r   )r   r   r	   M   s    zgenerator.__init__c             C   s   dS )Nz<generator_obj>r   )r   r   r   r   r
   c   s    zgenerator.__str__c             C   s   |   ¡ S )N)r<   )r   r   r   r   r   r   e   s    zgenerator.__getitem__c             C   s   d| _ | jrd | _|  ¡ S )NF)r9   r:   r;   r<   )r   r   r   r   r   g   s    zgenerator.__next__c             C   sö   | j dkrt‚nâd| _ | js>| j | j| j| j¡\}| _}}n&| jj| j| j| j| jd\}| _}}|d krî|\| _}xl|D ]d}|d dkr®||d  }| j	 
|d |g¡ q|x0| j	D ]&}|d t|d ƒkr¶| j	 |¡ P q¶W q|W d| _ |S t‚d S )Nr   )r;   r   r"   )r@   ÚStopIterationr:   r   Ú	yield_runr>   r?   r1   r;   rA   ÚappendÚabsÚremove)r   Únext_objÚyield_resultÚbase_esprA   Úf_ipZex_stack_numZfipr   r   r   Z__nextl   s&    
"&


zgenerator.__nextc             C   s  xş| j D ]ô}|d d | jj| jj< i }x0| jD ]&}| jj| ||< | j| | jj|< q0W x&t|d ƒD ]}| j | j| ¡ qhW | j d ¡ | j d¡ z@y| j 	d¡ W n* t
k
rÖ } zt|ƒ W d d }~X Y nX W d x|D ]}|| | jj|< qâW X qW d S )Nr   r   zfinally yield run)rA   r   r3   r-   r1   Ú
func_stackÚrangeÚpushr?   Úone_runÚ	ExceptionÚprint)r   rK   Ú
tem_stacksÚ	func_nameÚiÚer   r   r   r)   …   s     
zgenerator.__del__N)	r   r   r   r	   r
   r   r   r<   r)   r   r   r   r   r8   L   s   r8   c             C   s6   t t| ƒƒ}| d¡}| d|d ¡}||d |… S )Nú'r   )r2   ÚtypeÚindex)rU   ZstypeÚkÚk2r   r   r   Úfetch_errorŸ   s    
r[   c             C   s4   t | ƒtkr| jS t | ƒtkr,d| j› dS t | ƒS )Nz<class '__main__.z'>)rW   r   r   r+   r.   )Úobjr   r   r   r   ¤   s
    r   c              O   sX   g }x| D ]}|  t|ƒ¡ q
W d |¡}d|krFt  ||d  ¡ nt  |d ¡ d S )Nú ÚendÚ
)rE   r2   ÚjoinÚtotal_output)r'   r(   Útext_boxr\   Útextr   r   r   Úaprintª   s    

rd   )ÚIOErrorrW   c               @   s´   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zd-dd„Zd.dd„Zdd„ Zdd„ Zdd„ Zdd„ Zd d!„ Zd/d%d&„Zd'd(„ Zd0d)d*„Zd+d,„ ZdS )1ÚExecuterc             C   s    || _ t ¡ | _g | _i | _d S )N)ÚcodeÚbifsÚcopyÚex_functionÚ	run_layerrL   )r   rg   r   r   r   r	   Ã   s    
zExecuter.__init__c             C   s   | j | }|| j|< d S )N)Ú	data_dictr3   )r   Úvar_namer   Úlocationr   r   r   ÚsetÈ   s    
zExecuter.setc             C   s*   || j | j| j < | j| j  d8  < d S )Nr   )Ú	esp_stackr3   Úesp)r   r   r   r   r   rN   Ë   s    zExecuter.pushc             C   s&   | j | j  d7  < | j| j | j  S )Nr   )r3   rq   rp   )r   r   r   r   ÚpopÎ   s    zExecuter.popc             C   s8   || j kr| j | S | j| j |< |  jd7  _| jd S )Nr   )Úvar_dictZ	used_size)r   rm   r   r   r   ÚloginÑ   s
    

zExecuter.loginc             C   s
   | j | S )N)rs   )r   rm   r   r   r   Úget_var_location×   s    zExecuter.get_var_locationc             C   sB   x<t dƒD ]0}| j| | j| j| j < | j| j  d8  < q
W d S )Né   r   )rM   r3   rp   rq   )r   rT   r   r   r   ÚpushawÙ   s    zExecuter.pushawc             C   sF   x@t dƒD ]4}| j| j  d7  < | j| j| j  | jd| < q
W d S )Nrv   r   é   )rM   r3   rq   rp   )r   rT   r   r   r   Úpopawİ   s    zExecuter.popawc             C   s–  |d dkr|| j |d < nt|d dkrF|| j |d  j|d < nL|d dkrr|| j |d  | j |d  < n |d dkrœ|| j| j |d  |d  < nö|d dkrĞ|| j| j |d  |d   j|d < nÂ|d dkr
|| j| j |d  |d   | j |d  < nˆ|d dkr0|| j|d  |d < nb|d dkr`|| j|d  |d  j|d < n2|d d	kr’|| j|d  |d  | j |d  < d S )
Nr   r   é   é   rx   rv   é   é   é   )r3   r   rp   rL   )r   rn   r   r   r   r   r   á   s$     (,"zExecuter.__setitem__Nc          	   C   sf   | j | j }|d kri }|  ¡  t|ƒ| j d< |j| }d }z|||}W d |  ¡  || j | j< X |S )Nrz   )r3   rq   rw   Úlenr   ry   )r   r\   r'   Úfuncnamer(   Útem_espÚfuncr7   r   r   r   r   ÷   s     
zExecuter.call_obj_functionc             C   s  | j | j }|| j | j< i }x(|D ] }| j| ||< || | j|< q"W | j | j }x|D ]}	|  |	¡ qXW d }
d}z|| j d< |  d¡}d}W d | jd= |r¦| j d }
g }x,t|| j | j  ƒD ]}| d|  	¡ ¡ qÀW x|D ]}|| | j|< qŞW || j | j< X |||
|fS )NFr   z	yield runTr"   )
r3   r-   rL   rq   rN   Ú_Executer__runrk   rM   Úinsertrr   )r   r-   r?   r1   r;   Útem_iprR   rS   r   Zex_objrI   ZokrH   Znew_ex_stackrT   r   r   r   rD     s2    





zExecuter.yield_runc          
   C   s  | j | j }| j | j }i }x(|D ] }	| j|	 ||	< ||	 | j|	< q"W || jkrZd | j|< | j| }
dg| }||d< || j|< |d | j | j< |  t| jƒ¡ d }z|  d|› d¡ W d | j d }| jd= || j | j< |
| j|< x|D ]}	||	 | j|	< qêW || j | j< X |S )Nr   r   zFunc<z> runr"   )	r3   r-   rq   rL   rN   r   rg   rƒ   rk   )r   r-   r   r/   r0   r1   r…   r   Ztem_func_stackrS   Z	tem_stackrL   r7   r   r   r   r6   %  s2    








zExecuter.func_runc             C   s”  |d dkr| j |d  S |d dkrÌ| j |d  }t|ƒtttfkrh|d |jkrb|j|d  S | jS t|ƒtkrt| j	|d  › dƒ‚n:t|ƒt
kr¶|d |jkr¶|j|d  S t||d ƒ}|S nÄ|d dk rö| j |d  | j |d   S |d dkr | j| j |d  |d   S |d dkrÜ| j| j |d  |d   }t|ƒtttfkr‚|d |jkr||j|d  S | jS t|ƒtkrštdƒ‚n>t|ƒt
krÆ|d |jkrÆ|j|d  S t||d ƒ}|S n´|d dkr| j| j |d  |d   | j |d   S |d d	kr8| j|d  |d  S |d d
krì| j|d  |d  }t|ƒtttfkr”|d |jkr|j|d  S | jS t|ƒtkr¬tdƒ‚n>t|ƒt
krØ|d |jkrØ|j|d  S t||d ƒ}|S n¤|d dkr| j|d  |d  | j |d   S |d dkr:dg|d  S |d dkrLi S |d dkrhdg|d  S |d dkr| j t| ƒ¡ | jd S d S )Nr   r   rz   z is undefinedr{   rx   zvariable is undefinedrv   r|   r}   zthis variable is undefinedr~   é
   é   é   é   r"   )r3   rW   r   r8   ÚNamespace_stackr   Ú	undefinedr   rP   Úinverse_data_dictÚ	Ex_moduleZbuilt_in_operatorrp   rL   Ú
class_objsrE   )r   rn   r\   r‚   r   r   r   r   I  sr    
*
$zExecuter.__getitem__c             C   s    d}d}t |› |› |› ƒ d S )Nz[91mz[0m)rQ   )r   Úmsgr   r   r   r   r   Z__error_print‘  s    zExecuter.__error_printc             C   s    d}d}t |› |› |› ƒ d S )Nz[92mz[0m)rQ   )r   r   ZOKr   r   r   r   Z
__ok_print•  s    zExecuter.__ok_printc             C   s   |   |¡ d S )N)rƒ   )r   Úcommentr   r   r   rO   ™  s    zExecuter.one_runr   é   Únormalc             C   s(  | j jddd\| _| _| _i | _x| jD ]}|| j| j| < q*W || _dg| | _|  dd¡ |  dd¡ | jd | _	| jd | _
| jd | _| jd | _| jd	 | _d| j| j< d| _| jd
 | _| jd | _g | _i | _tƒ | _x.| jD ]$}|| jkrî| j| | j| j| < qîW |  d||¡ d S )Nr   T)Ú	start_rowÚresetrq   r"   r-   ÚZRÚTFz
$Exceptionz*argsz**kwargs)rg   Ú
parse_codeÚcodesr3   rl   rŒ   Ú
stack_sizerp   ro   rq   r-   r•   r–   ÚERÚ
error_liner4   r5   r   rL   r   r‹   rj   Ú
normal_run)r   Útfr™   r   r   r.   r   r   r   Úrun›  s0    
zExecuter.runc             C   s°   t  ¡  |dkr"| jdddd n„d | jd< | jj|dd\| _| _| _x.| jD ]$}|| jkrP| j| | j| j| < qPW x| jD ]}|| j	| j| < q€W |  
|dd¡ d t ¡S )Nr   i   ÚREPL)r   F)r“   r”   Ú )ra   Úclearr   r3   rg   r—   r˜   rl   rj   rŒ   rœ   r`   )r   Úrowr.   r   r   r   r   ÚREPL_run¶  s    

zExecuter.REPL_runc          
   C   s>  || _ |  dd¡ |  d|¡ yJ|  |¡ | j| j dkrN|dkrf|  d¡ n|  d| j| j › ¡ W nĞ tk
r8 } z°| j| j dkrš| j| j	 }n| j
}|dkrê| j |¡}|  d|d	  d
 t|d 
 ƒ ¡ |  d|d  ¡ t|ƒ}t|ƒdkrd| }|  t|ƒ| ¡ |dkr(|‚W d d }~X Y nX d S )Nrq   r"   r-   r   u   
ç¨‹å¼çµæŸ--------u*   ç¨‹å¼è­¦å‘Š:å †ç–Šæœªé‚„åŸ---------->   rŸ   z
Trackback:
FILE: Úfilez,  line:r¢   z   rg   z: )r   ro   rƒ   r3   rq   Ú_Executer__ok_printÚ_Executer__error_printrP   rš   r-   r›   rg   Úget_error_msgr2   r   r[   )r   r¢   r   r   rU   Úerror_ipr   r    r   r   r   rœ   Ä  s.    
$ 
zExecuter.normal_runc       4   
      sn  ˆj  |¡ ‡fdd„‰‡‡fdd„‰ ‡ ‡‡‡fdd„}ˆj‰ˆj‰ˆj}ˆj}ˆj}ˆj}ˆj}g }t	ˆj
ƒ}	xäˆjˆ |	k rVˆj
ˆjˆ  }
ˆjdkrî|ƒ  tƒ }|dkrît	|ƒd	k rÆd
ˆ_n(|dkrŞtdƒ dˆ_nˆ d¡ dˆ_ˆjdkr4ˆjˆ }dˆjj|  dˆjj| › d|›  }t|ƒ |
d dkrZˆ|
d  ˆ|
d < nÎ|
d dkr`ˆ|
d  }|dkrˆ|
d   ˆ|
d	  7  < q(|dkrÈˆ|
d   ˆ|
d	  8  < q(|dkròˆ|
d   ˆ|
d	  9  < q(|d	krˆ|
d   ˆ|
d	    < q(|dkrFˆ|
d   ˆ|
d	  C  < q(|dkrnˆ|
d   ˆ|
d	  ;  < nî|dkr–ˆ|
d   ˆ|
d	    < nÆ|dkr¾ˆ|
d   ˆ|
d	  K  < n|dkræˆ|
d   ˆ|
d	  L  < nv|dkrˆ|
d   ˆ|
d	  M  < nN|dkr6ˆ|
d   ˆ|
d	  N  < n&|dkr(ˆ|
d   ˆ|
d	  O  < nÈ|
d dkr˜ˆ|
d  }|dkr¨ˆ|
d  ˆ|
d	   ˆ|
d < q(|dkrÖˆ|
d  ˆ|
d	   ˆ|
d < q(|dkrˆ|
d  ˆ|
d	   ˆ|
d < q(|d	kr2ˆ|
d  ˆ|
d	   ˆ|
d < q(|dkr`ˆ|
d  ˆ|
d	   ˆ|
d < q(|dkrˆ|
d  ˆ|
d	   ˆ|
d < q(|dkrºˆ|
d  ˆ|
d	   ˆ|
d < nÚ|dkræˆ|
d  ˆ|
d	  > ˆ|
d < n®|dkrˆ|
d  ˆ|
d	  ? ˆ|
d < n‚|dkr>ˆ|
d  ˆ|
d	  @ ˆ|
d < nV|dkrjˆ|
d  ˆ|
d	  A ˆ|
d < n*|dkr(ˆ|
d  ˆ|
d	  B ˆ|
d < n|
d d	krÈˆ|
d  ˆ|
d   ˆj|< n`|
d dkrìˆ|
d  ˆjˆ< n<|
d dkrÜˆ|
d  }ˆj| }ˆj| }|dkr.|dks’|dkrB|dks’|dkrV|dks’|dkrj|dks’|d kr~|dks’|d!kr¦|dk r¦ˆ|
d  ˆjˆ< n2|d"kr¶|sÆ|d#kr(|s(ˆ|
d  ˆjˆ< 
nL|
d dkrøˆ|
d  }|d kr|
d d	 }t|ƒtkr:ˆj| }ˆj| }||| nºt|ƒtkrˆˆj| }ˆj| }ˆjˆ }ˆj| ||ˆjd< |ˆjˆ< nlˆj| }ˆj| }ˆjˆj }y
|j}W n   d}Y nX |d$krØt|| |||ˆjd< |ˆjˆj< 	n0|
d dkr4ˆ|
d  ˆjˆjˆ < ˆjˆ  d8  < nô|
d dkrpˆjˆ  d7  < ˆjˆjˆ  ˆ|
d < n¸|
d dk	r6ˆ|
d  }|dkr´ˆ|
d	  ˆ|
d  kˆj|< n~|dkrŞˆ|
d	  ˆ|
d  kˆj|< nT|dk	r
ˆ|
d	  ˆ|
d  jkˆj|< n(|d	kr(ˆ|
d	  ˆ|
d  kˆj|< nò|
d dk	r\ˆ|
d   d7  < nÌ|
d dk	r‚ˆ|
d   d8  < n¦|
d d%k
r"ˆ|
d  }|dk	rÜyˆ|
d   ˆ|
d < W n   d&ˆ|
d < Y nX nB|dk	rşˆ|
d   ˆ|
d < n |dkr(ˆ|
d   ˆ|
d < n|
d d'k
rnˆjˆ }ˆjˆ|
d   ˆ|
d	  ƒˆ|
d < |ˆjˆ< nº|
d d(kr"ˆ|
d  }|d)k
r–d S ˆjˆ  d7  < ˆjˆ }yˆ d*|› ¡ W nN tk
r } z.ˆjˆ ˆ_|ˆjˆ< |ˆj|< |ˆjˆ< W d d }~X Y nX ˆj d+= n|
d d,krVˆ|
d  }| |ˆjˆj f¡ nÒ|
d d-krtˆ|
d  ‚n´|
d d.krşˆ|
d  }t|ƒtkrÌt|kr²d/ˆj|< ntˆj| ƒ|kˆj|< n.|tkrâd/ˆj|< ntˆj| ƒ|kˆj|< n*|
d d0krpˆ|
d  }d	}i }x6|t	|
ƒk rVˆ|
|  }ˆj| ||< |d7 }q"W tˆ||ƒˆ|
d < n¸|
d d1kr¨ˆj d+ d2kr–td3ƒ‚ˆjˆ d |fS |
d d4kr<ˆjˆ }ˆjˆ }y*ˆ|
d  } t | ƒˆ|
d < d/ˆj|< W n. t!k
r" } zd&ˆj|< W d d }~X Y nX |ˆjˆ< |ˆjˆ< nì|
d d5krltd6ˆjˆj d7ˆjˆj ƒ n¼|
d d8kr
ˆ|
d  }!|!d9kr¤ˆj d+ d2kr¤d S |!d:kr(ˆ|
d  }t	|
ƒd	kr(ˆ|
d	   "d;¡}"tt#t$|"ƒƒ}#x|#D ]}$d ˆj| |$< qîW n|
d d<kr4ˆ|
d   %¡ ˆ|
d < nô|
d d=kr°ˆ|
d  }|dkrht&ƒ ˆ|
d < nD|dkrŠˆ|
d  ˆ|
d	  = n"|dkr(ˆ|
d  jˆ|
d	  = nx|
d d>krLˆ|
d  }%ˆ|
d	  }&ˆ|
d  }'ˆ|
d  }(d}i }x6|t	|
ƒk r,ˆ|
|  }ˆj| ||< |d7 }qøW tˆ|%|&|'|(|ƒˆ|
d < nÜ|
d d?kr^nÊ|
d d@kràˆ|
d	   "d;¡})d}*i }+x|)D ]},|*|+|,< |*d7 }*qŒW t&ƒ g|* }-ˆ|
d  }.|-ˆj|.< t'ˆ|.|+ƒˆ|
d < nH|
d dAkrˆ|
d  ˆ|
d	  d … ˆ|
d < n|
d dBkrzˆ|
d  }/ˆ|
d	   "d;¡}0i }1x$|/D ]}2|2|0krL|/|2 |1|2< qLW |1ˆ|
d < n®|
d dCkr¢t(ˆ|
d  ƒˆ|
d < n†|
d dDkrÈˆ|
d  ˆ|
d  _)n`|
d dEkrîˆ|
d  ˆ|
d  _*n:|
d dFkr(ˆ|
d  }3|3d kr(t|3ƒ t+ t|3ƒ¡ ˆjˆ  d7  < ˆjˆ  ˆj,krtt-dGƒ‚qtW ˆjdkrj|ƒ  d S )HNc                s   xˆ j D ]
}| |_qW d S )N)r   r   )Úlockr\   )r   r   r   Úobj_lockà  s     z Executer.__run.<locals>.obj_lockc                 sJ  t ddd xŠˆjD ]€} | d dkrX| dkrX| ˆjkrXt | › dˆjˆj|   › dd | d	krlt d
dd | dkr€t d
dd | dkrt ddd qW d}d}xVtdƒD ]J}ˆj| d  }t|ƒd }|d tˆjˆ  ƒk rì|t|ƒ7 }||7 }qªW t |d d… d ƒ t d| d ƒ x(ˆj	D ]}t |› dˆj	| › ƒ q$W d S )Nzdata: r    )r^   r   z"0123456789-')ÚNoneÚTrueÚFalseú:z  )r–   z**kwargsz
      z
$Exceptionz$Inheritanceu   
è‡ªç”±è®Šæ•¸:
      z	

stack:[r}   é   r   ú,r"   ú]r]   ú^z: )
rQ   rl   rj   r3   rM   rp   r2   rF   r   rL   )r   Z
stack_textZstack_nrT   r\   ÚgetrS   )rq   r   r   r   Ú	cpu_stateâ  s,    "  z!Executer.__run.<locals>.cpu_statec                 s|   ˆdƒ ˆj ˆ } ˆj | ¡ ˆ ƒ  tdˆj› ƒ | tˆjƒk rhtdˆjj|  dˆj|  ƒ tdƒ ntdƒ ˆdƒ d S )Nr   z
run_layer:u   
æº–å‚™åŸ·è¡Œ:u                     å°æ‡‰:z-------------------------------u   ç¨‹åºå·²çµæŸ
r   )r3   rg   ÚdisplayrQ   rk   r   r˜   )Únow_ip)r´   r-   rª   r   r   r   Ú
get_statusø  s    

z"Executer.__run.<locals>.get_statusr   r    r{   g      à?Zasdu   åµéŒ¯!!--------gš™™™™™¹?u   ç¨‹å¼é–‹å§‹--------r   z<                                                            z       úrz   rx   rv   r|   r}   r~   é	   r†   r‡   z==z!=z>=z<=ú>ú<ÚtÚfrQ   rˆ   Fr‰   é   r^   ztry r"   é   é   é   Té   é   zfinally yield runzVException ignored in: <generator object>
RuntimeError: generator ignored GeneratorExité   é   zip---->z
esp------>é   Zfinally_yieldr,   r°   é   é   r¯   é   é   é   é   é   é    é!   é"   z maxinum recursion depth exceeded).rk   rE   r-   rq   r•   r–   rš   r4   r5   r   r˜   r3   r   ÚinputrQ   r¥   rg   ÚcommentsrW   r+   r2   rj   r   rd   rp   r   rƒ   rP   r›   ÚlistrL   r8   ÚnextrC   ÚsplitÚmapÚintÚencoder   rŠ   r   r   r.   ra   r™   ÚRecursionError)4r   Zrun_commentr·   r•   r–   rš   r4   r5   rA   ÚnÚcmdÚar¶   r   ÚopZzrr   Zjmp_ipr'   r(   r…   Zcall_func_nameÚeventr¨   r   rU   rK   r    rB   Zex_kZimport_namesrS   r³   ÚcommandZ	items_strÚitemsrT   Zfunc_ipZfunc_class_objZfunc_stack_nameZfunc_stack_lenZvar_boxÚvar_krs   r.   ZstackZnamespace_nameZkey_dictZnot_needZ	void_dictr   r   r   )r´   rq   r-   rª   r   r   Z__runŞ  s6   



(
 
 
 
 
 






 
$
$
$
$
$
$
"
"
"
"
"
$"

<< 








 



 
 
"
"



&








"






(


zExecuter.__run)N)N)r   r‘   r’   )r’   )r   r   r   r	   ro   rN   rr   rt   ru   rw   ry   r   r   rD   r6   r   r¦   r¥   rO   r   r£   rœ   rƒ   r   r   r   r   rf   Â   s(   

!$H

rf   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r   c             C   s   || _ d| _i | _d S )Nr   )Úmodule_namer   r   )r   râ   r   r   r   r	   2  s    zEx_module.__init__c             C   s   | j S )N)râ   )r   r   r   r   r
   6  s    zEx_module.__str__c             O   s   t dƒ‚d S )Nz'module' object is not callable)r=   )r   r'   r(   r   r   r   r&   8  s    zEx_module.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r   1  s   r   c               @   s   e Zd Zdd„ Zdd„ ZdS )rŠ   c             C   s   || _ t|||ƒ| _d S )N)r/   Únamespace_stack_varr   )r   r   r/   rs   r   r   r   r	   ;  s    zNamespace_stack.__init__c             C   s   d| j › dS )Nzmodule "ú")r/   )r   r   r   r   r
   >  s    zNamespace_stack.__str__N)r   r   r   r	   r
   r   r   r   r   rŠ   :  s   rŠ   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rã   c             C   s   || _ || _|| _d S )N)r   r.   rs   )r   r   r/   rs   r   r   r   r	   A  s    znamespace_stack_var.__init__c             C   s
   || j kS )N)rs   )r   r   r   r   r   r   E  s    z namespace_stack_var.__contains__c             C   sX   || j kr$|| jj| j | j | < n0t| jj| j ƒ}|| j |< | jj| j  |¡ d S )N)rs   r   rL   r.   r   rE   )r   r   r   Z
now_lengthr   r   r   r   G  s
    

znamespace_stack_var.__setitem__c             C   s   | j j| j | j|  S )N)r   rL   r.   rs   )r   r   r   r   r   r   O  s    znamespace_stack_var.__getitem__N)r   r   r   r	   r   r   r   r   r   r   r   rã   @  s   rã   N)iZapython.built_inr   r   r+   r8   r[   r   rd   ra   rF   ÚallÚanyÚasciiÚbinÚboolÚ
breakpointÚ	bytearrayÚbytesÚcallableÚchrÚclassmethodÚcompileÚcomplexÚdelattrÚdictÚdirÚdivmodÚ	enumerateÚevalÚexecÚfilterÚfloatÚformatÚ	frozensetÚgetattrÚglobalsÚhasattrÚhashÚhexÚidrÑ   r×   Ú
isinstanceÚ
issubclassÚiterr   rÓ   ÚlocalsrÖ   ÚmaxÚ
memoryviewÚminrÔ   ÚobjectÚoctÚopenÚordÚpowrQ   ÚpropertyrM   ÚreprÚreversedÚroundro   ÚsetattrÚsliceÚsortedÚstaticmethodr2   ÚsumÚsuperÚtupler   ÚzipZbuilt_in_functionsÚ	NameErrorÚ
IndexErrorr=   ÚSyntaxErrorÚ
ValueErrorÚKeyboardInterruptÚAssertionErrorrP   rÙ   ÚKeyErrorÚZeroDivisionErrorÚAttributeErrorÚIndentationErrorÚUnboundLocalErrorZError_classrC   ÚStopAsyncIterationÚSyntaxWarningÚFileNotFoundErrorÚModuleNotFoundErrorZelse_built_inre   rh   r   r   rf   r   rŠ   rã   r   r   r   r   Ú<module>   s6   4S	 *"    s	275*122*ex_func.cpython-37.pycB
    N1Ve   ã               @   s<   d dl Z d dlZd dlZd dlZd dlZd dlZd dlZdS )é    N)ÚtimeÚmathÚosÚos.pathÚsysÚrandomÚsocket© r	   r	   ú/C:\Users\allen\Desktop\py\py\apython\ex_func.pyÚ<module>   s   45313*121*module.cpython-37.pycB
    ì¼UeAø  ã               @   sR  G d d„ dƒZ G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZG d
d„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZ	G dd„ dƒZ
G dd„ dƒZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZG d d!„ d!ƒZG d"d#„ d#ƒZG d$d%„ d%ƒZG d&d'„ d'ƒZG d(d)„ d)ƒZG d*d+„ d+ƒZG d,d-„ d-ƒZG d.d/„ d/ƒZG d0d1„ d1ƒZG d2d3„ d3ƒZG d4d5„ d5ƒZG d6d7„ d7ƒZG d8d9„ d9ƒZG d:d;„ d;ƒZG d<d=„ d=ƒZG d>d?„ d?ƒZG d@dA„ dAƒZ dBdC„ Z!G dDdE„ dEƒZ"G dFdG„ dGƒZ#G dHdI„ dIƒZ$G dJdK„ dKƒZ%G dLdM„ dMƒZ&G dNdO„ dOƒZ'G dPdQ„ dQƒZ(G dRdS„ dSƒZ)G dTdU„ dUƒZ*dVS )Wc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIntegerc             C   s   t |ƒ| _d S )N)ÚintÚnumber)Úselfr   © r   ú.C:\Users\allen\Desktop\py\py\apython\module.pyÚ__init__   s    zInteger.__init__c             C   s   | j › S )N)r   )r   r   r   r   Ú__str__   s    zInteger.__str__c             C   s   t | jƒ| _d S )N)Ústrr   Úlocation)r   Úcodesr   r   r   Úwrite   s    zInteger.writeN)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFloatc             C   s   t |ƒ| _d S )N)Úfloatr   )r   r   r   r   r   r   
   s    zFloat.__init__c             C   s   | j › S )N)r   )r   r   r   r   r      s    zFloat.__str__c             C   s   t | jƒ| _d S )N)r	   r   r
   )r   r   r   r   r   r      s    zFloat.writeN)r   r   r   r   r   r   r   r   r   r   r   	   s   r   c               @   s&   e Zd Zd	dd„Zdd„ Zdd„ ZdS )
ÚStringTc             C   s   || _ || _d S )N)ÚtextÚchange)r   r   r   r   r   r   r      s    zString.__init__c             C   s   d| j › dS )Nú")r   )r   r   r   r   r      s    zString.__str__c             C   s,   | j rd| j› d| _nd| j› d| _d S )Nr   ú')r   r   r
   )r   r   r   r   r   r      s    zString.writeN)T)r   r   r   r   r   r   r   r   r   r   r      s   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBytec             C   s
   || _ d S )N)r   )r   r   r   r   r   r      s    zByte.__init__c             C   s   d| j › dS )Nr   )r   )r   r   r   r   r      s    zByte.__str__c             C   s   |  d| j› d¡ d| _d S )Nz	byte AX "r   ÚAX)Úappendr   r
   )r   r   r   r   r   r       s    z
Byte.writeN)r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚVar_namec             C   s
   || _ d S )N)Úname)r   r   r   r   r   r   $   s    zVar_name.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   &   s    zVar_name.__str__N)r   r   r   r   r   r   r   r   r   r   #   s   r   c               @   s6   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zd
d„ ZdS )Ú	NamespaceÚ c             C   s
   || _ d S )N)Ú	namespace)r   r   r   r   r   r   *   s    zNamespace.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   ,   s    zNamespace.__str__c             C   s
   | j |kS )N)r   )r   Úotherr   r   r   Ú__eq__.   s    zNamespace.__eq__c             C   s
   || j kS )N)r   )r   Úitemr   r   r   Ú__contains__0   s    zNamespace.__contains__c             C   s   | j dkr| j | _d S )Nr   )r   r
   )r   r   r   r   r   r   2   s    
zNamespace.writeN)r   )r   r   r   r   r   r    r"   r   r   r   r   r   r   )   s
   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVariablec             C   s   || _ || _d S )N)r   r   )r   r   r   r   r   r   r   6   s    zVariable.__init__c             C   s   d| j › dS )Nz<var=ú>)r   )r   r   r   r   r   9   s    zVariable.__str__c             C   s:   | j dkr.| j  |¡ | j j› d| j› | _n| j| _d S )Nr   Ú.)r   r   r
   r   )r   r   r   r   r   r   ;   s    
zVariable.writeN)r   r   r   r   r   r   r   r   r   r   r#   5   s   r#   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSubVariablec             C   s   || _ || _d S )N)ÚobjÚattr)r   r'   r(   r   r   r   r   A   s    zSubVariable.__init__c             C   s   d| j › d| j› dS )Nz<obj=z  attr=r$   )r'   r(   )r   r   r   r   r   D   s    zSubVariable.__str__c             C   st   | j  |¡ | j j}d|ks0d|ks0|d dkrX| d| j j› d¡ d| jj› | _n| j j› d| jj› | _d S )Nr%   ú[é    )r   r   zmov AX u         ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²zAX.)r'   r   r
   r   r(   r   )r   r   Z	olocationr   r   r   r   F   s    zSubVariable.writeN)r   r   r   r   r   r   r   r   r   r   r&   @   s   r&   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSlicec             C   s   || _ || _|| _d S )N)Ú	start_objÚend_objÚstep_obj)r   r,   r-   r.   r   r   r   r   N   s    zSlice.__init__c             C   s   dS )Nz<slice>r   )r   r   r   r   r   R   s    zSlice.__str__c             C   s’   |  d¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ |  d¡ |  d¡ |  d¡ d| _d S )	Nzpush [3]zmov <esp+1>[0] zmov <esp+1>[1] zmov <esp+1>[2] z	pop *argszmov **kwargs [dict]z
call slicer   )r   r,   r   r
   r-   r.   )r   r   r   r   r   r   T   s    



zSlice.writeN)r   r   r   r   r   r   r   r   r   r   r+   M   s   r+   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIndexVariablec             C   s   || _ || _d S )N)r   Ú	slice_obj)r   r   r0   r   r   r   r   a   s    zIndexVariable.__init__c             C   s   d| j › d| j› dS )Nz<Index z slice=r$   )r   r0   )r   r   r   r   r   d   s    zIndexVariable.__str__c             C   sT   | j  |¡ | d| j j› ¡ | j |¡ | d| jj› ¡ | d¡ d| _d S )Nzpush zmov BX zpop AXzAX[BX])r   r   r   r
   r0   )r   r   r   r   r   r   f   s    
zIndexVariable.writeN)r   r   r   r   r   r   r   r   r   r   r/   `   s   r/   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚListc             C   s
   || _ d S )N)Úelements)r   r2   r   r   r   r   o   s    zList.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<List  ú,r$   )r2   r   r	   Újoin)r   Úboxr'   r   r   r   r   q   s    zList.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)Úlenr2   ÚStopIteration)r   Újr   r   r   Ú__getitem__v   s    
zList.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   Ú__len__z   s    zList.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX [ú]zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   Úranger   r
   )r   r   Úir   r   r   r   |   s    
"
z
List.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r1   n   s
   r1   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚTuplec             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   …   s    zTuple.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<Tuple  r3   r$   )r2   r   r	   r4   )r   r5   r'   r   r   r   r   ‡   s    zTuple.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)r6   r2   r7   )r   r8   r   r   r   r9   Œ   s    
zTuple.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:      s    zTuple.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX (ú)zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   r<   r   r
   )r   r   r=   r   r   r   r   ’   s    
"
zTuple.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r>   „   s
   r>   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
ÚDictc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ›   s    zDict.__init__c             C   s>   g }x&| j D ]\}}| |› d|› ¡ qW dd |¡ d S )Nú:z<Dict  r3   r$   )r2   r   r4   )r   r5   ÚkeyÚvaluer   r   r   r      s    zDict.__str__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:   ¢   s    zDict.__len__c             C   st   |  d¡ xT| jD ]J\}}| |¡ |  d|j› ¡ | |¡ |  d¡ |  d|j› ¡ qW |  d¡ d| _d S )Nzpush [dict]zpush zpop BXzmov <esp+1>[BX] zpop AXr   )r   r2   r   r
   )r   r   rB   rC   r   r   r   r   ¤   s    




z
Dict.writeN)r   r   r   r   r   r:   r   r   r   r   r   r@   š   s   r@   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSetc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ¯   s    zSet.__init__c             C   s   dS )Nz<set>r   )r   r   r   r   r   ±   s    zSet.__str__c             C   s0   t | jƒ}| |¡ | d|j› ¡ d| _d S )Nzex_func AX "set" r   )r>   r2   r   r   r
   )r   r   Z_tupler   r   r   r   ³   s    

z	Set.writeN)r   r   r   r   r   r   r   r   r   r   rD   ®   s   rD   c             C   s   yt | ƒ}dS    dS d S )NTF)r   )ÚnumÚer   r   r   Ú	is_number¹   s
     rG   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚLambdac             C   s   || _ || _|| _d S )N)ÚparamsÚ
return_objr   )r   rI   rJ   r   r   r   r   r   ¿   s    zLambda.__init__c             C   s   dS )Nz<lambda>r   )r   r   r   r   r   Ã   s    zLambda.__str__c             C   s¦   dt |ƒ› }t| jdƒ}tdƒ}x | jD ]}| dt|dƒ¡ q*W |j |¡ t	|| j|| j
ƒ}| |¡ | j
dkr~|| _n$| j
 |¡ | j
j› d|› }|| _d S )Nz&lambda_Úreturnr   Úvarr%   )r6   Ú	BacktrackrJ   ÚInforI   Úadd_infor#   Ú	codelinesr   ÚDefr   r   r
   )r   r   Ztem_nameZ_returnÚ
block_inforB   Z_defZlocr   r   r   r   Å   s    

zLambda.writeN)r   r   r   r   r   r   r   r   r   r   rH   ¾   s   rH   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rQ   c             C   s8   || _ || _|| _|j| _|j| _d| jk| _d| _d S )Nú^)r   r*   )r   rI   r   rP   ÚlocalsÚ
local_varsÚin_classÚ
orig_lines)r   ZfnamerI   rR   r   r   r   r   r   Ö   s    zDef.__init__c             C   sH   d| j › }g }x| jD ]}| t|ƒ¡ qW |dd |¡ d 7 }|S )Nz<Def ú{r   ú})r   rP   r   r	   r4   )r   r   Zvtextr'   r   r   r   r   ß   s    zDef.__str__c       *         s`	  dd„ }| j dkrf| j  |¡ t|ƒdt|ƒd | j jdg}| d¡ | d| j j› d| j› d	¡ n&t|ƒ| jt|ƒd
 d dg}| d¡ | ¡  t|ƒ}| d¡ | j› d|› | _| d¡ | d¡ d}g }d }t| j	ƒ}xà|D ]Ö}	| j
r|d kr|	}qê|	d d… dkrxd |¡}
| d|	dd … › d|
› d¡ | j	|	 | j	|	dd … < | j	|	= | |	dd … ¡ qê|	d dkrØ| d|	d
d … › d|› ¡ | j	|	 | j	|	d
d … < | j	|	= | |	d
d … ¡ qê| |	¡ | d¡ t|ƒ}| d¡ | d|	› d¡ t|ƒ}| d¡ | j	|	  |¡ | d|	› d| j	|	 j› ¡ | dt|ƒd › ¡ dt|ƒd
 › d||< | d|	› d|› d¡ | d¡ dt|ƒd
 › d ||< |d
7 }qêW d}i }x | j	D ]}	|d
7 }|||	< qÖW x6| jD ],}|| j	krø||krø|d
7 }|||< qøW |d
 |d!< d"|d
 › d#|d › d#|d$ › d%| j› d&|d! › 
||d < g }|  ¡ x>| j	D ]4}	|	|kr†| d'| j› d(||	 › d)|	› d*¡ q†W t|ƒ}| d¡ | d¡ d+}t|ƒ}x| jD ]}| |¡ qîW ‡ ‡fd,d-„}‡fd.d/„}g ‰g ‰ g g‰g }g }g }d0d1„ }x2tt|ƒ| ƒD ]}|||  }d|ksxd2|kr‚||ƒ}n
| d#¡}|d d3kr®| || ¡ qRnL|d d4krĞˆd5  |d
 ¡ n*|d d6krú| |d
 ¡ | || ¡ |d d7krd8|d< d9}n|d d:krDˆ  || g f¡ ˆ g ¡ nä|d d;krfˆ || g f¡ nÂ|d d<kr(|d
 d=krĞˆ d5 \}}t|ƒdkrÂ||7 }d%| j› d}|| | ||< ˆ d5= ˆd5= nT|d
 d>krRˆd5 \} }t|ƒdkr||7 }d%| j› d}!||  |! || < ˆd5= qRx0tt|ƒƒD ]}"|"dks8||" dkrZq8||" d d?krpq8||" d d@kr„P |||" ƒ\}}#||ƒs8||kr8|dkr¶P n ||krädA| j› dB|# ||"< ||d! ƒ nr|| j	krdA| j› d(|| › dC|# ||"< ||| ƒ n8|| jkr8dA| j› d(|| › dC|# ||"< ||| ƒ q8W d# |¡||| < qRW g }$x.t|d
 ƒD ]}||kr†|$ t|ƒ¡ q†W x|D ]}%d||%< q®W t|ƒ}&t|ƒdkr|d5 |&d
 krx^|D ]}'d|&d
 › dD||'< qîW n:x|D ]}'d|&› ||'< qW |r>| dE¡ n
| dF¡ |rÒttdGdƒttdHdƒgƒti ƒƒ}(t|(dIƒ})|) |¡ | dJ¡ dK|d › d%| j› d||< dt|ƒd
 › dL||d
 < | dM¡ nd||< d||d
 < | dN¡ |	r| dO| j› d¡ n&| dO| j› d&d d |$¡ d ¡ | dP¡ | ¡  dt|ƒd
 › dQ||< d S )RNc             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r*   é   r   )r6   )ÚstringÚspÚkÚnr   r   r   Úget_nameç   s    
zDef.write.<locals>.get_namer   ÚBXé   r*   zmov r%   z BXrZ   Ú_zpush **kwargsz
push *argsz**r3   z**kwargs <esp+2>["z"] <esp+2> "r   Ú*z*args <esp+2>["z"] <esp+1> zcmp CX 0ztf <esp+2> "in" "zmov <esp+2>["z"] zjmp z$jmp z "!="z"] <esp+1>[r;   zdec CXz "t"é   z	Function ú é   z "z" zmov <ú+z> <esp+2>["z"]Fc                s`   t ˆ ƒdkr.| ˆ d d kr.ˆ d d  | ¡ t ˆƒdkr\| ˆd d kr\ˆd d  | ¡ d S )Nr*   éÿÿÿÿrZ   )r6   r   )rE   )Úadd_FunctionÚadd_Generatorr   r   Úsave_genF  s    zDef.write.<locals>.save_genc                s   xˆ D ]}| |krdS qW dS )NTFr   )ZwordÚitems)Úglobal_wordsr   r   Ú	in_globalL  s    
zDef.write.<locals>.in_globalc             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr*   )r   r   rZ   ú\re   )r6   r   )Úliner5   r]   r^   ÚpÚcr   r   r   Ú
parse_lineW  s"    
  zDef.write.<locals>.parse_liner   rK   Úglobalrh   ÚnonlocalÚyieldÚYieldTÚFunctionÚ	GeneratorÚendz
"Function"z"Generator")r   r   ú;ú<z+0>r$   u            ;returné»z	mov AX ""zmov AX Noner7   r   Úraiseu+   stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡ŒzGenerator AX u*         ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ipzend "Generator"u,   $mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸zend "Function" "zpop ipu              ;è·³éæ­¤å‡½æ•¸)r   r   r6   r
   r   r   Úadd_tabÚfunc_varÚtuplerI   rV   r4   rU   rP   r<   Úsplitr	   ÚFuncCallr#   r1   r@   rM   Údel_tab)*r   r   r_   Zdeclare_funcZskip_ipr=   ZkeyboxÚ	class_objrI   rB   Zkey_textZ
skip_paramZskip_param2Z	local_numZ
local_dictrL   Z
return_ipsÚyield_ipZ
have_yieldrq   r'   rk   rn   Znonlocal__wordsZnonlocal_ipsZ	not_abortrs   rp   ÚdealZf_rowrl   Zfunc_add_textZg_rowZgen_add_textr8   ÚbackZ
need_abortZnon_ipZendipZripZstopiterationÚ_raiser   )ri   rj   rm   r   r   æ   sV   

 





 




<

*



 
 
  

 


"



&
z	Def.writeN)r   r   r   r   r   r   r   r   r   r   rQ   Õ   s   	rQ   c               @   s.   e Zd Zddd„Zdd„ Zdd„ Zd	d
„ ZdS )r‚   Nr   c             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )r   ÚargsÚkwargsÚs_argsÚs_kwargsrW   )r   r   r‰   rŠ   r‹   rŒ   r   r   r   r   Ô  s    zFuncCall.__init__c             C   s   d| j › d| j› d| j› dS )Nz<Call z args=z kwargs=r$   )r   r‰   rŠ   )r   r   r   r   r   Û  s    zFuncCall.__str__c             C   s   t tddƒt|ƒƒS )Nr   r   )r/   r#   r   )r   r!   r   r   r   r9   İ  s    zFuncCall.__getitem__c                s>  ‡ ‡‡fdd„}ˆ   dˆj¡ ˆj ˆ ¡ dˆjjkˆ_ˆjjd d… dkpVdˆjjk‰ˆrpˆ   dˆjj› ¡ ˆjr$ˆjj d	¡\}}ˆ   d
|› d|› d¡ tˆ ƒ}ˆ   d¡ |ˆj|ƒ tˆ ƒ}ˆ   d¡ dtˆ ƒd › dˆ |< t	ˆjj
dd … ƒ}||ˆjjƒ dtˆ ƒd › ˆ |< n|ˆjˆjjƒ dˆ_d S )Nc                sf  ˆ   dt| ƒ› d¡ |  ˆ ¡ ˆ j d| j› d|› dˆjd ˆjd krˆˆj ˆ ¡ ˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆ   d	¡ ˆj ˆ ¡ tˆjƒd
krˆ   dˆjj› ¡ xHˆjD ]>}| ˆ ¡ ˆ   d¡ ˆ   d|j› ¡ ˆ   d¡ ˆ   d¡ qÀW ˆ   d¡ nˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆrRˆ   d¡ ˆ   d¡ nˆ   d|› ¡ d S )Nzpush u           ;å„²å­˜CXu     ;ç‚ºcall u
    åšæº–å‚™)Úsimplifyzex_func AX "list" zex_func BX "len" AXz$mov <esp+2> "+" BXz$mov <esp+1> "+" AXr*   zmov *args [1]zmov *args[0] zmov **kwargs [dict]zcall <esp+1>.updatezpop **kwargszmov **kwargs z	pop *argsu   pop CX     ;å–å›CXzpop AXzcall AXzcall )r   r6   r   r
   rV   r‹   rŠ   rŒ   )r‰   Z	call_namerŒ   )r   Úneed_push_namer   r   r   Údeal_cx_args_kwargsà  s4    
 









z+FuncCall.write.<locals>.deal_cx_args_kwargsr   rS   ra   r   ú&zpush r%   ztf z "Ctn" "r   r*   z$jmp rZ   z "t"zjmp )r   rW   r   r   r
   rV   r   r6   r‰   r1   r2   )r   r   r   Úspacer   Zjmp_if_trueZ	jmp_leaver‰   r   )r   r   r   r   r   ß  s*      

zFuncCall.write)Nr   )r   r   r   r   r   r9   r   r   r   r   r   r‚   Ó  s   
r‚   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rM   c             C   s   || _ || _d| _d S )N)r   r*   )ÚAÚcmdrW   )r   rC   r“   r   r   r   r     s    zBacktrack.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r     s    zBacktrack.__str__c             C   sL   | j  |¡ | j jdkr,| d| j j› ¡ | | j› d| j¡ d| _d S )Nr   zmov AX z AX)r’   r   r
   r   r“   rW   )r   r   r   r   r   r     s
    zBacktrack.writeN)r   r   r   r   r   r   r   r   r   r   rM     s   rM   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVar_declarec             C   s   || _ || _d S )N)rC   r“   )r   rC   r“   r   r   r   r   "  s    zVar_declare.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   rC   )r   r   r   r   r   %  s    zVar_declare.__str__c             C   s¤   | j  |¡ | jdkr†d| j jkrN| j j d¡\}}| d|› d|› d¡ q | j jd d… dkrn| d¡ q | d	| j j› d
¡ n| | j› d| j j› ¡ d S )NÚdelr%   zdel 2 z "r   rf   zAX[zdel 1 AX BXzdel 0 z Nonere   )rC   r   r“   r
   r   r   )r   r   r„   rB   r   r   r   r   '  s    
zVar_declare.writeN)r   r   r   r   r   r   r   r   r   r   r”   !  s   r”   c               @   s&   e Zd Zd
dd„Zdd„ Zdd„ Zd	S )Ú
Try_Exceptr   r   c             C   s(   || _ || _|| _|| _|| _g | _d S )N)Útry_codelinesÚexcept_objectsÚelse_codelinesÚfinally_codelinesr   rW   )r   r—   r˜   r™   rš   r   r   r   r   r   4  s    zTry_Except.__init__c             C   s   dS )Nz<Try Except>r   )r   r   r   r   r   ;  s    zTry_Except.__str__c       &      C   s  d}t |ƒ}| d| j| ¡ t |ƒ}| d¡ g g g dœ}g }t |ƒ}| ¡  x| jD ]}| |¡ qXW | ¡  |d7 }xDtt |ƒ| ƒD ]0}	|||	   d¡d }
|
dkrŒ| ||	 ¡ qŒW | d¡ t |ƒ}| d¡ | j	dkr| j	 |¡ | j	j
› d}nd}d}d	t |ƒd › }g }g }g }xltt | jƒd ƒD ]T}	|dkr^|||< d}nd
t |ƒd › d||< |	t | jƒk r|| d| j| ¡ |d7 }| j|	 }|d  |¡ | d|d j
› ¡ t |ƒ}| d¡ |d d kr| d|› |d › d¡ | d¡ | t |ƒ¡ | d¡ | ¡  x|d D ]}| |¡ q<W | ¡  | d¡ | t |ƒ¡ | d¡ n| t |ƒ¡ | d¡ q@W xV|D ]N}dt |ƒd › d||< | d¡ | d¡ | |¡ | d|› d¡ q W g }dt |ƒd › d||< t | jƒdkr†| d| j| ¡ |d7 }| ¡  | t |ƒ¡ | d¡ x| jD ]}| |¡ q`W | d¡ | ¡  t |ƒd }x|D ]}d|› d||< q˜W | d¡ | d¡ | t |ƒ¡ | d¡ i }xbtt |ƒ| ƒD ]N}	t|||	  ƒtkrô|||	   d¡d }
|
|krô||
  ||	 ¡ qôW d}x°|D ]¨}t || ƒdkrPt |ƒd }x || D ]}d|› ||< q|W |dkrª| d¡ n
| d¡ | d¡ | d|› ¡ | t |ƒ¡ | d¡ |||< |d7 }qPW t |ƒd }x|D ]}d	|› ||< qW x|D ]}d|› d||< q,W | d¡ | d¡ t |ƒd }d|› ||< x|D ]}d|› d ||< qzW | d!|› ¡ t |ƒ} t | jƒdkr| d"¡ | d¡ | d| j| ¡ |d7 }| ¡  x| jD ]}| |¡ qúW | ¡  g g g dœ}!xbtt |ƒ|  ƒD ]N}	t|| |	  ƒtkr4|| |	   d¡d }
|
|!kr4|!|
  | |	 ¡ q4W t | jƒdkr | d#¡ | d$¡ i }"x8|D ]0}| d%|› ¡ || |"t |ƒ< | d¡ q´W | d&¡ t |ƒ}#| d¡ | d$¡ ttd'dƒd(ƒ}$|$ |¡ xh|!D ]`}t |!| ƒdkr.t |ƒd }x&|!| D ]}d|› d)|› ||< qZW | d*¡ | |¡ q.W xH|"D ]@}%d
t |ƒd › d+||%< | d#¡ | d$¡ | |"|% ¡ q˜W d
t |ƒd › d+||#< | d$¡ | d,¡ d S )-Nr*   )ÚcontinueÚbreakrK   rZ   re   rv   z	try "end"r   r%   ztry z$jmp z "f"zerror zmov z $Exceptionzmov $Exception 0ra   zjmp u    ;è™•ç†tryä¸­çš„yieldu-   yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡u#        ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œu!       ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°elseu     ;è·³åˆ°push 1u   push None  ;æ¨å…¥Noneu   push 1     ;ä»£è¡¨æ­£å¸¸rK   zpush AXz	push Nonezpush z ;push 0zpush 0zfinally u       ;è·³åˆ°finallyz	finally -zpush $Exceptionzpop $Exceptionzpop AXzcmp AX zcmp AX 1z
$Exceptionr}   u"          ;è·³è‡³finallyä¸­çš„äº‹ä»¶:z$mov esp "+" 3z "=="zend "finally_yield")r6   r   rW   r~   r—   r   rƒ   r<   r   r   r
   r˜   r™   Útyper	   rš   rM   r#   )&r   r   ÚolZto_finally_ipZto_except_ipZSDZ	yield_boxZstart_pr'   r=   r“   Z	try_leaveÚispacerF   Ztry_except_ipZ
try_push_0Z
jmp_push_0Z
jmp_push_1Z
error_datar…   Zjmp_to_finallyZpush_1Zjp0Zstype_SDÚstyperB   Újmp_ipÚipZpush_0Ztp0Z
finally_ipZjtfZ	finally_pZfinally_eventsZleave_SDZjmp_to_leaverˆ   Úlipr   r   r   r   =  s>   













































zTry_Except.writeN)r   r   r   )r   r   r   r   r   r   r   r   r   r   r–   3  s   
r–   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWithc             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )Úcall_objÚorig_as_nameÚas_nameÚwith_codelinesr   rW   )r   r¥   r¦   r§   r¨   r   r   r   r   r   ô  s    zWith.__init__c             C   s   dS )Nz<with>r   )r   r   r   r   r   û  s    zWith.__str__c       	      C   s0  |  d| j¡ | ¡  | j |¡ | j |¡ |  d| jj› d| jj› ¡ tt| jj› ddƒt	g ƒt
i ƒƒ}| |¡ | jd kr¶|  d|j› ¡ | j |¡ |  d| jj› ¡ | j}g }g }tt| jj› ddƒt	td ƒtd ƒtd ƒgƒt
i ƒƒ}|g}t||||ƒ}dddg|_| |¡ | ¡  d S )	Nr   zmov re   z
.__enter__zpush zpop z	.__exit__)r   r*   )r   rW   r~   r¦   r   r¥   r
   r‚   r#   r1   r@   r§   r¨   ÚTFNr–   rƒ   )	r   r   Z_enter_callr—   r˜   r™   Z
_exit_callrš   Z_try_exceptr   r   r   r   ı  s(    $

6
z
With.writeN)r   r   r   r   r   r   r   r   r   r   r¤   ó  s   r¤   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚStopc             C   s   d S )Nr   )r   r   r   r   r     s    zStop.__init__c             C   s   dS )Nz<$stop>r   )r   r   r   r   r     s    zStop.__str__c             C   s   |  d¡ d S )NÚstop)r   )r   r   r   r   r   r     s    z
Stop.writeN)r   r   r   r   r   r   r   r   r   r   rª     s   rª   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚCommandc             C   s
   || _ d S )N)Úcmd_list)r   r­   r   r   r   r     s    zCommand.__init__c             C   s   dS )Nz
<cmd_list>r   )r   r   r   r   r     s    zCommand.__str__c             C   s   x| j D ]}| |¡ qW d S )N)r­   r   )r   r   r“   r   r   r   r   !  s    zCommand.writeN)r   r   r   r   r   r   r   r   r   r   r¬     s   r¬   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_if_elsec             C   s   || _ || _|| _d S )N)ÚeventÚ	true_itemÚ
false_item)r   r¯   r°   r±   r   r   r   r   %  s    zsub_if_else.__init__c             C   s   dS )Nz<A if else B>r   )r   r   r   r   r   )  s    zsub_if_else.__str__c             C   sà   | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | jjdkrb| d| jj› d¡ t|ƒ}| d¡ dt|ƒd › d	||< | j |¡ | jjdkr¾|jd| jj› d
dd dt|ƒd › d||< d| _d S )Nzcmp z 1r*   r   zmov AX z   ;true itemz$jmp rZ   u    "!="   ;è·³åˆ°falsez   ;false item)r   zjmp u      ;é›¢é–‹sub_if_else)r¯   r   r   r
   r6   r°   r±   )r   r   Z	jne_falseÚleave_ipr   r   r   r   +  s    

zsub_if_else.writeN)r   r   r   r   r   r   r   r   r   r   r®   $  s   r®   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIf_elsec             C   s   || _ || _g | _d S )N)Úif_itemsr™   rW   )r   r´   r™   r   r   r   r   >  s    zIf_else.__init__c             C   sÌ   d| j d d › dg}x$| j d d D ]}| t|ƒ¡ q(W xL| j dd … D ]:}| d|d › d¡ x|d D ]}| t|ƒ¡ qrW qNW t| jƒdkrÂ| d¡ x| jD ]}| t|ƒ¡ q¬W d |¡S )Nzif r*   rA   rZ   zelif zelse:r   )r´   r   r	   r6   r™   r4   )r   r   r'   r=   r   r   r   r   B  s      
 zIf_else.__str__c       	      C   s6  g }d}x´| j D ]ª\}}| d| j| ¡ |d7 }| |¡ | d|j› d¡ | ¡  t|ƒ}| d¡ x|D ]}| |¡ qpW | t|ƒ¡ | d¡ dt|ƒd › d||< | ¡  qW t| jƒdkr
| d| j| ¡ | ¡  x| jD ]}| |¡ qğW | ¡  x&|D ]}dt|ƒd › d	||< qW d S )
Nr*   r   rZ   zcmp z 1z$jmp u#    "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·zjmp u           ;è·³è‡³åº•éƒ¨)	r´   r   rW   r   r
   r~   r6   rƒ   r™   )	r   r   Úneed_set_endr   r¯   ÚblockÚjipr'   r¢   r   r   r   r   L  s0    


 
 
zIf_else.writeN)r   r   r   r   r   r   r   r   r   r   r³   =  s   
r³   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWhilec             C   s   || _ || _|| _d| _d S )N)r   r*   )r¯   rP   r™   rW   )r   r¯   rP   r™   r   r   r   r   d  s    zWhile.__init__c             C   s   d| j › d| j› S )Nzevent:z do:)r¯   rP   )r   r   r   r   r   i  s    zWhile.__str__c             C   sd  t |ƒ}| d| j¡ | j |¡ | d| jj› d¡ | ¡  t |ƒ}| d¡ g }x†| jD ]|}t |ƒ}| |¡ xdtt |ƒ| ƒD ]P}|||   	d¡d }|dkrÀd|d › ||| < q†|d	kr†| || ¡ q†W q^W | d|d › d
¡ t |ƒd }	d|	› d||< x| j
D ]}| |¡ qW t |ƒd }
x|D ]}d|
› d||< q>W | ¡  d S )Nr   zcmp z 1r*   re   r›   zjmp rZ   rœ   u                  ;continueé‡ä¾†z$jmp z "!="u             ;breakå‡º)r6   r   rW   r¯   r   r
   r~   rP   r<   r   r™   rƒ   )r   r   Úagain_ipÚout_ipÚ	break_boxr'   rq   r=   r“   Z
to_else_ipÚbreak_ipÚb_ipr   r   r   r   k  s4    


zWhile.writeN)r   r   r   r   r   r   r   r   r   r   r¸   c  s   r¸   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_for_loopc             C   s"   || _ || _|| _|| _|| _d S )N)ÚexpressÚvnamesÚbase_objÚif_objÚis_list)r   r¿   rÀ   rÁ   rÂ   rÃ   r   r   r   r   ‰  s
    zsub_for_loop.__init__c             C   s   dS )Nz<sub for loop>r   )r   r   r   r   r     s    zsub_for_loop.__str__c       	      C   s  t | jdƒ}| jd krLt| j|gggg ƒ}dddg|_t| j| j|gg ƒ}nt| j| j|gg ƒ}tdƒ}x| jD ]}| 	d|¡ qpW | 
|d¡ t|ƒ}td|› i |dƒ}| 
|¡ | d¡ | d¡ | d¡ | d	¡ | d
¡ | d|› ¡ | jr
| d¡ d| _d S )Nrv   )r   r*   r   rL   z&generator_u   push 0        ;å„²å­˜CXzpush [0]zmov **kwargs [dict]z	pop *argsu   pop CX     ;å–å›CXzcall &generator_zex_func AX "list" AXr   )rM   r¿   rÂ   r³   rW   ÚFor_looprÀ   rÁ   rN   rO   r   r6   rQ   r   rÃ   r
   )	r   r   Z_yieldZ_ifZ	_for_loopÚinforL   ÚidÚfDefr   r   r   r   ‘  s,    







zsub_for_loop.writeN)r   r   r   r   r   r   r   r   r   r   r¾   ˆ  s   r¾   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rÄ   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r*   )rÀ   rÁ   rP   r™   rW   )r   rÀ   rÁ   rP   r™   r   r   r   r   ®  s
    zFor_loop.__init__c             C   s   dS )Nz
<For loop>r   )r   r   r   r   r   ´  s    zFor_loop.__str__c             C   sf  | j  |¡ | d| j j› | j¡ | ¡  | d¡ t|ƒ}| d¡ t|ƒ}| d¡ t| jƒdkr”| jd  |¡ | d| jd j› d¡ nHxFtt| jƒƒD ]4}| j|  |¡ | d| j| j› d|› d	¡ q¤W g }g }x¦| j	D ]œ}t|ƒ}| |¡ x„tt|ƒ| ƒD ]p}|||   
d
¡d }	|	dkrPd|d › ||| < n2|	dkrj| || ¡ n|	dkr| || ¡ qW qìW | d|d › ¡ t|ƒdkrìt|ƒ}
x |D ]}d|
d › ||< q¼W | d¡ | d¡ t|ƒd }d|› d||< x| jD ]}| |¡ qW t|ƒd }x|D ]}d|› d||< q6W | d¡ | ¡  d S )Nzex_func AX "iter" zpush AXzfetch AX <esp+1>r*   rZ   zmov z AXz AX[r;   re   r›   zjmp rœ   rK   zinc espz	return AXz$jmp z "f"u             ;breakå‡ºè¿´åœˆ)rÁ   r   r   r
   rW   r~   r6   rÀ   r<   rP   r   r™   rƒ   )r   r   r¹   r²   r=   r»   Z
return_boxr'   rq   r“   Zreturn_leave_ipZr_iprº   r¼   r½   r   r   r   r   ¶  sV    


$








zFor_loop.writeN)r   r   r   r   r   r   r   r   r   r   rÄ   ­  s   rÄ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMarkc             C   s
   || _ d S )N)Úmark)r   rÉ   r   r   r   r   ì  s    zMark.__init__c             C   s   d| j › dS )Nz<mark r$   )rÉ   )r   r   r   r   r   î  s    zMark.__str__c             C   s   |  | j¡ d S )N)r   rÉ   )r   r   r   r   r   r   ğ  s    z
Mark.writeN)r   r   r   r   r   r   r   r   r   r   rÈ   ë  s   rÈ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚPassc             C   s   d S )Nr   )r   r   r   r   r   ó  s    zPass.__init__c             C   s   dS )Nz<pass>r   )r   r   r   r   r   õ  s    zPass.__str__c             C   s   d S )Nr   )r   r   r   r   r   r   ÷  s    z
Pass.writeN)r   r   r   r   r   r   r   r   r   r   rÊ   ò  s   rÊ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r©   c             C   s
   || _ d S )N)rC   )r   rC   r   r   r   r   ú  s    zTFN.__init__c             C   s   d| j › dS )Nr|   r$   )rC   )r   r   r   r   r   ü  s    zTFN.__str__c             C   s   | j | _d S )N)rC   r
   )r   r   r   r   r   r   ş  s    z	TFN.writeN)r   r   r   r   r   r   r   r   r   r   r©   ù  s   r©   c               @   s&   e Zd Zddd„Zdd„ Zdd„ ZdS )	ÚClassNc             C   s2   || _ |j| _|j| _|| _|| _|| _d| _d S )N)r   r*   )r   ÚfuncsZ	functionsrP   r   Ú	class_espÚfatherrW   )r   r   rÅ   r   rÍ   rÎ   r   r   r   r     s    zClass.__init__c             C   s   d| j › dS )Nz<class r$   )r   )r   r   r   r   r     s    zClass.__str__c       
   	   C   sP  | j dkrn| j  |¡ | dt|ƒd › d| j j› d| j› d| j¡ | j j› d| j› }| d|› d	¡ n2| j}| d
|› dt|ƒd › d| j› d| j¡ | d|› d| j› d¡ | ¡  t|ƒ}| d¡ | d¡ | dt|ƒd › d¡ | d| j› d¡ | d¡ | dt|ƒd › ¡ | d| j› d¡ | d¡ | d¡ | d¡ | d¡ | d¡ | j	d kr t
| j	ƒtkrš| j	j}n| j	g}x\|D ]T}| |¡ | d¡ | d¡ | d ¡ | d!| j› d"¡ | d#|j› ¡ q¨W | d$| j› d%|› ¡ x| jD ]}| |¡ q W | d&| j› d"¡ | d'¡ | d(¡ | d)¡ | d*¡ | d+¡ t|ƒ}| d¡ | d,¡ | dt|ƒd- › d¡ t|ƒ}| d¡ | d.¡ | d&| j› d"¡ t|ƒd- }	d|	› d/||< d|	› ||< | d0| j› d1¡ | d2¡ dt|ƒd- › ||< d3| _| ¡  d S )4Nr   zFunction BX rf   re   z "z" 1r%   zmov z BXz	Function ra   z None "zname z "<class '__main__.z'>"r*   ztf $Inheritance "equ" Nonez$jmp z "t"zmov <z> $Inheritancezpush 1zjmp z	> [class]zpush 0zmov $Inheritance Nonezpush CXz
push *argszpush **kwargszmov **kwargs <esp+1>zmov *args <esp+2>zmov CX <esp+3>zmov $Inheritance <r$   zcall ztype <z> zmov AX <zpop **kwargsz	pop *argszpop CXzpop BXzcmp BX 1ztf AX "Ctn" "__init__"rZ   zcall AX.__init__z "=="zend "Function" "r   zpop ipr   )r   r   r   r6   r
   rÍ   rW   r   r~   rÎ   r   r>   r2   rP   rƒ   )
r   r   Zclass_paramZskip_class_ipr†   rÎ   r'   Zleave_init_ipZskip_init_iprz   r   r   r   r     st    
0,























zClass.write)N)r   r   r   r   r   r   r   r   r   r   rË      s   

rË   c             C   sÌ   |   |¡ | jd d… dks&| jdkr\| d¡ |  |¡ | d|j› ¡ | d¡ d}nl| jd d… dkr¸| d¡ | d	¡ |  |¡ | d
|j› ¡ | d¡ | d¡ d}n|  |¡ |j}|S )Nrf   zAX.r   zpush AXzmov BX zpop AXr`   zAX[zpush BXzmov DX zpop BXÚDX)r   r
   r   )r’   ÚBr   Ú	blocationr   r   r   Útwo_object_write\  s$    









rÒ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMultiple_Movc             C   s@   || _ || _|dkr"d| _d| _nd| _|d d… | _d| _d S )Nú=r*   ÚmovrZ   rh   )r   r*   )Úobj_listÚtargetÚctyper“   rW   )r   rÖ   r×   Úopr   r   r   r   ‡  s    zMultiple_Mov.__init__c             C   s   dS )Nz<Multiple mov>r   )r   r   r   r   r   ‘  s    zMultiple_Mov.__str__c             C   s,  |  d| j¡ | j |¡ |  d| jj› ¡ xî| jD ]ä}t|ƒttfkrÊxÎt	t
|ƒƒD ]l}||  |¡ | jdkr”|  d|| j› d|› d¡ qX| jdkrX|  d|| j› d	| j› d
|› d¡ qXW q6| |¡ | jdkrô|  d|j› d¡ q6| jdkr6|  d|j› d	| j› d¡ q6W |  d¡ d S )Nr   zpush r*   zmov z	 <esp+1>[r;   rZ   z$mov z "z
" <esp+1>[z <esp+1>z	" <esp+1>zinc esp)r   rW   r×   r   r
   rÖ   r   r>   r1   r<   r6   rØ   r“   )r   r   r'   r=   r   r   r   r   “  s"    
 
,


 zMultiple_Mov.writeN)r   r   r   r   r   r   r   r   r   r   rÓ   †  s   
rÓ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOperc             C   s   || _ || _|| _d S )N)r’   rĞ   Úsymbol)r   r’   rĞ   rÛ   r   r   r   r   ¨  s    zOper.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r’   rÛ   rĞ   )r   r   r   r   r   ­  s    zOper.__str__c             C   s\   | j  |¡ | d| j j› ¡ | j |¡ | d| j› d| jj› ¡ | d¡ d| _d S )Nzpush zoper <esp+1> "z" zpop AXr   )r’   r   r   r
   rĞ   rÛ   )r   r   r   r   r   r   ¯  s    
z
Oper.writeN)r   r   r   r   r   r   r   r   r   r   rÚ   §  s   rÚ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚTfc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   ¸  s    zTf.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   ½  s    z
Tf.__str__c             C   sF   t | j| j|ƒ}| d| jj› d| j› d|› ¡ | d¡ d| _d S )Nztf z "z" z	mov AX TFr   )rÒ   r’   rĞ   r   r
   r“   )r   r   rÑ   r   r   r   r   ¿  s    "
zTf.writeN)r   r   r   r   r   r   r   r   r   r   rÜ   ·  s   rÜ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAndOrc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   Æ  s    zAndOr.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   Ê  s    zAndOr.__str__c             C   sB  | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | d| jj› d¡ t|ƒ}| d¡ | jdkrĞ| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< nh| jdkr8| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< d| _d S )Nzcmp z 1r*   Úandzmov AX 1zjmp rZ   zmov AX 0)r   z$jmp z "!="Úorz "=="r   )r’   r   r   r
   r6   rĞ   r“   )r   r   r·   r£   Zto_falseZto_truer   r   r   r   Ì  s.    




zAndOr.writeN)r   r   r   r   r   r   r   r   r   r   rİ   Å  s   rİ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚDenyc             C   s   || _ || _d S )N)r’   r“   )r   r’   r“   r   r   r   r   å  s    zDeny.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r   é  s    zDeny.__str__c             C   sJ   | j  |¡ | j jdkr,| d| j j› ¡ | d| j› d¡ d| _d S )Nr   zmov AX z
$oper AX "r   )r’   r   r
   r   r“   )r   r   r   r   r   r   ë  s
    z
Deny.writeN)r   r   r   r   r   r   r   r   r   r   rà   ä  s   rà   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBoolc             C   s
   || _ d S )N)Úenebox)r   Z
enequalboxr   r   r   r   ó  s    zBool.__init__c             C   s$   d}x| j D ]}|t|ƒ7 }qW |S )Nr   )râ   r	   )r   r   r=   r   r   r   r   õ  s    zBool.__str__c             C   sğ  d}| j d  |¡ | d| j d j› ¡ g }g }ddddddd	œ}x|t| j ƒd
 k rL| j |d   |¡ | d¡ | j |d
  dkrÌ| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ n<| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ | d¡ |d t| j ƒk rB| d| j |d  j› ¡ |d7 }qJW | d¡ | dt|ƒd
 › ¡ t|ƒd
 }|jdd
d x,|D ]$}d|› d|d
 › d||d < qW x,|D ]$}d|› d|d
 › d||d < q¾W d| _d S )Nr*   zpush ÚfÚtz<=z>=r|   r$   )z==z!=r$   r|   z>=z<=rZ   ra   zpop DX)z==z!=ztf DX "equ" zcmp DX rf   zmov AX Truezjmp zmov AX False)r   z$jmp z "r   r   )râ   r   r   r
   r6   )r   r   r]   rµ   Zneed_set_tfZcmp_dictrz   r=   r   r   r   r   ú  s6    
" 


$
$z
Bool.writeN)r   r   r   r   r   r   r   r   r   r   rá   ò  s   rá   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAssertc             C   s   || _ || _d| _d S )N)r   r*   )r¯   ÚmsgrW   )r   r¯   ræ   r   r   r   r     s    zAssert.__init__c             C   s   d| j › d| j› dS )Nz<assert z, r$   )r¯   ræ   )r   r   r   r   r     s    zAssert.__str__c             C   sj   |  d| j¡ t| jdƒ}ttddƒt| jgƒti ƒƒ}t	|dƒ}t
||gggg ƒ}dg|_| |¡ d S )Nr   ÚnotÚAssertionErrorr}   )r   r*   )r   rW   rà   r¯   r‚   r#   r1   ræ   r@   rM   r³   r   )r   r   Z	not_eventZassertionerrorrˆ   rÂ   r   r   r   r      s    
zAssert.writeN)r   r   r   r   r   r   r   r   r   r   rå     s   rå   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSTRc             C   s
   || _ d S )N)r'   )r   r'   r   r   r   r   )  s    zSTR.__init__c             C   s   d| j › dS )Nz<STR: r$   )r'   )r   r   r   r   r   +  s    zSTR.__str__c             C   s*   | j  |¡ | d| j j› ¡ d| _d S )Nzex_func AX "str" r   )r'   r   r   r
   )r   r   r   r   r   r   -  s    z	STR.writeN)r   r   r   r   r   r   r   r   r   r   ré   (  s   ré   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rN   c             C   s(   g | _ i | _i | _i | _g | _|| _d S )N)rT   ÚvarsrÌ   ÚclassesrP   r   )r   r   r   r   r   r   3  s    zInfo.__init__c             C   s^   |dkr|| j |j< n*|dkr,|| j|j< n|dkr@|| j|j< |j| jkrZ| j |j¡ d S )NrL   ÚfuncÚclass)rê   r   rÌ   rë   rT   r   )r   r   r'   r   r   r   rO   :  s    zInfo.add_infoc             C   s>   |  j |j 7  _ | j |j¡ | j |j¡ | j |j¡ d S )N)rT   rê   ÚupdaterÌ   rë   )r   rÅ   r   r   r   rî   C  s    zInfo.updatec             C   s   dd„ }| j  |¡ ||_d S )Nc             S   sJ   g }x:| D ]2}t |ƒtkr*| d| ¡ q
| t|ƒd ¡ q
W d |¡S )Nre   r   )r   r   r   r	   r4   )Zorig_codeliner5   r'   r   r   r   Ú	deal_origI  s    
zInfo.write.<locals>.deal_orig)rP   r   rW   )r   ÚcodelineÚorig_codelinesrï   r   r   r   r   H  s    z
Info.writeN)r   r   r   r   rO   rî   r   r   r   r   r   rN   2  s   	rN   N)+r   r   r   r   r   r   r#   r&   r+   r/   r1   r>   r@   rD   rG   rH   rQ   r‚   rM   r”   r–   r¤   rª   r¬   r®   r³   r¸   r¾   rÄ   rÈ   rÊ   r©   rË   rÒ   rÓ   rÚ   rÜ   rİ   rà   rá   rå   ré   rN   r   r   r   r   Ú<module>   sZ      A A"&%%>\*!'
27269*122*package.cpython-37.pycB
    ¹êweæé  ã               @   s¼   d dl mZmZmZ d dlmZmZ d dlmZ d dl	T dd„ Z
dd	d
„Zdd„ Zdd„ Zddd„Zeƒ fdd„ZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZeƒ ZG dd„ dƒZdS ) é    )ÚlistdirÚgetcwdÚchdir)ÚisdirÚisfile)ÚCode)Ú*c       !   "      sF	  dd„ }dQ‡ ‡fdd„	}dddd	d
dddddddddddddddddddddd d!d"d#d$d%d&d'g"}d(d)d*d+d,d-d.d/d0d1œ	}d(t ˆƒ }}g }d(}d(}	ˆ d2¡}
d)g‰ d(ˆ d( |
ˆ d( d)  fg}xh||k 	r(ˆ| }|d3krv|}d4}x(||k rˆ| |kr
|d)7 }qèP qèW ˆ||…  ¡ }|d d*… d5krB||d*d … ƒ}d6|kr\| t|ƒ¡ n| t|ƒ¡ |d)8 }n¨|d7krè|d* |k r¼ˆ||d+ … }|d8kr¼| |¡ |d+7 }qÂ|d) |k røˆ||d* … }|d9krø| |¡ |d*7 }qÂ| |¡ |d:kr|d)7 }n|d;kr(|d)8 }|dk	r|d(k	r|	d(krP|	d)8 }	n”yˆ d2|¡}W n   t ˆƒ}Y nX || d)k	r| |¡ |d( d( d, ˆ d( |
ˆ d( d)  fg}|d)7 }xˆ| d<krÚ|d)7 }qÀW |d)8 }n6|d=kr&x&||k rˆ| d2kr|d)7 }qôW |d)8 }nø|d>krt||ƒ\}}t |ƒd(krft|d? ƒtkrf| d@¡ | |¡ nª|d2kr&ˆ d(  d)7  < |d(k	rt |ƒd)kr°| |¡ g }|d)7 }||k rd(}x.||k røˆ| d<krø|d)7 }|d)7 }qÌW | |ˆ d( |
ˆ d( d)  f¡ |d)8 }nø|dAkr |d) |k r ˆ|d)  d>kr |d)7 }||dBdC\}}t |ƒd(kr’t|d? ƒtkr’| d@¡ | |¡ n~|dDkr|d) |k rˆ|d)  d>kr|d)7 }||ƒ\}}t |ƒd(krt|d? ƒt	kr| d@¡ | t	|j
ƒ¡ n|dEkr|d) |k rˆ|d)  d>kr| dF¡ ˆ|d)  }|d* }x.ˆ| |ks†ˆ|d)  dGkr’|d)7 }qfW ˆ|d* |… }t |ƒ}d(}g }x4||k rê|| d2kràˆ d(  d)7  < || dHkr8||d)  dHkr| dH¡ |d)7 }qŞt |ƒd(kr@t|d? ƒtkr@| d@¡ | tdI |¡ƒ¡ g }|d)7 }|}d(}d)}x‚|d(krî|| }|d(krÂ|dHkr|d)7 }n"|dJkr²|d)8 }n|dKkrâ|}n ||krâ||d)  dGkrâd(}|d)7 }qnW |d)8 }|||… }t|ƒd( d)d … }|d@tdLƒdFg| dMd@g 7 }n¦|| dJkrt|||d* … dNkrt| || ¡ |d)7 }nj|| dGkr¨| || ¡ |d)7 }| || ¡ n6|| d>krĞ| dG¡ | || ¡ n| || ¡ |d)7 }q¸W | tdI |¡ƒ¡ | dM¡ |}n|d<k	rg }dO}x8||k r\ˆ| |krV| ˆ| ¡ |d)7 }nP q&W dI |¡} | |krö| dkrŒ| tdƒ¡ nV| dkr¦| tdBƒ¡ n<| dkrÀ| td ƒ¡ n"| d'krØ| tƒ ¡ n
| | ¡ | d"k	r|	d)7 }	n | |k	rdP|  } | t| ƒ¡ |d)8 }|d)7 }qÂW t |ƒd)k	rB| |¡ |S )RNc             S   sN   d}d\}}x8t t| ƒƒD ](}|| | | |  ¡| 7 }|d9 }qW t|ƒS )NZ0123456789abcdef)r   é   é   )ÚrangeÚlenÚindexÚstr)ÚhexÚstringZtotalÚbaseÚi© r   ú/C:\Users\allen\Desktop\py\py\apython\package.pyÚ
hex_to_int   s    zparse_code.<locals>.hex_to_intTc       	         s¸  ˆ|  }| d7 } | }xHˆ|  }|dkr6ˆ d  d7  < |dkrH| d7 } n
||krRP | d7 } qW ˆ|| … }|dkrv|r‚|dkr’|r’t ||d| fS |dkr(|r(g }dt|ƒ }}x\||k r|| dkrÖ| d¡ || dkrø| || ¡ |d7 }| || ¡ |d7 }q¶W t d |¡|d| fS |dkr´|s´g }dt|ƒ }}xV||k r || dkrn| d¡ | || ¡ || dkr”| d¡ |d7 }qLW t d |¡ƒ| fS d S )	Nr	   Ú
r   ú\ú'ú")ÚchangeÚ )ÚStringr   ÚappendÚjoin)	Úkr   ÚcÚpÚc2Zget_textÚtextZckÚn)ÚclineÚcoder   r   Údeal_string   sL    



zparse_code.<locals>.deal_stringÚdefÚwhileÚforÚinÚifÚelifÚelseÚclassÚbreakÚcontinueÚreturnú:ÚandÚnotÚorÚTrueÚFalseÚNoneÚfromÚimportÚasÚisÚwithÚraiseÚtryÚexceptÚfinallyÚyieldÚlambdaÚdelÚglobalÚnonlocalÚassertz$stopr   r	   é   é   é   é   é   é   é   )	ZAXZBXZCXZDXZipZespÚspZZRZTFr   Z
0123456789z0123456789.xabcdefXABCDEFZ0xÚ.z+-*/,()[]{}!=%:><.&^|~)z**=z//=z>>=z<<=)z+=z-=z*=z/=z==z!=z**ú>ú<z>=z<=z%=z//z>>z<<z&=z^=z|=)ú(ú[ú{)ú)ú]ú}ú ú#)r   r   éÿÿÿÿú+ÚrF)r   ÚbÚfrT   r   rV   r   rY   )r   r   z$strrW   z}}z+-*/,()[]{}!=%:><.&^|~\# 
:z$$)T)r   ÚsplitÚlowerr   ÚFloatÚIntegerr   Útyper   ÚByter#   r   Ú
parse_codeÚVar_nameÚTFNZStop)!r&   r   r'   Zkey_wordZ	data_dictr   r$   Ú	codelinesZin_bracketsZ	in_lambdaZ	orig_codeÚcodeliner    r!   ZnumbersZnumberZc3r"   Úqr   Z	space_numZsymbolÚgetZsnZskZtextboxZslockZscZvartextZsub_codelineZv_nameZban_wordZelement_namer   )r%   r&   r   rg      sj   (



 






 

 

 
( 

 




 * 
* 
*
"
 






 $







 
 
 
 

 



rg   Fr   c             C   s”   d}t | ƒ}t|ƒ}xr||k r†| | }|dkrN||kr:|S ||krN|rJ|S dS |dk rZ|S |dkrl|d7 }n|dkr||d8 }|d7 }qW |r|S dS )Nr   r\   )rT   rU   rV   r	   )rW   rX   rY   )r   Úlist)rk   r   ÚelementsÚendÚstopr    r$   Úelementr   r   r   Únext_element  s,    
  
  rs   c             C   s  t | ƒ}||krdS |}|d7 }d}d}xš||k rÂ| | |ksJ| | dkrÂ| | |kr¬d}|d7 }x\||k r¨|dkr¨| | |krŠ|d7 }n| | |kr|d8 }|d7 }qdW q*| | dkr*|d7 }q*W | ||… }t |ƒdkrt|d ƒtkrt|d j|ƒ|fS |d |fS nôt|d ƒtkrT|d jdkrTt|dd	… |ƒ}	t|	ƒ|fS |d d
kr|}
d}t|d ƒtkrt|d j|ƒ|d< ddlm} |ƒ d }xRt |ƒdkrú|| dkrhg }g }d }g }||d  dkr.xJ|t |ƒk r*||d  dkrP|d }t||dƒ}t|||… |ƒ}| 	t
||d  jƒ|f¡ nÆ||d  dkr¦|d }t||dƒ}t|||… |ƒ}|d kr˜|}nt||dƒ}np||d  dkræ|d }t||dƒ}| 	t|||… |ƒ¡ n0|d }t||dƒ}t|||… |ƒ}| 	|¡ || dkrìP qìW n|d7 }t|d t|ƒt|ƒ||ƒg||d d …  }nv|| dkr¤|d }g }x°t||dƒ}|| dkrØ||kr²td ƒ}nt|||… |ƒ}|d }| 	|¡ nVt |ƒdkrút|||… |ƒ}n2||kr| 	td ƒ¡ n| 	t|||… |ƒ¡ P q„W t|ƒtkr‚t |ƒdk rj|td ƒgdt |ƒ  7 }t|d |d |d ƒ}t|d |ƒg||d d …  }n:|| dkrŞt|d |d ƒ}|g|dd …  }|d8 }|ƒ |kròtdƒ‚d}qªW |d |
fS d S )N)Nr\   r	   )rU   rT   )rX   rW   rQ   r   rI   z$strr\   z([.)ÚtimerT   rW   ú=rJ   z,)r   r]   z**rU   z:]r3   z335 get error)r   re   rh   ÚVariableÚnameÚparse_codelineZSTRrt   rs   r   r   ÚOperÚFuncCallÚListÚDictri   rn   ZSliceÚIndexVariableÚSubVariableÚ	Exception)rk   r   Ú	namespacer$   r!   ZleftbZrightbr    rm   Úobjrl   rt   ÚstÚargsÚkwargsZs_argsZs_kwargsÚvalueZcollectZsubattrr   r   r   Úget_var  sÀ    " 
 "


 
2


"
r†   c             C   sT   | | d d }|d }t | ƒ}x.||krN|d7 }||kr<P | | d d }q"W |S )Nr   r	   )r   )rj   ÚrowZspace_nZs_nÚRowr   r   r   Únext_codelineƒ  s    
 r‰   c       %         sÌ	  d}x0|t | ƒk r6| | }|dkr,|}i }|d7 }t | ƒ}x–||k rÖ| | }t|ƒtkrÂtd ƒ||j< |d |k rÂ| |d  dkrÂ|d }t| |dƒ}t| ||… ˆ ƒ||j< | | dkrÂP |dkrÌP |d7 }qBW t| |dd	d
}	t| |d |	… dƒ}
t||
ˆ ƒ}| d |… |g | |	d …  } d}|d7 }qW d}xÜ|t | ƒk r|dks€t| |d  ƒtkr| |d  dkr| | }|dkrŞt| |d dƒ}	t| |d |	… ˆ ƒ}| d |… |g | |	d d …  } n0|dkr6t| |d dƒ}	t| |d |	… ˆ d	d}| d |… |g | |	d d …  } nØ|dkrt| |d dgƒ}	t| |d |	… ˆ d	d}|j	}d|ksŠt |ƒdkräg }d}t |ƒ}x>||k rØ|| }|d7 }|| }|d7 }| 
||f¡ qœW t|ƒ}nt|ƒ}| d |… |g | |	d d …  } |d7 }q@W d}x®|t | ƒk rÎ| | }t|ƒtkrX|dkrXt|ƒS t|ƒtkrv|dkrvtƒ S t | ƒ}t| |ˆ ƒ\}}	| d |… |g | |	d …  } t | ƒ|k rÂ|d8 }|d7 }q"W dd„ }‡ fdd„}dd„ }d}x´|t | ƒk r¤| | }|dkr˜|d7 }|}x t| | ƒtkr>|d7 }q W t| ||d … ˆ ƒ}t| |d  |dƒ}| d |d … |g | |d d …  } |d }|d7 }qòW || dddgtƒ} || d tƒ} || d!tƒ} || d"tƒ} || d#gtƒ} || d$gtƒ} || d%gtƒ} d}xº|t | ƒk rÄ| | }|d&kr¸| |d  g}|}xF|d&kr„||| |d  g7 }|d7 }|t | ƒk r~| | }nP q@W t|ƒ}| d |d … |g | |d …  } |d }|d7 }qW d}xÂ|t | ƒk r| | }|d'krt| |d(gd	d
}n~|d(krÈ|dkr‚| |d  d)kr|tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d d …  } |d8 }nJt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }nº|d*kr‚|dkr‚| |d  d)kr8tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d+ d …  } nBt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qÎW || d)gtƒ} || d,tƒ} d}x@|t | ƒk rğ| | }|d-kr\t| |d.gƒ}| |d  }t| |d |… ˆ ƒ}t| |d/d	d
}t| |d |… ˆ ƒ}t|||ƒ}| d |d … |g | |d …  } d}nˆ|d'krä| |d  }t| |d(gƒ} t| |d | … ˆ d	d}!| | d  }"t| | d-gƒ}#|#d0krÄd }$n| |#d  }$t||!|"|$|ƒ}|S |d7 }q²W || d1gtƒ} || d2tƒ} || d3tƒ} d}xP|t | ƒd k 	rl| | d/k	rF| |= n|d7 }|t | ƒd k	r|	sP 	qW t | ƒdk	r | d0 d/k	r |	r˜| d0= nt| ƒS |	r®t| ƒS t | ƒdk	rÄ| d S t| ƒS )4Nr   rD   r	   ru   rI   z,:r3   )ú,rW   T)rp   r   )rW   rX   rY   rT   rW   rU   rX   )Úis_listrV   rY   )r0   r1   Úpassc             S   s  d}xø|t | ƒk rü| | }||kròt| |d  ƒtkrò|dkrº|dksZt| |d  ƒtkrò|dkrœ|| |d  |ƒ}| d |… |g | |d d …  } d}qò| d |… | |d d …  } n8|| |d  |ƒ}| d |… |g | |d d …  } d}|d7 }qW | S )Nr   r	   )r]   ú-r   rI   r\   )r   re   r   )rk   Úop_boxÚoperatorr   r    rm   r   r   r   Údeal_single_operatorã  s     ""z,parse_codeline.<locals>.deal_single_operatorc                sh   d}x^|t | ƒk rb| | }||krXt| |d d … ˆ ƒ}|||ƒ}| d |… |g } d}|d7 }qW | S )Nr   r	   r\   )r   rx   )rk   r   r   r   r    r…   rm   )r€   r   r   Údeal_single_operator_allö  s    
z0parse_codeline.<locals>.deal_single_operator_allc             S   s„   d}xz|t | ƒk r~| | }||krt|dkrt|| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qW | S )Nr   r	   rI   )r   )rk   r   r   r   r    rm   r   r   r   Údeal_operator  s    &z%parse_codeline.<locals>.deal_operatorz**ú~r   r]   )r   ú/ú%z//)r]   r   )z<<z>>ú&ú^ú|)z==z!=rR   rS   z>=z<=r*   r+   r5   r=   rJ   )r4   r6   r,   r.   rŠ   r\   rC   )r2   r?   )rE   rF   rG   )r   re   rh   ri   rw   rs   rx   ZLambdar   ro   r   r|   ÚSetZMarkZPassr†   ry   ÚDenyÚBoolÚTfÚAndOrZsub_if_elseZsub_for_loopZ	BacktrackZVar_declareÚTupler{   )%rk   r€   r‹   r   r    Zp2Ú	paramsboxr$   r!   rl   Z
return_objZ
lambda_objZobjecctrm   ZcontentÚ	deal_lineZ
elementboxÚkeyr…   ÚlÚvarr   r‘   r’   r   ZeneboxZelse_kZ	true_itemZ	event_objZend_kZ
false_itemZexpressZin_kÚvnamesÚbase_objÚif_kZif_objr   )r€   r   rx     sb   

  2
&
$

"
 &

"


"&
&


"(&
"

    rx   c       ;      C   s&  t |ƒ}d}t| ƒ}x
||k r | | }|d dkrd|d j}i }d}t|ƒ}	d}
xš||	k rğ|| }|dkr†||d  dkr†|}
n`t|ƒtkræ|
|j }td ƒ||< ||d  d	krâ|d }t||d
ƒ}t|||… |ƒ||< d}
|d7 }qXW t| |ƒ}t	| |d |… t
ƒ d}t||||ƒ}|j|_| d|¡ | ||d d |d d f¡ |d }n²|d dkrD|d j}|d dkr¬t|ddgƒ}t|d|… |ƒ}nd }t| |ƒ}t jd7  _|› dtj› }t	| |d |… t
d|› dƒd}t|||||ƒ}| d|¡ | ||d d |d d f¡ |d }nÒ|d dkr¾g }g }g }d}x:||k r| | }|d dkr|dks|d dkr0|d7 }| |d d |d d f¡ t|dd… |ƒ}t|ƒtkrìtdƒ}t| |ƒ}| |d |… }t	||ƒ}| |¡ | ||jf¡ |}nj|d dkr˜| |d d |d d f¡ t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ |}P nP qfW |d8 }| t||ƒ|¡ 
nX|d dkr¶t|dd… |ƒ}t|ƒtkrôtdƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k r~| | d dkr~|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }| t|||ƒ|d d |d d f¡ |d }	n`|d dkrg }d}xft|| ƒtksî|| dkr2t|| ƒtkr&t|| j|ƒ}| d|¡ | |¡ |d7 }qÎW t||d d… |ƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k rÔ| | d dkrÔ|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }t||||ƒ} | | |d d |d d f¡ |d }n|d dkrRdt_i }!dt|ƒ }}	xê||	k r"t|| ƒtkr|| j}"xF|d |	k r¦||d  dkr¦|"d||d  j› 7 }"|d7 }qbW d }#|d |	k rî||d  dkrî||d  j}#t|#|ƒ}|d7 }nt|" d¡d |ƒ}|#|!|"< | d|¡ |d7 }q:W t|!|ƒ}$| |$|d d |d d f¡ nÄ|d dkrºdt_g }%|d j}"d}t|ƒ}	xF|d |	k rÆ||d  dkrÆ|"d||d  j› 7 }"|d7 }q‚W |d7 }x¶||	k r†t|| ƒtkrb|| j}&|d |	k r4||d  dkr4|&||d  jf}'|d7 }n|&|&f}'|% |'¡ t|'d |ƒ}| d|¡ n|| d krz|% d!¡ |d7 }qÒW t|"|%||ƒ}(| |(|d d |d d f¡ n\|d d"kr,|d d |d d fg}t| |ƒ}t	| |d |… |ƒ}|j})| |¡ g }*|}xô||k 
r| | d d#k
r| | }| |d d |d d f¡ t|dd$ƒ}|| d%k	rª|d dk	ršt|d|… |ƒ}+n
td&|ƒ}+d }#n t|d|… |ƒ}+||d  j}#t| |ƒ}t	| |d |… |ƒ}|* |+|#|jf¡ | |¡ |}	qW ||k 
r„| | d dk
r„| | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j}| |¡ ng }|}||k r | | d d'kr | | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j},| |¡ ng },t |)|*||,|ƒ}-| |-|¡ |d }nê|d d(krFd}t||dd%gƒ}t|||… |ƒ}.t jd7  _td)tj› |ƒ}/| d|/¡ || dkrÚt||d%gƒ}0t||d |0… |ƒ}#t|#ƒtkrŞ| d|#¡ nd }#t| |ƒ}t	| |d |… |ƒ}| |¡ t!|.|/|#|j|ƒ}1| |1|d d |d d f¡ |d }nĞ|d d*krât|ddgd+d,}t|d|… |ƒ}|t|ƒk r¬|| dkr¬t||d d … |ƒ}2nt"dƒ}2t#||2ƒ}3| |3|d d |d d f¡ n4t|dd-d.gd/}4||4 }5g }6d}7x¢|4dkr¦t||7|4… |ƒ}8t|8ƒtt$fkr`xD|8D ] }t|ƒtkr:| d|¡ q:W nt|8ƒtkrz| d|8¡ |4d }7|6 |8¡ t||4d d	d.gd/}4qW t||7d … |ƒ}9t|6ƒdkrê| |9|d d |d d f¡ n,t%|6|9|5ƒ}:| |:|d d |d d f¡ |d7 }qW |S )0Nr   r	   r(   rI   rK   r   )r   z**)rT   rŠ   ru   z,))r€   Úfuncr/   rJ   rT   rW   r—   rS   rR   r,   r-   r\   r.   r)   r*   rŠ   r£   r;   rQ   r<   r:   r   )r   r   r@   rA   )r3   r<   r3   r   rB   r>   z
%with_obj_rH   T)rp   )ru   z+=z-=z*=z/=z%=z//=z**=z<<=z>>=z&=z^=z|=rD   )rq   )&ZInfor   rw   re   rh   ri   rs   rx   r‰   Úparse_blockÚ	NamespaceZDefÚlocalsZ
local_varsÚadd_infoÚwriteÚimporterÚclass_nZClassr   r   rd   Úupdaterj   ZIf_elseZWhilerv   ZFor_loopÚ	need_loadra   ÚImportÚFrom_ImportZ
Try_ExceptZWithr   ZAssertr{   ZMultiple_Mov);rj   r€   Úinfor‡   rˆ   rk   Z	func_namerŸ   r   r$   Zprer    Z
param_namer!   rl   ZpinfoZfDefZ	classnameZfatherZ	class_esprm   ZeventboxZelse_codelinesZorig_codelinesr¦   ZeventZblockZwhile_codelinesr¤   r£   r¥   Zfp_codelinesZfor_loopÚpackage_dictÚmodule_nameÚas_nameZ
import_objÚobject_namesZobject_nameÚdealZfrom_import_objZtry_codelinesZexcept_objectsZ	error_objZfinally_codelinesZ
try_exceptZcall_objZorig_as_nameÚq2Zwith_objÚmsgZ
assert_objZequalÚopZvariableboxÚsÚvarsÚtargetZmov_objr   r   r   r¨   ‡  s   



 

$ & 





 




("





 
" 


$
"
 


$









 
$

" r¨   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r²   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r   )rµ   r·   r€   Únow_infoÚ
orig_lines)Úselfrµ   r·   r€   r¿   r   r   r   Ú__init__Í  s
    zFrom_Import.__init__c             C   s   d| j › d| j› dS )Nz<From z import rR   )rµ   r·   )rÁ   r   r   r   Ú__str__Ó  s    zFrom_Import.__str__c             C   sŠ  t  | j¡}| d| j¡ |d dkrTdt|ƒ› }| j|i}t|| jƒ}| |¡ | d|d › d¡ | jdkr| j |¡ | d| jj	› ¡ d}d	}nd}d
}x¼| j
D ]²}|d dkr8t j|d  }	|	dkræt j|d  }
n|	j}
xr|
D ]@}| d|› |› d|› d|› d¡ t|| jƒ}| j d|¡ qòW q®| d|› |d › d|› d|d › ¡ q®W | jdkr|| d¡ n
| d¡ d S )Nr   r	   r   z&tem_import_zpush $importer["z"]zpush z<esp+1>.z<esp+2>z<esp+1>r   zbuilt-inzmov rZ   rQ   z    ;import *r£   z$mov esp "+" 2zinc esp)r­   Úget_pathrµ   r   rÀ   r   r±   r€   r¬   Úlocationr·   ÚinfosÚmodule_dictrª   rv   r¿   r«   )rÁ   ÚcodesZmodule_dataZtem_module_namer´   Z_importZmodule_spaceZispacer£   r³   rª   Z	local_varZvariabler   r   r   r¬   Õ  s:    



",zFrom_Import.writeN)Ú__name__Ú
__module__Ú__qualname__rÂ   rÃ   r¬   r   r   r   r   r²   Ì  s   r²   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r±   c             C   s   || _ || _d| _d S )N)r   r   )r´   r€   rÀ   )rÁ   r´   r€   r   r   r   rÂ   ÷  s    zImport.__init__c             C   s   d| j › dS )Nz	<Import: rR   )r´   )rÁ   r   r   r   rÃ   û  s    zImport.__str__c             C   s¾  | j dkr&| j  |¡ | j j› d}nd}|}xˆ| jD ]|}| j| }| d¡}x\tt|ƒƒD ]J}d |d |d … ¡}t 	|¡}	t|ƒ}
d|| › d|
› }|	d dkr:| 
d|› d|	d › d	¡ |d krö| 
d|› || › d
|› ¡ n8|t|ƒd kr$| 
d|› |› d
|› ¡ n
| 
d¡ |› d}qb|	d dkrtj 
|	d ¡ | 
d|› d|	d › d¡ | 
d|	d › d|› ¡ |d krÆ| 
d|› || › d
|› d|› || › ¡ n,|t|ƒd krò| 
d|› |› d
|› ¡ dtj|	d < |› d}qb|	d dkrbtj 
|	d ¡ | 
d¡ | 
d|	d › d|› ¡ |d kr„| 
d|› || › d
|› d|› || › ¡ n8|t|ƒd kr²| 
d|› |› d
|› ¡ n
| 
d¡ | |	d ¡ t|	d dtjd ¡ }t|ƒ}t|ƒ}x|jD ]}| |¡ qúW |tj|	d < | ¡  i }g }d}xB|jD ]8}||kr8| 
|¡ d|› d|› d||< |d7 }q8W d |¡}d|› d|› d|› d||
< dd„ }dd„ }|
d 7 }
xğtt|ƒ|
 ƒD ]Ü}||
|  }d|ksèd!|krò||ƒ}n||
|   d
¡}x†tt|ƒƒD ]v}|dks|| dkr2q|| d d"krHq|| d d#kr\P ||| ƒ\}}||kr|| | ||< qW d
 |¡||
| < qÄW |› d}qbW |}q8W d S )$Nr   rQ   r	   r–   Ú_r   zmov z $importer["z"]rZ   rŒ   rI   zmodule z "r   zmov $importer["z"] u	     ;å®šç¾©zbuilt-inr^   )ÚencodingrS   r]   rR   rŠ   z
namespace z" "c             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r   r	   r   )r   )r   rP   r   r$   r   r   r   Úget_name@  s    
zImport.write.<locals>.get_namec             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr   )r   r   r	   r   rZ   )r   r   )ÚlineÚboxr   r$   r!   r    r   r   r   Ú
parse_lineH  s"    
  z Import.write.<locals>.parse_linerJ   r   )r   r   ú;)r€   r¬   rÅ   r´   ra   r   r   r   r­   rÄ   r   ÚloadedrÆ   Ú
add_newtabÚopenrÍ   Úreadrg   r¨   rj   Ú
del_newtabrª   )rÁ   rÈ   Z
last_layerZ	tem_layerrµ   r¶   ZmboxÚmZdealnameZ	deal_datar!   Znamespace_stack_namer&   rj   r³   r   Zparams_dictrĞ   Zvar_kr£   Zvar_textrÎ   rÑ   r   rÏ   r¸   ÚjZbackr   r   r   r¬   ı  s    



 

.

.




 
zImport.writeN)rÉ   rÊ   rË   rÂ   rÃ   r¬   r   r   r   r   r±   ö  s   r±   c                 sÆ   ‡ fdd„‰ i } t tƒ d ddd ¡  d¡}x’|D ]Š}t|dd	d
d}|t|ƒk r4|| dkr4t||d d	d
d}||d |… }t||d dƒ}||kr¶ˆ ||d d … ƒ| |< q4i | |< q4W | S )Nc                sö   i }t | ƒ}d}xà||k rğx ||k r:| | dkr:|d7 }qW t| |ddd}| ||… }x ||k rx| | dkrx|d7 }qZW ||k rÀ| | dkrÀt| |d d	ƒ}ˆ | |d |… ƒ||< |d }q||ksÔ| | d
kræi ||< |d }qtdƒ‚qW |S )Nr   z, r	   z( ,T)rp   rZ   rT   rW   rŠ   Zunknow)r   rs   r   )rÏ   Z	line_dictr$   r   rl   rr   r¹   )r    r   r   r    m  s&    
  

zRead_ex_func.<locals>.deal_linez/apython/ex_func.pyr^   zutf-8)rÍ   r   r   z #T)rp   rZ   r	   r[   )rÕ   r   rÖ   ra   rs   r   )rÇ   Zex_func_contentrÏ   r!   r   rµ   rl   r   )r    r   ÚRead_ex_funcl  s    
rÚ   c               @   s.   e Zd Zdd„ Zdd„ Zdd„ Zdd	d
„ZdS )ÚImporterc             C   s   t ƒ | _|  ¡  d S )N)rÚ   rÇ   Úreset)rÁ   r   r   r   rÂ   Œ  s    zImporter.__init__c                s$   ‡ ‡fdd„‰|  d¡‰ ˆ| jdƒS )Nc                sÀ   |t ˆ ƒd kr¤d}xŠt| ƒD ]~}| › d|›  dd¡}t|ƒrt| d¡d dkrt|dkrt|d d… ˆ | krt|}qt|ƒrd	t|ƒkr|ˆ | kr|d
 }qW |S ˆ| › dˆ | › |d ƒS )Nr	   r   r”   r   rQ   r\   Úpyéıÿÿÿz__init__.pyz/__init__.py)r   r   Úreplacer   ra   r   )Z	nowfolderr   ÚfilepathÚfileZroad)ÚfboxÚ
get_moduler   r   rã     s    6 z)Importer.__get_module.<locals>.get_modulerQ   r   )ra   Úwork_folder)rÁ   rµ   r   )râ   rã   r   Z__get_module  s    
zImporter.__get_modulec             C   sb   || j kr(|| jkr|› dgS |› dgS |  |¡}|| jkrD|dgS |dkrV|› dgS |dgS d S )Nr   rI   r   r	   )rÇ   rÓ   Ú_Importer__get_module)rÁ   rµ   rà   r   r   r   rÄ     s    






zImporter.get_pathr   Úcp950c             C   sh   d| _ || _| dd¡ d¡d }||kr4tƒ | _n|d t|ƒ d … | _|| _g | _i | _	d| _
d S )Nr   r   r”   r\   r	   )r°   rÍ   rß   ra   r   rä   r   ZnowpathrÓ   rÆ   r®   )rÁ   ZpyfilerÍ   Zpy_file_namer   r   r   rÜ   ª  s    
zImporter.resetN)r   ræ   )rÉ   rÊ   rË   rÂ   rå   rÄ   rÜ   r   r   r   r   rÛ   ‹  s   rÛ   c               @   s:   e Zd Zddd„Zdd„ Zddd„Zdd
d„Zdd„ ZdS )ÚPackagerræ   c             C   s0   t ƒ | _|| _dg g| _t d| j¡ d| _d S )NTÚmoduler   )r   r&   rÍ   ÚREPL_boxr­   rÜ   Úadd_need_load)rÁ   rÍ   r   r   r   rÂ   ¹  s
    
zPackager.__init__c             C   sÀ   |  d¡d }| dd¡  d¡d }|d t|ƒ … }t|ƒdkrNt|ƒ |}d|krtt|dƒ ¡ }|  d¡| j_nHt|d| jd	 ¡ }| j |¡ t	 
|| j¡ d| _|  |¡ | j ¡  d S )
NrQ   r\   r   r”   r   Zecr^   r   )rÍ   )ra   rß   r   r   rÕ   rÖ   r&   rÍ   rÔ   r­   rÜ   rê   Ú	load_coder×   )rÁ   rà   ZftypeÚfilenamerä   r&   r   r   r   Úload¿  s    
zPackager.loadTc             C   sÖ   | j  d¡ |dkrLt| jd ƒdkr@d | jd ¡}|  |¡ dg g| _nvt|ƒ}|r´|d }|d dkrˆd| jd< | jd	  |¡ qÂ| jd s¤| jd	  |¡ qÂ| j|dd
 n| j|dd
 | j  ¡  | jd S )NÚREPLr   r	   r   r   T)r(   r/   r,   r)   r*   r@   r>   Fr\   )Úrepl)	r&   rÔ   r   ré   r   rë   rg   r   r×   )rÁ   ÚcmdÚone_liner&   rj   rk   r   r   r   rî   Ò  s$    



zPackager.REPLFc             C   sâ   t |ƒ}t|ƒ| _tjr4| jdkr4| j d¡ d| _t| jj	ƒdkrŞx| jj	D ]}| 
| j¡ qNW |rŞt| jj	d ƒtttttttttttttttttfkrŞt| jj	d ƒtksÂ| jj	d jdkrŞ| j d| jj	d j› ¡ d S )Nr   zmov $importer [dict]r	   r\   Úprintzrepl_print )rg   r¨   r³   r­   r°   rê   r&   r   r   rj   r¬   re   rd   rc   r   rf   rv   r~   r}   r{   r   r|   r™   rz   ry   rœ   r   rš   r›   rw   rÅ   )rÁ   r&   rï   rj   r   r   r   r   rë   é  s    
:&zPackager.load_codec             C   s    t |dƒ ¡ }| d¡| j_d S )Nr^   r   )rÕ   rÖ   ra   r&   )rÁ   Zec_filer&   r   r   r   Z__load_easy_codeõ  s    zPackager.__load_easy_codeN)ræ   )T)F)rÉ   rÊ   rË   rÂ   rí   rî   rë   Z_Packager__load_easy_coder   r   r   r   rç   ¸  s
   


rç   N)Fr   )F)Úosr   r   r   Úos.pathr   r   Zapython.coder   Zapython.modulerg   rs   r†   r‰   rx   r©   r¨   r²   r±   rÚ   rÛ   r­   rç   r   r   r   r   Ú<module>   s&    |
m

 {  G*v+2064*123*__init__.cpython-37.pycB
    >Kle8  ã               @   s*   d dl mZ d dlmZ G dd„ dƒZdS )é    )ÚPackager)ÚExecuterc               @   sJ   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zddd„Zdd„ Zddd„Z	d
S )ÚApythonúutf-8c             C   s$   t |ƒ| _| jj| _t| jƒ| _d S )N)r   ÚpackagerÚcoder   Úexecuter)ÚselfÚencoding© r   ú0C:\Users\allen\Desktop\py\py\apython\__init__.pyÚ__init__   s    

zApython.__init__c             C   s   | j j}| ¡  d S )N)r   r   Zdisplay)r	   r   r   r   r   Úparse   s    zApython.parsec             C   s2   d  | jj¡}t|dƒ |¡ td|› dƒ d S )NÚ
Úwz[92mApython:save z[0m)Újoinr   ÚopenÚwriteÚprint)r	   Úfilepathr   r   r   r   Úsave   s    zApython.savec             C   s   | j  |¡ d S )N)r   Úload)r	   r   r   r   r   r      s    zApython.loadNc             C   sÊ   d}t | jjƒ}d}x°y|d kr*t|ƒ}n|}W n2 tk
rN   tdƒ wY n tk
rb   P Y nX y| j |¡}W n   d}|d krŠP wY nX |r´| j 	|¡}t | jjƒ}d}nd}|d krP qW |S )Nz>>>Ú z
KeyboardInterruptzCompile Errorz...)
Úlenr   ÚinputÚKeyboardInterruptr   ÚEOFErrorr   ÚREPLr   ÚREPL_run)r	   Zone_line_cmdÚhintÚprocessÚprint_resultÚcmdZneed_executer   r   r   r      s8    
  zApython.REPLc             C   s,   t | jjƒ}| jj|dd | j |¡}|S )NF)Zone_line)r   r   r   r   r   r   )r	   Z
code_blockr    r!   r   r   r   Úinteraactive.   s    zApython.interaactiver   é   c             C   s   | j  ||¡ d S )N)r   Úrun)r	   ZtfÚ
stack_sizer   r   r   r%   3   s    zApython.run)r   )N)r   r$   )
Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r#   r%   r   r   r   r   r      s   

r   N)Zapython.packager   Zapython.executerr   r   r   r   r   r   Ú<module>   s   368*122*è®Šæ•¸å‘½åè¦å‰‡.txt$name            ç³»çµ±è®Šæ•¸ï¼Œéç³»çµ±åƒæ•¸ä¸å¯ä½¿ç”¨
&name_len(code)  æš«æ™‚è®Šæ•¸ï¼Œç†è«–ä¸Šå› ç‚ºipä¸é‡è¤‡ï¼Œæ‰€ä»¥ä¸é‡è¤‡ï¼Œä¸å¯ç”¨æ–¼å †ç–Šè®Šæ•¸ï¼Œåªèƒ½ç”¨æ–¼å®£å‘ŠæŸç‰©ä»¶æ™‚
%name_id         ä¸å…·ååƒæ•¸ï¼Œidç‚ºimporterçš„è®Šå‹•id
name^id          classåƒæ•¸ï¼Œç•¶namepaceç‚ºæ­¤æ™‚ï¼Œä»£è¡¨æ­¤ç‰©ä»¶åœ¨classä¹‹ä¸­496*17*main.pyfrom apython import Apython
from sys import argv
from os.path import isfile
apython=Apython()
cmd=argv
hint='''
+any python file to execute
-o filename    =>save as filename
'''
if len(argv)==1:
    print('This is Apython')
    print(hint)
    apython.REPL()
else:
    if isfile(argv[1]):
        apython.load(argv[1])
        if len(argv)>=4 and argv[2]=='-o':
            apython.save(argv[3])
        apython.run()
    else:
        print(f'"{argv[1]}" not exist')24613*09*test_data569*16*del.pyb=[4]
a=[[1],[2],[3],b]
print(a)
del a[-1]
print(a)
#print(b)
def abc():
    x=1
    y=2
    def rew():
        print(x+y)
    return rew
a=abc()
a()
class ABC:
    def __init__(self):
        self.a=5
        self.k=0
    def k(self):
        print('100')
abc=ABC()
print(abc.k)
print(abc.a)
del abc.k
print(abc.k)
a=list(range(10))
print(a[3:])
print(a[3::])
print(a[:5:])
print(a[:8:-1])
del a[2:5]
print(a[::-1])
a+=['hello','world!']+a[::-2]
for i in range(3):
    del a[-1]
print(a)
b='hello'
print(b)
del b
print(b)557*111*function.pydef func1(a,b,c):
    w=a+b
    z=a+c
    d=a*b-c
    return w*z*d
def func2(q,w,e):
    s=q-w**e
    return s
print(func1(3,6,7))
print(func1(func2(2,3,4),6,7))
class ABC:
    def __init__(self):
        print('init')
        self.k=0
    def func(self,a,b):
        print('func')
        return 100*a*b
    def __str__(self):
        return 'this is abc'
    def __add__(self, other):
        self.k+=other
        print(f'now self.k is {self.k}')
        return self
abc=ABC()
c=abc.func(2,3)+50
print(c,str(abc+5))1408*19*glocal.pya=None
def test():
    a=100
    def test2():
        nonlocal a
        a=200
        print('test2:a=', a)
       # $stop
       # $stop
        def test3():
            nonlocal a
            a=300
            def test5():
                nonlocal a
                a+=30
                print('test5:a=',a)
            test5()
            print('test3:a=',a)
            return test5
        def test4():
           # $stop
            global a
            global he_plus
            #$stop
           # $stop
            class ABC:
                def __init__(self,orig,nnn):
                    self.k=orig**nnn
                def __add__(self, other):
                    new=ABC(2,3)
                    new.k=self.k+other.k
                    return new
                def __str__(self):
                    return f'{self.k}'
            he_plus=ABC(4,5)
            a=400
          #  $stop
            return ABC(6,7)
        print('test2:a=', a)
        ss=test3()
        print('test2:a=', a)
        nonlocal he2
        print('test2:a=', a)
        he2=test4()
      #  $stop
#        $stop
      #  $stop
        print('test2:a=',a)
        ss()
        ss()
    #$stop
    he2=0
    test2()
    #$stop
    print('test:a=',a)
    global fff
   # $stop
    fff=he2+he_plus
test()
#$stop
print('å…¨åŸŸa=',a)
print(fff)399*19*import.pyfrom import2 import Apple,b,test_function,q
#import test2
a=Apple()
print(a.func1(20))
d=b.func1(5)
c=b
print(c.k*d)
#print(test_function(q))
import okg.pk2.sss
print(okg)
print(okg.pk2)
print(okg.pk2.sss)
print(b)
print(c)
d=not b
#print(not b)
#assert 1==2 or 1==3 or c is not b,'123'+'456'
asd=okg.ABC()
print(okg.pk2.sss.repeat_func(asd.asd))
print(asd.func('he+'))436*110*import2.pyimport import3
from import3 import *
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(a.k)
#223*110*import3.pyimport import2
q='this is test'
from mix import *
def test_function(string):
    for i in string:
        print(i)
    print(string)
    print(test2.test3.q)
print('answer:--------------------',s,a,b,y)910*114*inheritance.py#from random import random
class AAA:
    print('sound good')
    def __init__(self):
        self.k=10
        print('my k is ',self.k)
    def func(self):
        self.k+=100
        return self.k
    print('he+')
    ccc=3000
class BBB(AAA):
    print('my first')
    def __init__(self):
        self.k=200
        print('my k is ',self.k)
    def func(self):
        self.k+=2000
        return self.k
    print('zzz')
b=BBB()
print(b.func())
print(b.ccc)
class A2:
    print('A2')
    def func(self):
        return 2
class A1:
    print('A1')
    def func(self):
        return 1
class A3:
    print('A3')
    def func(self):
        return 3
box=[A1,A2,A3]
class BB(A3,A2,A1):
    def __init__(self):
        print('start')
for i in range(10):
    a=BB()
    print(a.func())
def p1():
    print('p1')
def p2():
    print('p2')
a=[p2(),p1()]637*110*keyword.pyimport keyword2
from keyword3 import *
def abc(x,y,*args,**kwargs):
    print(x)
    print(y)
    for i in args:
        print(i,end=' ')
    print(kwargs['ed'])
dfg={'ed':200,'su':400}
abc(1,2,3,2,3,4,5,6,r=100,**dfg)
def allen_func(function,*args, **kwargs):
    a=function(*args,**kwargs)
    print(a)
for i in range(3):
    allen_func(print,'hello',' he+ ',123456,'',end=' \n\n')
alen=allen_func(len,[1,2,3,4,5])
print(alen)
qq=allen_func('hey he+'.replace,'h','H')
allen_func(print,allen_func('this is easy '.split,' '),qq,end='\nthis is end')
keyword2.sleep(1)
allen_func(keyword2.keyword3.listdir)570*111*keyword2.pyfrom time import *
import keyword3
import os.path
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(f'now time is {round(time(),2)} and a.k=',a.k)
#
print(f'new.txt is '+('file' if os.path.isfile('new.txt') else 'not file'))123*111*keyword3.pyfrom os import listdir
def test_function(string):
    for i in string:
        print(i)
    print(string)696*17*loop.pybox=[]
for i in range(10):
    box.append(i**2-i)
    for j in range(10):
        box.append(i*j)
s=sum(box)%30
k=[]
hintbox=[]
while s>0:
    k.append((s,s**2))
    s-=1
    if s>10:
        hintbox+=['>10']
    elif s==10:
        hintbox+=['==10']
    else:
        hintbox+=['<10']
sss=[i+j for i,j in k]
print(sss)
c=(i for i in range(10))
for i in range(10):
    print(next(c))
print(hintbox)
def func_loop(a,b):
    def sub_func(a,b,x):
        for i in range(10):
            yield i**a+b/(abs(x)+12)
    xbox=sub_func(a+b,a*b*1234,a-b)
    for i in range(10):
        yield next(xbox)
func=func_loop(2,5)
for i in range(10):
    print(next(func))2552*16*mix.pyb=lambda x,y:x**2+y*3-5
s=b(5,7)
print(s)
c=lambda x:[i for i in range(x) if i%2==0]
d=lambda x,y:((yield x+y+i) for i in range(10) if i%3==1)
g=d(2,3)
#a=c(10)
try:
    for i in c(100):
        print(next(g),end=' ')
except:
    print(c(10))
    def abc(x,y):
        def p():
            for i in range(10):
                yield (x+y+i)
        return p()
    class YYY:
        a=(lambda self,x,y,z:x+y**z)(0,3,5,7)
        b=lambda self,w,e:(lambda q,w,e:q*w+e-7)(w,e,10)
        def __init__(self,x,y):
            self.value=self.b(x,y)
        def __str__(self):
            return str(self.value)
        def func(self,func):
            func()
    #with c(10) as ce:
     #   print('happy')
finally:
    def this_is_mix_try():
        class test:
            def __init__(self):
                print('__init__')
            def __enter__(self):
                print('__enter__')
                return YYY(10,20)
            def __exit__(self, exc_type, exc_val, exc_tb):
                print('__exit__')
        with test() as T:
            k=0
            while k<2:
                with test():
                    print('inside test')
                    def lock():
                        for i in range(10):
                            yield k**3+T.value
                    lo=lock()
                    print('yield:',next(lo))
                k+=1
                if T.value>10:
                    print(f'T is bigger:{T.value}')
                elif s<30:
                    print('s is small')
                print(T.value,s)
            else:
                print('this is else leave')
    sss=this_is_mix_try
    for i in range(20):
        try:
            a=abc(2,3)
            for i in range(10):
                print(next(a)*i,end=' ')
            y=YYY(3,6)
            y.func(sss)
            print(y,end=' ')
            if i>3:
                i+=5
                break
        except:
            print('a except occur')
        finally:
            print(i,end=' ')
            if i>8:
                break

a=[1,2,3]
b=list(map(str,a))
print(b)
a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
class YYY:
    a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
    b = lambda self, w, e: (lambda q, w, e: q * w + e - 7)(w, e, 10)
    def __init__(self, x, y):
        self.value = self.b(x, y)*1000+self.a
        #print(self.value)
    def __str__(self):
        return str(self.value)
y=YYY(3,6)

print(y)4564*03*okg183*16*pk1.pya=100
b=200
c=300
from okg.pk2 import *
def gen(x,y):
    try:
        for i in range(10):
            yield i+x*y
        x+=2
    finally:
        print('gen end')2543*03*pk2309*16*sss.pya1=100
b2=200
c3=300
def repeat_func(func):
    for i in range(5):
        func()
class Guava:
    def __init__(self,l):
        print('this is Guava')
        self.k=100*l
    def print(self):
        print(self.k)
    def __add__(self, other):
        self.k+=other
        return self400*111*__init__.pyimport okg.pk2.sss
fg='this is good'
#LO=okg.pk2.sss.repeat_func
#bbb=okg.pk2.sss.a1
class OKK:
    def __init__(self):
        print('this is init')
    def __enter__(self):
        print('enter')
        self.tem=okg.pk2.sss.Guava(3.5)
        return self.tem
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
        print('my tem is ',self.tem.k)1813*011*__pycache__909*118*sss.cpython-37.pycB
    cOe-  ã               @   s&   d Z dZdZdd„ ZG dd„ dƒZdS )éd   éÈ   i,  c             C   s   xt dƒD ]
}| ƒ  q
W d S )Né   )Úrange)ÚfuncÚi© r   ú5C:\Users\allen\Desktop\py\py\test_data\okg\pk2\sss.pyÚrepeat_func   s    r	   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚGuavac             C   s   t dƒ d| | _d S )Nzthis is Guavar   )ÚprintÚk)ÚselfÚlr   r   r   Ú__init__   s    zGuava.__init__c             C   s   t | jƒ d S )N)r   r   )r   r   r   r   r      s    zGuava.printc             C   s   |  j |7  _ | S )N)r   )r   Úotherr   r   r   Ú__add__   s    zGuava.__add__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r
      s   r
   N)Za1Zb2Zc3r	   r
   r   r   r   r   Ú<module>   s   880*123*__init__.cpython-37.pycB
    cOe‚  ã               @   s   d dl ZdZG dd„ dƒZdS )é    Nzthis is goodc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOKKc             C   s   t dƒ d S )Nzthis is init)Úprint)Úself© r   ú:C:\Users\allen\Desktop\py\py\test_data\okg\pk2\__init__.pyÚ__init__   s    zOKK.__init__c             C   s   t dƒ tjj d¡| _| jS )NZenterg      @)r   ÚokgÚpk2ÚsssZGuavaÚtem)r   r   r   r   Ú	__enter__   s    zOKK.__enter__c             C   s   t dƒ t d| jjƒ d S )NÚexitz
my tem is )r   r   Úk)r   Úexc_typeZexc_valZexc_tbr   r   r   Ú__exit__   s    zOKK.__exit__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   )Úokg.pk2.sssr   Zfgr   r   r   r   r   Ú<module>   s   403*111*__init__.pyimport okg
import okg.pk1
a=100
a*=okg.pk1.a
from okg.pk1 import *
class ABC:
    def __init__(self):
        self.test='hello'
    def asd(self):
        self.test+='_asd'
    def func(self,rp):
        print(f'{rp} {self.test}')
print('okg')
print(a+b+c)
s=gen(3,5)
for i in range(5):
    print(next(s))
with OKK() as ok:
    for i in range(3):
        ok+=next(s)

1408*011*__pycache__417*118*pk1.cpython-37.pycB
    cOe¯   ã               @   s    d Z dZdZddlT dd„ ZdS )éd   éÈ   i,  é    )Ú*c             c   s<   z,xt dƒD ]}|| |  V  qW | d7 } W d tdƒ X d S )Né
   é   zgen end)ÚrangeÚprint)ÚxÚyÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\okg\pk1.pyÚgen   s
    r   N)ÚaÚbÚcZokg.pk2r   r   r   r   r   Ú<module>   s   967*123*__init__.cpython-37.pycB
    cOe…  ã            	   @   sª   d dl Z d dlZ dZee jj9 Zd dlT G dd„ dƒZedƒ eee e ƒ eddƒZ	xe
dƒD ]Zeee	ƒƒ qbW eƒ $Zxe
dƒD ]Zeee	ƒ7 ZqˆW W dQ R X dS )	é    Néd   )Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚABCc             C   s
   d| _ d S )NZhello)Útest)Úself© r   ú6C:\Users\allen\Desktop\py\py\test_data\okg\__init__.pyÚ__init__   s    zABC.__init__c             C   s   |  j d7  _ d S )NZ_asd)r   )r   r   r   r   Úasd	   s    zABC.asdc             C   s   t |› d| j› ƒ d S )Nú )Úprintr   )r   Zrpr   r   r   Úfunc   s    zABC.funcN)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r   r      s   r   Úokgé   é   )r   Zokg.pk1ÚaZpk1r   r   ÚbÚcÚgenÚsÚrangeÚiÚnextZOKKZokr   r   r   r   Ú<module>   s   
252*17*oper.py#'''
#é€™è£¡æ”¾ç½®åŸºæœ¬é‹ç®—
#'''
a=12
b=23
c=a+b
d=c-b
e=a*b
f=a/b
g=a**b
h=c%d
i=c//d
j=e>>d
k=e<<d
l=int(f)&g
m=l^g
n=l|g
answer=[c,d,e,f,g,h,i,j,k,l,m,n]
print(answer)
o=a*b-c+d//e-(a+b/3+120-g)*d
print(sum(answer)*o)722*19*string.pyeasy='hello world'
print(easy)
easy2="hello he+"
print(easy2)
string1='\'""\"sa\\\''
print(string1)
r_string1=r'\'""\"sa\\\''
print(r_string1)
string2="\'123\n\'\\\"\'''"
print(string2)
r_string2=r"\'123\n\'\\\"\'''"
print(r_string2)
string3=f'abc\'{{"12\'3"}}12{345}}}\"\''
print(string3)
r_string3=r'abc\'{{"12\'3"}}12{345}}}\"\''
print(r_string3)
n_string3='abc\'{{"12\'3"}}12{345}}}\"\''
print(n_string3)
x=f'12{"hello"}}}{{\'\""\'"}}'.join(['"',"'"])
y='"\''
print(x)
print(y)
class ABC:
    def __init__(self,a):
        print(f'this is \' self. {a} \' init ! ')
        self.k=0
    def func(self):
        print(f'this is \'self.{self.k}\' init ! ')
abc=ABC(10)
abc.func()
2011*16*try.py
a=100
b='200'

try:
    print('try')
    c=a+b
except NameError:
    print('name error')
except ValueError:
    print('value error')
except Exception as e:
    print('except is ',e)
else:
    print('else')
finally:
    print('fist try end')
class NEW:
    def __init__(self):
        print('new init')
        class new:
            def __init__(self):
                self.value=10
            def __getitem__(self, item):
                return self.value*item
            def __setitem__(self, key, value):
                self.value+=key+value
        self.sss=new()
    def __add__(self, other):
       # print('my sss:', self.sss.value)
       # print('other sss:', other.sss.value)
        self.sss.value+=other.sss.value
       # print('my sss:',self.sss.value)
        return self
    def __setitem__(self, key, value):
        self.sss[key]=value
    def __getitem__(self, item):
        return self.sss[item]
    def __del__(self):
        print('with value:',self.sss.value,' be destroy')
    def yield_loop(self):
        try:
            for i in range(10):
                self.sss[i]=i**2
                yield self.sss[10]
        finally:
            print('loop end with:',self.sss.value)
class DEF:
    def Class(self,a,b):
        self.a=a
        self.b=b
        print('this is class test')
    def __init__(this,a,b):
        this.Class(b,a)
        print('__init__')
        this.k=10
        this.abc=100
        this.random=300
    def __enter__(self):
        print('enter!')
        self.k+=20
        new=NEW()
        new.sss[self.a]=self.b
        return new
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
with DEF(10,20) as rew:
    new=NEW()
    print(rew.sss.value)
    print(new.sss.value)
  #  $stop
    rew+=new
    print(rew.sss.value)
    print('happy')
print(rew.sss[100])
x=rew.yield_loop()
y=new.yield_loop()
for i in range(10):
    print(next(x)*next(y))7883*011*__pycache__1081*122*import2.cpython-37.pycB
    ñ^Oe§  ã               @   sP   d dl Z d dl T G dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zeejƒ dS )é    N)Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú1C:\Users\allen\Desktop\py\py\test_data\import2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__	   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   )Zimport3r   r   Úbr   Úar   r   r   r   r   Ú<module>   s   
470*122*import3.cpython-37.pycB
    aeOeÒ   ã               @   s0   d dl Z dZd dlT dd„ Zedeeeeƒ dS )é    Nzthis is test)Ú*c             C   s.   x| D ]}t |ƒ qW t | ƒ t tjjƒ d S )N)ÚprintZtest2Ztest3Úq)ÚstringÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\import3.pyÚtest_function   s    
r	   zanswer:--------------------)	Úimport2r   Zmixr	   r   ÚsÚaÚbÚyr   r   r   r   Ú<module>   s   1250*123*keyword2.cpython-37.pycB
    ”ÑPe,  ã               @   s†   d dl T d dlZd dlZG dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zede	e ƒ dƒ› d	ej
ƒ ed
ej d¡rzdnd ƒ dS )é    )Ú*Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__
   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   znow time is é   z	 and a.k=znew.txt is znew.txtÚfileznot file)ZtimeÚkeyword3Zos.pathÚosr   r   Úbr   ÚaÚroundr   ÚpathÚisfiler   r   r   r   Ú<module>   s   
347*123*keyword3.cpython-37.pycB
    ŞĞPem   ã               @   s   d dl mZ dd„ ZdS )é    )Úlistdirc             C   s"   x| D ]}t |ƒ qW t | ƒ d S )N)Úprint)ÚstringÚi© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword3.pyÚtest_function   s    
r   N)Úosr   r   r   r   r   r   Ú<module>   s   4693*118*mix.cpython-37.pycB
    *ØGeğ	  ã               @   s¤  d d„ Z e ddƒZeeƒ dd„ Zdd„ ZeddƒZzZy&x edƒD ]Zeeeƒd	d
 qBW W n.   eedƒƒ dd„ ZG dd„ dƒZ	Y nX W ddd„ Z
e
Zx®edƒD ]¢Zz‚yheddƒZx$edƒD ]Zeeeƒe d	d
 qÂW e	ddƒZe e¡ eed	d
 edkred7 ZP W n   edƒ Y nX W deed	d
 edkrFP X q¦W X dddgZeeeeƒƒZ ee ƒ dd„ ddddƒZG dd„ dƒZ	e	ddƒZeeƒ dS )c             C   s   | d |d  d S )Né   é   é   © )ÚxÚyr   r   ú-C:\Users\allen\Desktop\py\py\test_data\mix.pyÚ<lambda>   ó    r   r   é   c             C   s   dd„ t | ƒD ƒS )Nc             S   s   g | ]}|d  dkr|‘qS )r   é    r   )Ú.0Úir   r   r   ú
<listcomp>   s    z<lambda>.<locals>.<listcomp>)Úrange)r   r   r   r   r      r	   c                s   ‡ ‡fdd„t dƒD ƒS )Nc             3   s(   | ] }|d  dkrˆ ˆ | V V  qdS )r   é   Nr   )r   r   )r   r   r   r   ú	<genexpr>   s    z<lambda>.<locals>.<genexpr>é
   )r   )r   r   r   )r   r   r   r      r	   r   r   éd   ú )Úendr   c                s   ‡ ‡fdd„}|ƒ S )Nc              3   s$   xt dƒD ]} ˆ ˆ |  V  q
W d S )Nr   )r   )r   )r   r   r   r   Úp   s    zabc.<locals>.pr   )r   r   r   r   )r   r   r   Úabc   s    r   c               @   s>   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ Zdd„ ZdS )ÚYYYc             C   s   |||  S )Nr   )Úselfr   r   Úzr   r   r   r      r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )ÚqÚwÚer   r   r   r      r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r      r	   c             C   s   |   ||¡| _d S )N)ÚbÚvalue)r   r   r   r   r   r   Ú__init__   s    zYYY.__init__c             C   s
   t | jƒS )N)Ústrr   )r   r   r   r   Ú__str__   s    zYYY.__str__c             C   s
   |ƒ  d S )Nr   )r   Úfuncr   r   r   r#      s    zYYY.funcN)Ú__name__Ú
__module__Ú__qualname__Úar   r    r"   r#   r   r   r   r   r      s
   r   Nc           
      sº   G dd„ dƒ} | ƒ œ‰ d‰xˆdk r¢| ƒ 0 t dƒ ‡ ‡fdd„}|ƒ }t dt|ƒƒ W d Q R X ˆd	7 ‰ˆ jd
kr„t dˆ j› ƒ ntdk r”t dƒ t ˆ jtƒ qW t dƒ W d Q R X d S )Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )zthis_is_mix_try.<locals>.testc             S   s   t dƒ d S )Nr    )Úprint)r   r   r   r   r        s    z&this_is_mix_try.<locals>.test.__init__c             S   s   t dƒ tddƒS )NÚ	__enter__r   é   )r(   r   )r   r   r   r   r)   "   s    z'this_is_mix_try.<locals>.test.__enter__c             S   s   t dƒ d S )NÚ__exit__)r(   )r   Úexc_typeZexc_valZexc_tbr   r   r   r+   %   s    z&this_is_mix_try.<locals>.test.__exit__N)r$   r%   r&   r    r)   r+   r   r   r   r   Útest   s   r-   r   r   zinside testc              3   s&   x t dƒD ]} ˆd ˆ j V  q
W d S )Nr   r   )r   r   )r   )ÚTÚkr   r   Úlock,   s    zthis_is_mix_try.<locals>.lockzyield:r   r   zT is bigger:é   z
s is smallzthis is else leave)r(   Únextr   Ús)r-   r0   Zlor   )r.   r/   r   Úthis_is_mix_try   s     

r4   r*   é   za except occuré   r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   O   r	   r   c               @   s6   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ ZdS )r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   Q   r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )r   r   r   r   r   r   r   R   r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r   R   r	   c             C   s   |   ||¡d | j | _d S )Niè  )r   r'   r   )r   r   r   r   r   r   r    S   s    zYYY.__init__c             C   s
   t | jƒS )N)r!   r   )r   r   r   r   r"   V   s    zYYY.__str__N)r$   r%   r&   r'   r   r    r"   r   r   r   r   r   P   s   )r   r3   r(   ÚcÚdÚgr   r2   r   r   r4   Ússsr   r'   r   r#   ÚlistÚmapr!   r   r   r   r   Ú<module>   sJ   









2417451*07*backup2377749*07*apython14320*111*built_in.py#encoding='utf-8'
from apython.ex_func import *
class bcolors:
    OK = "[92m"  # GREEN
    WARNING = "[93m"  # YELLOW
    FAIL = "[91m"  # RED
    RESET = "[0m"  # RESET COLOR
def built_in_operator(obj,op):
    stype = str(type(obj))
    if stype=="<class 'str'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='format':return obj.format
        elif op=='encode':return obj.encode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='casefold':return obj.casefold
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='format_map':return obj.format_map
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdecimal':return obj.isdecimal
        elif op=='isdigit':return obj.isdigit
        elif op=='isidentifier':return obj.isidentifier
        elif op=='islower':return obj.islower
        elif op=='isnumeric':return obj.isnumeric
        elif op=='isprintable':return obj.isprintable
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'list'>":
        if op=='append':return obj.append
        elif op=='pop':return obj.pop
        elif op=='count':return obj.count
        elif op=='remove':return obj.remove
        elif op=='insert':return obj.insert
        elif op=='clear':return obj.clear
        elif op=='copy':return obj.copy
        elif op=='index':return obj.index
        elif op=='extend':return obj.extend
        elif op=='reverse':return obj.reverse
        elif op=='sort':return obj.sort
    elif stype=="<class 'tuple'>":
        if op=='index':return obj.index
        elif op=='count':return obj.count
    elif stype=="<class 'dict'>":
        if op=='pop':return obj.pop
        elif op=='get':return obj.get
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='keys':return obj.keys
        elif op=='fromkeys':return obj.fromkeys
        elif op=='items':return obj.items
        elif op=='popitem':return obj.popitem
        elif op=='setdefault':return obj.setdefault
        elif op=='values':return obj.values
    elif stype=="<class 'bytes'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='decode':return obj.decode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdigit':return obj.isdigit
        elif op=='islower':return obj.islower
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'set'>":
        if op=='pop':return obj.pop
        elif op=='add':return obj.add
        elif op=='remove':return obj.remove
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='difference':return obj.difference
        elif op=='difference_update':return obj.difference_update
        elif op=='discard':return obj.discard
        elif op=='intersection':return obj.intersection
        elif op=='intersection_update':return obj.intersection_update
        elif op=='isdisjoint':return obj.isdisjoint
        elif op=='issubset':return obj.issubset
        elif op=='issuperset':return obj.issuperset
        elif op=='symmetric_difference':return obj.symmetric_difference
        elif op=='symmetric_difference_update':return obj.symmetric_difference_update
        elif op=='union':return obj.union
    elif stype=="<class '_io.TextIOWrapper'>":
        if op=='write':return obj.write
        elif op=='tell':return obj.tell
        elif op=='read':return obj.read
        elif op=='close':return obj.close
        elif op=='seek':return obj.seek
        elif op=='fileno':return obj.fileno
        elif op=='flush':return obj.flush
        elif op=='isatty':return obj.isatty
        elif op=='readable':return obj.readable
        elif op=='readline':return obj.readline
        elif op=='readlines':return obj.readlines
        elif op=='seekable':return obj.seekable
        elif op=='truncate':return obj.truncate
        elif op=='writable':return obj.writable
        elif op=='writelines':return obj.writelines
        elif op=='__enter__':return obj.__enter__
        elif op=='__exit__':return obj.__exit__
    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>
        module_name=obj.module_name
        if module_name=="time":
            if op=='time':return time.time
            elif op=='sleep':return time.sleep
            elif op=='ctime':return time.ctime
            elif op=='localtime':return time.localtime
            elif op=='gmtime':return time.gmtime
            elif op=='mktime':return time.mktime
            elif op=='asctime':return time.asctime
            elif op=='strftime':return time.strftime
            elif op=='strptime':return time.strptime
        elif module_name=="math":
            if op=='pi':return math.pi
            elif op=='e':return math.e
            elif op=='ceil':return math.ceil
            elif op=='floor':return math.floor
            elif op=='copysign':return math.copysign
            elif op=='fabs':return math.fabs
            elif op=='fmod':return math.fmod
            elif op=='fsum':return math.fsum
            elif op=='gcd':return math.gcd
            elif op=='pow':return math.pow
            elif op=='sqrt':return math.sqrt
            elif op=='factorial':return math.factorial
            elif op=='degrees':return math.degrees
            elif op=='radians':return math.radians
            elif op=='sin':return math.sin
            elif op=='cos':return math.cos
            elif op=='tan':return math.tan
            elif op=='asin':return math.asin
            elif op=='acos':return math.acos
            elif op=='atan':return math.atan
            elif op=='exp':return math.exp
            elif op=='log':return math.log
            elif op=='log1p':return math.log1p
            elif op=='log2':return math.log2
            elif op=='log10':return math.log10
            elif op=='isclose':return math.isclose
            elif op=='isfinite':return math.isfinite
            elif op=='isinf':return math.isinf
            elif op=='isnan':return math.isnan
        elif module_name=="os":
            if op=='getcwd':return os.getcwd
            elif op=='listdir':return os.listdir
            elif op=='mkdir':return os.mkdir
            elif op=='chdir':return os.chdir
            elif op=='rmdir':return os.rmdir
            elif op=='open':return os.open
            elif op=='write':return os.write
            elif op=='rename':return os.rename
            elif op=='remove':return os.remove
            elif op=='stat':return os.stat
            elif op=='close':return os.close
            elif op=='path':return os.path
            elif op=='system':return os.system
            elif op=='walk':return os.walk
            elif op=='environ':return os.environ
            elif op=='_exit':return os._exit
        elif module_name=="os.path":
            if op=='isdir':return os.path.isdir
            elif op=='isfile':return os.path.isfile
            elif op=='abspath':return os.path.abspath
            elif op=='basename':return os.path.basename
            elif op=='dirname':return os.path.dirname
            elif op=='exists':return os.path.exists
            elif op=='getatime':return os.path.getatime
            elif op=='getmtime':return os.path.getmtime
            elif op=='getctime':return os.path.getctime
            elif op=='getsize':return os.path.getsize
            elif op=='isabs':return os.path.isabs
            elif op=='join':return os.path.join
            elif op=='realpath':return os.path.realpath
            elif op=='relpath':return os.path.relpath
            elif op=='samefile':return os.path.samefile
            elif op=='sameopenfile':return os.path.sameopenfile
            elif op=='samestat':return os.path.samestat
            elif op=='split':return os.path.split
            elif op=='splitext':return os.path.splitext
        elif module_name=="sys":
            if op=='argv':return sys.argv
            elif op=='platform':return sys.platform
            elif op=='version_info':return sys.version_info
            elif op=='path':return sys.path
            elif op=='stdin':return sys.stdin
            elif op=='stdout':return sys.stdout
            elif op=='stderr':return sys.stderr
            elif op=='displayhook':return sys.displayhook
            elif op=='exceptionhook':return sys.exceptionhook
            elif op=='setrecursionlimit':return sys.setrecursionlimit
            elif op=='setswitchinterval':return sys.setswitchinterval
            elif op=='settrace':return sys.settrace
            elif op=='setprofile':return sys.setprofile
        elif module_name=="random":
            if op=='seed':return random.seed
            elif op=='getstate':return random.getstate
            elif op=='setstate':return random.setstate
            elif op=='getrandbits':return random.getrandbits
            elif op=='randrange':return random.randrange
            elif op=='randint':return random.randint
            elif op=='choice':return random.choice
            elif op=='choices':return random.choices
            elif op=='shuffle':return random.shuffle
            elif op=='sample':return random.sample
            elif op=='random':return random.random
            elif op=='uniform':return random.uniform
            elif op=='triangular':return random.triangular
            elif op=='betavariate':return random.betavariate
            elif op=='expovariate':return random.expovariate
            elif op=='gammavariate':return random.gammavariate
            elif op=='gauss':return random.gauss
            elif op=='lognormvariate':return random.lognormvariate
            elif op=='normalvariate':return random.normalvariate
            elif op=='vonmisesvariate':return random.vonmisesvariate
            elif op=='paretovariate':return random.paretovariate
            elif op=='weibullvariate':return random.weibullvariate
        elif module_name=="socket":
            if op=='socket':return socket.socket
            elif op=='AF_INET':return socket.AF_INET
            elif op=='SOCK_STREAM':return socket.SOCK_STREAM
            elif op=='gethostname':return socket.gethostname
            elif op=='gethostbyname':return socket.gethostbyname
            elif op=='SOL_SOCKET':return socket.SOL_SOCKET
            elif op=='SO_REUSEADDR':return socket.SO_REUSEADDR
    obj_name=obj.__name__
    if op=="__name__":return obj_name
    if obj_name=="localtime":
        if op=='tm_year':return obj.tm_year
        elif op=='tm_mon':return obj.tm_mon
        elif op=='tm_mday':return obj.tm_mday
        elif op=='tm_hour':return obj.tm_hour
        elif op=='tm_min':return obj.tm_min
        elif op=='tm_sec':return obj.tm_sec
        elif op=='tm_wday':return obj.tm_wday
    elif obj_name=="socket":
        if op=='bind':return obj.bind
        elif op=='listen':return obj.listen
        elif op=='accept':return obj.accept
        elif op=='send':return obj.send
        elif op=='recv':return obj.recv
    print(f'{bcolors.FAIL}apython built_in error:\n    {obj} has no attribute {op} {bcolors.RESET}')
    raise Exception
15444*17*code.pyfrom apython.executer import Undefine
class Code:
    def __init__(self):
        self.tem=('AX','BX')
        self.clean()
    def clean(self):
        self.code=[]
        self.comments=[]
        self.simplify=0
        self.base_num=[]      #åŸºåº•æ•¸å€¼(ä¾æ“šæª”æ¡ˆ) #(namecode,[0,0,0])
        self.base_esp=-1
        self.file_ed=[]
        self.base=(0,0,0)
    def __apply_file(self,name):
        if name not in self.file_ed:
            self.file_ed.append(name)
        return self.file_ed.index(name)
    def add_newtab(self,name):
        namecode=self.__apply_file(name)
        self.base_num.append((namecode,[0]))
    def del_newtab(self):
        del self.base_num[-1]
    def add_tab(self):
        #print('add_tab')
        pass
       # self.base_num[self.base_esp][1].append(0)
    def del_tab(self):
        pass
        #print('del_tab')
      #  del self.base_num[self.base_esp][1][-1]
    def get_error_msg(self,row):    #ç²å–éŒ¯èª¤è¨Šæ¯
        if row<len(self.comments):
            cmt_n=self.comments[row][0][2]
            cmt=self.comments[cmt_n]
       #  print(self.comments[cmt_n-1],self.comments[cmt_n],self.comments[cmt_n+1])
            return {'file':self.file_ed[cmt[0][0]],'row':cmt[0][1],'code':cmt[1]}
        else:
            return {'file':'','row':row,'code':self.code[row]}
    def append(self,command,comment=None,simplify=0):
        if comment != None and comment[0]!='':
           # print(command,comment)
            cmt, row = comment
            self.base_num[self.base_esp][1][-1] = row
            real_row = sum(self.base_num[self.base_esp][1])  # å¯¦éš›åœ¨ç¨‹å¼ç¢¼ä¸­çš„è¡Œ
            namecode=self.base_num[self.base_esp][0]
            self.base = (namecode,real_row,len(self.comments))
            self.comments.append((self.base,cmt))     #(æª”æ¡ˆåç¨±ï¼Œç¬¬å¹¾è¡Œ)ï¼ŒåŸå§‹å‘½ä»¤
        if command=='':return
        if self.simplify==0 and simplify==0 and comment==None and len(self.code)>0 and type(command)==str and type(self.code[-1])==str:
            last=self.code[-1].split(' ')
            cmd=command.split(' ')
            if last[0]=='push' and cmd[0]=='pop':
                del self.code[-1]
                if last[1]!=cmd[1]:
                    self.code.append(f'mov {cmd[1]} {last[1]}')
            elif last[0] == 'pop' and cmd[0] == 'push' and last[1]==cmd[1]:
                del self.code[-1]
                if last[1] not in self.tem:
                    self.code.append(f'mov {last[1]} <esp+1>')
            elif last[0]=='mov' and cmd[0]=='push' and last[1]==cmd[1] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'push {last[2]}')
            elif last[0]=='pop' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'pop {cmd[1]}')
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[2]==cmd[1]:
                pass
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:      #ä¸‹ä¸€è¡Œå¯èƒ½æ˜¯åˆ¥äººè·³çš„ï¼Œå› æ­¤ç„¡æ³•ç°¡åŒ–
                del self.code[-1]
                self.code.append(f'mov {cmd[1]} {last[2]}')
            elif cmd[0] in ('add','sub') and cmd[2]=='0':
                pass
            else:
                self.code.append(command)
        else:
            self.code.append(command)
        if self.simplify>0:self.simplify-=1
        self.simplify+=simplify
        if len(self.code) > len(self.comments):
            self.comments.append((self.base, ''))
    def display(self,now_ip=-1):
        print('--------------------------------')
        Row=len(self.code)
        if now_ip<Row and now_ip!=-1 and now_ip<len(self.comments):
            now_row=self.comments[now_ip][0][2]
        else:now_row=Row
        for i in range(Row):
            statement=(' â— ' if now_ip == i else '   ')+str(i)+ ' ' * (4 - len(str(i)))+'|'+self.code[i]
            #if now_ip==i:
             #   statement="[93m"+statement+"[0m"
            space=' '*70
            cmt = self.comments[i]
            if cmt[1]!='':   #è¦matchåˆ°æ‰æœƒprint
                orig_code=(' â— ' if i== now_row else '   ')+str(cmt[0][1])+ ' ' * (4 - len(str(i)))+'| '+cmt[1]
            else:orig_code=''
            print(space+orig_code[:40]+'\r'+statement)
            if i>100:
                print('row more than 100')
                break
        print('--------------------------------')
    def parse_code(self,start_row=0,reset=True):                    #è§£æç‚ºé©åˆåŸ·è¡Œçš„æ ¼å¼
        def deal_string(codeline,k):  # kç‚º',"çš„ä½ç½®
            c = codeline[k]
            k+=1
            p = k
            while True:
                if codeline[k] == '\\':
                    k += 1
                elif codeline[k] == c:
                    break
                k += 1
            return c+codeline[p:k]+c,k
        def login_item(item):
            if item not in self.data_dict:
                if len(self.data)-self.data_n<100:
                    self.data+=[Undefine()]*1024
                self.data_dict[item]=self.data_n
                if item[0] in ('"',"'"):
                    string=item[1:-1]
                    if item[0]=='"':
                        rbox = {'\\n':'\n','\\r':'\r','\\t':'\t','\\a':'\a','\\b':'\b','\\f':'\f','\\v':'\v','\\"':'"','\\\'':'\'','\\\\':'\\'}
                        k,n=0,len(string)
                        text_box=[]
                        while k<n:
                            if string[k]=='\\' and string[k:k+2] in rbox:
                                text_box.append(rbox[string[k:k+2]])
                                k+=1
                            else:text_box.append(string[k])
                            k+=1
                        string=''.join(text_box)
                    self.data[self.data_n]=string
                elif item[0] in '0123456789-':
                    if '.' in item:self.data[self.data_n]=float(item)
                    else:self.data[self.data_n]=int(item)
                self.data_n+=1
            return self.data_dict[item]
        cmd_dict={'mov':(0,2),
                  '$mov':(1,3),               #$mov AX op BX  #AX+=BX
                  'oper':(2,3),               #oper AX op BX  #AX=AX+BX             #'add','sub','mul','div','pow','quo','rem','address'
                  'cmp':(3,2),                #ZR=AX-BX
                  'jmp':(4,1),               #jmp ip
                  '$jmp':(5,2),              #$jmp ip ">"  #ZRå¤§æ–¼0å‰‡è·³
                  'call':(6,1),              #å‘¼å«å‡½æ•¸
                  'push':(7,1),'pop':(8,1),
                  'tf':(9,3),                 #tf AX "ctn" BX    #åˆ¤æ–·çœŸå‡      'ctn','equ','Ctn','is',
                  'inc':(10,1),'dec':(11,1),
                  '$oper':(12,2),              #$oper AX "op" BX                       #'neg','NEG','not'
                  'ex_func':(13,3),           #ex_fuunc AX "str" BX  #AX=str(BX)       #'iter'
                  'try':(14,1),'finally':(15,1),'raise':(16,1),'error':(17,1),
                  'Generator':(18,-1),'Yield':(19,0),'fetch':(20,2),
                  'stop':(21,0),'end':(22,-1),
                  'byte':(23,2),'del':(24,3),'Function':(25,-1),
                  'global':(26,0),'namespace':(28,3),'pass':(26,0),     #globalä¸äºˆç†æœƒ
                  '*args':(29,3),'**kwargs':(30,3),'module':(31,2),
                  'type':(32,2),'name':(33,2),'repl_print':(34,1)}
        #-----------------------------------------------------
        if reset:
            self.data_dict={'AX':0,'BX':1,'CX':2,'DX':3,'ip':4,'esp':5,'sp':6,'ZR':7,'TF':8,
                       '*args':9,'**kwargs':10,'$Exception':11,
                       'True':12,'False':13,'None':14,'$Inheritance':15}
            self.data_n = len(tuple(self.data_dict))
            self.data=[None]*self.data_n
            self.data+=[Undefine()]*1024
            self.data[12]=True
            self.data[13]=False
            self.data[14]=None
            self.data[15]=None
            self.parse_codes=[]
        else:
            self.data_n = len(tuple(self.data_dict))                              #dataé–‹å§‹ç™»è¨˜çš„ä½ç½®
        #print('data_n:',self.data_n)
        ROW=len(self.code)-1
        start_row-=1
        #print('code:',self.code)
        #print('start_row:',start_row)
        while start_row<ROW:
            start_row+=1
            line=self.code[start_row]
            if line=='':          #lineç‚ºç©º
                self.parse_codes.append([26])     #ä¸äºˆç†æœƒç©ºline
                continue
            op=line.split(' ')[0]
            cmd=cmd_dict[op]
            deal = [cmd[0]]
            k=len(op)+1
            fetch_k=0
            while fetch_k<cmd[1] or (cmd[1]==-1 and k<len(line)):
                if line[k] in ('"',"'"):                       #å¿…å®šç‚ºå­—ä¸²
                    string,k=deal_string(line,k)          #kç‚º"çš„ä½ç½®
                    if fetch_k==1:
                        if op in ('$mov','oper'):
                            op_num=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='tf':
                            op_num = ('in','equ','Ctn','is').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='$oper':
                            op_num = ('not','-','~').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        else:
                            deal.append((0, login_item(string)))
                    else:
                        deal.append((0,login_item(string)))
                    k+=2
                elif line[k] in '0123456789-':                  #å¿…å®šç‚ºæ•¸å€¼
                    k2=k
                    while k2<len(line) and line[k2] in '-0123456789.':k2+=1
                    number=line[k:k2]
                    deal.append((0,login_item(number)))
                    k=k2+1
                elif line[k]=='[':                    #æ­¤è™•ç‚º[value]é¡å‹ï¼Œé variable[value] é¡å‹ï¼Œå› æ­¤[]ä¸­åªèƒ½æ˜¯int,dict,class
                    k2=line.index(']',k)
                    value=line[k+1:k2]
                    if value=='dict':                   #11:dict
                        deal.append((11,-1))
                    elif value=='class':                #13:class
                        deal.append((13,-1))
                    elif value=='func':                 #16:func
                        deal.append((16,-1))
                    else:                                #10:list
                        deal.append((10,int(value)))
                    k=k2+2
                elif line[k]=='(':             #è¦æ±‚[number]        #12:tuple
                    k2=line.index(')',k)
                    deal.append((12,int(line[k+1:k2])))   #tupleå®£å‘Š
                    k=k2+2
                else:
                    typebox=''
                    if line[k]=='<':
                        k2=line.index('>',k)
                        name=line[k+1:k2]
                        if '+' in name:
                            c=name.split('+')
                            result=[c[0],int(c[1])]
                        else:result=[name,0]
                        k2+=1
                        if result[0]=='esp':
                            typebox+='1'                                   #<esp+k>:1
                            result[0] = login_item(result[0])
                        else:
                            #result[0] = login_item(result[0])            #æ­¤è™•ä¸é€²è¡Œç™»è¨˜ï¼Œå› ç‚ºfunc_nameè¦ä½œç‚ºkeyä½¿ç”¨
                            typebox='2'                                   #<func+k>:2
                    else:                                                  #name:0
                        k2=k
                        while k2<len(line) and line[k2] not in '[ .':k2+=1
                        result=[line[k:k2]]
                        typebox+='0'
                        result[0] = login_item(result[0])
                    k=k2+1
                    #----------------
                    #[],{},()æŒ‡ä»¤

                    if k2 < len(line) and line[k2] == '.':             # ä»£è¡¨æ˜¯å­å±¬æ€§ï¼Œ'.':0
                        k2+=1
                        while k2 < len(line) and line[k2] not in '[ .': k2 += 1
                        attr=line[k:k2]
                        result.append(attr)
                        typebox+='0'
                        k=k2+1
                    if k2<len(line) and line[k2]=='[':                        #ä»£è¡¨æ˜¯ç´¢å¼•ï¼Œ[key]:1
                        if line[k2+1] in ('"', "'"):           #å…§å®¹æ˜¯å­—ä¸²
                            value, k3 = deal_string(line,k2+ 1)
                            result.append(login_item(value))
                            k3+=1            #k3ç§»å‹•åˆ°]çš„ä½ç½®
                        else:
                            k3=line.index(']',k2)
                            value=line[k2+1:k3]
                            result.append(login_item(value))
                        typebox += '1'
                        k=k3+2
                    if typebox=='0':                    #ç´”åå­—                #name
                        deal.append((0,result[0]))
                    elif typebox=='00':                                       #name.attr
                        deal.append((1,result[0],result[1]))
                    elif typebox=='01':                                       #name[key]
                        deal.append((2, result[0], result[1]))  # name[key]
                    elif typebox=='1':                                       #<esp+k>
                        deal.append((3, result[0], result[1]))
                    elif typebox=='10':                                       #<esp+k>.attr
                        deal.append((4,result[0],result[1],result[2]))
                    elif typebox=='11':                                       #<esp+k>[key]
                        deal.append((5,result[0],result[1],result[2]))
                    elif typebox=='2':                                       #<func+k>
                        deal.append((6, result[0], result[1]))
                    elif typebox=='20':                                       #<func+1>.attr
                        deal.append((7,result[0],result[1],result[2]))
                    elif typebox=='21':                                       #<func+k>[key]
                        deal.append((8,result[0],result[1],result[2]))
                fetch_k+=1
            self.parse_codes.append(deal)
        return self.parse_codes,self.data,self.data_dict
    def __len__(self):
        return len(self.code)
    def __getitem__(self, item):
        return self.code[item]
    def __setitem__(self, key, value):
        self.code[key]=value
    #def __delitem__(self, key):        #æœ¬ç¨‹å¼è‡ªå‹•å„ªåŒ–ï¼Œå‹¿del
     #   del self.code[key]8435*112*ebuilt_in.pyfrom os import system
built_in=\
{
    "<class 'str'>":
        {
            'attr':'',
            'example':"'hello'",
            'function':'join,count,split,index,format,encode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'list'>":
        {
            'attr':'',
            'example':"[1,2,3]",
            'function':'append,pop,count,remove,insert,clear,copy,index,extend,reverse,sort'
        },
    "<class 'tuple'>":
        {
            'attr':'',
            'example':"(1,5,9)",
            'function':'index,count'
        },
    "<class 'dict'>":
        {
            'attr':'',
            'example':"{1:2,3:4}",
            'function':'pop,get,copy,clear,update,keys,fromkeys,items,popitem,setdefault,values'
        },
    "<class 'bytes'>":
        {
            'attr':'',
            'example':"b'hell'",
            'function':'join,count,split,index,format,decode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'set'>":
        {
            'attr':'',
            'example':"{1,2,3,4}",
            'function':'pop,add,remove,copy,clear,update,difference,difference_update,discard,intersection,intersection_update,'
                       'isdisjoint,issubset,issuperset,symmetric_difference,symmetric_difference_update,union'
        },
    "<class '_io.TextIOWrapper'>":
        {
            'attr':'name,encoding,mode,buffer,closed,errors,line_buffering,newlines',
            'example':"open('newtext.txt','w')",
            'function':'write,tell,read,close,seek,fileno,flush,isatty,readable,readline,readlines,seekable,truncate,writable,writelines,'
                       '__enter__,__exit__'
        },
    "<class 'builtin_function_or_method'>":
        {
            'attr':'__name__',
            'example':"print",
            'function':''
        }
}
build_template='''
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\\nfrom apython.ex_func import *\\n")
    g.write('class bcolors:\\n    OK = "\033[92m"  # GREEN\\n    WARNING = "\033[93m"  # YELLOW\\n    FAIL = "\033[91m"  # RED\\n    RESET = "\033[0m"  # RESET COLOR\\n')
    g.write("def built_in_operator(obj,op):\\n    stype = str(type(obj))\\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\\n')
            else:
                g.write(f'    elif stype=="{stype}":\\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\\'{item}\\':return obj.{item}\\n')
                else:
                    g.write(f'        elif op==\\'{item}\\':return obj.{item}\\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\\n        module_name=obj.module_name\\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            else:
                g.write(f'            elif op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\\n')
        k += 1
    g.write('    obj_name=obj.__name__\\n    if op=="__name__":return obj_name\\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            else:
                g.write(f'        elif op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\\\n    {obj} has no attribute {op} {bcolors.RESET}')\\n    raise Exception\\n")
    g.close()
build()
'''
def test_and_build():
    f=open('test_error.txt','w',encoding='utf-8')
    f.write("#encoding='utf-8'\ndatas=[]")
    k=1
    for key in built_in:
        data=built_in[key]
        f.write(f'\ntype{k}="{key}"')
        f.write(f'\nexample{k}='+data['example'])
        f.write(f'\nabox{k}=[]')
        f.write(f'\nfbox{k}=[]')
        if data['attr'] != '':
            attrs = data['attr'].split(',')
            for item in attrs:
                f.write(f'\ntry:\n    abox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        if data['function']!='':
            functions = data['function'].split(',')
            for item in functions:
                f.write(f'\ntry:\n    fbox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        f.write(f'\ndatas.append((type{k},abox{k},fbox{k}))')
        k+=1
    f.write(build_template)
    f.close()
test_and_build()
system('py test_error.txt')41704*111*executer.pyfrom apython.built_in import *
class Undefine:
    def __init__(self):
        self.Fail = "[91m"
        self.RESET = "[0m"
    def __str__(self):
        return f'{self.Fail}<undefined>{self.RESET}'
class class_obj:
    def __init__(self,ram):
        self.ram=ram
        self.atype=None
        self.vars={}
        self.print_lock=0        #0:é€²è¡Œé‹ç®—ï¼Œ1:ç›´æ¥å›å‚³<The class obj>
    def __str__(self):
        if self.print_lock==0 and '__str__' in self.vars:
            return self.ram.call_obj_function(self,[],'__str__')
        return '<class_obj>'
    def __add__(self, other):
        if self.print_lock==0 and '__add__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__add__')
    def __sub__(self, other):
        if self.print_lock==0 and '__sub__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__sub__')
    def __len__(self):
        if self.print_lock==0 and '__len__' in self.vars:
            return self.ram.call_obj_function(self,[],'__len__')
    def __setitem__(self, key, value):
        if self.print_lock==0 and '__setitem__' in self.vars:
            return self.ram.call_obj_function(self,[key,value],'__setitem__')
    def __getitem__(self, item):
        if self.print_lock==0 and '__getitem__' in self.vars:
            return self.ram.call_obj_function(self,[item],'__getitem__')
    def __contains__(self, item):
        if self.print_lock == 0 and '__contains__' in self.vars:
            return self.ram.call_obj_function(self, [item], '__contains__')
    def __next__(self):
        if self.print_lock == 0 and '__next__' in self.vars:
            return self.ram.call_obj_function(self, [], '__next__')
        elif '__getitem__' in self.vars:
            self.error=False
            self.item_k += 1
            return self.__getitem__(self.item_k)
    def __iter__(self):
        self.item_k=-1
        if self.print_lock == 0 and '__iter__' in self.vars:
            return self.ram.call_obj_function(self, [], '__iter__')
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.print_lock == 0 and '__exit__' in self.vars:
            return self.ram.call_obj_function(self, [exc_type,exc_val,exc_tb], '__exit__')
    def __call__(self, *args, **kwargs):
        if self.print_lock == 0 and '__call__' in self.vars:
            return self.ram.call_obj_function(self, args, '__call__',kwargs)
    def __del__(self):
        if self.print_lock == 0 and '__del__' in self.vars:
            return self.ram.call_obj_function(self, [], '__del__')
    def __eq__(self, other):
        if self.print_lock == 0 and '__eq__' in self.vars:
            return self.ram.call_obj_function(self, [other], '__eq__')
class Func:
    def __init__(self,ram,ip,class_obj,func_var,stack_len,import_funcs):
        self.name='Function'
        self.atype='Function'
        self.ram=ram
        self.vars={'ip':ip,'class_obj':class_obj}
        self.stack_name=func_var
        self.stack_len=stack_len
        self.import_funcs=import_funcs
    def __str__(self):
        return str(self.name)
    def __call__(self, *args, **kwargs):                 #ç”±å…§éƒ¨æˆ–å¤–éƒ¨å‡½æ•¸(ex_function)å‘¼å«
        self.ram.data[self.ram.args_location] = args
        self.ram.data[self.ram.kwargs_location] = kwargs
        result=self.ram.func_run(self.vars['ip'],self.vars['class_obj'],self.stack_name,self.stack_len,self.import_funcs)    #ipå›ºå®šï¼Œclass_objå’Œex_boxéƒ½æ˜¯ä½å€å®šç¾©ï¼Œå› æ­¤ä¸ç”¨æ¥å—è¿”é‚„å€¼
        return result
class generator:
    def __init__(self,ram,start_ip,import_funcs):
        self.ram=ram
        self.next_ip=start_ip
        self.import_funcs = import_funcs
        #self.params=params
        #self.locals=locals
        self.ex_stack=[]                 #ç¨‹å¼ä¸­æ–·æ™‚å¯èƒ½æœ‰è¶…å‡ºçš„å †ç–Š
        #self.ex_box=ex_box                   #çˆ¶å‡½æ•¸å€‘çš„è³‡æ–™å…§å®¹ï¼Œ[(loc,stack),...]
        #self.orig_local_len=len(locals)
        #self.base_location=base_location
        self.enter=0                           #ç•¶enter=1æ™‚ï¼Œä»£è¡¨å·²ç¶“é­é‡äº†stopiteration
        self.next_lock=True                    #åœ¨sendå‰éœ€è¦å…ˆå•Ÿå‹•next
        self.send=False
        self.send_obj=None
        self.finally_box=[]                    #å¦‚æœç¨‹å¼åœ¨æœ‰finallyçš„tryä¸­è·³å‡ºï¼Œä¸¦ä¸”è‡ªå·±è¢«delï¼Œå‰‡ä¾åºåŸ·è¡Œfinallyboxä¸­çš„å…§å®¹
        def send(value):
            if not self.next_lock:
                self.send=True
                self.send_obj=value
                return self.__next()
            raise TypeError("can't send non-None value to a just-started generator")
        self.vars={'send':send}
    def __str__(self):
        return '<generator_obj>'
    def __getitem__(self, item):
        return self.__next()
    def __next__(self):
        self.next_lock=False
        if self.send:
            self.send_obj =None               #åœ¨å•Ÿç”¨sendä¹‹å¾Œï¼Œå¿…å®šè¦å‚³çµ¦AXå€¼
        return self.__next()
    def __next(self):
        if self.enter==1:    #ä»£è¡¨ä¹‹å‰é€²å…¥å»ä¹‹æ•—äº†
            raise StopIteration
        else:
            self.enter=1
            if not self.send:
                next_obj,self.ex_stack,yield_result,base_esp= self.ram.yield_run(self.next_ip,self.ex_stack, self.import_funcs)
            else:
                next_obj, self.ex_stack, yield_result, base_esp = self.ram.yield_run(self.next_ip, self.ex_stack,self.import_funcs,send_obj=self.send_obj)
             #print('å–å¾—çµæœ:',yield_result)
           # print('ex_stack',self.ex_stack)
            if next_obj!=None:
                self.next_ip,finally_box=next_obj
                for f_ip in finally_box:
                    if f_ip[0]>-1:
                        ex_stack_num=base_esp-f_ip[1]       #åŸºåº•å †ç–Šé‡èˆ‡é€²å…¥tryæ™‚å †ç–Šé‡çš„å·®
                        self.finally_box.append([f_ip[0],ex_stack_num])
                    else:
                        for fip in self.finally_box:          #åŒå€‹finallyå°±åˆªæ‰
                            if fip[0]==abs(f_ip[0]):
                                self.finally_box.remove(fip)
                                break
                self.enter=0
                return yield_result
            raise StopIteration
    def __del__(self):
       # print('del:',self.finally_box)
        for f_ip in self.finally_box:
           # print(f_ip)
            #å°‡å †ç–ŠåŒä½
            self.ram.data[self.ram.ip]= f_ip[0]+1
            # --------------------------------------------
            tem_stacks = {}
            for func_name in self.import_funcs:
                tem_stacks[func_name] = self.ram.func_stack[func_name]
                self.ram.func_stack[func_name] = self.import_funcs[func_name]
            for i in range(f_ip[1]):    #åŸå§‹localé‡+ex_stack
                self.ram.push(self.ex_stack[i])
            #self.ram.data[self.base_location] = self.ram.data[self.ram.esp]        #<stack_esp>
            self.ram.push(None)           #ç‚ºäº†ç¬¦åˆfinallyçš„å †ç–Šæ ¼å¼
            self.ram.push(1)
            # --------------------------------------------
            #self.ram.tf=1
            try:
                self.ram.one_run('finally yield run')
            except Exception as e:
                print(e)
            finally:
                for func_name in tem_stacks:
                    self.ram.func_stack[func_name] = tem_stacks[func_name]
         #   print('run finish')
def fetch_error(e):
    stype = str(type(e))
    k = stype.index("'")
    k2 = stype.index("'", k + 1)
    return stype[k + 1:k2]
def atype(obj):
    if type(obj)==class_obj:
        return obj.atype
    elif type(obj)==Func:
        return f"<class '__main__.{obj.name}'>"
    return type(obj)     #string,list,int,tuple,...
def aprint(*args,**kwargs):
    text_box=[]
    for obj in args:
        text_box.append(str(obj))
    text=' '.join(text_box)
    if 'end' in kwargs:
        total_output.append(text+kwargs['end'])
    else:
        total_output.append(text+'\n')
total_output=[]
built_in_functions=[abs,all,any,ascii,bin,bool,breakpoint,bytearray,bytes,callable,chr,classmethod,compile,complex,
                    delattr,dict,dir,divmod,enumerate,eval,exec,filter,float,format,frozenset,getattr,globals,hasattr,hash,hex,
                    id,input,int,isinstance,issubclass,iter,len,list,locals,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,
                    range,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,vars,zip]
Error_class=[NameError,IndexError,TypeError,SyntaxError,ValueError,KeyboardInterrupt,AssertionError,Exception,RecursionError,
             KeyError,ZeroDivisionError,AttributeError,IndentationError ,UnboundLocalError]
else_built_in=[StopIteration,StopAsyncIteration,SyntaxWarning,FileNotFoundError,ModuleNotFoundError]
bifs={
   # 'help':help,             #æ‰“åŒ…æˆexeæ™‚ï¼Œhelpæœƒç„¡æ•ˆ
    'IOError':IOError,
    'type':atype       #helpæ²’æœ‰name,IOErrorçš„nameç‚ºOSError
      }
for key in built_in_functions+Error_class+else_built_in:
    bifs[key.__name__]=key
class Executer:                                               #è¼‰å…¥ç¨‹å¼ç¢¼èˆ‡è¨˜æ†¶é«”
    def __init__(self,code):
        self.code=code
        self.ex_function=bifs.copy()
        self.run_layer=[]
        self.func_stack={}
    def set(self,var_name,value):
        location=self.data_dict[var_name]
        self.data[location]=value
    def push(self, value):
        self.esp_stack[self.data[self.esp]] = value
        self.data[self.esp]-= 1
    def pop(self):
        self.data[self.esp]+= 1
        return self.esp_stack[self.data[self.esp]]
    def login(self,var_name):
        if var_name in self.var_dict:
            return self.var_dict[var_name]
        self.var_dict[var_name]=self.used_size
        self.used_size+=1
        return self.used_size-1
    def get_var_location(self,var_name):
        return self.var_dict[var_name]
    def pushaw(self):
        for i in range(5):                                #å„²å­˜AX,BX,CX,DX,ipé€²å †ç–Š
            self.esp_stack[self.data[self.esp]]=self.data[i]
            self.data[self.esp]-=1
    def popaw(self):
        for i in range(5):                                #å›å¾©AX,BX,CX,DX,ipé€²å †ç–Š
            self.data[self.esp] += 1
            self.data[4-i]=self.esp_stack[self.data[self.esp]]
    def __setitem__(self,location, value):
     #   print(location,value)
        if location[0]==0:                                                       #name
            self.data[location[1]]=value
        elif location[0]==1:                                                        #name.attr
            self.data[location[1]].vars[location[2]]=value
        elif location[0]==2:                                                             #name[key]
            self.data[location[1]][self.data[location[2]]]=value
        #-----------------------------------------------------------------------------------------------
        elif location[0]==3:                                                             #<esp+k>
            self.esp_stack[self.data[location[1]]+location[2]]=value
        elif location[0]==4:                                                            #<esp+k>
            self.esp_stack[self.data[location[1]] + location[2]].vars[location[3]]=value
        elif location[0]==5:                                                              #<esp+k>[key]
            self.esp_stack[self.data[location[1]]+location[2]][self.data[location[3]]]=value
        # -----------------------------------------------------------------------------------------------
        elif location[0]==6:                                                             #<func+k>
            self.func_stack[location[1]][location[2]]=value
        elif location[0]==7:                                                            #<func+k>
            self.func_stack[location[1]][location[2]].vars[location[3]]=value
        elif location[0]==8:                                                              #<func+k>[key]
            self.func_stack[location[1]][location[2]][self.data[location[3]]]=value
    def call_obj_function(self,obj,args,funcname,kwargs=None):
        tem_esp=self.data[self.esp]
        if kwargs==None:kwargs={}
        self.pushaw()
        self.data[2] = len(args)                                           # CX=len(args)
        func=obj.vars[funcname]
        result=None
        try:
            result=func(*args,**kwargs)
        finally:
            self.popaw()
            self.data[self.esp]=tem_esp
        return result
    def yield_run(self,ip,ex_stack,import_funcs,send_obj=None):
        tem_ip=self.data[self.ip]
        self.data[self.ip]=ip
        #--------------------------------------------
        tem_stacks={}
        for func_name in import_funcs:
            tem_stacks[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        #--------------------------------------------
        tem_esp=self.data[self.esp]       #å„²å­˜ç›®å‰esp
        for ex_obj in ex_stack:
            self.push(ex_obj)
        #--------------------------------------------
        yield_result =None
        ok=False
        try:                                #æ­¤è™•runå¯èƒ½æœƒå™´StopIterationéŒ¯èª¤ï¼Œè‡³å°‘è¦å›æ”¶å †ç–Šã€é‚„åŸip
            self.data[0]=send_obj
            next_obj=self.__run('yield run')
            ok=True
        #--------------------------------------------
        finally:
            del self.run_layer[-1]          #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€é™¤å»yield run
            if ok:
                yield_result=self.data[0]            #ç²å–yieldçš„å€¼
            new_ex_stack=[]
            for i in range(tem_esp-self.data[self.esp]):
                new_ex_stack.insert(0,self.pop())
            # é‚„åŸçˆ¶å‡½æ•¸
            for func_name in tem_stacks:
                self.func_stack[func_name]=tem_stacks[func_name]
            #-------------------------------------------
            self.data[self.ip]=tem_ip
        return next_obj,new_ex_stack,yield_result,tem_esp
    def func_run(self,ip,class_obj,stack_name,stack_len,import_funcs):
        tem_ip = self.data[self.ip]  # ç•¶å‰ip
        tem_esp=self.data[self.esp]
        # --------------------------------------------
        tem_func_stack={}
        for func_name in import_funcs:
            tem_func_stack[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        if stack_name not in self.func_stack:            #è™•ç†å †ç–Šè³‡è¨Š
            self.func_stack[stack_name]=None
        tem_stack=self.func_stack[stack_name]
        # --------------------------------------------
       # self.push(len(self.code))  # æ¨å…¥æœ€å¾Œä¸€è¡Œï¼Œç¨‹å¼åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³æœ€å¾Œä¸€è¡Œ     #push ip
        #å»ºç«‹æ–°functionå †ç–Š
        func_stack=[0]*stack_len
        func_stack[0]=class_obj                 #ç¬¬0ä½ç½®ç‚ºclass_obj
        self.func_stack[stack_name]=func_stack
        #-------------------------------------------------------
        self.data[self.ip] = ip+ 1
        self.push(len(self.code))   #é€™æ¨£pop ipå°±æœƒç›´æ¥return
        result=None
        try:
            self.__run(f'Func<{ip}> run')
        #except Exception as e:
        #    print(e)
        #    raise e
        finally:
            result=self.data[0]
            del self.run_layer[-1]
            self.data[self.ip] = tem_ip
            # é‚„åŸçˆ¶å‡½æ•¸
            self.func_stack[stack_name]=tem_stack
            for func_name in import_funcs:
                self.func_stack[func_name] = tem_func_stack[func_name]
            self.data[self.esp]=tem_esp
        return result
    def __getitem__(self, location):
        #------------------------------------------------------------------------------------------------name
        if location[0] == 0:                                        # name
            return self.data[location[1]]
        elif location[0] == 1:                                       #name.attr
            obj = self.data[location[1]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[2] in obj.vars:
                    return obj.vars[location[2]]
                return self.undefined  # ç™¼ç”ŸéŒ¯èª¤
            elif type(obj)==Undefine:
                raise Exception(f'{self.inverse_data_dict[location[1]]} is undefined')
            elif type(obj)==Ex_module and location[2] in obj.vars:
                return obj.vars[location[2]]
            else:
                func=built_in_operator(obj, location[2])
                return func
        elif location[0] == 2:                                       # name[key]
            return self.data[location[1]][self.data[location[2]]]
        #------------------------------------------------------------------------------------------------<esp+k>
        elif location[0] == 3:                                       #<esp+k>
            return self.esp_stack[self.data[location[1]] + location[2]]
        elif location[0]==4:                                         #<esp+k>.attr
            obj = self.esp_stack[self.data[location[1]] + location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
                raise Exception(f'variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 5:                                         # <esp+k>[key]
            return self.esp_stack[self.data[location[1]] + location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------<func+k>
        elif location[0] == 6:                                       #<func+k>
            return self.func_stack[location[1]][location[2]]
        elif location[0]==7:                                         #<func+k>.attr
            obj =self.func_stack[location[1]][location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
               # ip=self.data[self.ip]
               # print('ip:',ip)
               # start_ip=ip-20
               # error_lines=self.code.code[start_ip:ip+10]
               # for i in range(30):
               #     print(start_ip+i,error_lines[i])
               # print('location:',location)
                raise Exception(f'this variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 8:                                         # <func+k>[key]
            return self.func_stack[location[1]][location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------[object]
        elif location[0]==10:                                          #list
            return [0]*location[1]
        elif location[0]==11:                                          #dict
            return {}
        elif location[0]==12:                                          #tuple
            return [0]*location[1]
        elif location[0] == 13:                                        #<class obj>
            self.class_objs.append(class_obj(self))
            return self.class_objs[-1]
    def __error_print(self,msg):
        Fail="[91m"
        RESET = "[0m"
        print(f'{Fail}{msg}{RESET}')
    def __ok_print(self,msg):
        OK="[92m"
        RESET = "[0m"
        print(f'{OK}{msg}{RESET}')
    def one_run(self,comment):
        self.__run(comment)
    def run(self,tf=0,stack_size=1024,comment='normal'):
        self.codes, self.data, self.data_dict = self.code.parse_code(start_row=0,reset=True)
        self.inverse_data_dict = {}
        for key in self.data_dict:
            self.inverse_data_dict[self.data_dict[key]] = key
        self.stack_size=stack_size
        self.esp_stack= [0] * stack_size
        #-------------------------------------------------------------
        self.set('esp', -1)  # è¨­å®šå †ç–ŠæŒ‡æ¨™
        self.set('ip',0)
        self.esp = self.data_dict['esp']
        self.ip = self.data_dict['ip']
        self.ZR = self.data_dict['ZR']
        self.TF = self.data_dict['TF']
        self.ER=self.data_dict['$Exception']
        self.data[self.ER]=0
        self.error_line=0        #ç™¼ç”ŸéŒ¯èª¤çš„line
        self.args_location = self.data_dict['*args']
        self.kwargs_location = self.data_dict['**kwargs']
        self.class_objs=[]
        self.func_stack={}
        self.undefined=Undefine()
        #--------------------------åˆå§‹åŒ–å¤–éƒ¨å‡½æ•¸
        for name in self.data_dict:
            if name in self.ex_function:
                self.data[self.data_dict[name]]=self.ex_function[name]
        self.normal_run(0,tf,comment)
    def REPL_run(self, row):
        total_output.clear()
        if row==0:
            self.run(0,1024,comment='REPL')
        else:
            self.data[0]=None
            self.codes, self.data, self.data_dict = self.code.parse_code(start_row=row,reset=False)
            for name in self.data_dict:
                if name in self.ex_function:
                    self.data[self.data_dict[name]] = self.ex_function[name]
            for key in self.data_dict:
                self.inverse_data_dict[self.data_dict[key]] = key
            self.normal_run(row,0,'REPL')
        return ''.join(total_output)
    def normal_run(self,row,tf,comment='normal'):
        self.tf=tf
        self.set('esp',-1)
        self.set('ip',row)
        try:
            self.__run(comment)
            if self.data[self.esp] == -1:
                if tf > 0:
                    self.__ok_print('\nç¨‹å¼çµæŸ--------')
            else:
                self.__error_print(f'ç¨‹å¼è­¦å‘Š:å †ç–Šæœªé‚„åŸ---------->   {self.data[self.esp]}')
        except Exception as e:
            if self.data[self.ER] == 0:  # éŒ¯èª¤ä¸æ˜¯ä¾†è‡ªtryï¼ŒéŒ¯èª¤ä¾†è‡ªæ­£å¸¸è¡Œ
                error_ip = self.data[self.ip]
            else:  # éŒ¯èª¤ä¾†è‡ªtry
                error_ip = self.error_line
            if comment!='REPL':
                msg = self.code.get_error_msg(error_ip)
                self.__error_print(f'\nTrackback:\nFILE: ' + msg['file'] + ',  line:' + str(+msg['row']))
                self.__error_print('   ' + msg['code'])
            error = str(e)
            if len(error) > 0: error = ': ' + error
            self.__error_print(fetch_error(e) + error)
            # print('--------------')
            if tf > 0:
                raise e
    def __run(self,run_comment):
        self.run_layer.append(run_comment)
        def obj_lock(lock):
            for obj in self.class_objs: obj.print_lock = lock
        def cpu_state():
            print('data: ', end='')
            for key in self.data_dict:
                if key[0] not in '"0123456789-' + "'" and key not in  ('None','True','False') and key not in self.ex_function:
                    # if type(key) != int and '"' != key[0] and "'" != key[0]:  # å»é™¤æ•¸å€¼å’Œå­—ä¸²
                    print(f'{key}:{self.data[self.data_dict[key]]}', end='  ')
                if key in ('TF', '**kwargs'): print('\n      ', end='')
                if key=='$Exception':print('\n      ', end='')
                if key=='$Inheritance':
                    print('\nè‡ªç”±è®Šæ•¸:\n      ',end='')
            stack_text = '\n\nstack:['
            stack_n = 7
            for i in range(25):
                obj = self.esp_stack[-i - 1]
                get = str(obj) + ','
                if i + 1 < abs(self.data[esp]):
                    stack_n += len(get)
                stack_text += get
            print(stack_text[:-1] + ']')
            print(' ' * stack_n + '^')
            for func_name in self.func_stack:
                print(f'{func_name}: {self.func_stack[func_name]}')
        def get_status():
            obj_lock(1)
            now_ip=self.data[ip]
            self.code.display(now_ip)
            cpu_state()
            print(f'run_layer:{self.run_layer}')
            if now_ip < len(self.codes):
                print('\næº–å‚™åŸ·è¡Œ:', self.code.code[now_ip], '                  å°æ‡‰:', self.codes[now_ip])
                print('-------------------------------')
            else:
                print('ç¨‹åºå·²çµæŸ\n')
            obj_lock(0)
        ip=self.ip
        esp=self.esp
        ZR=self.ZR
        TF=self.TF
        ER=self.ER
        args_location=self.args_location
        kwargs_location=self.kwargs_location
        finally_box=[]
        n=len(self.codes)
        while self.data[ip]<n:
            cmd=self.codes[self.data[ip]]
           # print(f'{self.data[ip]}   {self.code.code[self.data[ip]]}                       {cmd}')
            if self.tf==1:
                get_status()
                a=input()
                if a!='':
                    #print(f'AX:"{self.data[0]}"')
                    if len(a)<3:
                        self.tf=0.5
                    elif a=='asd':
                        print('åµéŒ¯!!--------')
                        self.tf=0.1
                    else:
                        self.__ok_print('ç¨‹å¼é–‹å§‹--------')
                        self.tf=0
            if self.tf==0.1:
                now_ip=self.data[ip]
                msg=' '*60+self.code.comments[now_ip]+f'\r       {self.code.code[now_ip]}\r{now_ip}'
                print(msg)
                #cpu_state()
            #------------------------------------------
            if cmd[0] ==0:#mov
                self[cmd[1]] = self[cmd[2]]
            elif cmd[0]==1: #$mov
                op=self[cmd[2]]
                if op==0:  #add
                    self[cmd[1]] += self[cmd[3]]
                elif op==1: #sub
                    self[cmd[1]] -= self[cmd[3]]
                elif op==2: #mul
                    self[cmd[1]] *= self[cmd[3]]
                elif op==3: #div
                    self[cmd[1]]/=self[cmd[3]]
                elif op==4: #pow
                    self[cmd[1]] **= self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] %= self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] //= self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]<<=self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]>>=self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] &= self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] ^= self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] |=self[cmd[3]]
            elif cmd[0]==2:  #oper
                op = self[cmd[2]]
                if op == 0:  # add
                    self[cmd[1]] =self[cmd[1]]+self[cmd[3]]
                elif op == 1:  # sub
                    self[cmd[1]] =self[cmd[1]]-self[cmd[3]]
                elif op == 2:  # mul
                    self[cmd[1]] =self[cmd[1]]* self[cmd[3]]
                elif op == 3:  # div
                    self[cmd[1]] =self[cmd[1]]/self[cmd[3]]
                elif op == 4:  # pow
                    self[cmd[1]] =self[cmd[1]]**self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] =self[cmd[1]]%self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] =self[cmd[1]]//self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]=self[cmd[1]]<<self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]=self[cmd[1]]>>self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] =self[cmd[1]]&self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] =self[cmd[1]]^self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] =self[cmd[1]] | self[cmd[3]]
            elif cmd[0] == 3:  # cmp ç›¸æ¸›
                self.data[ZR] = self[cmd[1]] - self[cmd[2]]
            elif cmd[0]==4: #jmp
                self.data[ip]=self[cmd[1]]
            elif cmd[0]==5: #$jmp
                op=self[cmd[2]]
                zr=self.data[ZR]
                tf=self.data[TF]
                if (op=='==' and  zr== 0) or (op=='!=' and zr != 0) or (op=='>=' and zr >= 0) or (
                        op=='<=' and zr <= 0) or (op=='>' and zr > 0) or (op=='<' and zr < 0):
                    self.data[ip] = self[cmd[1]]
                elif (op=='t' and tf) or (op=='f' and not tf):
                    self.data[ip] = self[cmd[1]]
            elif cmd[0]==6: #call
                jmp_ip=self[cmd[1]]
               # print('jmp:',jmp_ip)
                if jmp_ip==None:
                    jmp_ip=cmd[1][3]               #[mode,name,offset,key]ï¼Œå–å‡ºkey
                if type(jmp_ip)==Func:   #ä»£è¡¨è¦callå…§éƒ¨function
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    jmp_ip(*args,**kwargs)
                elif type(jmp_ip)==str:              #exfunction
                  #  print('exfunc')
                    args = self.data[args_location]
                    kwargs = self.data[kwargs_location]
                    tem_ip=self.data[ip]
                    self.data[0] = self.ex_function[jmp_ip](*args, **kwargs)  # å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                  #  print('get:',self.data[0])
                    self.data[ip]=tem_ip
                else:                                  #jmp_ipæ˜¯functionæœ¬èº«
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    tem_ip = self.data[self.ip]
                    #-------------------------------------------catch print
                    try:
                        call_func_name=jmp_ip.__name__
                    except:call_func_name=''
                    if call_func_name == 'print':
                        aprint(*args, **kwargs)
                    #-------------------------------------------
                    self.data[0]=jmp_ip(*args,**kwargs)            #å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                    self.data[self.ip] = tem_ip
            elif cmd[0] == 7:#push
                self.esp_stack[self.data[esp]]=self[cmd[1]]
                self.data[esp]-=1
            elif cmd[0] == 8:#pop
                self.data[esp] += 1
                self[cmd[1]]=self.esp_stack[self.data[esp]]
            elif cmd[0]==9:  #tfåˆ¤æ–·çœŸå‡
                event=self[cmd[2]]
                if event==0: #in
                    self.data[TF]=self[cmd[3]] in self[cmd[1]]
                elif event==1: #equ
                    self.data[TF]=self[cmd[3]]==self[cmd[1]]
                elif event ==2: # Ctn
                    self.data[TF] = self[cmd[3]] in self[cmd[1]].vars
                elif event ==3: # is
                    self.data[TF] = self[cmd[3]] is self[cmd[1]]
            elif cmd[0] == 10: #inc
                self[cmd[1]] += 1
            elif cmd[0] == 11:#dec
                self[cmd[1]] -= 1
            elif cmd[0]==12: #$oper
                op=self[cmd[2]]
                if op== 0:  # not
                    try:                                  #ç”¨tryæ˜¯æ€•ç‰©ä»¶ç„¡æ³•è½‰æ›:'NoneType' object cannot be interpreted as an integer
                        self[cmd[1]] = not self[cmd[1]]
                    except:
                        self[cmd[1]]=False
                elif op == 1:  #           è² æ•¸
                    self[cmd[1]] = -self[cmd[1]]
                elif op==2:  #          è£œæ•¸
                    self[cmd[1]] = ~self[cmd[1]]

            elif cmd[0]==13:                              #ex_func AX funcname BX
                tem_ip=self.data[ip]
                self[cmd[1]]=self.ex_function[self[cmd[2]]](self[cmd[3]])
                self.data[ip]=tem_ip
            elif cmd[0]==14: #--------------------------------------------------------------------------try
                error_ip=self[cmd[1]]
                if error_ip=='end':
                   # del self.run_layer[-1]                #tryæ­£å¸¸å¾Œæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return     #try end
                self.data[ip] += 1
                tem_esp=self.data[esp]           #å„²å­˜ç•¶å‰esp
                try:
                    self.__run(f'try {error_ip}')              #å¯èƒ½åœ¨å †ç–Šéç¨‹ä¸­æ–·
                                                               #å¯èƒ½å‡ºç¾yieldä¸­æ–·ï¼Œespè®Šå‹•
                except Exception as e:
                    self.error_line=self.data[ip]       #è¨»è¨˜ç™¼ç”ŸéŒ¯èª¤çš„ip
                    self.data[esp] = tem_esp  # é‚„åŸåŸæœ¬çš„esp
                    self.data[ER]=e
                    self.data[ip] = error_ip     #é‡åˆ°éŒ¯èª¤æ™‚ï¼Œè·³åˆ°åµéŒ¯ip
                del self.run_layer[-1]                   #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€del
            elif cmd[0]==15:  #finally
                f_ip=self[cmd[1]]
                finally_box.append((f_ip,self.data[self.esp]))
            elif cmd[0]==16: #raise
                raise self[cmd[1]]       #é€²å…¥exceptæœƒè‡ªå‹•delæ‰run_layer
            elif cmd[0]==17:  #error
                error=self[cmd[1]]
                if type(error)==list:
                    if Exception in error:
                        self.data[TF]=True
                    else:self.data[TF]=type(self.data[ER]) in error
                elif error==Exception:
                    self.data[TF]=True
                else:
                    self.data[TF] = type(self.data[ER])==error
            elif cmd[0]==18:  #Generator
                start_ip=self[cmd[2]]
                ex_k=3
                import_names={}   #(loc,stack)
                while ex_k<len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]
                    ex_k+=1
                self[cmd[1]]=generator(self,start_ip,import_names)
            elif cmd[0]==19:  #Yield
                if self.run_layer[-1]=='finally yield run':
                    raise Exception("Exception ignored in: <generator object>\nRuntimeError: generator ignored GeneratorExit")
               # del self.run_layer[-1]                    #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                return self.data[ip]+1,finally_box
            elif cmd[0] == 20:         #-------------------------------------------------------------- fetch
                tem_esp = self.data[esp]  # å„²å­˜ç•¶å‰esp
                tem_ip=self.data[ip]      #æš«å­˜ç•¶å‰ip
                try:
                    get=self[cmd[2]]
                    self[cmd[1]]=next(get)
                    self.data[TF]=True                 #æˆåŠŸ
                except StopIteration as e:                              #å› ç‚ºå‰é¢çš„tryæ²’æœ‰é™„åŠ run layerï¼Œæ­¤è™•exceptä¸æ¸…ç†ä»»ä½•run layer
                    self.data[TF]=False
                self.data[esp]=tem_esp
                self.data[ip]=tem_ip           #fetchçµæŸå¾Œç†è«–ä¸Šipä¸è®Š
            elif cmd[0]==21:  #stop
                print('ip---->',self.data[self.ip],'esp------>',self.data[self.esp])
              #  if self.tf!=1:
               #     get_status()
               # input()
               # self.tf=1
            elif cmd[0]==22:      #end
                command=self[cmd[1]]
                if command=='finally_yield' and self.run_layer[-1]=='finally yield run':
                   # del self.run_layer[-1]                                              #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return
                elif command=='Function':
                    func_name=self[cmd[2]]
                    if len(cmd)>3:
                        items_str = self[cmd[3]].split(',')
                        items = list(map(int, items_str))
                        for i in items:
                            self.func_stack[func_name][i]=None       #abort params
            elif cmd[0]==23:     #byte
                self[cmd[1]]=self[cmd[2]].encode()
               # del self[cmd[1]]
            elif cmd[0]==24:     #del
                op=self[cmd[1]]
                if op==0:    #åˆªé™¤å–®å…ƒç´ 
                    self[cmd[2]]=Undefine()
                elif op==1:  #åˆªé™¤AX[BX]
                    del self[cmd[2]][self[cmd[3]]]
                elif op==2:                         #åˆªé™¤  XXX.attr
                    del self[cmd[2]].vars[self[cmd[3]]]
            elif cmd[0]==25:     #Function
                func_ip=self[cmd[2]]
                func_class_obj=self[cmd[3]]
                func_stack_name=self[cmd[4]]
                func_stack_len=self[cmd[5]]
                ex_k = 6
                import_names= {}  #è¦åŒ¯å…¥çš„çˆ¶å‡½æ•¸åç¨±
                while ex_k < len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]         #åœ¨å®£å‘Šæ™‚å°±å„²å­˜ç•¶å‰å †ç–Šè³‡è¨Š
                    ex_k += 1
                self[cmd[1]] = Func(self, func_ip,func_class_obj,func_stack_name,func_stack_len,import_names)
            elif cmd[0]==26: #pass
                pass
            elif cmd[0]==28:   #namespace
                var_box=self[cmd[3]].split(',')
                var_k=0
                var_dict={}
                for name in var_box:
                    var_dict[name]=var_k
                    var_k+=1
                stack=[Undefine()]*var_k
                namespace_name=self[cmd[2]]
                self.func_stack[namespace_name]=stack
                self[cmd[1]]=Namespace_stack(self,namespace_name,var_dict)
            elif cmd[0]==29:  #*args
                self[cmd[1]]=self[cmd[2]][self[cmd[3]]:]
            elif cmd[0]==30:  #kwargs
                key_dict=self[cmd[2]]
                not_need=self[cmd[3]].split(',')
                void_dict={}
                for key in key_dict:
                    if key not in not_need:
                        void_dict[key]=key_dict[key]
                self[cmd[1]]=void_dict
            elif cmd[0] == 31:  # module
                self[cmd[1]]=Ex_module(self[cmd[2]])
            elif cmd[0]==32:   #type
                self[cmd[1]].atype=self[cmd[2]]
            elif cmd[0]==33:   #name
                self[cmd[1]].name=self[cmd[2]]
            elif cmd[0] == 34:  #repl_print
                item=self[cmd[1]]
                if item!=None:
                    print(item)
                    total_output.append(str(item))
            self.data[ip]+=1
            if -self.data[esp]>self.stack_size:
                raise RecursionError('maxinum recursion depth exceeded')
        #del self.run_layer[-1]       #delè®“__runçš„è«‹æ±‚è€…delæ‰å°±å¥½ï¼Œè‡ªå·±ä¸ç”¨del
        if self.tf>0:
            get_status()
class Ex_module:    #å¼•å…¥å¤–éƒ¨å‡½æ•¸
    def __init__(self,module_name):
        self.module_name=module_name
        self.__name__='Ex_module'
        self.vars={}
    def __str__(self):
        return self.module_name
    def __call__(self, *args, **kwargs):
        raise TypeError("'module' object is not callable")
class Namespace_stack:
    def __init__(self,ram,stack_name,var_dict):
        self.stack_name=stack_name
        self.vars=namespace_stack_var(ram,stack_name,var_dict)
    def __str__(self):
        return f'module "{self.stack_name}"'
class namespace_stack_var:
    def __init__(self,ram,stack_name,var_dict):
        self.ram = ram
        self.name = stack_name
        self.var_dict = var_dict
    def __contains__(self, item):
        return item in self.var_dict
    def __setitem__(self, key, value):
        if key in self.var_dict:
            self.ram.func_stack[self.name][self.var_dict[key]]=value
        else:
            #ç™»è¨˜æ–°å±¬æ€§
            now_length=len(self.ram.func_stack[self.name])
            self.var_dict[key]=now_length
            self.ram.func_stack[self.name].append(value)            #åµŒå…¥æœ€å¾Œä¸€å€‹
    def __getitem__(self, item):
        return self.ram.func_stack[self.name][self.var_dict[item]]1197*110*ex_func.pyimport time     #time,sleep,ctime,localtime(tm_year,tm_mon,tm_mday,tm_hour,tm_min,tm_sec,tm_wday),gmtime,mktime,asctime,strftime,strptime
import math     #pi,e,ceil,floor,copysign,fabs,fmod,fsum,gcd,pow,sqrt,factorial,degrees,radians,sin,cos,tan,asin,acos,atan,exp,log,log1p,log2,log10,isclose,isfinite,isinf,isnan
import os       #getcwd,listdir,mkdir,chdir,rmdir,open,write,rename,remove,stat,close,path,system,walk,environ,_exit
import os.path  #isdir,isfile,abspath,basename,dirname,exists,getatime,getmtime,getctime,getsize,isabs,join,realpath,relpath,samefile,sameopenfile,samestat,split,splitext
import sys      #argv,platform,version_info,path,stdin,stdout,stderr,displayhook,exceptionhook,setrecursionlimit,setswitchinterval,settrace,setprofile
import random   #seed,getstate,setstate,getrandbits,randrange,randint,choice,choices,shuffle,sample,random,uniform,triangular,betavariate,expovariate,gammavariate,gauss,lognormvariate,normalvariate,vonmisesvariate,paretovariate,weibullvariate
#import requests #delete,get,head,patch,post,put,request
import socket   #socket(bind,listen,accept,send,recv),AF_INET,SOCK_STREAM,gethostname,gethostbyname,SOL_SOCKET,SO_REUSEADDR63564*19*module.py#åŸºæœ¬å‹æ…‹:
class Integer:                         #æ•´æ•¸
    def __init__(self,number):
        self.number=int(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class Float:                          #æµ®æ•´æ•¸
    def __init__(self,number):
        self.number=float(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class String:                          #å­—ä¸²
    def __init__(self,text,change=True):    #change:è‡ªå‹•æ”¹è®Š\',\nç¬¦è™Ÿ
        self.text=text
        self.change=change
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        if self.change:
            self.location=f'"{self.text}"'
        else:
            self.location=f"'{self.text}'"
class Byte:                          #å­—ä¸²
    def __init__(self,text):
        self.text=text
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        codes.append(f'byte AX "{self.text}"')
        self.location=f'AX'
class Var_name:
    def __init__(self,name):           #è®Šæ•¸å
        self.name=name
    def __str__(self):
        return f'{self.name}'
#é€šç”¨è®Šæ•¸å‹æ…‹
class Namespace:
    def __init__(self,namespace=''):
        self.namespace=namespace
    def __str__(self):
        return f'{self.namespace}'
    def __eq__(self, other):
        return self.namespace==other
    def __contains__(self, item):
        return item in self.namespace
    def write(self,codes):
        if self.namespace!='':
            self.location=self.namespace
class Variable:
    def __init__(self,name,namespace):     #codelineæ˜¯æŸæ®µæŒ‡ç¨±è®Šæ•¸
        self.namespace=namespace
        self.name=name
    def __str__(self):
        return f'<var={self.name}>'
    def write(self,codes):
        if self.namespace!='':
            self.namespace.write(codes)
            self.location=f'{self.namespace.location}.{self.name}'
        else:self.location=self.name
class SubVariable:                          #å±¬æ€§æŒ‡ç¨±è®Šæ•¸
    def __init__(self,obj,attr):
        self.obj=obj                 #ä»»æ„ç‰©ä»¶
        self.attr=attr               #variable
    def __str__(self):
        return f'<obj={self.obj}  attr={self.attr}>'
    def write(self,codes):
        self.obj.write(codes)
        olocation=self.obj.location
        if '.' in olocation or '[' in olocation or olocation[0] in ('"',"'"):     #å¤ªé•·ï¼Œæˆ–æ˜¯å­—ä¸²
            codes.append(f'mov AX {self.obj.location}      ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²')
            self.location = f'AX.{self.attr.name}'
        else:self.location=f'{self.obj.location}.{self.attr.name}'
class Slice:
    def __init__(self,start_obj,end_obj,step_obj):
        self.start_obj=start_obj
        self.end_obj=end_obj
        self.step_obj=step_obj
    def __str__(self):
        return '<slice>'
    def write(self,codes):
        codes.append('push [3]')
        self.start_obj.write(codes)
        codes.append(f'mov <esp+1>[0] {self.start_obj.location}')
        self.end_obj.write(codes)
        codes.append(f'mov <esp+1>[1] {self.end_obj.location}')
        self.step_obj.write(codes)
        codes.append(f'mov <esp+1>[2] {self.step_obj.location}')
        codes.append('pop *args')
        codes.append('mov **kwargs [dict]')
        codes.append('call slice')
        self.location='AX'
class IndexVariable:
    def __init__(self,name,slice_obj):      #[a1:a2,a1:,a3...] => [(a1,a2),(a1,None),a3...]
        self.name=name
        self.slice_obj=slice_obj    #å–®å…ƒç´  or tuple
    def __str__(self):
        return f'<Index {self.name} slice={self.slice_obj}>'
    def write(self,codes):
        self.name.write(codes)
        codes.append(f'push {self.name.location}')
        self.slice_obj.write(codes)
        codes.append(f'mov BX {self.slice_obj.location}')
        codes.append('pop AX')
        self.location='AX[BX]'
#ä¸²åˆ—æ‰“åŒ…å‹æ…‹:
class List:
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        box=[]
        for obj in self.elements:
            box.append(str(obj))
        return '<List  '+','.join(box)+'>'
    def __getitem__(self, j):
        if j<len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append(f'mov AX [{len(self.elements)}]')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location='AX'
class Tuple:
    def __init__(self, elements):
        self.elements = elements
    def __str__(self):
        box = []
        for obj in self.elements:
            box.append(str(obj))
        return '<Tuple  ' + ','.join(box) + '>'
    def __getitem__(self, j):
        if j < len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self, codes):
        codes.append(f'mov AX ({len(self.elements)})')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location = 'AX'
class Dict:
    def __init__(self,elements):  #[(key,value),...]
        self.elements=elements
    def __str__(self):
        box=[]
        for key,value in self.elements:
            box.append(f'{key}:{value}')
        return '<Dict  '+','.join(box)+'>'
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append('push [dict]')
        for key,value in self.elements:
            key.write(codes)
            codes.append(f'push {key.location}')
            value.write(codes)
            codes.append(f'pop BX')
            codes.append(f'mov <esp+1>[BX] {value.location}')
        codes.append('pop AX')
        self.location = 'AX'
class Set:                           #é›†åˆ
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        return '<set>'
    def write(self,codes):
        _tuple=Tuple(self.elements)
        _tuple.write(codes)
        codes.append(f'ex_func AX "set" {_tuple.location}')
        self.location='AX'
#é«˜éšæ‰“åŒ…å‹æ…‹:
def is_number(num):
    try:
        e=float(num)
        return True
    except:return False
class Lambda:
    def __init__(self,params,return_obj,namespace):
        self.params=params                   #{key:value,...}
        self.return_obj=return_obj
        self.namespace=namespace
    def __str__(self):
        return '<lambda>'
    def write(self,codes):
        tem_name = f'&lambda_{len(codes)}'
        _return=Backtrack(self.return_obj,'return')
        block_info=Info('')
        for key in self.params:
            block_info.add_info('var',Variable(key,''))
        block_info.codelines.append(_return)
        _def=Def(tem_name,self.params,block_info,self.namespace)
        _def.write(codes)
        if self.namespace == '':
            self.location=tem_name
        else:
            self.namespace.write(codes)
            loc=f'{self.namespace.location}.{tem_name}'
        #    codes.append(f'mov {loc} {tem_name}')
            self.location=loc
class Def:                                            #å‡½æ•¸å®šç¾©å‹æ…‹
    def __init__(self,fname,params,block_info,namespace):
        self.name=fname
        self.params=params        #{key:value,...}
      #  print('my params:',params)
        self.namespace = namespace
        self.codelines=block_info.codelines
        self.local_vars = block_info.locals
        self.in_class='^' in self.namespace
        self.orig_lines=('',0)
    def __str__(self):
        text=f'<Def {self.name}'
        vtext=[]
        for obj in self.codelines:
            vtext.append(str(obj))
        text+='{'+''.join(vtext)+'}'
        return text
    def write(self,codes):
        def get_name(string):
            sp='.[ ;'
            k,n=0,len(string)
            while k<n:
                if string[k] in sp:
                    return string[:k],string[k:]
                k+=1
            return string,''
        if self.namespace!='':                                 #å®£å‘Šè‡ªå·±çš„ç¨‹å¼é–‹å§‹ä½å€(<class>,ip)
            self.namespace.write(codes)
            declare_func=[len(codes),'BX',len(codes)+2,self.namespace.location,0]
            codes.append(0)
            codes.append(f'mov {self.namespace.location}.{self.name} BX')
        else:
            declare_func = [len(codes),self.name, len(codes) + 1,None, 0]
            codes.append(0)
        codes.add_tab()
        skip_ip=len(codes)                      #ä¸Šä¸€è¡Œçš„ç¨‹å¼éœ€è¦è·³éè‡ªå·±
        codes.append(0)             #é¡å¤–1
        #ç¨‹å¼é–‹å§‹å‰æº–å‚™------------------------------------------------------------
        self.func_var=f'{self.name}_{skip_ip}'       #è‡ªå·±çš„å †ç–Š
       # codes.append(f'push {self.func_var}')        #å°‡è‡ªå·±ä¸Šæ¬¡çš„espå­˜èµ·ä¾†
        codes.append('push **kwargs')
        codes.append('push *args')
        #é–‹è™•è™•ç†åƒæ•¸
        i=0      #ç´¯è¨ˆä½¿ç”¨åƒæ•¸æ•¸é‡
        keybox=[]   #ç´¯è¨ˆä½¿ç”¨åƒæ•¸å
      #  print('#############')
       # print(self.params)
        #print('namespace:',self.namespace)
        class_obj=None
        params=tuple(self.params)
        for key in params:
            if self.in_class and class_obj==None:                 #è‹¥æ˜¯classï¼Œæ“·å–ç¬¬ä¸€å€‹åƒæ•¸
                class_obj=key
                continue
            if key[:2]=='**':   #ä»£è¡¨æ˜¯kwargs
                key_text=','.join(keybox)
                codes.append(f'**kwargs <esp+2>["{key[2:]}"] <esp+2> "{key_text}"')
                self.params[key[2:]]=self.params[key]
                del self.params[key]
                keybox.append(key[2:])
            elif key[0]=='*':
                codes.append(f'*args <esp+2>["{key[1:]}"] <esp+1> {i}')
                self.params[key[1:]] = self.params[key]
                del self.params[key]
                keybox.append(key[1:])
            else:
                keybox.append(key)
                codes.append('cmp CX 0')
                skip_param=len(codes)
                codes.append(0)
                codes.append(f'tf <esp+2> "in" "{key}"')     #æŸ¥çœ‹keyæ˜¯å¦åœ¨å·²æœ‰åƒæ•¸ä¸­
                skip_param2=len(codes)
                codes.append(0)
                self.params[key].write(codes)
                codes.append(f'mov <esp+2>["{key}"] {self.params[key].location}')
                codes.append(f'jmp {len(codes)+2}')
                codes[skip_param]=f'$jmp {len(codes)-1} "!="'
                codes.append(f'mov <esp+2>["{key}"] <esp+1>[{i}]')
                codes.append('dec CX')
                codes[skip_param2]=f'$jmp {len(codes)-1} "t"'
                i+=1
        #è¨ˆç®—éparamçš„localæ•¸é‡
        local_num = 0
        local_dict = {}
        for key in self.params:
            local_num+=1
            local_dict[key]=local_num             #å°‡è‡ªå·±åƒæ•¸åŠ å…¥
        for var in self.local_vars:
            if var not in self.params and var not in local_dict:
                local_num+=1
                local_dict[var]=local_num
        declare_func[4]=local_num+1
        codes[declare_func[0]]=f'Function {declare_func[1]} {declare_func[2]} {declare_func[3]} "{self.func_var}" {declare_func[4]}'    #æ–°å»ºé™£åˆ—[0,1,2,3,...]
        #--------------------------------------------------------------------åœ°é»(åå­—)ï¼Œipï¼Œclass_obj,local_num+1,...
        return_ips=[]
        #çœŸæ­£çš„ç¨‹å¼é–‹å§‹----------------------------------------------------------------------------------åƒæ•¸ç§»å‹•
        codes.append(f'')
        for key in self.params:
            if key!=class_obj:
                #if key[:2]=='**':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[2:]}"]')
                #elif key[0]=='*':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[1:]}"]')
                #else:
                codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key}"]')
        yield_ip = len(codes)
        codes.append(0)  # é€™è£¡é€²è¡Œ2é¸ä¸€ï¼Œä»¥ç¨‹å¼ä¸­æ˜¯å¦æœ‰yieldä½œç‚ºåˆ¤æ–·
        codes.append(0)
        # çœŸæ­£çš„ç¨‹å¼é–‹å§‹--------------------------------------------------------------------------------------
        have_yield=False
        p = len(codes)
        for obj in self.codelines:
            obj.write(codes)             #æ¯ä¸€æ®µvoid_codeéƒ½æ˜¯ç¨ç«‹çš„
        def save_gen(num):
            if len(add_Function)>0 and num not in add_Function[-1][1]:
                add_Function[-1][1].append(num)
            if len(add_Generator)>0 and num not in add_Generator[-1][1]:
                add_Generator[-1][1].append(num)
    #------------------------------------------------------------------------------------ç¨‹å¼çµ„æ…‹è¨­å®š
        def in_global(word):
            for items in global_words:
                if word in items:
                    return True
            return False
        add_Generator=[]            #å…§å®¹:(len(codes),)
        add_Function=[]         #è‡ªå·±æœ‰å“ªäº›å­æ¶µæ•¸?è¦åœ¨é€™äº›å­æ¶µæ•¸çš„æ¨™æŠ•æ¬„æ·»åŠ è‡ªå·±åƒæ•¸çš„å †ç–Šåç¨±
        global_words=[[]]      #ç•¶è‡ªå·±æˆ–å­æ¶µæ•¸å®£å‘Šglobalæ™‚ï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal__words=[]     #è‡ªå·±æ‰€å®£å‘Šçš„nonlocal wordï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal_ips=[]       #è‡ªèº«å®£å‘Šnonlocalæ™‚çš„ipï¼Œ
        not_abort=[]                         #ä¸å¯åœ¨ç¨‹å¼çµæŸå¾Œå¾å †ç–ŠéŠ·æ¯€çš„è®Šæ•¸ï¼ŒåŒ…å«add_Generator,add_Function
        def parse_line(line):
            box=[]
            k,n=0,len(line)
            while k<n:
                p=k
                if line[p] in ('"',"'"):
                    c=line[p]
                    k=p+1
                    while line[k]!=c:
                        if line[k]=='\\':k+=1
                        k+=1
                    k+=1
                while k<n and line[k]!=' ':k+=1
                box.append(line[p:k])
                k+=1
            return box
        for i in range(len(codes)-p):
            line=codes[p+i]
            if '"' in line or "'" in line:
                deal=parse_line(line)
            else:
                deal=line.split(' ')
            if deal[0]=='return':           #è™•ç†return
                return_ips.append(p+i)
                continue
            elif deal[0]=='global':
                global_words[-1].append(deal[1])           #è¨»è¨˜globalï¼Œé€²å…¥å…¶ä»–functionæ™‚ï¼Œä¸å¯é€²è¡Œåƒæ•¸æ›¿æ›
          #      print(p+i,deal[1])
            elif deal[0]=='nonlocal':          #è‡ªå·±æ¨™è¨˜çš„nonlocal
                nonlocal__words.append(deal[1])
                nonlocal_ips.append(p+i)
         #       print(p+i,deal[1])
            if deal[0] == 'yield':
                deal[0] ='Yield'     #å°‡yieldæ›æˆYieldè¡¨ç¤ºè¢«è™•ç†é
                have_yield=True
            elif deal[0]=='Function':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Function.append((p+i,[]))
                global_words.append([])
            elif deal[0]=='Generator':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Generator.append((p+i,[]))
            elif deal[0]=='end':
                if deal[1]=='"Function"':          #å„²å­˜çµæœ
                    f_row,items=add_Function[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort+=items                    #å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        func_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[f_row]=codes[f_row]+func_add_text
                  #  print('------------------item:',items)
                    del add_Function[-1]
                   # print(f'{self.name} before del:',global_words)
                    del global_words[-1]
                elif deal[1]=='"Generator"':          #å„²å­˜çµæœ
                    g_row,items=add_Generator[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort += items  # å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        gen_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[g_row]=codes[g_row]+gen_add_text
                    del add_Generator[-1]
                continue
            for j in range(len(deal)):                      #å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                if j==0 or deal[j]=='':continue
                if deal[j][0] in ('"',"'"):   #ä»£è¡¨æ˜¯å­—ä¸²
                    continue
                if deal[j][0]==';':     #ä»£è¡¨æ˜¯è¨»è§£
                    break
                var,back=get_name(deal[j])
                if not in_global(var) and var not in nonlocal__words:
                    if var == '': break
                    elif var==class_obj:
                        deal[j]=f'<{self.func_var}+0>'+back
                       # deal.append(f'        ;æ­¤ç‚ºclass obj')
                        save_gen(local_num+4)
                    elif var in self.params:                     #è‡ªå·±çš„åƒæ•¸
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
                    elif var in self.local_vars:
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
            codes[p+i]=' '.join(deal)
        need_abort=[]
        for i in range(local_num+1):
            if i not in not_abort:
                need_abort.append(str(i))
        #---------------------------------------------------------------æ¸…é™¤nonlocalï¼Œä»¥å…è¢«å…¶ä»–function(çˆ¶å‡½æ•¸)è®€å–
        for non_ip in nonlocal_ips:
            codes[non_ip]=''
        #----------------------------------------------------------------------------------------------------------
        # returnå¾Œç›´é”ç¨‹å¼çµæŸ
        endip = len(codes)
        if len(return_ips)>0 and return_ips[-1]==endip-1:
            for rip in return_ips:
                codes[rip]=f'jmp {endip-1}         ;returné»'
        else:
            for rip in return_ips:
                codes[rip]=f'jmp {endip}'
            if have_yield:
                codes.append('mov AX ""')
            else:
                codes.append('mov AX None')            #return None
        #é‚„åŸå †ç–Šï¼Œreturn_ipè·³åˆ°æ­¤
        if have_yield:             #å¦‚æœæœ‰yieldï¼Œå‰‡return AXï¼Œä¸¦ä¸”ç™¼ç”ŸéŒ¯èª¤
            stopiteration=FuncCall(Variable('StopIteration',''),List([Variable('AX','')]),Dict({}))
            _raise=Backtrack(stopiteration,'raise')
            _raise.write(codes)
            codes.append('stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡Œ')
         #   codes.append(f'$mov esp "+" 1      ;ç¢ºä¿å¾raiseå¾Œå¯é›¢é–‹')
          #  codes.append('pop ip')
            codes[yield_ip] = f'Generator AX {yield_ip + 2} "{self.func_var}"'  # Generatoråœ°é»ï¼Œå§‹ipï¼Œè¦å„²å­˜çš„å †ç–Šåç¨±
            codes[yield_ip + 1] = f'jmp {len(codes) - 1}      ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ip'  # è·³åˆ°pop ip
            codes.append('end "Generator"')  # çµ„è­¯å™¨èªè¨€ï¼Œçµ¦è‡ªå·±çœ‹çš„
        else:
            codes[yield_ip] = ''  # f'$mov esp "-" {local_num}'                                        #æ­£å¸¸æƒ…æ³
            codes[yield_ip + 1] = ''  # f'mov {self.func_var} esp'
        #----------------------------------------------------------------å¦‚æœæœ‰yieldï¼Œå‰‡ç›´æ¥è·³åˆ°pop ip
        codes.append(f'$mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸')
        if have_yield:
            codes.append(f'end "Function" "{self.func_var}"')           #å› ç‚ºé‚„è¦é€²ä¾†ï¼Œå› æ­¤ä¸åˆªé™¤è‡ªèº«ä»»ä½•è®Šæ•¸
        else:
            codes.append(f'end "Function" "{self.func_var}" '+'"'+','.join(need_abort)+'"')        #åœ¨é€™è£¡ä¹‹å¾Œå°±ä¸ç”¨å†æ›¿æ›è®Šæ•¸äº†
        codes.append('pop ip')       #pop ipè·³åˆ°ç¨‹å¼æœ€å¾Œä¸€è¡Œreturn
        codes.del_tab()
        codes[skip_ip]=f'jmp {len(codes)-1}           ;è·³éæ­¤å‡½æ•¸'
class FuncCall:                                       #å‡½æ•¸å‘¼å«å‹æ…‹
    def __init__(self,name,args,kwargs,s_args=None,s_kwargs=()):  #name,args,kwargséƒ½æ˜¯objå‹æ…‹
        self.name=name
        self.args=args
        self.kwargs=kwargs
        self.s_args=s_args
        self.s_kwargs=s_kwargs
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Call {self.name} args={self.args} kwargs={self.kwargs}>'
    def __getitem__(self, item):
        return IndexVariable(Variable('AX',''),Integer(item))
    def write(self,codes):
        def deal_cx_args_kwargs(args,call_name):
            codes.append(f'push {len(args)}        ;å„²å­˜CX')  # ä¸åŒ…å«ï¼Œå°±å…¨æ¨
            args.write(codes)
            codes.append(f'push {args.location}  ;ç‚ºcall {call_name} åšæº–å‚™', simplify=self.in_class)
            if self.s_args != None:
                self.s_args.write(codes)
                codes.append(f'ex_func AX "list" {self.s_args.location}')    #AXè½‰ç‚ºé™£åˆ—
                codes.append(f'ex_func BX "len" AX')     #BXç‚ºé™£åˆ—é•·åº¦
                codes.append('$mov <esp+2> "+" BX')       #åŸCXå¢åŠ 
                codes.append('$mov <esp+1> "+" AX')       #AXå¢åŠ 
            self.kwargs.write(codes)
            if len(self.s_kwargs)>0:
                codes.append(f'push {self.kwargs.location}')
                for s_kwargs in self.s_kwargs:
                    s_kwargs.write(codes)
                    codes.append('mov *args [1]')
                    codes.append(f'mov *args[0] {s_kwargs.location}')
                    codes.append('mov **kwargs [dict]')
                    codes.append('call <esp+1>.update')
                codes.append('pop **kwargs')
            else:
                codes.append(f'mov **kwargs {self.kwargs.location}')
            codes.append('pop *args')
            codes.append(f'pop CX     ;å–å›CX')  # æ‰¹æ¬¡è®“Defè¼‰å…¥åƒæ•¸
            if need_push_name:
                codes.append('pop AX')
                codes.append('call AX')
            else:
                codes.append(f'call {call_name}')
        codes.append('',self.orig_lines)
        self.name.write(codes)
        self.in_class = '^' in self.name.location       #function callçš„namespaceåŒ…å«åœ¨nameä¸­
        need_push_name=self.name.location[:2]=='AX' or '&' in self.name.location
        if need_push_name:codes.append(f'push {self.name.location}')
        if self.in_class:
            space,name=self.name.location.split('.')
            codes.append(f'tf {space} "Ctn" "{name}"')    #æŸ¥çœ‹æ­¤å‡½æ•¸æ˜¯å¦åŒ…å«nameé€™å€‹function
            jmp_if_true=len(codes)          #åŒ…å«å°±è·³
            codes.append(0)
            #---------------------------------------------------å› ç‚ºä¸åŒ…å«ï¼Œæ‰€ä»¥å‘¼å«å¤–éƒ¨function
            deal_cx_args_kwargs(self.args,name)
            jmp_leave=len(codes)
            codes.append(0)
            #-----------------------------------------------------------------æœ‰åŒ…å«ï¼Œæ¨args[1:]ä¸¦å‘¼å«
            codes[jmp_if_true]=f'$jmp {len(codes)-1} "t"'
            args=List(self.args.elements[1:])     #è‹¥åŒ…å«ï¼Œå°±åªæ¨[1:]
            deal_cx_args_kwargs(args,self.name.location)
            #-------------------------------------------------------é›¢é–‹
            codes[jmp_leave]=f'jmp {len(codes)-1}'
        else:                                                     #-----------------------------ä¸åœ¨classè£¡çš„æ­£å¸¸æ¨¡å¼ä¸­
            deal_cx_args_kwargs(self.args,self.name.location)
        self.location='AX'
class Backtrack:           #å›å‚³
    def __init__(self,value,cmd):
        self.A=value
        self.cmd=cmd
        self.orig_lines=('',0)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location!='AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'{self.cmd} AX',self.orig_lines)
        self.location='AX'
class Var_declare:                      #è®Šæ•¸çš„å„ç¨®å®£å‘Š
    def __init__(self,value,cmd):      #del,global,nonlocal
        self.value=value
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.value}>'
    def write(self,codes):
        self.value.write(codes)
        if self.cmd=='del':
            if '.' in self.value.location:     #XXX.attr
                class_obj,key=self.value.location.split('.')
                codes.append(f'del 2 {class_obj} "{key}"')
            elif self.value.location[:3]=='AX[':    #AX[BX]
                codes.append('del 1 AX BX')
            else:
                codes.append(f'del 0 {self.value.location} None')
        else:
            codes.append(f'{self.cmd} {self.value.location}')
class Try_Except:
    def __init__(self,try_codelines,except_objects,else_codelines=(),finally_codelines=(),namespace=''):   #except_dict:{error_term:(as_name,codelines) }
        self.try_codelines=try_codelines
        self.except_objects=except_objects
        self.else_codelines=else_codelines
        self.finally_codelines=finally_codelines               #å³ä½¿exceptæ²’æŠ“åˆ°éŒ¯èª¤ï¼Œä¹Ÿå¿…å®šæœƒåŸ·è¡Œï¼Œç„¶å¾Œæ‰ç”¢ç”ŸéŒ¯èª¤
        self.namespace=namespace
        self.orig_lines = []
    def __str__(self):
        return f'<Try Except>'
    def write(self,codes):
        ol=0
        to_finally_ip=len(codes)               #å®£å‘Šå¿…å®šå¾—è¦åŸ·è¡Œçš„finallyä½ç½®
        codes.append(0,self.orig_lines[ol])   #finally ip
        to_except_ip=len(codes)                                     #try error_ip
        codes.append(0)   #try except_ip
        #----------------------------------------------**åƒæ•¸è’é›†ç®±
        SD = {'continue': [], 'break': [], 'return': []}        #å…¨åŸŸè’é›†
        yield_box=[]                                            #åªè™•ç†tryä¸­çš„
        #----------------------------------------é–‹å§‹å¯«try
        start_p=len(codes)                                 #é–‹å§‹æª¢æŸ¥çš„åŸºåº•p
        codes.add_tab()
        for obj in self.try_codelines:
            obj.write(codes)
        codes.del_tab()
        ol+=1
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†tryä¸­yield
            cmd = codes[start_p+i].split(' ')[0]
            if cmd=='yield':
                yield_box.append(start_p+i)
        #----------------------------------------
        codes.append('try "end"')           #åœæ­¢try
        try_leave = len(codes)                               # -----------------è·³åˆ°else
        codes.append(0)
        #-----------------------------------------é–‹å§‹å¯«except
        if self.namespace!='':
            self.namespace.write(codes)
            ispace=f'{self.namespace.location}.'
        else:ispace=''
        e=0
        try_except_ip = f'try {len(codes) - 1}'
        try_push_0= []
        jmp_push_0=[]
        jmp_push_1 = []  # æ”¶é›†å¾exceptçµæŸé€šå¾€finallyçš„ip
        for i in range(len(self.except_objects)+1):            #(obj,as_name,codelines)
            if e==0:
                codes[to_except_ip]=try_except_ip
                e=1
            else:
                codes[to_except_ip] = f'$jmp {len(codes) - 1} "f"'
            if i<len(self.except_objects):
                codes.append('', self.orig_lines[ol])
                ol += 1
                error_data = self.except_objects[i]
                error_data[0].write(codes)
                codes.append(f'error {error_data[0].location}')
                to_except_ip=len(codes)
                codes.append(0)
                if error_data[1]!=None:            #ä»£è¡¨æœ‰as
                    codes.append(f'mov {ispace}{error_data[1]} $Exception')
                codes.append('mov $Exception 0')               #æ¸…ç©ºException
                #---------------------------------exceptå…§å®¹é–‹å§‹
                try_push_0.append(len(codes))
                codes.append(0)
                codes.add_tab()
                for obj in error_data[2]:
                    obj.write(codes)
                codes.del_tab()
                codes.append('try "end"')
                jmp_push_1.append(len(codes))
                codes.append(0)
            else:                     #åŸ·è¡Œåˆ°æ­¤ä»£è¡¨éŒ¯èª¤éƒ½æ²’æœ‰è¢«æŠ“åˆ°
                jmp_push_0.append(len(codes))              #ç›´æ¥è·³åˆ°push 0
                codes.append(0)
                #_raise=Raise(Variable('$Exception',''))
                #_raise.write(codes)
        # -------------------------------è™•ç†tryä¸­çš„yield
        for yield_ip in yield_box:
            codes[yield_ip]=f'jmp {len(codes)-1} ;è™•ç†tryä¸­çš„yield'
            codes.append('try "end"')
            codes.append('yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡')
            codes.append(try_except_ip)
            codes.append(f'jmp {yield_ip}     ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œ')
        #--------------------------------------------------é–‹å§‹å¯«else
        jmp_to_finally=[]
        codes[try_leave]=f'jmp {len(codes)-1}    ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°else'
        if len(self.else_codelines) > 0:
            codes.append('',self.orig_lines[ol])
            ol+=1
            codes.add_tab()
            try_push_0.append(len(codes))
            codes.append(0)
            for obj in self.else_codelines:
                obj.write(codes)
            codes.append('try "end"')
            codes.del_tab()
        push_1=len(codes)-1
        for jp0 in jmp_push_1:
            codes[jp0]=f'jmp {push_1}  ;è·³åˆ°push 1'
        codes.append('push None  ;æ¨å…¥None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 1     ;ä»£è¡¨æ­£å¸¸')
        jmp_to_finally.append(len(codes))
        codes.append(0)
        #-------------------------#è™•ç†continue,break,return
        stype_SD={}
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†try,except,elseä¸­çš„continue,break,return
            if type(codes[start_p+i])==str:
                cmd = codes[start_p+i].split(' ')[0]
                if cmd in SD:
                    SD[cmd].append(start_p+i)
        stype=2
        for key in SD:
            if len(SD[key])>0:
                jmp_ip = len(codes)-1
                for ip in SD[key]:
                    codes[ip]=f'jmp {jmp_ip}'
                if key=='return':
                    codes.append('push AX')
                else:
                    codes.append('push None')        #å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
                codes.append('try "end"')  # åœæ­¢try
                codes.append(f'push {stype}')
                jmp_to_finally.append(len(codes))
                codes.append(0)                       #jmp to_finally
                #é€²è¡Œè¨»å†Š
                stype_SD[stype]=key
                stype+=1
        #-------------------------æ”¶é›†æ‰€æœ‰éŒ¯èª¤é€²ä¾†è€…
        push_0= len(codes) - 1
        for tp0 in try_push_0:
            codes[tp0]=f'try {push_0}'
        for jp0 in jmp_push_0:
            codes[jp0]=f'jmp {push_0} ;push 0'
        codes.append('push None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 0')
        #--------------------------------------------------------------------------é–‹å§‹å¯«finally
        finally_ip=len(codes)-1
        codes[to_finally_ip]=f'finally {finally_ip}'
        for jtf in jmp_to_finally:
            codes[jtf]=f'jmp {finally_ip}    ;è·³åˆ°finally'
        codes.append(f'finally -{finally_ip}')
        finally_p=len(codes)
        if len(self.finally_codelines)>0:
            codes.append('push $Exception')        #å„²å­˜éŒ¯èª¤è¨Šæ¯
            codes.append('mov $Exception 0')
            codes.append('', self.orig_lines[ol])
            ol += 1
            codes.add_tab()
            for obj in self.finally_codelines:
                obj.write(codes)
            codes.del_tab()
          #  codes.append('pop $Exception')        #å–å›éŒ¯èª¤è¨Šæ¯
        #-------------------------------æŠ“å–finallyä¸­çš„continue(å¯¦éš›ä¸å‡ºç¾)ï¼Œbreakï¼Œreturn
        finally_events={'continue':[],'break':[],'return':[]}
        for i in range(len(codes)-finally_p):                    #---------------------------------è™•ç†tryä¸­yieldï¼Œå¼·åˆ¶æ·¨åŒ–ä¹‹å‰çš„æ•ˆæœ
            if type(codes[finally_p+i])==str:
                cmd = codes[finally_p+i].split(' ')[0]
                if cmd in finally_events:
                    finally_events[cmd].append(finally_p+i)
        #-------------------------------------è™•ç†ä¹‹å‰pushçš„é—œéµè©ï¼Œæ­¤è™•ç‚ºä¸­é–“æ²’æœ‰breakæˆ–returnä¸­æ–·çš„å¾ŒçºŒ
        if len(self.finally_codelines)>0:
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
        codes.append('pop AX')
        leave_SD={}
        for stype in stype_SD:
            codes.append(f'cmp AX {stype}')
            leave_SD[len(codes)]=stype_SD[stype]
            codes.append(0)
        codes.append('cmp AX 1')
        jmp_to_leave=len(codes)
        codes.append(0)
        codes.append('pop AX')                             #å¾0èµ°è‡³æ­¤ï¼Œé‚„åŸå †ç–Š
        _raise=Backtrack(Variable('$Exception', ''),'raise')
        _raise.write(codes)
        #--------------------------------
        for key in finally_events:            #å¾finallyä¸­breakæˆ–returnçš„äº‹ä»¶
            if len(finally_events[key])>0:
                jmp_ip=len(codes)-1
                for ip in finally_events[key]:
                    codes[ip]=f'jmp {jmp_ip}       ;è·³è‡³finallyä¸­çš„äº‹ä»¶:{key}'
                codes.append('$mov esp "+" 3')    #å»é™¤é—œéµè©ï¼Œç„¡è«–å…ˆå‰æ˜¯ç”šéº¼éƒ½ä¸é‡è¦(å›å‚³å€¼None,åˆ¤æ–·å€¼0,éŒ¯èª¤error)
                codes.append(key)
        #---------------------------------
        for lip in leave_SD:                        #å¾try,except,elseä¸­çš„continue,break,returnäº‹ä»¶
            codes[lip]=f'$jmp {len(codes)-1} "=="'                   #å¾2,3,4é›¢é–‹è‡³æ­¤
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
            codes.append('pop AX')                     #é‚„åŸAXå †ç–Š
            codes.append(leave_SD[lip])
        #--------------------------------
        codes[jmp_to_leave]=f'$jmp {len(codes)-1} "=="'            #å¾1é›¢é–‹è‡³æ­¤
        codes.append('pop AX')                          #é‚„åŸAXå †ç–Š
        codes.append('end "finally_yield"')
class With:
    def __init__(self,call_obj,orig_as_name,as_name,with_codelines,namespace):
        self.call_obj=call_obj
        self.orig_as_name=orig_as_name
        self.as_name=as_name
        self.with_codelines=with_codelines
        self.namespace=namespace
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<with>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        codes.add_tab()
        self.orig_as_name.write(codes)
        self.call_obj.write(codes)    #å®šç¾©å¥½åƒæ•¸argså’Œkwargsï¼Œpush ip,call (<class>,ip)
        codes.append(f'mov {self.orig_as_name.location} {self.call_obj.location}')
       # codes.append('stop')
        _enter_call=FuncCall(Variable(f'{self.orig_as_name.location}.__enter__',''),List([]),Dict({}))       #æœƒå…ˆpush ipå†callï¼Œæ•…é¡åˆ¥ä½ç½®ç‚º<esp+2>
        _enter_call.write(codes)
        if self.as_name!=None:                          #as_nameç²å–__enter__æ‰€å›å‚³çš„æ±è¥¿
            codes.append(f'push {_enter_call.location}')
            self.as_name.write(codes)
            codes.append(f'pop {self.as_name.location}')
        #--------------------------------------------------------------------
        try_codelines=self.with_codelines
        except_objects=[]
        else_codelines = []            #ç•¶å‰å †ç–Š:<class_obj>,(finallyçš„returnç‰©ä»¶),stype,æ­¤functionæ‰€pushçš„ipï¼Œæ•…è¦å‘¼å«ä½ç½®ç‚º<esp+4>
        _exit_call = FuncCall(Variable(f'{self.orig_as_name.location}.__exit__', ''), List([TFN(None), TFN(None), TFN(None)]), Dict({}))
        finally_codelines =[_exit_call]
        _try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines)
        _try_except.orig_lines=[('',0),('',0),('',0)]
        _try_except.write(codes)
        codes.del_tab()
        #codes.append('inc esp     ;é‚„åŸwithçš„<class_objç‰©ä»¶>')
class Stop:
    def __init__(self):
        pass
    def __str__(self):
        return '<$stop>'
    def write(self,codes):
        codes.append('stop')
class Command:
    def __init__(self,cmd_list):
        self.cmd_list=cmd_list
    def __str__(self):
        return f'<cmd_list>'
    def write(self,codes):
        for cmd in self.cmd_list:
            codes.append(cmd)
class sub_if_else:
    def __init__(self,event,true_item,false_item):           # A if B else C
        self.event=event
        self.true_item=true_item
        self.false_item=false_item
    def __str__(self):
        return f'<A if else B>'
    def write(self,codes):
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        jne_false=len(codes)
        codes.append(0)
        self.true_item.write(codes)
        if self.true_item.location!='AX':
            codes.append(f'mov AX {self.true_item.location}   ;true item')
        leave_ip=len(codes)
        codes.append(0)
        codes[jne_false]=f'$jmp {len(codes)-1} "!="   ;è·³åˆ°false'
#        print('false item:',self.false_item)
        self.false_item.write(codes)
 #       print('location:',self.false_item.location)
        if self.false_item.location!='AX':
            codes.append(f'mov AX {self.false_item.location}   ;false item',simplify=1)   #ä¸‹ä¸€è¡Œå¯èƒ½æœƒmov item AXï¼Œæœƒè¢«ç°¡åŒ–å°è‡´éŒ¯èª¤
        codes[leave_ip]=f'jmp {len(codes)-1}   ;é›¢é–‹sub_if_else'
        self.location='AX'
class If_else:                                        #if,elseå‹æ…‹
    def __init__(self,if_items,else_codelines):     #if_items=[[event_obj,codelines],...]
        self.if_items=if_items
        self.else_codelines=else_codelines
        self.orig_lines=[]
    def __str__(self):
        text=[f'if {self.if_items[0][0]}:']
        for obj in self.if_items[0][1]:text.append(str(obj))
        for i in self.if_items[1:]:
            text.append(f'elif {i[0]}:')
            for obj in i[1]:text.append(str(obj))
        if len(self.else_codelines)>0:
            text.append('else:')
            for obj in self.else_codelines:text.append(str(obj))
        return ''.join(text)
    def write(self,codes):
        need_set_end=[]
        ol=0
        for event,block in self.if_items:
            codes.append('',self.orig_lines[ol])
            ol+=1
            event.write(codes)          #é€²è¡Œæ¢ä»¶é‹ç®—
            codes.append(f'cmp {event.location} 1')
            codes.add_tab()
            jip=len(codes)
            codes.append(0)                         #jneæ¢ä»¶è¢«å¦å®šæ™‚è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·
            for obj in block:obj.write(codes)       #æ¢ä»¶æˆç«‹å‰‡ç¹¼çºŒåŸ·è¡Œ
            need_set_end.append(len(codes))         #åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³åº•éƒ¨
            codes.append(0)
            codes[jip]=f'$jmp {len(codes)-1} "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·'          #ä¸‹ä¸€å¥åˆ¤æ–·çš„ä½ç½®
            codes.del_tab()
        if len(self.else_codelines)>0:
            codes.append('',self.orig_lines[ol])
            codes.add_tab()
            for obj in self.else_codelines:obj.write(codes)               #çµæŸåŸ·è¡Œ
            codes.del_tab()
        for ip in need_set_end:
            codes[ip]=f'jmp {len(codes)-1}        ;è·³è‡³åº•éƒ¨'           #è¨­å®šåº•éƒ¨
class While:                                          #whileå‹æ…‹
    def __init__(self,event,codelines,else_codelines):
        self.event=event
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return f'event:{self.event} do:{self.codelines}'
    def write(self,codes):
        again_ip=len(codes)
        codes.append('',self.orig_lines)
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        codes.add_tab()
        out_ip=len(codes)
        codes.append(0)          #ä¸æ˜¯Trueï¼Œè·³å‡ºè¿´åœˆ
        break_box=[]
        for obj in self.codelines:
            p=len(codes)
            obj.write(codes)
            for i in range(len(codes)-p):
                cmd=codes[p+i].split(' ')[0]
                if cmd=='continue':
                    codes[p+i]=f'jmp {again_ip-1}'     #continueè·³å›é–‹é ­
                elif cmd=='break':
                    break_box.append(p+i)
        codes.append(f'jmp {again_ip-1}               ;continueé‡ä¾†')     #é‡ä¾†
        #----------------------------------------
        to_else_ip=len(codes)-1
        codes[out_ip]=f'$jmp {to_else_ip} "!="'              #åœ¨whileåˆ¤å®šç‚ºFalseæ™‚ï¼Œè·³åˆ°else
        for obj in self.else_codelines:
            obj.write(codes)
        #----------------------------------------
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip]=f'jmp {break_ip}          ;breakå‡º'
        codes.del_tab()
class sub_for_loop:
    def __init__(self,express,vnames,base_obj,if_obj,is_list):
        self.express=express
        self.vnames=vnames
        self.base_obj=base_obj
        self.if_obj=if_obj
        self.is_list=is_list
    def __str__(self):
        return '<sub for loop>'
    def write(self,codes):
        _yield=Backtrack(self.express,'yield')        #expresséè³¦å€¼è®Šæ•¸ï¼Œä¸ç”¨è¨»å†Š
        if self.if_obj!=None:
            _if=If_else([[self.if_obj,[_yield]]],[])
            _if.orig_lines=[('',0),('',0),('',0)]
            _for_loop=For_loop(self.vnames,self.base_obj,[_if],[])
        else:
           # print(self.vnames)
          #  print(self.base_obj)
            _for_loop = For_loop(self.vnames, self.base_obj, [_yield],[])
        info = Info('')
        for var in self.vnames:
            info.add_info('var', var)
        info.write(_for_loop,('',0))
        id=len(codes)
        fDef=Def(f'&generator_{id}',{},info,'')      #functionæœ¬èº«ä¸æœƒè¢«å…¶ä»–ç‰©ä»¶å‘¼å«ï¼Œä¸éœ€è¦namespaceï¼Œ&ä»¥len(codes)ä½œç‚ºæ¨™èªŒï¼Œä¸æœƒæ‰¾éŒ¯
        fDef.write(codes)
        codes.append('push 0        ;å„²å­˜CX')
        codes.append('push [0]')
        codes.append('mov **kwargs [dict]')
        codes.append('pop *args')
        codes.append('pop CX     ;å–å›CX')
        codes.append(f'call &generator_{id}')
#        fcall=FuncCall(Variable(f'&generator_{id}',''),List([]),Dict({}))
 #       fcall.write(codes)
        if self.is_list:
            codes.append(f'ex_func AX "list" AX')
        self.location='AX'
class For_loop:                                       #for,loopå‹æ…‹
    def __init__(self,vnames,base_obj,codelines,else_codelines):                 #varuables=[name1,name2,...]
        self.vnames=vnames
        self.base_obj=base_obj
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return '<For loop>'
    def write(self,codes):
        self.base_obj.write(codes)
        #base_obj_name=f'&base_obj_{len(codes)}'
        codes.append(f'ex_func AX "iter" {self.base_obj.location}',self.orig_lines)                        #å°‡base_objè½‰ç‚ºiterå­˜èµ·ä¾†
        codes.add_tab()
        codes.append('push AX')
       # codes.append('stop')
        #-------------------------------
        again_ip=len(codes)                           #æ¯ä¸€åœˆçš„èµ·å§‹é»
        codes.append(f'fetch AX <esp+1>')                                           #å¾base_objå–å‡ºä¸€å€‹å€¼åˆ°AXï¼Œå–å‡ºæˆåŠŸæ™‚TF=1ï¼Œå¦å‰‡TF=0
        leave_ip=len(codes)                             #æ¯”è¼ƒç™¼ç¾ç„¡æ³•å–å‡ºæ±è¥¿è·³å‡º
        codes.append(0)
        if len(self.vnames)==1:                                  #é–‹å§‹åˆ†é…åƒæ•¸
            self.vnames[0].write(codes)
            codes.append(f'mov {self.vnames[0].location} AX')
        else:
            #codes.append('mov AX <esp+3>[CX]')
            for i in range(len(self.vnames)):
                self.vnames[i].write(codes)
                codes.append(f'mov {self.vnames[i].location} AX[{i}]')
        #---------------------------------------------------------å‡½æ•¸é–‹å§‹
        break_box = []
        return_box=[]
        for obj in self.codelines:
            p = len(codes)
            obj.write(codes)
            for i in range(len(codes) - p):
                cmd = codes[p + i].split(' ')[0]
                if cmd == 'continue':
                    codes[p + i] = f'jmp {again_ip - 1}'  # continueè·³å›é–‹é ­
                elif cmd == 'break':
                    break_box.append(p + i)
                elif cmd=='return':                   #æ­¤æ™‚è¦returnçš„ç‰©ä»¶å·²ç¶“å­˜åœ¨AX
                    return_box.append(p+i)
        codes.append(f'jmp {again_ip-1}')
        #-------------------------------------è¿´åœˆçµæŸ
        if len(return_box)>0:
            return_leave_ip=len(codes)                      #æ‰€æœ‰returnéƒ½è·³åˆ°é€™è£¡
            for r_ip in return_box:
                codes[r_ip]=f'jmp {return_leave_ip-1}'
            codes.append('inc esp')                       #é‚„åŸå †ç–Š
            codes.append('return AX')                       #è£œè¶³return
        #-------------------------------------breakæˆ–æ­£å¸¸é›¢é–‹åˆ°æ­¤
        out_ip=len(codes)-1
        codes[leave_ip] = f'$jmp {out_ip} "f"'                  # ç„¡æ³•å–å‡ºæ±è¥¿æ™‚ï¼Œtf=0ï¼Œè·³è‡³else
        for obj in self.else_codelines:
            obj.write(codes)
        #--------------------------------                   #ä¸­é€”breakçš„ç›´æ¥è·³å‡º
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip] = f'jmp {break_ip}          ;breakå‡ºè¿´åœˆ'
        codes.append('inc esp')                                     #é‚„åŸå †ç–Š
        codes.del_tab()
class Mark:                    #æ¨™èªŒ
    def __init__(self,mark):
        self.mark=mark
    def __str__(self):
        return f'<mark {self.mark}>'
    def write(self,codes):
        codes.append(self.mark)
class Pass:
    def __init__(self):
        pass
    def __str__(self):
        return '<pass>'
    def write(self,codes):
        pass
class TFN:                 #True,False,None
    def __init__(self,value):
        self.value=value
    def __str__(self):
        return f'<{self.value}>'
    def write(self,codes):
        self.location=self.value
class Class:
    def __init__(self,name,info,namespace,class_esp,father=None):
        self.name=name
        self.functions=info.funcs
        #for func_key in self.functions:
         #   self.functions[func_key].in_class=True
        self.codelines=info.codelines
        self.namespace=namespace
        self.class_esp=class_esp
        self.father=father
        self.orig_lines=('',0)
    def __str__(self):
        return f'<class {self.name}>'
    def write(self,codes):
        #codes.append('mov BX [func]',self.orig_lines)
       # set_ip=len(codes)
       # codes.append(0)
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'Function BX {len(codes) + 3} {self.namespace.location} "{self.class_esp}" 1', self.orig_lines)
            class_param=f'{self.namespace.location}.{self.name}'
            codes.append(f'mov {class_param} BX')
        else:
            class_param=self.name
            codes.append(f'Function {class_param} {len(codes) + 2} None "{self.class_esp}" 1', self.orig_lines)  # åœ°é»(åå­—)ï¼Œipï¼Œclass_obj
        codes.append(f'name {class_param} "<class \'__main__.{self.name}\'>"')     #è¨»å†Šé¡åˆ¥åç¨±
        codes.add_tab()
        skip_class_ip=len(codes)
        codes.append(0)                                           #è·³éè‡ªå·±
        #------------------------------------------------------
        codes.append('tf $Inheritance "equ" None')          #åˆ¤æ–·å‘¼å«è‡ªå·±çš„äººæ˜¯å¦è¦ç¹¼æ‰¿è‡ªå·±ï¼Œç”¨equå› ç‚ºæ€•inheritanceç‚ºundefined
        codes.append(f'$jmp {len(codes)+3} "t"')        #jt ip 'f'
        codes.append(f'mov <{self.class_esp}> $Inheritance')
        codes.append('push 1')              #è¦ç¹¼æ‰¿
        codes.append(f'jmp {len(codes)+2}')
        codes.append(f'mov <{self.class_esp}> [class]')
        codes.append('push 0')
        codes.append('mov $Inheritance None')      #æ¸…ç©ºç¹¼æ‰¿
        # ------------------------------------------------------å„²å­˜CX,args,kwargs
        codes.append('push CX')
        codes.append('push *args')
        codes.append('push **kwargs')  # å…ˆå°‡å®£å‘Šç”¨çš„argså’Œkwargså„²å­˜èµ·ä¾†
        #--------------------------------------------------------
        if self.father!=None:
            if type(self.father)==Tuple:
                deal=self.father.elements
            else:deal=[self.father]
           # print(deal)
            for father in deal:
                #-----------------------------åœ¨çˆ¶å‡½æ•¸writeå‰è¦å…ˆpush cx,args,kwargs
                father.write(codes)
                #------------------------------åœ¨callçˆ¶å‡½æ•¸å‰å…ˆå–å›åƒæ•¸
                codes.append('mov **kwargs <esp+1>')
                codes.append('mov *args <esp+2>')
                codes.append('mov CX <esp+3>')
                #------------------------------
                codes.append(f'mov $Inheritance <{self.class_esp}>')
                codes.append(f'call {father.location}')
        #------------------------------------------------------
        codes.append(f'type <{self.class_esp}> {class_param}')     #è¨»å†Šè‡ªå·±çš„é¡åˆ¥
        #é€²è¡Œå€åŸŸç‰©ä»¶å®£å‘Š
        for obj in self.codelines:
            obj.write(codes)
        #-------------------------------------------------------
        #åœ¨æ‰€æœ‰å‡½æ•¸å®£å‘ŠçµæŸå¾Œï¼Œå¦‚æœè‡ªå·±æœ‰å»ºç«‹__init__ï¼Œå°±é€²å…¥
        codes.append(f'mov AX <{self.class_esp}>')  # å–å›è‡ªå·±class
        codes.append('pop **kwargs')
        codes.append('pop *args')
        codes.append('pop CX')
        #----------------------------------------
        codes.append('pop BX')           #å–å›ç¹¼æ‰¿åˆ¤æ–·
        codes.append('cmp BX 1')         #åˆ¤æ–·æ˜¯å¦ç¹¼æ‰¿
        leave_init_ip=len(codes)
        codes.append(0)           #å¦‚æœè¦ç¹¼æ‰¿ï¼Œå°±è·³éinitã€‚$jmp ip "t"
        #----------------------------------------
        codes.append('tf AX "Ctn" "__init__"')             #æ˜¯å¦åŒ…å«__init__é€™å€‹å®£å‘Š?
        codes.append(f'$jmp {len(codes)+1} "t"')                 #å¦‚æœåŒ…å«initå°±call
        skip_init_ip=len(codes)
        codes.append(0)
        codes.append('call AX.__init__')
        codes.append(f'mov AX <{self.class_esp}>')                   #å–å›è‡ªå·±
        #------------------------------------------------------
        end=len(codes)-1
        codes[leave_init_ip]=f'$jmp {end} "=="'
        codes[skip_init_ip]=f'jmp {end}'
        codes.append(f'end "Function" "{self.class_esp}"')
        codes.append('pop ip')      #å›å»ç¨‹å¼çš„å®£å‘Šè™•
        #----------------------------------------------------------
        codes[skip_class_ip] = f'jmp {len(codes) - 1}'
        self.location='AX'
        codes.del_tab()
#è³‡æ–™ç§»è½‰å‹æ…‹
def two_object_write(A,B,codes):
    A.write(codes)
    if A.location[:3] == 'AX.' or A.location=='AX':  # Aç‚ºsubvariable
        codes.append('push AX')
        B.write(codes)
        codes.append(f'mov BX {B.location}')
        codes.append('pop AX')
        blocation = 'BX'
    elif A.location[:3] == 'AX[':  # Aç‚ºindexvariableï¼Œlocationå¿…ç‚ºAX[BX]
        codes.append('push AX')
        codes.append('push BX')
        B.write(codes)
        codes.append(f'mov DX {B.location}')
        codes.append('pop BX')
        codes.append('pop AX')
        blocation = 'DX'
    else:  # æ­£å¸¸æƒ…æ³
        B.write(codes)
        blocation = B.location
    return blocation
#class Mov:
#    def __init__(self,A,B,op='='):
#        self.A=A
#        self.B=B
##        cmd={'+=':'add','-=':'sub','*=':'mul','/=':'div','%=':'quo','//=':'rem','**=':'pow',
# #            '<<=':'shl','>>=':'shr','&=':'and','^=':'xor','|=':'or'}
#        if op=='=':
#            self.ctype=0
#            self.cmd='mov'
#        else:
#            self.ctype=1
#            self.cmd=op[:-1]     #å°‡ç­‰è™Ÿå»é™¤
#        self.orig_lines = ('', 0)
#    def __str__(self):
#        return f'<{self.cmd} {self.A} {self.B}>'
#    def write(self,codes):
#        codes.append('',self.orig_lines)
#        blocation=two_object_write(self.A,self.B,codes)
#        if self.ctype == 0:
#            codes.append(f'mov {self.A.location} {blocation}')
#        elif self.ctype == 1:
#            codes.append(f'$mov {self.A.location} "{self.cmd}" {blocation}')
class Multiple_Mov:
    def __init__(self,obj_list,target,op):
        self.obj_list=obj_list
        self.target=target
        if op == '=':
            self.ctype = 0
            self.cmd = 'mov'
        else:
            self.ctype = 1
            self.cmd = op[:-1]  # å°‡ç­‰è™Ÿå»é™¤
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<Multiple mov>'
    def write(self,codes):
        codes.append('', self.orig_lines)
        self.target.write(codes)
        codes.append(f'push {self.target.location}')
        for obj in self.obj_list:
            if type(obj) in (Tuple,List):
                for i in range(len(obj)):
                    obj[i].write(codes)
                    if self.ctype == 0:
                        codes.append(f'mov {obj[i].location} <esp+1>[{i}]')
                    elif self.ctype == 1:
                        codes.append(f'$mov {obj[i].location} "{self.cmd}" <esp+1>[{i}]')
            else:
                obj.write(codes)
                if self.ctype == 0:
                    codes.append(f'mov {obj.location} <esp+1>')
                elif self.ctype == 1:
                    codes.append(f'$mov {obj.location} "{self.cmd}" <esp+1>')
        codes.append('inc esp')          #é‚„åŸå †ç–Š
#é‹ç®—å‹æ…‹
class Oper:
    def __init__(self,A,B,symbol):
        self.A=A
        self.B=B
        self.symbol=symbol#{'+':'add','-':'sub','*':'mul','/':'div','**':'pow','%':'quo','//':'rem','<<':'shl','>>':'shr','&':'and','^':'xor','|':'or'}[symbol]
       # self.oper=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(symbol)
    def __str__(self):
        return f'<{self.A} {self.symbol} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'push {self.A.location}')
        self.B.write(codes)
        codes.append(f'oper <esp+1> "{self.symbol}" {self.B.location}')
        codes.append('pop AX')
        self.location = 'AX'
#é‚è¼¯é‹ç®—ç¬¦
class Tf:   #çœŸå‡åˆ¤æ–·å¼
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
       # self.oper=('in','equ','Ctn','is').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
       # print('tf:  ',self.A,self.B,self.cmd)
        blocation=two_object_write(self.A,self.B,codes)
        codes.append(f'tf {self.A.location} "{self.cmd}" {blocation}')    #Bæ˜¯å¦cmdåœ¨A
        codes.append('mov AX TF')
        self.location='AX'
class AndOr:
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'cmp {self.A.location} 1')          #ç›¸åŒå°±ç¹¼çºŒï¼Œå¦å‰‡è·³è‡³mov AX 0
        jip=len(codes)
        codes.append(0)
        self.B.write(codes)
        codes.append(f'cmp {self.B.location} 1')           #å¤±æ•—å°±è·³è‡³mov AX 0
        lip = len(codes)
        codes.append(0)
        if self.cmd=='and':       #å…©é‚Šéƒ½è¦Trueï¼Œjip,lipç‚ºFalseæ™‚è·³åˆ°0
            codes.append('mov AX 1')
            codes.append(f'jmp {len(codes)+1}')          #æˆåŠŸå°±è·³émov AX 0
            to_false=len(codes)-1
            codes.append('mov AX 0', simplify=1)
            codes[jip]=f'$jmp {to_false} "!="'
            codes[lip]=f'$jmp {to_false} "!="'
        elif self.cmd=='or':       #å…©é‚Šéƒ½è¦Falseï¼Œjip,lipç‚ºTrueæ™‚è·³åˆ°1
            codes.append('mov AX 0')
            codes.append(f'jmp {len(codes) + 1}')  # å¤±æ•—å°±è·³émov AX 1
            to_true = len(codes) - 1
            codes.append('mov AX 1', simplify=1)
            codes[jip] = f'$jmp {to_true} "=="'
            codes[lip] = f'$jmp {to_true} "=="'
        self.location='AX'
class Deny:       #å¦å®šoperator
    def __init__(self,A,cmd):
        self.A=A
        self.cmd=cmd
        #self.oper=('not','-','~').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location != 'AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'$oper AX "{self.cmd}"')
        self.location = 'AX'
#çœŸå‡åˆ¤æ–·ç¬¦
class Bool:
    def __init__(self,enequalbox):     #enebox=[var,==,var,!=,var...]
        self.enebox=enequalbox
    def __str__(self):
        text=''
        for i in self.enebox:
            text+=str(i)
        return text
    def write(self,codes):
        k=0
        self.enebox[0].write(codes)           #è¨ˆç®—ç¬¬ä¸€å€‹
        codes.append(f'push {self.enebox[0].location}')        #å°‡çµæœå­˜èµ·ä¾†
        need_set_end=[]
        need_set_tf=[]
        cmp_dict={'==':'f','!=':'t','>':'<=','<':'>=','>=':'<','<=':'>'}            #å¦å®šæ™‚è·³é›¢ç¬¦
        while k<len(self.enebox)-1:
            self.enebox[k+2].write(codes)             #è¨ˆç®—ç¬¬äºŒå€‹
            codes.append('pop DX')           #å°‡ç¬¬ä¸€å€‹çš„çµæœæ”¾åœ¨DX  (ä¸Šä¸€å€‹çš„çµæœå¯èƒ½åœ¨AX,AX[BX],xxx.attr)
            if self.enebox[k+1] in ('==','!='):
                codes.append(f'tf DX "equ" {self.enebox[k + 2].location}')
                need_set_tf.append((len(codes),cmp_dict[self.enebox[k+1]]))
            else:
                codes.append(f'cmp DX {self.enebox[k+2].location}')       #å°‡ç¬¬äºŒå€‹çš„å€¼èˆ‡ç¬¬ä¸€å€‹
                need_set_end.append((len(codes),cmp_dict[self.enebox[k+1]]))              #Trueå°±ç¹¼çºŒæ¯”è¼ƒä¸‹å»ï¼ŒFalseå‰‡è·³è‡³mov AX 0
            codes.append(0)                            #è‹¥æ¯”è¼ƒçµæœç‚ºFalseå‰‡è·³é›¢
            if k+3<len(self.enebox):
                codes.append(f'push {self.enebox[k+2].location}')        #å°‡ç¬¬äºŒå€‹çµæœçš„å€¼å­˜èµ·ä¾†
            k+=2
        codes.append('mov AX True')                         #ç•¶æ¢ä»¶æˆåŠŸåˆ°æœ€å¾Œï¼Œè¨­ç½®AXç‚º1
        codes.append(f'jmp {len(codes)+1}')                                     #è·³émov AX 0æŒ‡ä»¤
        end = len(codes)-1  # æ‰€æœ‰ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤è¡Œ
        codes.append('mov AX False',simplify=1)                #ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤ï¼Œè¨­ç‚ºFalse
        for i in need_set_end:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
        for i in need_set_tf:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
       # codes.append('dec esp')                       #å †ç–ŠæŒ‡æ¨™å›å»ä¸€å€‹
        self.location='AX'
#ç‰¹æ®ŠåŠŸèƒ½å‡½æ•¸
class Assert:
    def __init__(self,event,msg):
        self.event=event
        self.msg=msg
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<assert {self.event}, {self.msg}>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        not_event=Deny(self.event,'not')
        assertionerror = FuncCall(Variable('AssertionError', ''), List([self.msg]), Dict({}))
        _raise = Backtrack(assertionerror, 'raise')
        if_obj=If_else([[not_event,[_raise]]],[])
        if_obj.orig_lines=[('',0)]
        if_obj.write(codes)
class STR:
    def __init__(self,obj):
        self.obj=obj
    def __str__(self):
        return f'<STR: {self.obj}>'
    def write(self,codes):
        self.obj.write(codes)
        codes.append(f'ex_func AX "str" {self.obj.location}')
        self.location='AX'
#------------------------------------------------------------------ç¨‹å¼è³‡è¨Š
class Info:                             #ç”¨ä¾†è¨˜éŒ„parse_blockè³‡è¨Š
    def __init__(self,namespace):
        self.locals=[]
        self.vars={}
        self.funcs={}       #fname:fDef
        self.classes={}
        self.codelines=[]
        self.namespace=namespace
    def add_info(self,type,obj):
        if type=='var':
            self.vars[obj.name]=obj
        elif type=='func':
            self.funcs[obj.name]=obj
        elif type=='class':
            self.classes[obj.name]=obj
        if obj.name not in self.locals:
            self.locals.append(obj.name)
    def update(self,info):
        self.locals+=info.locals
        self.vars.update(info.vars)
        self.funcs.update(info.funcs)
        self.classes.update(info.classes)
    def write(self,codeline,orig_codelines):
        def deal_orig(orig_codeline):
            box = []
            for obj in orig_codeline:
                if type(obj)==int:
                    box.append(' '*obj)
                else:box.append(str(obj)+' ')
            return ''.join(box)
        self.codelines.append(codeline)
        #if type(orig_codelines)==list:
        #    nbox=[]
        #    for line in orig_codelines:
        #        nbox.append((deal_orig(line[0]),line[1]))
        #else:nbox=(deal_orig(orig_codelines[0]),orig_codelines[1])
        codeline.orig_lines=orig_codelines14*111*newtext.txt59891*110*package.py#æ‰“åŒ…ç¨‹å¼ç¢¼
from os import listdir,getcwd,chdir
from os.path import isdir,isfile
from apython.code import Code
from apython.module import *

def parse_code(code):  # æ‰“åŒ…ç¨‹å¼ç¢¼ç‚º[codeline_1,codeline_2,...]
    def hex_to_int(hex):
        string='0123456789abcdef'
        total,base=0,1
        for i in range(len(hex)):
            total+=string.index(hex[-i-i])*base
            base*=16
        return str(total)
    def deal_string(k,change=True):  # kç‚º',"çš„ä½ç½®
        c = code[k]
        k += 1
        p = k
        while True:
            c2=code[k]
            if c2=='\n':
                cline[0]+=1   #é¡å¤–åŠ ä¸€è¡Œ
            if c2 == '\\':
                k += 1
            elif c2 == c:
                break
            k += 1
        get_text=code[p:k]
       # print('c:',c,change)
        if (c=="'" and not change) or (c=='"' and change):      #ä»£è¡¨å…§å®¹æ‹¬è™Ÿç‚º"ï¼Œèˆ‡stringä¸€æ¨£
            return String(get_text,change=change),k
        elif c == "'" and change:
            text = []
            ck, n = 0, len(get_text)
            while ck < n:
                if get_text[ck]=='"':
                    text.append('\\')
                if get_text[ck]=='\\':
                    text.append(get_text[ck])
                    ck += 1
                text.append(get_text[ck])
                ck += 1
            return String(''.join(text),change=change), k
        elif c=='"' and not change:      #è£¡é¢å¯èƒ½æœ‰"
            text=[]
            ck,n=0,len(get_text)
            while ck<n:
                if get_text[ck]=='"':
                    text.append('\\')
                text.append(get_text[ck])
                if get_text[ck]=='\\':
                    text.append('\\')
                ck+=1
            return String(''.join(text)),k
    key_word=['def','while','for','in','if','elif','else','class','break','continue','return',':','and','not','or',
              'True','False','None','from','import','as','is','with','raise','try','except','finally','yield',
              'lambda','del','global','nonlocal','assert','$stop']        #ç„¡æ³•è¢«ç•¶æˆè®Šæ•¸çš„å…ƒç´ ï¼Œ$stopæ˜¯apythonèªè¨€
    data_dict = {'AX': 0, 'BX': 1, 'CX': 2, 'DX': 3, 'ip': 4, 'esp': 5, 'sp': 6, 'ZR': 7, 'TF': 8}      #codeä¸­çš„ç¦ç”¨é—œéµå­—åç¨±
    k, n = 0, len(code)
    codelines = []
    in_brackets=0
    in_lambda=0
    orig_code=code.split('\n')
    cline=[1]         #æ­¤ç‚ºçœŸå¯¦è¡Œ
    codeline = [(0,cline[0],orig_code[cline[0]-1])]                   #0ä»£è¡¨å‰ç½®ç©ºæ ¼æ•¸é‡,lineç‚ºç¬¬å¹¾è¡Œ,å¾Œæ–¹ç‚ºåŸå§‹ç¨‹å¼
    while k < n:
      #  print('codeline:',codeline)
      #  input()
        c = code[k]
        if c in '0123456789':  # ä»£è¡¨æ­¤ç‚ºæ•¸å€¼
            p = k
            numbers = '0123456789.xabcdefXABCDEF'
            while k < n:
                if code[k] in numbers:
                    k += 1
                else:
                    break
            number=code[p:k].lower()
            if number[:2]=='0x':
                number=hex_to_int(number[2:])
            if '.' in number:codeline.append(Float(number))
            else:codeline.append(Integer(number))
            k -= 1
        elif c in '+-*/,()[]{}!=%:><.&^|~':  # é‹ç®—å–®å…ƒç´ 
            if k+2<n:
                c3=code[k:k+3]
                if c3 in ('**=','//=','>>=','<<='):
                    codeline.append(c3)
                    k += 3
                    continue
            if k+1<n:
                c2=code[k:k+2]
                if c2 in ('+=','-=','*=','/=','==','!=','**','>','<','>=','<=','%=','//','>>','<<','&=','^=','|='):
                    codeline.append(c2)
                    k += 2
                    continue
            codeline.append(c)
            if c in ('(','[','{'):in_brackets+=1
            elif c in (')',']','}'):in_brackets-=1
            if c==':' and in_brackets==0: #-----------------------------------------------------------è™•ç†å†’è™Ÿ
                if in_lambda>0:
                    in_lambda-=1
                else:
                    try:
                        q=code.index('\n',k)        #å¦‚æœæ‰¾ä¸åˆ°\nä»£è¡¨æ˜¯æœ€å¾Œä¸€è¡Œäº†
                    except:q=len(code)
                    if q-k>1:
                        codelines.append(codeline)
                        #cline+=1                    #åœ¨åŒä¸€è¡Œï¼Œclineä¸åŠ ä¸€
                       # print('codeline:',codeline)
                        codeline = [(codeline[0][0]+4,cline[0],orig_code[cline[0]-1])]   #[(ç©ºæ ¼æ•¸,ç¬¬å¹¾è¡Œ,åŸå§‹ç¨‹å¼),...]
                        k+=1
                        while code[k]==' ':k+=1
                        k-=1
        elif c == '#':  # ç•¥éè¨»è§£
            while k < n and code[k] != '\n':
                k += 1
            k -= 1
        elif c in ('"', "'"):  # å­—ä¸²
            string,k=deal_string(k)
            if len(codeline)>0 and type(codeline[-1])==String:    #é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == '\n':    #å¦‚æœin_bracketsï¼Œå‰‡å¿½ç•¥\n
            cline[0]+=1
            if in_brackets==0:
                if len(codeline)>1:
                    codelines.append(codeline)
                codeline = []
                # -----------------------------è¨ˆç®—ä¸‹ä¸€è¡Œçš„ç©ºæ ¼ï¼Œå³ä¾¿æ²’æœ‰ç©ºæ ¼ä¹Ÿéœ€è¦
                k += 1
                if k < n:
                    space_num=0             #ç©ºæ ¼æ•¸é‡
                    while k < n and code[k] == ' ':
                        k += 1
                        space_num+=1
                    codeline.append((space_num,cline[0],orig_code[cline[0]-1]))       #æ¯å€‹[]çš„ç¬¬ä¸€å€‹ç‚ºç©ºæ ¼æ•¸é‡
                k -= 1
        elif c == 'r' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k += 1
            string, k = deal_string(k,change=False)
            if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == 'b' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k+=1
            string,k=deal_string(k)
            if len(codeline) > 0 and type(codeline[-1]) == Byte:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(Byte(string.text))
        elif c=='f' and k+1<n and code[k+1] in ('"',"'"):          #ä»£è¡¨æ˜¯f'aaa{bbb}aaa'é¡å‹
           # print('é€™è£¡2')
            codeline.append('(')
            symbol=code[k+1]
            q=k+2
            while code[q] != symbol or code[q-1]=='\\':
                q += 1
            get=code[k+2:q]
           # print('getç‚º:',get)
            sn=len(get)
            sk=0
            textbox = []
            while sk<sn:
                if get[sk]=='\n':
                    cline[0]+=1
                if get[sk]=='{':
                    if get[sk+1]=='{':
                        textbox.append('{')
                        sk+=1
                    else:                                   #å…§åµŒè®Šæ•¸
                        #å…ˆå„²å­˜å…ˆå‰çš„
                        if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                            codeline.append('+')
                        codeline.append(String(''.join(textbox)))
                        textbox=[]
                        sk+=1
                        p=sk
                        #ç´¢å¼•è‡³ä¸‹ä¸€å€‹"}"
                        slock=0            #å­—ä¸²é–
                        c=1                #{é–
                        while c>0:
                            sc = get[sk]
                            if slock==0:
                                if sc=='{':
                                    c+=1
                                elif sc=='}':
                                    c-=1
                                elif sc in ("'",'"'):      #å•Ÿå‹•å­—ä¸²é–ï¼Œé–‹å§‹å¿½ç•¥{}
                                    slock=sc
                            else:
                                if sc==slock and get[sk-1]!='\\':    #è§£é™¤å­—ä¸²é–
                                    slock=0
                            sk+=1
                        sk-=1                 #ç‚ºäº†è®“get[sk]å®šä½åœ¨"}"
                        vartext=get[p:sk]        #ç›®å‰get[sk]=="}"
                        sub_codeline=parse_code(vartext)[0][1:]        #ç†è«–ä¸Šåªæœ‰ä¸€è¡Œï¼Œå»é™¤æœ€å‰æ–¹çš„0
                        codeline+=['+',Var_name('$str'),'(']+sub_codeline+[')','+']
                elif get[sk]=='}' and get[sk:sk+2]=='}}':
                    textbox.append(get[sk])
                    sk+=1
                elif get[sk]=='\\':
                    textbox.append(get[sk])
                    sk+=1
                    textbox.append(get[sk])
                elif get[sk] in ('"',"'"):
                    textbox.append('\\')
                    textbox.append(get[sk])
                else:
                    textbox.append(get[sk])
                sk+=1
            codeline.append(String(''.join(textbox)))
            codeline.append(')')
            k=q
        elif c!=' ':                         # ä»£è¡¨æ­¤ç‚ºè‡ªå®šç¾©è®Šæ•¸
        #    print('c:',c)
          #  print('end')
            v_name = []
            ban_word = '+-*/,()[]{}!=%:><.&^|~\\# \n:'   #åœ¨è®Šæ•¸ä¸­ç¦æ­¢å‡ºç¾çš„å…ƒç´ 
            while k < n:
                if code[k] not in ban_word:
                    v_name.append(code[k])
                    k += 1
                else:
                    break
            element_name=''.join(v_name)
            if element_name in key_word:
                if element_name=='True':codeline.append(TFN(True))
                elif element_name=='False':codeline.append(TFN(False))
                elif element_name == 'None':codeline.append(TFN(None))
                elif element_name == '$stop':codeline.append(Stop())
                else:codeline.append(element_name)
                if element_name=='lambda':in_lambda+=1
            else:
                #if len(codeline)>=2 and codeline[-1] in ('*','**') and codeline[-2] in ('(',','): #ä»£è¡¨æ˜¯key word argument
                #    codeline[-1]=Var_name(codeline[-1]+element_name)
                #else:                                                 #ä¸€èˆ¬é—œéµå­—
                if element_name in data_dict:
                    element_name='$$'+element_name
                codeline.append(Var_name(element_name))
            k -= 1
      #  else:
       #     print('nononono')
        k += 1
       # print(code[k:])
    if len(codeline)>1:
        codelines.append(codeline)
    #print('ç²å–codelines:\n[')
    #for line in codelines:
    #    if len(line)>0:
    #        print('[',end='')
    #        for i in range(len(line)-1):
    #            print(line[i],',',end='')
    #        print(line[-1],'],')
    #    else:print('[],')
    #print(']\n')
    return codelines
#---------------------------å·¥å…·å‡½æ•¸
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
          #  print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def get_var(codeline,k,namespace):                        #å¾ké–‹å§‹å–å¾—ä¸€å€‹è®Šæ•¸
    n=len(codeline)
    if k==n:
        return None,-1
    p=k                     #ç›®å‰pçš„ä½ç‚ºobj
    k+=1
    leftb=('[','(')
    rightb=(']',')')
    while k<n and (codeline[k] in leftb or codeline[k]=='.'):    #functionæˆ–index
        if codeline[k] in leftb:
            c=1
            k+=1
            while k<n and c>0:
                if codeline[k] in leftb:c+=1
                elif codeline[k] in rightb:c-=1
                k+=1
        elif codeline[k]=='.':
            k+=2
    get=codeline[p:k]
    if len(get)==1:      #ä»£è¡¨æ˜¯æŸç‰©ä»¶
        if type(get[0])==Var_name:
            return Variable(get[0].name,namespace),k                            #å›å‚³ è®Šæ•¸,ç´¢å¼•çµæŸé»ï¼Œ')'å¾Œä¸€æ ¼
        else:return get[0],k
    elif type(get[0])==Var_name and get[0].name=='$str':                        #æ“·å–apythonè‡ªèº«å‡½æ•¸
        obj=parse_codeline(get[2:-1],namespace)            #å–å¾—()ä¸­çš„æ±è¥¿
        return STR(obj),k
    elif get[1] in '([.':                                      #ä»£è¡¨æ˜¯functionæˆ–index
       # print('é€²ä¾†äº†,getç‚º',get)
        q=k
        k=1
        if type(get[0])==Var_name:
            get[0]=Variable(get[0].name,namespace)
       # print('get:',get)
        from time import time
        st=time()+1
        while len(get)>1:
            if get[k]=='(':                         #ä»£è¡¨æ˜¯function call
               # print('èµ°é€™æ¢')
                args=[]
                kwargs=[]
                s_args=None
                s_kwargs=[]
                if get[k+1]!=')':
                    while k<len(get):              #é–‹å§‹è’é›†åƒæ•¸
                        if get[k+2]=='=':                      #ä»£è¡¨æ˜¯æŒ‡å®šåƒæ•¸
                            p=k+3
                            k = next_element(get, p, ',)')
                            value = parse_codeline(get[p:k],namespace)
                            kwargs.append((String(get[p-2].name),value))
                        elif get[k+1]=='*':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            value=parse_codeline(get[p:k], namespace)
                            if s_args==None:
                                s_args =value
                            else:
                                s_args=Oper(s_args,value,'+')  #ç›¸åŠ 
                        elif get[k+1]=='**':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            s_kwargs.append(parse_codeline(get[p:k], namespace))
                        else:
                            p=k+1
                            k=next_element(get,p,',)')
                            value = parse_codeline(get[p:k],namespace)
                            args.append(value)
                        if get[k]==')':break
                    #print('args:',args)
                    #print('kwargs:',kwargs)
                else:k+=1
                #æ­¤æ™‚kç‚º ")"
                get=[FuncCall(get[0],List(args),Dict(kwargs),s_args,s_kwargs)]+get[k+1:]
            elif get[k]=='[':
                p=k+1
                collect=[]
                while True:
                    k=next_element(get,p,':]')
                    if get[k]==':':                                           #sliceç´¢å¼•
                        if k==p:
                            value=TFN(None)                                 #ä»£è¡¨ç¬¬ä¸€æ¬„ä½ç‚ºç©º
                        else:
                            value = parse_codeline(get[p:k],namespace)
                        p=k+1
                        collect.append(value)
                    else:                                                        #å–®ç´¢å¼•
                        if len(collect)==0:
                            collect=parse_codeline(get[p:k],namespace)
                        elif k==p:
                            collect.append(TFN(None))
                        else:
                            collect.append(parse_codeline(get[p:k],namespace))
                        break
                #kç‚º "]"
                if type(collect)==list:
                    if len(collect)<3:
                        collect+=[TFN(None)]*(3-len(collect))
                    collect=Slice(collect[0],collect[1],collect[2])
                get=[IndexVariable(get[0],collect)]+get[k+1:]
            elif get[k]=='.':                                        #attribute
                subattr=SubVariable(get[0],get[2])
                get=[subattr]+get[3:]
                k-=1
            if time()>st:
              #  print('getç‚º:',get)
                raise Exception('335 get error')
            k=1
       # print('å–å¾—:',get[0])
       # a=input()
        return get[0],q
def next_codeline(codelines,row):
    space_n=codelines[row][0][0]
    s_n=space_n+1
    Row=len(codelines)
    while s_n>space_n:
        row += 1
        if row==Row:break
        s_n = codelines[row][0][0]
    return row
#è§£æä¸€è¡Œ:
def parse_codeline(codeline,namespace,is_list=False):     #å›å‚³è§£ç­”é™£åˆ—[A,B,C,...]
    # è™•ç†lambda(å› ç‚ºæ€•namespaceè¢«è¦†è“‹)
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c == 'lambda':
            # print('æ‰¾åˆ°äº†')
            p2 = k
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k += 1  # kå¾æ­¤é–‹å§‹æ˜¯è®Šæ•¸
            n = len(codeline)
            while k < n:
                c = codeline[k]
                if type(c) == Var_name:  # å–å¾—param
                    paramsbox[c.name]= TFN(None)
                    if k + 1 < n and codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',:')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[c.name] = parse_codeline(codeline[p:k], namespace)  # functionåƒæ•¸éœ€è¦namespace
                        if codeline[k] == ':': break
                if c == ':': break
                k += 1
            #  print('ç²å–åƒæ•¸:',paramsbox)
            # æ­¤æ™‚kæœƒæŒ‡è‘—å†’è™Ÿ
            # print('ç›®å‰kæŒ‡è‘—:',codeline[k])
            q = next_element(codeline, k, (',',')'), end=True)  # ç¢°åˆ°",",")"åœæ­¢
           # print('getå¾·:',codeline[k + 1:q])
            return_obj = parse_codeline(codeline[k + 1:q], '')  # functionå…§çš„å…§å®¹(namespace)è¦æ¸…ç©º
            #  print('return_obj:',return_obj)
            lambda_obj = Lambda(paramsbox, return_obj, namespace)
            codeline = codeline[:p2] + [lambda_obj] + codeline[q:]
            # print('æ–°codeline:',codeline)
            k = 0
        k += 1
    # è™•ç†æ‹¬å¼§
    k = 0
    while k < len(codeline):
        if k==0 or (type(codeline[k-1])==str and codeline[k-1] not in (')',']','}')):                 #å‰é¢ç‚º',','='
            objecct = codeline[k]
            if objecct == '(' :  # ä»£è¡¨æ­¤è™•æœ‰tupleï¼Œ
                q = next_element(codeline, k + 1, ')')
                get = parse_codeline(codeline[k + 1:q], namespace)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k-=1
            elif objecct == '[':  # ä»£è¡¨æ˜¯list
                q = next_element(codeline, k + 1, ']')
                get = parse_codeline(codeline[k + 1:q], namespace, is_list=True)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k -= 1
            elif objecct == '{':  # ä»£è¡¨æ˜¯é›†åˆæˆ–dict
                #print(codeline)
                q=next_element(codeline,k+1,['}'])      #å…ˆå°‡å­—å…¸åº•éƒ¨æ‰¾åˆ°
               # print('q:',q)
                content=parse_codeline(codeline[k+1:q],namespace,is_list=True)       #æ­¤æ™‚contentçš„å½¢å¼ç‚º <obj>:<obj><obj>:<obj>ï¼Œé€—è™Ÿæœƒæ¶ˆå¤±ï¼Œå¦‚æœæ²’å†’è™Ÿï¼Œå°±æ˜¯é›†åˆ
                #codeline=codeline[:k]+content.elements+codeline[q+1:]
                deal_line=content.elements
                #print('deal_line:',deal_line)
                if ':' in deal_line or len(deal_line)==0:     #deal_lineç‚ºç©ºï¼Œé»˜èªç‚ºdict
                    elementbox = []      #[(key,value),...]
                    p =0
                    n=len(deal_line)
                    while p<n:
                        key=deal_line[p]
                        p+=2
                        value=deal_line[p]
                        p+=1
                        elementbox.append((key, value))
                    get = Dict(elementbox)
                else:
                    get=Set(deal_line)        #é›†åˆå…ƒç´ 
                codeline = codeline[:k] + [get] + codeline[q + 1:]
        k += 1
    k=0
    while k<len(codeline):
        c=codeline[k]
        if type(c)==str and c in ('break','continue'):      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Mark(c)
        elif type(c)==str and c=='pass':      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Pass()
        else:
            l=len(codeline)
            var, q = get_var(codeline, k, namespace)
            codeline = codeline[:k] + [var] + codeline[q:]
            if len(codeline)<l:                              #æœ‰è®ŠåŒ–æ‰è™•ç†
                k -= 1
        k+=1
    def deal_single_operator(codeline,op_box,operator):
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box and type(codeline[k + 1]) != str:
                if c in ('+','-'):
                    if k==0 or type(codeline[k-1])==str:   #ä»£è¡¨æ²’æœ‰åŠ æ¸›é‹ç®—
                        if c=='-':
                            get = operator(codeline[k + 1],c)
                            codeline = codeline[:k] + [get] + codeline[k + 2:]
                            k=-1
                        else:
                            codeline=codeline[:k]+codeline[k+1:]            #åˆªé™¤"+"
                else:
                    get = operator(codeline[k + 1],c)
                    codeline = codeline[:k] + [get] + codeline[k + 2:]
                    k = -1
            k += 1
        return codeline
    def deal_single_operator_all(codeline,op_box,operator):     #å°‡opå¾Œçš„åƒæ•¸å…¨éƒ¨æ‰“åŒ…
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box:
                value=parse_codeline(codeline[k+1:],namespace)
                get = operator(value,c)
                codeline = codeline[:k] + [get]
                k = -1
            k += 1
        return codeline
    def deal_operator(codeline,op_box,operator):
        k=0
        while k<len(codeline):
            c=codeline[k]
            if c in op_box:
                if k>0:
                    get=operator(codeline[k-1],codeline[k+1],c)
                    codeline=codeline[:k-1]+[get]+codeline[k+2:]
                    k-=1
            k+=1
        return codeline
    # è™•ç†**
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='**':
            k+=1
            p=k
            while type(codeline[k])==str:k+=1    #å¯èƒ½å–åˆ°è² è™Ÿæˆ–è£œæ•¸ã€æ­£è™Ÿ
            obj=parse_codeline(codeline[p:k+1],namespace)
            get=Oper(codeline[p-2],obj,'**')
            codeline = codeline[:p-2] + [get] + codeline[k+1:]
            k=p-2
        k += 1
    #è™•ç† ~,-
    codeline = deal_single_operator(codeline, ['~','-','+'],Deny)
    # è™•ç†*/
    codeline=deal_operator(codeline,('*','/','%','//'),Oper)
    #è™•ç†+-
    codeline=deal_operator(codeline,('+','-'),Oper)
    # è™•ç†<<>>
    codeline = deal_operator(codeline,('<<','>>'),Oper)
    # è™•ç†&
    codeline = deal_operator(codeline, ['&'],Oper)
    # è™•ç†^
    codeline = deal_operator(codeline, ['^'],Oper)
    # è™•ç†|
    codeline = deal_operator(codeline,['|'],Oper)
    #è™•ç†==,!=
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c in ('==','!=','>','<','>=','<='):
            enebox=[codeline[k-1]]
            p=k
            while c in ('==','!=','>','<','>=','<='):
                enebox+=[c,codeline[k+1]]
                k+=2
                if k<len(codeline):
                    c=codeline[k]
                else:break
            get=Bool(enebox)
            codeline=codeline[:p-1]+[get]+codeline[k:]
            k=p-1
        k += 1
    # è™•ç†in,isï¼Œinå‰é¢ä¸èƒ½æœ‰for
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='for':
            k=next_element(codeline,k,['in'],end=True)    #è¦ç•¥éforå¾Œé¢çš„in
        elif c=='in':                # è™•ç†in
            if k > 0:
                if codeline[k-1]=='not':
                    get=Deny(Tf(codeline[k+1], codeline[k-2], c),'not')
                    codeline = codeline[:k - 2] + [get] + codeline[k + 2:]
                    k -= 2
                else:
                    get = Tf(codeline[k+1], codeline[k-1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                    k -= 1
        elif c=='is':              # è™•ç†is
            if k > 0:
                if codeline[k+1]=='not':
                    get=Deny(Tf(codeline[k+2], codeline[k-1], c),'not')
                    codeline = codeline[:k -1] + [get] + codeline[k + 3:]
                else:
                    get = Tf(codeline[k+1], codeline[k - 1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                k -= 1
        k += 1
    #è™•ç†not
    codeline=deal_single_operator(codeline,['not'],Deny)
    #è™•ç†and,or
    codeline = deal_operator(codeline,('and','or'),AndOr)
    #è™•ç† A if B else C
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='if':                                                             #è™•ç† A if B else C
            else_k=next_element(codeline,k,['else'])
            true_item=codeline[k-1]
            event_obj=parse_codeline(codeline[k+1:else_k],namespace)
            end_k=next_element(codeline,else_k,',',end=True)
            false_item=parse_codeline(codeline[else_k+1:end_k],namespace)
            get = sub_if_else(event_obj,true_item,false_item)
            codeline = codeline[:k-1] + [get] + codeline[end_k:]
            k = 0
        elif c=='for':              #è™•ç†for
           # print(codeline)
            #print('k:',k)
            express=codeline[k-1]
            in_k=next_element(codeline,k,['in'])
            vnames=parse_codeline(codeline[k+1:in_k],namespace,is_list=True)
            base_obj=codeline[in_k+1]
            if_k=next_element(codeline,in_k,['if'])
           # print('in_k:',in_k)
            if if_k==-1:      #æ²’æœ‰if
                if_obj=None
            else:if_obj=codeline[if_k+1]
           # print('å–å¾—:')
            #print(express,vnames,base_obj,if_obj)
            get=sub_for_loop(express,vnames,base_obj,if_obj,is_list)
            return get                                                #å…¶ä»–éƒ½åˆ¥ç®¡äº†ï¼Œç›´æ¥return
        k += 1
    #è™•ç†return
    codeline=deal_single_operator(codeline,['yield'],Backtrack)
    codeline = deal_single_operator_all(codeline, ('return', 'raise'), Backtrack)
    codeline = deal_single_operator(codeline, ('del','global','nonlocal'),Var_declare)
    #åˆªé™¤å…§éƒ¨é€—è™Ÿ
    k=0
    while k<len(codeline)-1:                       #å¯èƒ½æ˜¯(a,)çš„tuple
        if codeline[k]==',':del codeline[k]
        else:k+=1
        if k==len(codeline)-1 and not is_list:break
    if len(codeline)>0 and codeline[-1]==',':         #codelineå¯èƒ½ç‚º[],()é€²ä¾†ï¼Œé•·åº¦ç‚º0
        if is_list:del codeline[-1]
        else:
            return Tuple(codeline)
    if is_list:
        return List(codeline)
    if len(codeline)==1:return codeline[0]
    return Tuple(codeline)
#è§£æç¨‹å¼å€å¡Š:
def parse_block(codelines,namespace=Namespace()):         #å›å‚³[[A,B,C,...],[A,B,C,...],...]
    info=Info(namespace)       #localç‚ºæ‰€æœ‰è®Šæ•¸ï¼Œcodelinesç‚ºè™•ç†å¥½çš„codelines
    #é–‹å§‹è™•ç†
    row=0
    Row = len(codelines)  # ç¸½è¡Œæ•¸
    while row<Row:
        codeline=codelines[row]                 #å–å¾—ä¸€è¡Œ
        if codeline[1]=='def':
            func_name = codeline[2].name  # Variable
            # 3æ˜¯(ï¼Œ4é–‹å§‹æ˜¯è®Šæ•¸
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k = 4
            n = len(codeline)
            pre=''        #å‰ç¶´ï¼Œå¯èƒ½ç‚º*æˆ–**
            while k < n:
                c = codeline[k]
                if c in ('*','**') and codeline[k-1] in ('(',','): #ç¢ºä¿é€™ä¸æ˜¯é‹ç®—ç¬¦
                    pre=c
                elif type(c) == Var_name:  # å–å¾—param
                    param_name=pre+c.name
                    paramsbox[param_name] = TFN(None)
                    if codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',)')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[param_name] =parse_codeline(codeline[p:k],namespace)
                    pre=''             #æ¸…ç©ºå‰ç¶´
                k += 1
            q = next_codeline(codelines, row)
            pinfo =parse_block(codelines[row + 1:q],namespace=Namespace())   #Defå…§éš”çµ•å¤–éƒ¨namespace
            fDef = Def(func_name, paramsbox,pinfo,namespace)
            fDef.local_vars=pinfo.locals
            #é€²è¡Œç™»è¨˜
            info.add_info('func',fDef)
            info.write(fDef,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='class':
            classname=codeline[2].name
            if codeline[3]=='(':      #ä»£è¡¨æœ‰ç¹¼æ‰¿
                q=next_element(codeline,4,[')'])
                father=parse_codeline(codeline[4:q],namespace)
            else:
                father=None
            q=next_codeline(codelines,row)
            importer.class_n+=1
            class_esp=f'{classname}^{importer.class_n}'
            pinfo=parse_block(codelines[row+1:q],namespace=Namespace(f'<{class_esp}>'))           #åœ¨namespaceç‹€æ…‹ä¸‹ï¼Œvarè½‰ç‚ºnamespace.var, funcè½‰ç‚º namespace.func
            get=Class(classname,pinfo,namespace,class_esp,father)
            #é€²è¡Œç™»è¨˜
            info.add_info('class',get)
            info.write(get,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='if':                                            #if,elif,elseå‹æ…‹
            eventbox=[]
            else_codelines=[]
            orig_codelines=[]
            if_k=0
            while row<Row:
                codeline=codelines[row]
                if (codeline[1]=='if' and if_k==0) or codeline[1]=='elif':
                    if_k+=1
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    event=parse_codeline(codeline[2:-1],namespace)         #äº‹ä»¶çœŸå‡å€¼
                    if type(event)==Tuple:event=Integer(1)
                    q=next_codeline(codelines,row)
                    block=codelines[row+1:q]
                    pinfo=parse_block(block,namespace)
                    #é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    eventbox.append((event,pinfo.codelines))
                    row=q
                elif codeline[1]=='else':
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    q = next_codeline(codelines, row)
                    block = codelines[row + 1:q]
                    pinfo=parse_block(block,namespace)
                    else_codelines=pinfo.codelines
                    # é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    row=q
                    break
                else:break
            row-=1
            info.write(If_else(eventbox,else_codelines),orig_codelines)
        elif codeline[1]=='while':                                         #whileå‹æ…‹
            event=parse_codeline(codeline[2:-1],namespace)
            if type(event) == Tuple: event = Integer(1)
            q = next_codeline(codelines, row)
            block = codelines[row + 1:q]
            pinfo= parse_block(block,namespace)
            while_codelines=pinfo.codelines
            # é€²è¡Œç™»è¨˜
            info.update(pinfo)
            #--------------------------------------
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            info.write(While(event,while_codelines,else_codelines),(codeline[0][2],codeline[0][1]))
            row = q-1
        elif codeline[1]=='for':                                           #for,loopå‹æ…‹
            vnames=[]
            k=2            #é–‹å§‹æ¸…é»åƒæ•¸
            while type(codeline[k])==Var_name or codeline[k]==',':
                if type(codeline[k])==Var_name:
                    var=Variable(codeline[k].name,namespace)
                    info.add_info('var',var)
                    vnames.append(var)
                k+=1
            #æ¥ä¸‹ä¾†kæœƒæŒ‡åˆ° in
            base_obj=parse_codeline(codeline[k+1:-1],namespace)
            q=next_codeline(codelines,row)
            block = codelines[row + 1:q]
            pinfo = parse_block(block, namespace)
            fp_codelines=pinfo.codelines
            info.update(pinfo)
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            for_loop=For_loop(vnames,base_obj,fp_codelines,else_codelines)
            # é€²è¡Œç™»è¨˜
            info.write(for_loop,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='import':
            importer.need_load=1
            package_dict={}
            k,n=2,len(codeline)
            while k<n:
                if type(codeline[k])==Var_name:
                    module_name=codeline[k].name
                    while k+1<n and codeline[k+1]=='.':
                        module_name+=f'.{codeline[k+2].name}'
                        k+=2
                    as_name=None
                    if k+1<n and codeline[k+1]=='as':
                        as_name=codeline[k+2].name
                        var = Variable(as_name, namespace)
                        k+=2
                    else:
                        var=Variable(module_name.split('.')[0],namespace)
                    package_dict[module_name]=as_name   #(filepath,1/0)
                    #ç™»è¨˜
                    info.add_info('var',var)
                k+=1
            import_obj=Import(package_dict,namespace)                  #{'abc.def.ghi':as_name,...} , namespace
            info.write(import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1] == 'from':
            importer.need_load = 1
            object_names=[]
            module_name=codeline[2].name
            k = 2
            n = len(codeline)
            while k + 1 < n and codeline[k + 1] == '.':
                module_name += f'.{codeline[k + 2].name}'
                k += 2
            #-----------------------------------------
            k+=2                              #è·³éimport
            while k<n:
                if type(codeline[k])==Var_name:
                    object_name=codeline[k].name
                    if k+1<n and codeline[k+1]=='as':
                        deal=(object_name,codeline[k+2].name)
                        k+=2
                    else:deal=(object_name,object_name)
                    object_names.append(deal)
                    var=Variable(deal[1],namespace)
                    #ç™»è¨˜
                    info.add_info('var',var)
                elif codeline[k]=='*':
                    object_names.append(('*','*'))
                k+=1
            from_import_obj = From_Import(module_name,object_names,namespace,info)
            info.write(from_import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1]=='try':
            orig_codelines=[(codeline[0][2],codeline[0][1])]
            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            try_codelines=pinfo.codelines
            info.update(pinfo)
            except_objects=[]
            row=q
            while q<Row and codelines[q][1]=='except':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                k=next_element(codeline,1,(':','as'))
                if codeline[k]==':':
                    if k-1>1:                #ä»£è¡¨ä¸­é–“æœ‰åŒ…æ±è¥¿
                        error_obj=parse_codeline(codeline[2:k],namespace)
                    else:                    #ä¸­é–“æ²’æœ‰åŒ…æ±è¥¿
                        error_obj=Variable('Exception',namespace)
                    as_name=None
                else:                              #ä»£è¡¨æ˜¯as
                    error_obj = parse_codeline(codeline[2:k], namespace)
                    as_name=codeline[k+1].name
                #é–‹å§‹æ”¶é›†codelines
                q=next_codeline(codelines,q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                except_objects.append((error_obj,as_name,pinfo.codelines))
                info.update(pinfo)
                row=q
            if q<Row and codelines[q][1]=='else':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                else_codelines=pinfo.codelines
                info.update(pinfo)
            else:else_codelines=[]
            row=q
            if q<Row and codelines[q][1]=='finally':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                finally_codelines=pinfo.codelines
                info.update(pinfo)
            else:finally_codelines=[]
            #if len(except_objects)==0 and len(finally_codelines)==0:
             #   raise SyntaxError('invalid syntax')
            try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines,namespace)
            info.write(try_except,orig_codelines)
            row=q-1
        elif codeline[1]=='with':
            k=2
            q=next_element(codeline,k,['as',':'])
            call_obj=parse_codeline(codeline[k:q],namespace)
            importer.class_n += 1
            orig_as_name=Variable(f'%with_obj_{importer.class_n}',namespace)
            info.add_info('var', orig_as_name)
            if codeline[q]=='as':
                q2=next_element(codeline,q,[':'])
                as_name=parse_codeline(codeline[q+1:q2],namespace)
                if type(as_name)==Variable:
                    info.add_info('var', as_name)
            else:as_name=None

            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            info.update(pinfo)
            with_obj=With(call_obj,orig_as_name,as_name,pinfo.codelines,namespace)
            info.write(with_obj,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='assert':
            k=next_element(codeline,1,[','],end=True)
            event=parse_codeline(codeline[2:k],namespace)
            if k<len(codeline) and codeline[k]==',':
                msg=parse_codeline(codeline[k+1:],namespace)
            else:msg=String('')
            assert_obj=Assert(event,msg)
            info.write(assert_obj, (codeline[0][2], codeline[0][1]))
        else:
            equal=next_element(codeline,0,('=','+=','-=','*=','/=','%=','//=','**=','<<=','>>=','&=','^=','|='),stop=['lambda'])                             #è™•ç†=
            op=codeline[equal]      #operator
            variablebox=[]                          #æ”¶é›†[(var1,var2,...),(var1,var2,...),...]
            s=1
            while equal>0:
                vars=parse_codeline(codeline[s:equal],namespace)
                if type(vars) in (Tuple,List):
                    for var in vars:
                        if type(var)==Variable:
                            info.add_info('var', var)
                elif type(vars)==Variable:
                    info.add_info('var', vars)
                s=equal+1
                #vars=[]
                #d=1
                #while d<equal:
                #    if codeline[d]==',':d+=1    #è·³éé€—è™Ÿ
                #    var,d=get_var(codeline,d,namespace)
                #    if type(var)==Variable:
                #        var.namespace=namespace
                #        info.add_info('var',var)
                #    vars.append(var)
                #    s=d+1
                variablebox.append(vars)
                equal=next_element(codeline,equal+1,'=',stop=['lambda'])
            target=parse_codeline(codeline[s:],namespace)                      #æœ€å°¾ç«¯çš„ç‰©ä»¶
           # variablebox.append(results)
           # print('variablebox:',variablebox)
          #  print('\n\ncodeline:',codeline,'\n\n')
           # print('variablebox:',variablebox)
            if len(variablebox)==0:                                   #æ²’æœ‰ç­‰æ–¼
                info.write(target,(codeline[0][2],codeline[0][1]))
            #elif len(variablebox)==1 and type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
            #        object = Mov(variablebox[0], target, op)
            #        info.write(object, (codeline[0][2], codeline[0][1]))
            else:
                mov_obj=Multiple_Mov(variablebox,target,op)
                info.write(mov_obj, (codeline[0][2], codeline[0][1]))
                #if type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #    object = Mov(variablebox[0], target, op)
                #    info.write(object, (codeline[0][2], codeline[0][1]))
                #target = variablebox[-1]
                #if
                #for i in range(len(variablebox)-1):
                #    vars=variablebox[i]
                #
                #    if type(vars) not in (Tuple,List):   #ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #        object = Mov(vars,target,op)
                #        info.write(object,(codeline[0][2],codeline[0][1]))
                #        if type(vars[0])==Variable:
                #            info.add_info('var',vars[0])
                #    else:
                #        if type(target)==FuncCall:
                #            info.write(target,('',0))
                #        for j in range(len(vars)):
                #            object=Mov(vars[j],target[j])
                #            info.write(object,(codeline[0][2],codeline[0][1]))
                #            if type(vars[j])==Variable:
                #                info.add_info('var',vars[j])
        row+=1
    return info
#å¤–éƒ¨åŒ¯å…¥å‡½æ•¸
class From_Import:
    def __init__(self,module_name,object_names,namespace,now_info):   #dict:name:(filepath,1/0,name2)ï¼Œ[(name,name2),(name,name2),...],
        self.module_name=module_name
        self.object_names=object_names
        self.namespace=namespace
        self.now_info=now_info
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<From {self.module_name} import {self.object_names}>'
    def write(self,codes):
        module_data = importer.get_path(self.module_name)
        codes.append('',self.orig_lines)
        if module_data[1]!=0:       #éœ€è¦è¢«è¼‰å…¥
            tem_module_name=f'&tem_import_{len(codes)}'
            package_dict={self.module_name:tem_module_name}
            _import = Import(package_dict,self.namespace)
            _import.write(codes)  # å¯ä½¿å€åŸŸè®Šæ•¸åå¤±æ•ˆ
        codes.append(f'push $importer["{module_data[0]}"]')
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'push {self.namespace.location}')
            module_space='<esp+1>.'
            ispace='<esp+2>'
        else:
            module_space=''
            ispace='<esp+1>'
        for var in self.object_names:
            if var[0]=='*':             #import å…§éƒ¨æ‰€æœ‰ç‰©ä»¶
                info=importer.infos[module_data[0]]
                if info=='built-in':
                    locals=importer.module_dict[module_data[0]]
                else:
                    locals=info.locals
                for local_var in locals:
                    codes.append(f'mov {module_space}{local_var} {ispace}.{local_var}    ;import *')
                    variable=Variable(local_var,self.namespace)
                    self.now_info.add_info('var',variable)
            else:
                codes.append(f'mov {module_space}{var[1]} {ispace}.{var[0]}')
        if self.namespace!='':
            codes.append('$mov esp "+" 2')               #é‚„åŸå †ç–Š
        else:codes.append('inc esp')
class Import:
    def __init__(self,package_dict,namespace):   #package_dict:{'name':name2/None}    #åç¨±:æª”æ¡ˆè·¯å¾‘ï¼Œæ˜¯å¦è®€å–ï¼Œæ˜¯å¦è½‰ç‚ºå…¶ä»–åç¨±(as)
        self.package_dict=package_dict
        self.namespace=namespace
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Import: {self.package_dict}>'
    def write(self,codes):         #å¦‚æœcheckç‚ºTrueï¼Œå‰‡åœ¨å·²importç‹€æ…‹ä¸é€²è¡Œimport
        if self.namespace != '':
            self.namespace.write(codes)
            last_layer = f'{self.namespace.location}.'
        else:last_layer=''
        tem_layer=last_layer
        for module_name in self.package_dict:
            as_name = self.package_dict[module_name]
            mbox=module_name.split('.')
            for m in range(len(mbox)):
                dealname='.'.join(mbox[:m+1])
                deal_data=importer.get_path(dealname)    #,[filepath,0:å·²è™•ç†/1:æœªè™•ç†]
                p = len(codes)
                namespace_stack_name = f'&{mbox[m]}_{p}'  # æ­¤åç‚ºå”¯ä¸€ï¼Œæ›¿æ›åƒæ•¸å †ç–Šå
                if deal_data[1] == 0:  # å·²ç¶“è¢«è™•ç†
                    codes.append(f'mov {namespace_stack_name} $importer["{deal_data[0]}"]')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==2:       #ä»£è¡¨æ˜¯å¤–éƒ¨å‡½æ•¸
                    importer.loaded.append(deal_data[0])
                    codes.append(f'module {namespace_stack_name} "{deal_data[0]}"')
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    importer.infos[deal_data[0]] ='built-in'
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==1:       #æœªè™•ç†
                    importer.loaded.append(deal_data[0])    #-----------------------------ç™»è¨˜å·²è¼‰å…¥
                    codes.append(0)
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    #--------------------------------------------------------------------é–‹å§‹ç·¨è­¯
                    codes.add_newtab(deal_data[0])
                    code = open(deal_data[0], 'r', encoding=importer.encoding).read()
                    codelines = parse_code(code)
                    info = parse_block(codelines)    #ç•¶ä½œç¨ç«‹ç¨‹å¼ç¢¼é€²è¡Œè§£æ
                    for obj in info.codelines:
                        obj.write(codes)
                    importer.infos[deal_data[0]] = info   #ç™»è¨˜infoè³‡è¨Š
                    codes.del_newtab()
                    #--------------------------------------------------------------------ç·¨è­¯çµæŸ
                    #-------------------------ç·¨å¯«åƒæ•¸æ›¿æ›å­—å…¸
                    params_dict={}
                    box=[]
                    var_k=0
                   # print('info locals:',info.locals)
                    for var in info.locals:
                        if var not in box:
                            box.append(var)
                            params_dict[var]=f'<{namespace_stack_name}+{var_k}>'          #name:order
                            var_k+=1
                    var_text=','.join(box)
                    codes[p] = f'namespace {namespace_stack_name} "{namespace_stack_name}" "{var_text}"'
                    #--------------------------
                    #-------------------------------------------------------------é€²è¡Œåƒæ•¸æ›¿æ›
                    def get_name(string):
                        sp = '.[ ;'
                        k, n = 0, len(string)
                        while k < n:
                            if string[k] in sp:
                                return string[:k], string[k:]
                            k += 1
                        return string, ''
                    def parse_line(line):
                        box = []
                        k, n = 0, len(line)
                        while k < n:
                            p = k
                            if line[p] in ('"', "'"):
                                c = line[p]
                                k = p + 1
                                while line[k] != c:
                                    if line[k] == '\\': k += 1
                                    k += 1
                                k += 1
                            while k < n and line[k] != ' ': k += 1
                            box.append(line[p:k])
                            k += 1
                        return box
                    p+=3           #è·³éè‡ªå·±å®£å‘Šçš„åç¨±ï¼Œ(å°å¿ƒè‡ªå·±çš„åƒæ•¸ä¸è¦è¢«æ›¿æ›)
                    for i in range(len(codes) - p):
                        line=codes[p+i]
                        if '"' in line or "'" in line:
                            deal=parse_line(line)
                        else:
                            deal = codes[p + i].split(' ')
                        for j in range(len(deal)):  # å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                            if j == 0 or deal[j] == '': continue       #é™¤äº†å‘½ä»¤å’Œç©ºï¼Œå…¶é¤˜æª¢æŸ¥
                            if deal[j][0] in ('"', "'"):
                                continue
                            if deal[j][0] == ';':  # ä»£è¡¨æ˜¯è¨»è§£
                                break
                            var, back = get_name(deal[j])
                            if var in params_dict:
                                deal[j]=params_dict[var]+back
                        codes[p + i] = ' '.join(deal)
                    #----------------------------------------------------------------------åƒæ•¸æ›¿æ›çµæŸ
                    last_layer=f'{namespace_stack_name}.'
            last_layer=tem_layer
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open(getcwd() + '/apython/ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict
class Importer:          #æ¨¡çµ„åŒ¯å…¥ç®¡ç†å™¨
    def __init__(self):
        self.module_dict=Read_ex_func()
        self.reset()
    def __get_module(self,module_name):        #ç²å–è©²è³‡æ–™å¤¾å…§æ‰€æœ‰å¯importæ¨¡çµ„
        def get_module(nowfolder,k):      #ç›®å‰å·¥ä½œè³‡æ–™å¤¾ï¼Œfboxçš„index
            if k==len(fbox)-1:
                filepath=''
                for file in listdir(nowfolder):
                    road = f'{nowfolder}/{file}'.replace('\\', '/')
                    if isfile(road) and file.split('.')[-1] == 'py' and filepath=='' and file[:-3]==fbox[k]:
                        filepath = road
                    elif isdir(road) and '__init__.py' in listdir(road) and file==fbox[k]:  # å¦‚æœæœ‰è³‡æ–™å¤¾å’Œpyæª”åŒé¡ï¼Œå–è³‡æ–™å¤¾
                        filepath= road + '/__init__.py'
                return filepath
            return get_module(f'{nowfolder}/{fbox[k]}',k+1)
        fbox=module_name.split('.')
        return get_module(self.work_folder,0)
    def get_path(self,module_name):          #importå¾ŒåŠ [åŒç›®éŒ„æª”æ¡ˆå]ï¼Œåªèƒ½æ˜¯[.py]æˆ–[å…§éƒ¨æœ‰__init__çš„è³‡æ–™å¤¾]
        if module_name in self.module_dict:
            if module_name in self.loaded:
                return [f'{module_name}',0]
            return [f'{module_name}',2]      #2ä»£è¡¨built-in
        else:
            filepath=self.__get_module(module_name)
            if filepath in self.loaded:   #å·²ç¶“è¼‰å…¥é
                return [filepath,0]
            if filepath=='':    #ä»£è¡¨æ‰¾ä¸åˆ°
                return [f'{module_name}', 2]  # 2ä»£è¡¨built-inï¼Œå‰µå»ºä¸€å€‹ç©ºçš„Ex_module
            #print('filepath:',filepath,module_name)
            return [filepath,1]
    def reset(self,pyfile='',encoding='cp950'):
        self.need_load=0
        self.encoding=encoding
        py_file_name=pyfile.replace('\\','/').split('/')[-1]
        if pyfile==py_file_name:
            self.work_folder = getcwd()
        else:
            self.work_folder=pyfile[:-len(py_file_name)-1]
        self.nowpath = pyfile
        self.loaded=[]
        self.infos={}                     #path:info
        self.class_n = 0  # é¡åˆ¥ç®¡ç†
importer=Importer()
#æ‰“åŒ…è€…
class Packager:
    def __init__(self,encoding='cp950'):
        self.code=Code()
        self.encoding=encoding
        self.REPL_box=[True,[]]
        importer.reset('module', self.encoding)
        self.add_need_load = 0
    def load(self,filepath):
        ftype = filepath.split('.')[-1]
        filename = filepath.replace('\\', '/').split('/')[-1]
        work_folder = filepath[:-len(filename)]
        if len(work_folder) > 0:
            chdir(work_folder)
            filepath = filename
        if 'ec' == ftype:
            code = open(filepath, 'r').read()
            self.code.code = code.split('\n')
        else:
            code = open(filepath, 'r',encoding=self.encoding).read()
            self.code.add_newtab(filepath)
            importer.reset(filepath,self.encoding)
            self.add_need_load=0
            #--------------------------------------------------
            self.load_code(code)
            #--------------------------------------------------
            self.code.del_newtab()
    def REPL(self,cmd,one_line=True):               #å–®è¡Œç¨‹å¼ç¢¼
        self.code.add_newtab('REPL')
        if cmd=='':
            if len(self.REPL_box[1])>0:
                code='\n'.join(self.REPL_box[1])
              #  print('code:',code)
                self.load_code(code)
            self.REPL_box=[True,[]]
        else:
            codelines = parse_code(cmd)
            if one_line:
                codeline=codelines[0]
                if codeline[1] in ('def','class','if','while','for','try','with'):
                    self.REPL_box[0]=False     #False ä»£è¡¨ä¸åŸ·è¡Œ
                    self.REPL_box[-1].append(cmd)
                elif not self.REPL_box[0]:
                    self.REPL_box[-1].append(cmd)
                else:
                    self.load_code(cmd,repl=True)
            else:
                self.load_code(cmd, repl=True)
        self.code.del_newtab()
        return self.REPL_box[0]    #æ˜¯å¦åŸ·è¡Œ
    def load_code(self,code,repl=False):     #ç›´æ¥è¼¸å…¥ä»£ç¢¼
        codelines = parse_code(code)
        self.info = parse_block(codelines)
        if importer.need_load and self.add_need_load == 0:
            self.code.append('mov $importer [dict]')
            self.add_need_load = 1
        if len(self.info.codelines)>0:
            for obj in self.info.codelines:
                obj.write(self.code)
            if repl and type(self.info.codelines[-1]) in (Integer,Float,String,Byte,Variable,SubVariable,IndexVariable,List,Tuple,Dict,Set,FuncCall,Oper,Tf,AndOr,Deny,Bool):
                if type(self.info.codelines[-1])!=FuncCall or self.info.codelines[-1].name!='print':
                    self.code.append(f'repl_print {self.info.codelines[-1].location}')
    def __load_easy_code(self,ec_file):
        code = open(ec_file, 'r').read()
        self.code.code=code.split('\n')
16723*113*test_error.pydatas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='cp950')
    g.write('from apython.ex_func import *\n')
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
16851*114*test_error.txt#encoding='utf-8'
datas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\nfrom apython.ex_func import *\n")
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n    if op=="__name__":return obj_name\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
16776*114*test_error2.py#encoding='utf-8'
datas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w')
    g.write('from apython.ex_func import *\n')
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
2118*111*__init__.pyfrom apython.package import Packager
from apython.executer import Executer
class Apython:
    def __init__(self,encoding='utf-8'):
        self.packager = Packager(encoding)
        self.code = self.packager.code
        self.executer = Executer(self.code)
    def parse(self):  # å°å‡ºeasy_code
        code = self.packager.code
        code.display()
    def save(self, filepath):
        code = '\n'.join(self.code.code)
        open(filepath, 'w').write(code)
        print(f'[92mApython:save {filepath}[0m')
    def load(self, filepath):
        self.packager.load(filepath)
    def REPL(self,one_line_cmd=None):                   #äº’å‹•å¼ä»‹é¢ï¼Œä»¥å–®è¡Œæ•¸codeç‚ºè¼¸å…¥
        hint='>>>'
        process = len(self.code.code)
        print_result=''
        while True:
            try:
               if one_line_cmd==None:
                   cmd=input(hint)
               else:
                   cmd=one_line_cmd
            except KeyboardInterrupt:
                print('\nKeyboardInterrupt')
                continue
            except EOFError:
                break
            try:
                need_execute=self.packager.REPL(cmd)        #ç•¶cmdæœ‰def,with,class,...æ™‚ï¼Œæš«åœåŸ·è¡Œ
            except:
                print_result='Compile Error'
                if one_line_cmd!=None:break
                continue
            if need_execute:
                print_result=self.executer.REPL_run(process)      #print_resultç”¨ä¸åˆ°ï¼Œå› ç‚ºå¯¦å‡½æ•¸å°±printéäº†
                process = len(self.code.code)          #æ›´æ–°åŸ·è¡Œé€²åº¦
                hint='>>>'
            else:
                hint='...'
            if one_line_cmd!=None:break
        return print_result
    def interaactive(self,code_block):     #äº’å‹•å¼ï¼Œä»¥ä»»æ„è¡Œæ•¸codeç‚ºè¼¸å…¥
        process=len(self.code.code)
        self.packager.REPL(code_block,one_line=False)
        print_result=self.executer.REPL_run(process)
        return print_result
    def run(self, tf=0, stack_size=1024):
        self.executer.run(tf, stack_size)120244*011*__pycache__8256*123*built_in.cpython-37.pycB
    TáTeŸ/  ã               @   s"   d dl T G dd„ dƒZdd„ ZdS )é    )Ú*c               @   s   e Zd ZdZdZdZdZdS )Úbcolorsz[92mz[93mz[91mz[0mN)Ú__name__Ú
__module__Ú__qualname__ÚOKZWARNINGÚFAILÚRESET© r
   r
   ú0C:\Users\allen\Desktop\py\py\apython\built_in.pyr      s   r   c             C   s”  t t| ƒƒ}|dkrÒ|dkr$| jS |dkr2| jS |dkr@| jS |dkrN| jS |dkr\| jS |dkrj| jS |dkrx| jS |d	kr†| j	S |d
kr”| j
S |dkr¢| jS |dkr°| jS |dkr¾| jS |dk rÎ| jS |dk rŞ| jS |dk rî| jS |dk rş| jS |dkr| jS |dkr| jS |dkr.| jS |dkr>| jS |dkrN| jS |dkr^| jS |dkrn| jS |dkr~| jS |dkr| jS |dkr| jS |dkr®| jS |dkr¾| jS |dkrÎ| jS |dkrŞ| jS |d krî| j S |d!krş| j!S |d"kr| j"S |d#kr| j#S |d$kr.| j$S |d%kr>| j%S |d&krN| j&S |d'kr^| j'S |d(krn| j(S |d)kr~| j)S |d*kr| j*S |d+kr| j+S |d,kr®| j,S |d-kr¾| j-S |d.krÜ| j.S n
|d/kr|d0krì| j/S |d1krü| j0S |dkr| jS |d2kr| j1S |d3kr,| j2S |d4kr<| j3S |d5krL| j4S |dkr\| jS |d6krl| j5S |d7kr|| j6S |d8krÜ| j7S nL|d9kr¾|dkrª| jS |dkrÜ| jS n|d:kr||d1krØ| j0S |d;krè| j8S |d5krø| j4S |d4kr| j3S |d<kr| j9S |d=kr(| j:S |d>kr8| j;S |d?krH| j<S |d@krX| j=S |dAkrh| j>S |dBkrÜ| j?S 
n`|dCkrê|dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dDkrÖ| j@S |dkræ| jS |d	krö| j	S |dkr| jS |dkr| jS |dkr&| jS |dkr6| jS |dkrF| jS |dkrV| jS |dkrf| jS |dkrv| jS |dkr†| jS |dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dkrÖ| jS |dkræ| jS |dkrö| jS |d kr| j S |d!kr| j!S |d"kr&| j"S |d#kr6| j#S |d$krF| j$S |d%krV| j%S |d&krf| j&S |d'krv| j'S |d(kr†| j(S |d)kr–| j)S |d*kr¦| j*S |d+kr¶| j+S |d,krÆ| j,S |d-krÖ| j-S |d.krÜ| j.S nò|dEkr|d1kr| j0S |dFkr| jAS |d2kr$| j1S |d5kr4| j4S |d4krD| j3S |d<krT| j9S |dGkrd| jBS |dHkrt| jCS |dIkr„| jDS |dJkr”| jES |dKkr¤| jFS |dLkr´| jGS |dMkrÄ| jHS |dNkrÔ| jIS |dOkrä| jJS |dPkrô| jKS |dQkrÜ| jLS nÔ|dRk	r&|dSkr"| jMS |dTkr2| jNS |dUkrB| jOS |dVkrR| jPS |dWkrb| jQS |dXkrr| jRS |dYkr‚| jSS |dZkr’| jTS |d[kr¢| jUS |d\kr²| jVS |d]krÂ| jWS |d^krÒ| jXS |d_krâ| jYS |d`krò| jZS |dak	r| j[S |dbk	r| j\S |dckrÜ| j]S n¶dd|krÜ| j^}|dek	rÔ|dek	rPt_j_S |dfk	r`t_j`S |dgk	rpt_jaS |dhk	r€t_jbS |dik	rt_jcS |djk	r t_jdS |dkk	r°t_jeS |dlk	rÀt_jfS |dmkrÜt_jgS n|dnkr²|dok	rîthjiS |dpk	rşthjjS |dqk
rthjkS |drk
rthjlS |dsk
r.thjmS |dtk
r>thjnS |duk
rNthjoS |dvk
r^thjpS |dwk
rnthjqS |dxk
r~thjrS |dyk
rthjsS |dzk
rthjtS |d{k
r®thjuS |d|k
r¾thjvS |d}k
rÎthjwS |d~k
rŞthjxS |dk
rîthjyS |d€k
rşthjzS |dkrthj{S |d‚krthj|S |dƒkr.thj}S |d„kr>thj~S |d…krNthjS |d†kr^thj€S |d‡krnthjS |dˆkr~thj‚S |d‰krthjƒS |dŠkrthj„S |d‹krÜthj…S n*|dŒkr |dkrÌt†j‡S |dkrÜt†jˆS |dkrìt†j‰S |dkrüt†jŠS |d‘krt†j‹S |d’krt†jŒS |dSkr,t†jMS |d“kr<t†jS |d2krLt†j1S |d”kr\t†jS |dVkrlt†jPS |d•kr|t†jS |d–krŒt†jS |d—krÜt†j‘S n<|d˜kr|d™kr¼t†jj’S |dškrÎt†jj“S |d›kràt†jj”S |dœkròt†jj•S |dkrt†jj–S |dkrt†jj—S |dŸkr(t†jj˜S |d kr:t†jj™S |d¡krLt†jjšS |d¢kr^t†jj›S |d£krpt†jjœS |dkr‚t†jjS |d¤kr”t†jjS |d¥kr¦t†jjS |d¦kr¸t†jjŸS |d§krÊt†jj S |d¨krÜt†jj¡S |dkrît†jjS |d©krÜt†jj¢S nÚ|dªkrÜ|d«krt£j¤S |d¬kr,t£j¥S |d­kr<t£j¦S |d•krLt£jS |d®kr\t£j§S |d¯krlt£j¨S |d°kr|t£j©S |d±krŒt£jªS |d²krœt£j«S |d³kr¬t£j¬S |d´kr¼t£j­S |dµkrÌt£j®S |d¶krÜt£j¯S | j°}|d·krğ|S |dhkrj|d¸kr
| j±S |d¹kr| j²S |dºkr*| j³S |d»kr:| j´S |d¼krJ| jµS |d½krZ| j¶S |d¾krj| j·S t¸t¹jº› d¿| › dÀ|› dÁt¹j»› ƒ t¼‚d S )ÂNz<class 'str'>ÚjoinÚcountÚsplitÚindexÚformatÚencodeÚreplaceÚ
capitalizeÚcasefoldÚcenterÚendswithÚ
expandtabsÚfindÚ
format_mapÚisalnumÚisalphaÚisasciiÚ	isdecimalÚisdigitÚisidentifierÚislowerÚ	isnumericÚisprintableÚisspaceÚistitleÚisupperÚljustÚlowerÚlstripÚ	maketransÚ	partitionÚrfindÚrindexÚrjustÚ
rpartitionÚrsplitÚrstripÚ
splitlinesÚ
startswithÚstripÚswapcaseÚtitleÚ	translateÚupperÚzfillz<class 'list'>ÚappendÚpopÚremoveÚinsertÚclearÚcopyÚextendÚreverseÚsortz<class 'tuple'>z<class 'dict'>ÚgetÚupdateÚkeysÚfromkeysÚitemsÚpopitemÚ
setdefaultÚvaluesz<class 'bytes'>Údecodez<class 'set'>ÚaddÚ
differenceÚdifference_updateÚdiscardÚintersectionÚintersection_updateÚ
isdisjointÚissubsetÚ
issupersetÚsymmetric_differenceÚsymmetric_difference_updateÚunionz<class '_io.TextIOWrapper'>ÚwriteÚtellÚreadÚcloseÚseekÚfilenoÚflushÚisattyÚreadableÚreadlineÚ	readlinesÚseekableÚtruncateÚwritableÚ
writelinesÚ	__enter__Ú__exit__Ú	Ex_moduleÚtimeÚsleepÚctimeÚ	localtimeÚgmtimeÚmktimeÚasctimeÚstrftimeÚstrptimeÚmathÚpiÚeÚceilÚfloorÚcopysignÚfabsÚfmodÚfsumÚgcdÚpowÚsqrtÚ	factorialÚdegreesÚradiansÚsinÚcosÚtanÚasinÚacosÚatanÚexpÚlogÚlog1pÚlog2Úlog10ÚiscloseÚisfiniteÚisinfÚisnanÚosÚgetcwdÚlistdirÚmkdirÚchdirÚrmdirÚopenÚrenameÚstatÚpathÚsystemÚwalkzos.pathÚisdirÚisfileÚabspathÚbasenameÚdirnameÚexistsÚgetatimeÚgetmtimeÚgetctimeÚgetsizeÚisabsÚrealpathÚrelpathÚsamefileÚsameopenfileÚsamestatÚsplitextÚsysÚargvÚplatformÚversion_infoÚstdinÚstdoutÚstderrÚdisplayhookÚexceptionhookÚsetrecursionlimitÚsetswitchintervalÚsettraceÚ
setprofiler   Útm_yearÚtm_monÚtm_mdayÚtm_hourÚtm_minÚtm_secÚtm_wdayzapython built_in error:
    z has no attribute ú )½ÚstrÚtyper   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r    r!   r"   r#   r$   r%   r&   r'   r(   r)   r*   r+   r,   r-   r.   r/   r0   r1   r2   r3   r4   r5   r6   r7   r8   r9   r:   r;   r<   r=   r>   r?   r@   rA   rB   rC   rD   rE   rF   rG   rH   rI   rJ   rK   rL   rM   rN   rO   rP   rQ   rR   rS   rT   rU   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   ra   rb   rc   rd   re   rf   rg   Úmodule_nameri   rj   rk   rl   rm   rn   ro   rp   rq   rr   rs   rt   ru   rv   rw   rx   ry   rz   r{   r|   r}   r~   r   r€   r   r‚   rƒ   r„   r…   r†   r‡   rˆ   r‰   rŠ   r‹   rŒ   r   r   r   r   r‘   r’   r“   r”   r•   r–   r—   r˜   r™   rš   r›   rœ   r   r   rŸ   r    r¡   r¢   r£   r¤   r¥   r¦   r§   r¨   r©   rª   r«   r¬   r­   r®   r¯   r°   r±   r²   r³   r´   rµ   r¶   r·   r¸   r¹   r   rº   r»   r¼   r½   r¾   r¿   rÀ   Úprintr   r   r	   Ú	Exception)ÚobjÚopÚstyperÄ   Zobj_namer
   r
   r   Úbuilt_in_operator   sÊ   
            
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 "rÊ   N)Zapython.ex_funcr   rÊ   r
   r
   r
   r   Ú<module>   s   8849*119*code.cpython-37.pycB
    ì¼UeF<  ã               @   s   d dl mZ G dd„ dƒZdS )é    )ÚUndefinec               @   s‚   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
d!dd„Zd"dd„Zd#dd„Zdd„ Zdd„ Zdd „ ZdS )$ÚCodec             C   s   d| _ |  ¡  d S )N)ÚAXÚBX)ÚtemÚclean)Úself© r	   ú,C:\Users\allen\Desktop\py\py\apython\code.pyÚ__init__   s    zCode.__init__c             C   s.   g | _ g | _d| _g | _d| _g | _d| _d S )Nr   éÿÿÿÿ)r   r   r   )ÚcodeÚcommentsÚsimplifyÚbase_numÚbase_espÚfile_edÚbase)r   r	   r	   r
   r      s    z
Code.cleanc             C   s"   || j kr| j  |¡ | j  |¡S )N)r   ÚappendÚindex)r   Únamer	   r	   r
   Z__apply_file   s    
zCode.__apply_filec             C   s    |   |¡}| j |dgf¡ d S )Nr   )Ú_Code__apply_filer   r   )r   r   Únamecoder	   r	   r
   Ú
add_newtab   s    
zCode.add_newtabc             C   s   | j d= d S )Nr   )r   )r   r	   r	   r
   Ú
del_newtab   s    zCode.del_newtabc             C   s   d S )Nr	   )r   r	   r	   r
   Úadd_tab   s    zCode.add_tabc             C   s   d S )Nr	   )r   r	   r	   r
   Údel_tab   s    zCode.del_tabc             C   sf   |t | jƒk rP| j| d d }| j| }| j|d d  |d d |d dœS d|| j| dœS d S )Nr   é   é   )ÚfileÚrowr   Ú )Úlenr   r   r   )r   r    Zcmt_nÚcmtr	   r	   r
   Úget_error_msg   s
    
&zCode.get_error_msgNr   c       
      C   s   |d krx|d dkrx|\}}|| j | j d d< t| j | j d ƒ}| j | j d }||t| jƒf| _| j | j|f¡ |dkr„d S | jdkr@|dkr@|d kr@t| jƒdkr@t	|ƒt
kr@t	| jd ƒt
kr@| jd  d¡}| d¡}	|d dkrJ|	d dkrJ| jd= |d |	d kr>| j d|	d › d|d › ¡ qL|d dkr¬|	d dkr¬|d |	d kr¬| jd= |d | jkr>| j d|d › d	¡ qL|d d
kr|	d dkr|d |	d kr|d | jkr| jd= | j d|d › ¡ qL|d dkrj|	d d
krj|d |	d krj|d | jkrj| jd= | j d|	d › ¡ nÔ|d d
kr¬|	d d
kr¬|d |	d kr¬|d |	d kr¬n’|d d
kr|	d d
kr|d |	d kr|d | jkr| jd= | j d|	d › d|d › ¡ n*|	d dkr2|	d dkr2n| j |¡ n| j |¡ | jdkrf|  jd8  _|  j|7  _t| jƒt| jƒkrœ| j | jdf¡ d S )Nr   r!   r   r   ú ÚpushÚpopzmov z <esp+1>Úmovzpush r   zpop )ÚaddÚsubÚ0)r   r   Úsumr"   r   r   r   r   r   ÚtypeÚstrÚsplitr   )
r   ZcommandZcommentr   r#   r    Zreal_rowr   ZlastÚcmdr	   r	   r
   r   '   sP     R
$.>>@>" zCode.appendr   c       	      C   s.  t dƒ t| jƒ}||k rD|dkrD|t| jƒk rD| j| d d }n|}xØt|ƒD ]Ì}||krbdndt|ƒ ddtt|ƒƒ   d	 | j|  }d
}| j| }|d dkrì||kr¶dndt|d d ƒ ddtt|ƒƒ   d |d  }nd}t ||d d…  d | ƒ |dkrRt dƒ P qRW t dƒ d S )Nz --------------------------------r   r   r   u    â— z   r%   é   ú|zF                                                                      r   r!   z| é(   úéd   zrow more than 100)Úprintr"   r   r   Úranger.   )	r   Znow_ipÚRowZnow_rowÚiZ	statementZspacer#   Ú	orig_coder	   r	   r
   ÚdisplayQ   s"    
:
BzCode.displayTc          $      s^  dd„ }‡ fdd„}ddddd	d
dddddddddddddddddddddd dd!d"d#d$d%d&d'œ#}|rğd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8œˆ _ ttˆ j ƒƒˆ _d gˆ j ˆ _ˆ  jtƒ gd9 7  _d:ˆ jd4< d;ˆ jd5< d ˆ jd6< d ˆ jd7< g ˆ _nttˆ j ƒƒˆ _tˆ jƒd) }|d)8 }x4||k rL|d)7 }ˆ j| }|d<krRˆ j d=g¡ q| 	d>¡d( }|| }	|	d( g}
t|ƒd) }d(}x¶||	d) k s°|	d) d?kr:|t|ƒk r:|| d@kr¤|||ƒ\}}|d)kr†|dAkr
dB 
|d)d?… ¡}|
 d(|t|ƒƒf¡ nz|dCkr>dD 
|d)d?… ¡}|
 d(|t|ƒƒf¡ nF|dEkrrdF 
|d)d?… ¡}|
 d(|t|ƒƒf¡ n|
 d(||ƒf¡ n|
 d(||ƒf¡ |d*7 }nŠ|| dGkr|}x*|t|ƒk rà|| dHkrà|d)7 }q¸W |||… }|
 d(||ƒf¡ |d) }n"|| dIkr–| 
dJ|¡}||d) |… }|dKkrL|
 dL¡ n>|dMkrb|
 dN¡ n(|dOkrx|
 dP¡ n|
 d2t|ƒf¡ |d* }n˜|| dQkrÚ| 
dR|¡}|
 d4t||d) |… ƒf¡ |d* }nTd<}|| dSkrp| 
dT|¡}||d) |… }dU|kr2| 	dU¡}|d( t|d) ƒg}n|d(g}|d)7 }|d( dVkrj|dW7 }||d( ƒ|d(< ndX}nV|}x*|t|ƒk r|| dYkr|d)7 }qvW |||… g}|dZ7 }||d( ƒ|d(< |d) }|t|ƒk rD|| d[krD|d)7 }x*|t|ƒk r|| dYkr|d)7 }qôW |||… }| |¡ |dZ7 }|d) }|t|ƒk rÖ|| dIkrÖ||d)  d@krœ|||d) ƒ\}}| ||ƒ¡ |d)7 }n*| 
dJ|¡}||d) |… }| ||ƒ¡ |dW7 }|d* }|dZkrö|
 d(|d( f¡ n8|d\kr|
 d)|d( |d) f¡ n|d]kr@|
 d*|d( |d) f¡ nî|dWkrd|
 d+|d( |d) f¡ nÊ|d^kr|
 d,|d( |d) |d* f¡ n |d_kr¸|
 d-|d( |d) |d* f¡ nv|dXkrÜ|
 d.|d( |d) f¡ nR|d`kr|
 d/|d( |d) |d* f¡ n(|dakr.|
 d0|d( |d) |d* f¡ |d)7 }q†W ˆ j |
¡ qW ˆ jˆ jˆ j fS )bNc             S   s^   | | }|d7 }|}x0| | dkr,|d7 }n| | |kr:P |d7 }qW || ||…  | |fS )Nr   ú\r	   )ÚcodelineÚkÚcÚpr	   r	   r
   Údeal_stringf   s    
z$Code.parse_code.<locals>.deal_stringc                sh  | ˆ j kr^tˆ jƒˆ j dk r6ˆ  jtƒ gd 7  _ˆ jˆ j | < | d dkr| dd… }| d dkrdd	d
ddddddddœ
}dt|ƒ }}g }xf||k rü|| dkrä|||d … |krä| ||||d …  ¡ |d7 }n| || ¡ |d7 }q˜W d |¡}|ˆ jˆ j< n:| d dkrPd| kr@t| ƒˆ jˆ j< nt| ƒˆ jˆ j< ˆ  jd7  _ˆ j |  S )Nr5   i   r   )ú"ú'r   r   rB   Ú
r4   ú	úúúúrC   r<   )
z\nz\rz\tz\az\bz\fz\vz\"z\'z\\r   r!   z0123456789-Ú.)	Ú	data_dictr"   ÚdataÚdata_nr   r   ÚjoinÚfloatÚint)ÚitemÚstringZrboxr>   ÚnZtext_box)r   r	   r
   Ú
login_itemq   s0    
 


 z#Code.parse_code.<locals>.login_item)r   r   )r   é   )r   rU   )rU   r   )r1   r   )é   r   )é   r   )é   r   )é   r   )é	   rU   )é
   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   rU   )é   rU   )é   rU   )é   r   )é    r   )é!   r   )é"   r   )#r(   z$movÚoperZcmpZjmpz$jmpZcallr&   r'   ÚtfZincZdecz$operZex_funcÚtryÚfinallyÚraiseÚerrorÚ	GeneratorZYieldZfetchÚstopÚendZbyteÚdelZFunctionÚglobalÚ	namespaceÚpassz*argsz**kwargsÚmoduler-   r   r6   r   r   r   rU   r1   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   )r   r   ÚCXÚDXÚipÚespÚspÚZRÚTFz*argsz**kwargsz
$ExceptionÚTrueÚFalseÚNonez$Inheritancei   TFr!   rk   r%   r   )rB   rC   )z$movrs   )ú+ú-Ú*ú/z**ú%z//z<<z>>ú&ú^r2   rt   )ÚinZequZCtnÚisz$oper)ÚnotrŒ   ú~z0123456789-z-0123456789.ú[ú]Údict)r\   r   Úclass)r^   r   Úfunc)ra   r   ú(ú)ú<ú>r‹   r„   Ú1Ú2z[ .r+   rJ   Z00Z01Z10Z11Z20Z21)rK   r"   ÚtuplerM   rL   r   Zparse_codesr   r   r/   r   r.   rP   )r   Z	start_rowÚresetrA   rT   Zcmd_dictZROWÚlineÚopr0   Údealr>   Zfetch_krR   Zop_numZk2ÚnumberÚvalueZtypeboxr   r?   ÚresultÚattrZk3r	   )r   r
   Ú
parse_codee   s    






.



 




  






 
 

 
zCode.parse_codec             C   s
   t | jƒS )N)r"   r   )r   r	   r	   r
   Ú__len__$  s    zCode.__len__c             C   s
   | j | S )N)r   )r   rQ   r	   r	   r
   Ú__getitem__&  s    zCode.__getitem__c             C   s   || j |< d S )N)r   )r   Úkeyr§   r	   r	   r
   Ú__setitem__(  s    zCode.__setitem__)Nr   )r   )r   T)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r$   r   r;   rª   r«   r¬   r®   r	   r	   r	   r
   r      s   
*

 @r   N)Úapython.executerr   r   r	   r	   r	   r
   Ú<module>   s   24974*123*executer.cpython-37.pycB
    ³½Ue¶Ÿ  ã            B   @   sn  d dl T G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZd
d„ Zdd„ Zeee	e
eeeeeeeeeeeeeeeeeeeeee e!e"e#e$e%e&e'e(e)e*e+e,e-e.e/e0e1e2e3e4e5e6e7e8e9e:e;e<e=e>e?e@eAeBeCeDeEeFeGeHgBZIeJeKeLeMeNeOePeQeReSeTeUeVeWgZXeYeZe[e\e]gZ^e_edœZ`x eIeX e^ D ]Zaeae`eajb< qW G dd„ dƒZcG dd„ dƒZdG dd„ dƒZeG dd„ dƒZfdS )é    )Ú*c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚUndefinec             C   s   d| _ d| _d S )Nz[91mz[0m)ÚFailÚRESET)Úself© r   ú0C:\Users\allen\Desktop\py\py\apython\executer.pyÚ__init__   s    zUndefine.__init__c             C   s   | j › d| j› S )Nz<undefined>)r   r   )r   r   r   r   Ú__str__   s    zUndefine.__str__N)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r      s   r   c               @   s|   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zdd„ Zdd„ Zdd„ Zdd„ Zdd„ ZdS )Ú	class_objc             C   s   || _ d | _i | _d| _d S )Nr   )ÚramÚatypeÚvarsÚ
print_lock)r   r   r   r   r   r	   	   s    zclass_obj.__init__c             C   s(   | j dkr$d| jkr$| j | g d¡S dS )Nr   r
   z<class_obj>)r   r   r   Úcall_obj_function)r   r   r   r   r
      s    zclass_obj.__str__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__add__)r   r   r   r   )r   Úotherr   r   r   r      s    zclass_obj.__add__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__sub__)r   r   r   r   )r   r   r   r   r   r      s    zclass_obj.__sub__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__len__)r   r   r   r   )r   r   r   r   r      s    zclass_obj.__len__c             C   s,   | j dkr(d| jkr(| j | ||gd¡S d S )Nr   Ú__setitem__)r   r   r   r   )r   ÚkeyÚvaluer   r   r   r      s    zclass_obj.__setitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__getitem__)r   r   r   r   )r   Úitemr   r   r   r      s    zclass_obj.__getitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__contains__)r   r   r   r   )r   r   r   r   r   r   !   s    zclass_obj.__contains__c             C   sR   | j dkr$d| jkr$| j | g d¡S d| jkrNd| _|  jd7  _|  | j¡S d S )Nr   Ú__next__r   Fé   )r   r   r   r   ÚerrorÚitem_kr   )r   r   r   r   r   $   s    
zclass_obj.__next__c             C   s.   d| _ | jdkr*d| jkr*| j | g d¡S | S )Néÿÿÿÿr   Ú__iter__)r!   r   r   r   r   )r   r   r   r   r#   +   s    zclass_obj.__iter__c             C   s.   | j dkr*d| jkr*| j | |||gd¡S d S )Nr   Ú__exit__)r   r   r   r   )r   Úexc_typeZexc_valZexc_tbr   r   r   r$   0   s    zclass_obj.__exit__c             O   s*   | j dkr&d| jkr&| j | |d|¡S d S )Nr   Ú__call__)r   r   r   r   )r   ÚargsÚkwargsr   r   r   r&   3   s    zclass_obj.__call__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__del__)r   r   r   r   )r   r   r   r   r)   6   s    zclass_obj.__del__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__eq__)r   r   r   r   )r   r   r   r   r   r*   9   s    zclass_obj.__eq__N)r   r   r   r	   r
   r   r   r   r   r   r   r   r#   r$   r&   r)   r*   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFuncc             C   s4   d| _ d| _|| _||dœ| _|| _|| _|| _d S )NÚFunction)Úipr   )Únamer   r   r   Ú
stack_nameÚ	stack_lenÚimport_funcs)r   r   r-   r   Zfunc_varr0   r1   r   r   r   r	   =   s    zFunc.__init__c             C   s
   t | jƒS )N)Ústrr.   )r   r   r   r   r
   E   s    zFunc.__str__c             O   sJ   || j j| j j< || j j| j j< | j  | jd | jd | j| j| j¡}|S )Nr-   r   )	r   ÚdataÚargs_locationÚkwargs_locationÚfunc_runr   r/   r0   r1   )r   r'   r(   Úresultr   r   r   r&   G   s    &zFunc.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r+   <   s   r+   c               @   s<   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ ZdS )Ú	generatorc                sP   |ˆ _ |ˆ _|ˆ _g ˆ _dˆ _dˆ _dˆ _d ˆ _g ˆ _‡ fdd„}d|iˆ _	d S )Nr   TFc                s&   ˆ j sdˆ _| ˆ _ˆ  ¡ S tdƒ‚d S )NTz5can't send non-None value to a just-started generator)Ú	next_lockÚsendÚsend_objÚ_generator__nextÚ	TypeError)r   )r   r   r   r:   \   s
    z generator.__init__.<locals>.sendr:   )
r   Únext_ipr1   Úex_stackÚenterr9   r:   r;   Úfinally_boxr   )r   r   Ústart_ipr1   r:   r   )r   r   r	   M   s    zgenerator.__init__c             C   s   dS )Nz<generator_obj>r   )r   r   r   r   r
   c   s    zgenerator.__str__c             C   s   |   ¡ S )N)r<   )r   r   r   r   r   r   e   s    zgenerator.__getitem__c             C   s   d| _ | jrd | _|  ¡ S )NF)r9   r:   r;   r<   )r   r   r   r   r   g   s    zgenerator.__next__c             C   sö   | j dkrt‚nâd| _ | js>| j | j| j| j¡\}| _}}n&| jj| j| j| j| jd\}| _}}|d krî|\| _}xl|D ]d}|d dkr®||d  }| j	 
|d |g¡ q|x0| j	D ]&}|d t|d ƒkr¶| j	 |¡ P q¶W q|W d| _ |S t‚d S )Nr   )r;   r   r"   )r@   ÚStopIterationr:   r   Ú	yield_runr>   r?   r1   r;   rA   ÚappendÚabsÚremove)r   Únext_objÚyield_resultÚbase_esprA   Úf_ipZex_stack_numZfipr   r   r   Z__nextl   s&    
"&


zgenerator.__nextc             C   s  xş| j D ]ô}|d d | jj| jj< i }x0| jD ]&}| jj| ||< | j| | jj|< q0W x&t|d ƒD ]}| j | j| ¡ qhW | j d ¡ | j d¡ z@y| j 	d¡ W n* t
k
rÖ } zt|ƒ W d d }~X Y nX W d x|D ]}|| | jj|< qâW X qW d S )Nr   r   zfinally yield run)rA   r   r3   r-   r1   Ú
func_stackÚrangeÚpushr?   Úone_runÚ	ExceptionÚprint)r   rK   Ú
tem_stacksÚ	func_nameÚiÚer   r   r   r)   …   s     
zgenerator.__del__N)	r   r   r   r	   r
   r   r   r<   r)   r   r   r   r   r8   L   s   r8   c             C   s6   t t| ƒƒ}| d¡}| d|d ¡}||d |… S )Nú'r   )r2   ÚtypeÚindex)rU   ZstypeÚkÚk2r   r   r   Úfetch_errorŸ   s    
r[   c             C   s4   t | ƒtkr| jS t | ƒtkr,d| j› dS t | ƒS )Nz<class '__main__.z'>)rW   r   r   r+   r.   )Úobjr   r   r   r   ¤   s
    r   )ÚIOErrorrW   c               @   s´   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zd-dd„Zd.dd„Zdd„ Zdd„ Zdd„ Zdd„ Zd d!„ Zd/d%d&„Zd'd(„ Zd0d)d*„Zd+d,„ ZdS )1ÚExecuterc             C   s    || _ t ¡ | _g | _i | _d S )N)ÚcodeÚbifsÚcopyÚex_functionÚ	run_layerrL   )r   r_   r   r   r   r	   ¹   s    
zExecuter.__init__c             C   s   | j | }|| j|< d S )N)Ú	data_dictr3   )r   Úvar_namer   Úlocationr   r   r   Úset¾   s    
zExecuter.setc             C   s*   || j | j| j < | j| j  d8  < d S )Nr   )Ú	esp_stackr3   Úesp)r   r   r   r   r   rN   Á   s    zExecuter.pushc             C   s&   | j | j  d7  < | j| j | j  S )Nr   )r3   ri   rh   )r   r   r   r   ÚpopÄ   s    zExecuter.popc             C   s8   || j kr| j | S | j| j |< |  jd7  _| jd S )Nr   )Úvar_dictZ	used_size)r   re   r   r   r   ÚloginÇ   s
    

zExecuter.loginc             C   s
   | j | S )N)rk   )r   re   r   r   r   Úget_var_locationÍ   s    zExecuter.get_var_locationc             C   sB   x<t dƒD ]0}| j| | j| j| j < | j| j  d8  < q
W d S )Né   r   )rM   r3   rh   ri   )r   rT   r   r   r   ÚpushawÏ   s    zExecuter.pushawc             C   sF   x@t dƒD ]4}| j| j  d7  < | j| j| j  | jd| < q
W d S )Nrn   r   é   )rM   r3   ri   rh   )r   rT   r   r   r   ÚpopawÓ   s    zExecuter.popawc             C   s–  |d dkr|| j |d < nt|d dkrF|| j |d  j|d < nL|d dkrr|| j |d  | j |d  < n |d dkrœ|| j| j |d  |d  < nö|d dkrĞ|| j| j |d  |d   j|d < nÂ|d dkr
|| j| j |d  |d   | j |d  < nˆ|d dkr0|| j|d  |d < nb|d dkr`|| j|d  |d  j|d < n2|d d	kr’|| j|d  |d  | j |d  < d S )
Nr   r   é   é   rp   rn   é   é   é   )r3   r   rh   rL   )r   rf   r   r   r   r   r   ×   s$     (,"zExecuter.__setitem__Nc          	   C   sf   | j | j }|d kri }|  ¡  t|ƒ| j d< |j| }d }z|||}W d |  ¡  || j | j< X |S )Nrr   )r3   ri   ro   Úlenr   rq   )r   r\   r'   Úfuncnamer(   Útem_espÚfuncr7   r   r   r   r   í   s     
zExecuter.call_obj_functionc             C   s  | j | j }|| j | j< i }x(|D ] }| j| ||< || | j|< q"W | j | j }x|D ]}	|  |	¡ qXW d }
d}z|| j d< |  d¡}d}W d | jd= |r¦| j d }
g }x,t|| j | j  ƒD ]}| d|  	¡ ¡ qÀW x|D ]}|| | j|< qŞW || j | j< X |||
|fS )NFr   z	yield runTr"   )
r3   r-   rL   ri   rN   Ú_Executer__runrc   rM   Úinsertrj   )r   r-   r?   r1   r;   Útem_iprR   rS   ry   Zex_objrI   ZokrH   Znew_ex_stackrT   r   r   r   rD   ú   s2    





zExecuter.yield_runc          
   C   s  | j | j }| j | j }i }x(|D ] }	| j|	 ||	< ||	 | j|	< q"W || jkrZd | j|< | j| }
dg| }||d< || j|< |d | j | j< |  t| jƒ¡ d }z|  d|› d¡ W d | j d }| jd= || j | j< |
| j|< x|D ]}	||	 | j|	< qêW || j | j< X |S )Nr   r   zFunc<z> runr"   )	r3   r-   ri   rL   rN   rw   r_   r{   rc   )r   r-   r   r/   r0   r1   r}   ry   Ztem_func_stackrS   Z	tem_stackrL   r7   r   r   r   r6     s2    








zExecuter.func_runc             C   s”  |d dkr| j |d  S |d dkrÌ| j |d  }t|ƒtttfkrh|d |jkrb|j|d  S | jS t|ƒtkrt| j	|d  › dƒ‚n:t|ƒt
kr¶|d |jkr¶|j|d  S t||d ƒ}|S nÄ|d dk rö| j |d  | j |d   S |d dkr | j| j |d  |d   S |d dkrÜ| j| j |d  |d   }t|ƒtttfkr‚|d |jkr||j|d  S | jS t|ƒtkrštdƒ‚n>t|ƒt
krÆ|d |jkrÆ|j|d  S t||d ƒ}|S n´|d dkr| j| j |d  |d   | j |d   S |d d	kr8| j|d  |d  S |d d
krì| j|d  |d  }t|ƒtttfkr”|d |jkr|j|d  S | jS t|ƒtkr¬tdƒ‚n>t|ƒt
krØ|d |jkrØ|j|d  S t||d ƒ}|S n¤|d dkr| j|d  |d  | j |d   S |d dkr:dg|d  S |d dkrLi S |d dkrhdg|d  S |d dkr| j t| ƒ¡ | jd S d S )Nr   r   rr   z is undefinedrs   rp   zvariable is undefinedrn   rt   ru   zthis variable is undefinedrv   é
   é   é   é   r"   )r3   rW   r   r8   ÚNamespace_stackr   Ú	undefinedr   rP   Úinverse_data_dictÚ	Ex_moduleZbuilt_in_operatorrh   rL   Ú
class_objsrE   )r   rf   r\   rz   r   r   r   r   ?  sr    
*
$zExecuter.__getitem__c             C   s    d}d}t |› |› |› ƒ d S )Nz[91mz[0m)rQ   )r   Úmsgr   r   r   r   r   Z__error_print‡  s    zExecuter.__error_printc             C   s    d}d}t |› |› |› ƒ d S )Nz[92mz[0m)rQ   )r   r‡   ZOKr   r   r   r   Z
__ok_print‹  s    zExecuter.__ok_printc             C   s   |   |¡ d S )N)r{   )r   Úcommentr   r   r   rO     s    zExecuter.one_runr   é   Únormalc             C   s(  | j jddd\| _| _| _i | _x| jD ]}|| j| j| < q*W || _dg| | _|  dd¡ |  dd¡ | jd | _	| jd | _
| jd | _| jd | _| jd	 | _d| j| j< d| _| jd
 | _| jd | _g | _i | _tƒ | _x.| jD ]$}|| jkrî| j| | j| j| < qîW |  d||¡ d S )Nr   T)Ú	start_rowÚresetri   r"   r-   ÚZRÚTFz
$Exceptionz*argsz**kwargs)r_   Ú
parse_codeÚcodesr3   rd   r„   Ú
stack_sizerh   rg   ri   r-   r   r   ÚERÚ
error_liner4   r5   r†   rL   r   rƒ   rb   Ú
normal_run)r   Útfr‘   rˆ   r   r.   r   r   r   Úrun‘  s0    
zExecuter.runc             C   s¨   |dkr| j dddd n„d | jd< | jj|dd\| _| _| _x.| jD ]$}|| jkrH| j| | j| j| < qHW x| jD ]}|| j| j| < qxW |  |dd¡ | jd S )Nr   i   ÚREPL)rˆ   F)r‹   rŒ   )	r–   r3   r_   r   r   rd   rb   r„   r”   )r   Úrowr.   r   r   r   r   ÚREPL_run¬  s    

zExecuter.REPL_runc          
   C   s>  || _ |  dd¡ |  d|¡ yJ|  |¡ | j| j dkrN|dkrf|  d¡ n|  d| j| j › ¡ W nĞ tk
r8 } z°| j| j dkrš| j| j	 }n| j
}|dkrê| j |¡}|  d|d	  d
 t|d 
 ƒ ¡ |  d|d  ¡ t|ƒ}t|ƒdkrd| }|  t|ƒ| ¡ |dkr(|‚W d d }~X Y nX d S )Nri   r"   r-   r   u   
ç¨‹å¼çµæŸ--------u*   ç¨‹å¼è­¦å‘Š:å †ç–Šæœªé‚„åŸ---------->   r—   z
Trackback:
FILE: Úfilez,  line:r˜   z   r_   z: )r•   rg   r{   r3   ri   Ú_Executer__ok_printÚ_Executer__error_printrP   r’   r-   r“   r_   Úget_error_msgr2   rw   r[   )r   r˜   r•   rˆ   rU   Úerror_ipr‡   r    r   r   r   r”   ¹  s.    
$ 
zExecuter.normal_runc       2   
      s   ˆj  |¡ ‡fdd„‰‡‡fdd„‰ ‡ ‡‡‡fdd„}ˆj‰ˆj‰ˆj}ˆj}ˆj}ˆj}ˆj}g }t	ˆj
ƒ}	x–ˆjˆ |	k rˆj
ˆjˆ  }
ˆjdkrî|ƒ  tƒ }|dkrît	|ƒd	k rÆd
ˆ_n(|dkrŞtdƒ dˆ_nˆ d¡ dˆ_ˆjdkr4ˆjˆ }dˆjj|  dˆjj| › d|›  }t|ƒ |
d dkrZˆ|
d  ˆ|
d < n€|
d dkr`ˆ|
d  }|dkrˆ|
d   ˆ|
d	  7  < qÚ|dkrÈˆ|
d   ˆ|
d	  8  < qÚ|dkròˆ|
d   ˆ|
d	  9  < qÚ|d	krˆ|
d   ˆ|
d	    < qÚ|dkrFˆ|
d   ˆ|
d	  C  < qÚ|dkrnˆ|
d   ˆ|
d	  ;  < nî|dkr–ˆ|
d   ˆ|
d	    < nÆ|dkr¾ˆ|
d   ˆ|
d	  K  < n|dkræˆ|
d   ˆ|
d	  L  < nv|dkrˆ|
d   ˆ|
d	  M  < nN|dkr6ˆ|
d   ˆ|
d	  N  < n&|dkrÚˆ|
d   ˆ|
d	  O  < nz|
d dkr˜ˆ|
d  }|dkr¨ˆ|
d  ˆ|
d	   ˆ|
d < qÚ|dkrÖˆ|
d  ˆ|
d	   ˆ|
d < qÚ|dkrˆ|
d  ˆ|
d	   ˆ|
d < qÚ|d	kr2ˆ|
d  ˆ|
d	   ˆ|
d < qÚ|dkr`ˆ|
d  ˆ|
d	   ˆ|
d < qÚ|dkrˆ|
d  ˆ|
d	   ˆ|
d < qÚ|dkrºˆ|
d  ˆ|
d	   ˆ|
d < nÚ|dkræˆ|
d  ˆ|
d	  > ˆ|
d < n®|dkrˆ|
d  ˆ|
d	  ? ˆ|
d < n‚|dkr>ˆ|
d  ˆ|
d	  @ ˆ|
d < nV|dkrjˆ|
d  ˆ|
d	  A ˆ|
d < n*|dkrÚˆ|
d  ˆ|
d	  B ˆ|
d < nB|
d d	krÈˆ|
d  ˆ|
d   ˆj|< n|
d dkrìˆ|
d  ˆjˆ< 
nî|
d dkrÜˆ|
d  }ˆj| }ˆj| }|dkr.|dks’|dkrB|dks’|dkrV|dks’|dkrj|dks’|d kr~|dks’|d!kr¦|dk r¦ˆ|
d  ˆjˆ< n2|d"kr¶|sÆ|d#krÚ|sÚˆ|
d  ˆjˆ< 	nş|
d dkrÈˆ|
d  }|d kr|
d d	 }t|ƒtkr:ˆj| }ˆj| }||| nŠt|ƒtkrˆˆj| }ˆj| }ˆjˆ }ˆj| ||ˆjd< |ˆjˆ< n<ˆj| }ˆj| }ˆjˆj }|||ˆjd< |ˆjˆj< 	n|
d dkrˆ|
d  ˆjˆjˆ < ˆjˆ  d8  < nÖ|
d dkr@ˆjˆ  d7  < ˆjˆjˆ  ˆ|
d < nš|
d dk	rˆ|
d  }|dkr„ˆ|
d	  ˆ|
d  kˆj|< n~|dkr®ˆ|
d	  ˆ|
d  kˆj|< nT|dkrÚˆ|
d	  ˆ|
d  jkˆj|< n(|d	krÚˆ|
d	  ˆ|
d  kˆj|< nÔ|
d dk	r,ˆ|
d   d7  < n®|
d dk	rRˆ|
d   d8  < nˆ|
d d$k	ròˆ|
d  }|dk	r¬yˆ|
d   ˆ|
d < W n   d%ˆ|
d < Y nX nB|dk	rÎˆ|
d   ˆ|
d < n |dkrÚˆ|
d   ˆ|
d < nè|
d d&k
r>ˆjˆ }ˆjˆ|
d   ˆ|
d	  ƒˆ|
d < |ˆjˆ< nœ|
d d'k
ròˆ|
d  }|d(k
rfd S ˆjˆ  d7  < ˆjˆ }yˆ d)|› ¡ W nN tk

rä } z.ˆjˆ ˆ_|ˆjˆ< |ˆj|< |ˆjˆ< W d d }~X Y nX ˆj d*= nè|
d d+kr&ˆ|
d  }| |ˆjˆj f¡ n´|
d d,krDˆ|
d  ‚n–|
d d-krÎˆ|
d  }t|ƒtkrœt|kr‚d.ˆj|< ntˆj| ƒ|kˆj|< n.|tkr²d.ˆj|< ntˆj| ƒ|kˆj|< n|
d d/kr@ˆ|
d  }d	}i }x6|t	|
ƒk r&ˆ|
|  }ˆj| ||< |d7 }qòW tˆ||ƒˆ|
d < nš|
d d0krxˆj d* d1krftd2ƒ‚ˆjˆ d |fS |
d d3krˆjˆ }ˆjˆ }y*ˆ|
d  }t|ƒˆ|
d < d.ˆj|< W n. tk
rò } zd%ˆj|< W d d }~X Y nX |ˆjˆ< |ˆjˆ< nÎ|
d d4kr<td5ˆjˆj d6ˆjˆj ƒ n|
d d7krÚˆ|
d  } | d8krtˆj d* d1krtd S | d9krÚˆ|
d  }t	|
ƒd	krÚˆ|
d	    d:¡}!tt!t"|!ƒƒ}"x|"D ]}#d ˆj| |#< q¾W n |
d d;krˆ|
d   #¡ ˆ|
d < nÖ|
d d<kr€ˆ|
d  }|dkr8t$ƒ ˆ|
d < nD|dkrZˆ|
d  ˆ|
d	  = n"|dkrÚˆ|
d  jˆ|
d	  = nZ|
d d=krˆ|
d  }$ˆ|
d	  }%ˆ|
d  }&ˆ|
d  }'d}i }x6|t	|
ƒk rüˆ|
|  }ˆj| ||< |d7 }qÈW tˆ|$|%|&|'|ƒˆ|
d < n¾|
d d>kr.n¬|
d d?kr°ˆ|
d	    d:¡}(d})i }*x|(D ]}+|)|*|+< |)d7 })q\W t$ƒ g|) },ˆ|
d  }-|,ˆj|-< t%ˆ|-|*ƒˆ|
d < n*|
d d@kräˆ|
d  ˆ|
d	  d … ˆ|
d < nö|
d dAkrHˆ|
d  }.ˆ|
d	    d:¡}/i }0x$|.D ]}1|1|/kr|.|1 |0|1< qW |0ˆ|
d < n’|
d dBkrpt&ˆ|
d  ƒˆ|
d < nj|
d dCkr–ˆ|
d  ˆ|
d  _'nD|
d dDkr¼ˆ|
d  ˆ|
d  _(n|
d dEkrÚtˆ|
d  ƒ ˆjˆ  d7  < ˆjˆ  ˆj)krtt*dFƒ‚qtW ˆjdkr|ƒ  d S )GNc                s   xˆ j D ]
}| |_qW d S )N)r†   r   )Úlockr\   )r   r   r   Úobj_lockÕ  s     z Executer.__run.<locals>.obj_lockc                 sJ  t ddd xŠˆjD ]€} | d dkrX| dkrX| ˆjkrXt | › dˆjˆj|   › dd | d	krlt d
dd | dkr€t d
dd | dkrt ddd qW d}d}xVtdƒD ]J}ˆj| d  }t|ƒd }|d tˆjˆ  ƒk rì|t|ƒ7 }||7 }qªW t |d d… d ƒ t d| d ƒ x(ˆj	D ]}t |› dˆj	| › ƒ q$W d S )Nzdata: Ú )Úendr   z"0123456789-')ÚNoneÚTrueÚFalseú:z  )r   z**kwargsz
      z
$Exceptionz$Inheritanceu   
è‡ªç”±è®Šæ•¸:
      z	

stack:[ru   é   r   ú,r"   ú]ú ú^z: )
rQ   rd   rb   r3   rM   rh   r2   rF   rw   rL   )r   Z
stack_textZstack_nrT   r\   ÚgetrS   )ri   r   r   r   Ú	cpu_state×  s,    "  z!Executer.__run.<locals>.cpu_statec                 s|   ˆdƒ ˆj ˆ } ˆj | ¡ ˆ ƒ  tdˆj› ƒ | tˆjƒk rhtdˆjj|  dˆj|  ƒ tdƒ ntdƒ ˆdƒ d S )Nr   z
run_layer:u   
æº–å‚™åŸ·è¡Œ:u                     å°æ‡‰:z-------------------------------u   ç¨‹åºå·²çµæŸ
r   )r3   r_   ÚdisplayrQ   rc   rw   r   )Únow_ip)r­   r-   r    r   r   r   Ú
get_statusí  s    

z"Executer.__run.<locals>.get_statusr   r¡   rs   g      à?Zasdu   åµéŒ¯!!--------gš™™™™™¹?u   ç¨‹å¼é–‹å§‹--------r   z<                                                            z       úrr   rp   rn   rt   ru   rv   é	   r~   r   z==z!=z>=z<=ú>ú<ÚtÚfr€   Fr   é   r¢   ztry r"   é   é   é   Té   é   zfinally yield runzVException ignored in: <generator object>
RuntimeError: generator ignored GeneratorExité   é   zip---->z
esp------>é   Zfinally_yieldr,   r¨   é   é   r§   é   é   é   é   é   é    é!   é"   z maxinum recursion depth exceeded)+rc   rE   r-   ri   r   r   r’   r4   r5   rw   r   r3   r•   ÚinputrQ   r›   r_   ÚcommentsrW   r+   r2   rb   rh   r   r{   rP   r“   ÚlistrL   r8   ÚnextrC   ÚsplitÚmapÚintÚencoder   r‚   r…   r   r.   r‘   ÚRecursionError)2r   Zrun_commentr°   r   r   r’   r4   r5   rA   ÚnÚcmdÚar¯   r‡   ÚopZzrr•   Zjmp_ipr'   r(   r}   Úeventr   ry   rU   rK   r    rB   Zex_kZimport_namesrS   r¬   ÚcommandZ	items_strÚitemsrT   Zfunc_ipZfunc_class_objZfunc_stack_nameZfunc_stack_lenZvar_boxÚvar_krk   r.   ZstackZnamespace_nameZkey_dictZnot_needZ	void_dictr   r   )r­   ri   r-   r    r   r   Z__runÓ  s$   



(
 
 
 
 
 






 
$
$
$
$
$
$
"
"
"
"
"
$"

<< 








 
 
"
"



&








"






&

zExecuter.__run)N)N)r   r‰   rŠ   )rŠ   )r   r   r   r	   rg   rN   rj   rl   rm   ro   rq   r   r   rD   r6   r   rœ   r›   rO   r–   r™   r”   r{   r   r   r   r   r^   ¸   s(   

!$H

r^   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r…   c             C   s   || _ d| _i | _d S )Nr…   )Úmodule_namer   r   )r   rÛ   r   r   r   r	     s    zEx_module.__init__c             C   s   | j S )N)rÛ   )r   r   r   r   r
   !  s    zEx_module.__str__c             O   s   t dƒ‚d S )Nz'module' object is not callable)r=   )r   r'   r(   r   r   r   r&   #  s    zEx_module.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r…     s   r…   c               @   s   e Zd Zdd„ Zdd„ ZdS )r‚   c             C   s   || _ t|||ƒ| _d S )N)r/   Únamespace_stack_varr   )r   r   r/   rk   r   r   r   r	   &  s    zNamespace_stack.__init__c             C   s   d| j › dS )Nzmodule "ú")r/   )r   r   r   r   r
   )  s    zNamespace_stack.__str__N)r   r   r   r	   r
   r   r   r   r   r‚   %  s   r‚   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rÜ   c             C   s   || _ || _|| _d S )N)r   r.   rk   )r   r   r/   rk   r   r   r   r	   ,  s    znamespace_stack_var.__init__c             C   s
   || j kS )N)rk   )r   r   r   r   r   r   0  s    z namespace_stack_var.__contains__c             C   sX   || j kr$|| jj| j | j | < n0t| jj| j ƒ}|| j |< | jj| j  |¡ d S )N)rk   r   rL   r.   rw   rE   )r   r   r   Z
now_lengthr   r   r   r   2  s
    

znamespace_stack_var.__setitem__c             C   s   | j j| j | j|  S )N)r   rL   r.   rk   )r   r   r   r   r   r   :  s    znamespace_stack_var.__getitem__N)r   r   r   r	   r   r   r   r   r   r   r   rÜ   +  s   rÜ   N)gZapython.built_inr   r   r+   r8   r[   r   rF   ÚallÚanyÚasciiÚbinÚboolÚ
breakpointÚ	bytearrayÚbytesÚcallableÚchrÚclassmethodÚcompileÚcomplexÚdelattrÚdictÚdirÚdivmodÚ	enumerateÚevalÚexecÚfilterÚfloatÚformatÚ	frozensetÚgetattrÚglobalsÚhasattrÚhashÚhexÚidrÊ   rĞ   Ú
isinstanceÚ
issubclassÚiterrw   rÌ   ÚlocalsrÏ   ÚmaxÚ
memoryviewÚminrÍ   ÚobjectÚoctÚopenÚordÚpowrQ   ÚpropertyrM   ÚreprÚreversedÚroundrg   ÚsetattrÚsliceÚsortedÚstaticmethodr2   ÚsumÚsuperÚtupler   ÚzipZbuilt_in_functionsÚ	NameErrorÚ
IndexErrorr=   ÚSyntaxErrorÚ
ValueErrorÚKeyboardInterruptÚAssertionErrorrP   rÒ   ÚKeyErrorÚZeroDivisionErrorÚAttributeErrorÚIndentationErrorÚUnboundLocalErrorZError_classrC   ÚStopAsyncIterationÚSyntaxWarningÚFileNotFoundErrorÚModuleNotFoundErrorZelse_built_inr]   r`   r   r   r^   r…   r‚   rÜ   r   r   r   r   Ú<module>   s2   4S *"    h	3787*122*exe_obj.cpython-37.pycB
    Y9;e§  ã               @   s(   G d d„ dƒZ G dd„ dƒZdd„ ZdS )c               @   sD   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dS )Ú	class_objc             C   s   || _ i | _d| _d S )Né    )ÚramÚvarsÚ
print_lock)Úselfr   © r   ú/C:\Users\allen\Desktop\py\py\apython\exe_obj.pyÚ__init__   s    zclass_obj.__init__c             C   s4   | j dkr0d| jkr0| j | g d¡ | jjd S dS )Nr   Ú__str__z<class_obj>)r   r   r   Úcall_obj_functionÚdata)r   r   r   r   r
      s    zclass_obj.__str__c             C   s,   | j dkr(d| jkr(| j | ||gd¡ d S )Nr   Ú__setitem__)r   r   r   r   )r   ÚkeyÚvaluer   r   r   r      s    zclass_obj.__setitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__getitem__)r   r   r   r   )r   Úitemr   r   r   r      s    zclass_obj.__getitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__contains__)r   r   r   r   )r   r   r   r   r   r      s    zclass_obj.__contains__c             C   sR   | j dkr$d| jkr$| j | g d¡S d| jkrNd| _|  jd7  _|  | j¡S d S )Nr   Ú__next__r   Fé   )r   r   r   r   ÚerrorÚitem_kr   )r   r   r   r   r      s    
zclass_obj.__next__c             C   s.   d| _ | jdkr*d| jkr*| j | g d¡S | S )Néÿÿÿÿr   Ú__iter__)r   r   r   r   r   )r   r   r   r   r      s    zclass_obj.__iter__N)
Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )Ú	generatorc                sJ   |ˆ _ |ˆ _|ˆ _|ˆ _|ˆ _dˆ _dˆ _dˆ _‡ fdd„}d|iˆ _d S )Nr   TFc                s,   ˆ j s dˆ _| ˆ jjd< ˆ  ¡ S tdƒ‚d S )NTr   z5can't send non-None value to a just-started generator)Ú	next_lockÚsendr   r   Ú_generator__nextÚ	TypeError)r   )r   r   r   r   *   s
    z generator.__init__.<locals>.sendr   )	r   Únext_ipÚparamsÚlocalsÚbase_locationÚenterr   r   r   )r   r   Zstart_ipr"   r#   r$   r   r   )r   r   r	   !   s    zgenerator.__init__c             C   s   dS )Nz<generator_obj>r   )r   r   r   r   r
   1   s    zgenerator.__str__c             C   s   |   ¡ S )N)r   )r   r   r   r   r   r   3   s    zgenerator.__getitem__c             C   s    d| _ | jrd | jjd< |  ¡ S )NFr   )r   r   r   r   r   )r   r   r   r   r   5   s    zgenerator.__next__c             C   sL   | j dkrt‚n8d| _ | j | j| j| j| j¡\| _| _| _}d| _ |S d S )Nr   r   )r%   ÚStopIterationr   Ú	yield_runr!   r"   r#   r$   )r   Úyield_resultr   r   r   Z__next:   s    
(zgenerator.__nextN)r   r   r   r	   r
   r   r   r   r   r   r   r   r       s
   r   c             C   s  t | ƒtkrœ|dkr|  ¡ S |dkr.| j| S |dkr@| j| S |dkrR| j| S |dkrd| j| S |dkrv| j| S |dkrˆ| j| S |dkrš| j	| S nXt | ƒt
k rô|d	kr¼| j| S |d
krÎ| j| S |dkrà| j| S |dk rô| j| S tdƒ t| ||ƒ t‚d S )NÚencodeÚsplitÚreplaceÚformatÚjoinÚindexÚlowerÚupperÚappendÚinsertÚremovez

error!)ÚtypeÚstrr)   r*   r+   r,   r-   r.   r/   r0   Úlistr1   r2   r3   ÚprintÚ	Exception)ÚobjÚopÚargsr   r   r   Úbuilt_in_opB   s:      
 
 
 
 
 
  
 
 

 
r<   N)r   r   r<   r   r   r   r   Ú<module>   s   "239*122*ex_func.cpython-37.pycB
    	áTeç  ã               @   s,   d dl Z d dlZd dlZd dlZd dlZdS )é    N)ÚtimeÚmathÚosÚos.pathÚsys© r   r   ú/C:\Users\allen\Desktop\py\py\apython\ex_func.pyÚ<module>   s   45313*121*module.cpython-37.pycB
    ì¼UeAø  ã               @   sR  G d d„ dƒZ G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZG d
d„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZ	G dd„ dƒZ
G dd„ dƒZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZG d d!„ d!ƒZG d"d#„ d#ƒZG d$d%„ d%ƒZG d&d'„ d'ƒZG d(d)„ d)ƒZG d*d+„ d+ƒZG d,d-„ d-ƒZG d.d/„ d/ƒZG d0d1„ d1ƒZG d2d3„ d3ƒZG d4d5„ d5ƒZG d6d7„ d7ƒZG d8d9„ d9ƒZG d:d;„ d;ƒZG d<d=„ d=ƒZG d>d?„ d?ƒZG d@dA„ dAƒZ dBdC„ Z!G dDdE„ dEƒZ"G dFdG„ dGƒZ#G dHdI„ dIƒZ$G dJdK„ dKƒZ%G dLdM„ dMƒZ&G dNdO„ dOƒZ'G dPdQ„ dQƒZ(G dRdS„ dSƒZ)G dTdU„ dUƒZ*dVS )Wc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIntegerc             C   s   t |ƒ| _d S )N)ÚintÚnumber)Úselfr   © r   ú.C:\Users\allen\Desktop\py\py\apython\module.pyÚ__init__   s    zInteger.__init__c             C   s   | j › S )N)r   )r   r   r   r   Ú__str__   s    zInteger.__str__c             C   s   t | jƒ| _d S )N)Ústrr   Úlocation)r   Úcodesr   r   r   Úwrite   s    zInteger.writeN)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFloatc             C   s   t |ƒ| _d S )N)Úfloatr   )r   r   r   r   r   r   
   s    zFloat.__init__c             C   s   | j › S )N)r   )r   r   r   r   r      s    zFloat.__str__c             C   s   t | jƒ| _d S )N)r	   r   r
   )r   r   r   r   r   r      s    zFloat.writeN)r   r   r   r   r   r   r   r   r   r   r   	   s   r   c               @   s&   e Zd Zd	dd„Zdd„ Zdd„ ZdS )
ÚStringTc             C   s   || _ || _d S )N)ÚtextÚchange)r   r   r   r   r   r   r      s    zString.__init__c             C   s   d| j › dS )Nú")r   )r   r   r   r   r      s    zString.__str__c             C   s,   | j rd| j› d| _nd| j› d| _d S )Nr   ú')r   r   r
   )r   r   r   r   r   r      s    zString.writeN)T)r   r   r   r   r   r   r   r   r   r   r      s   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBytec             C   s
   || _ d S )N)r   )r   r   r   r   r   r      s    zByte.__init__c             C   s   d| j › dS )Nr   )r   )r   r   r   r   r      s    zByte.__str__c             C   s   |  d| j› d¡ d| _d S )Nz	byte AX "r   ÚAX)Úappendr   r
   )r   r   r   r   r   r       s    z
Byte.writeN)r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚVar_namec             C   s
   || _ d S )N)Úname)r   r   r   r   r   r   $   s    zVar_name.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   &   s    zVar_name.__str__N)r   r   r   r   r   r   r   r   r   r   #   s   r   c               @   s6   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zd
d„ ZdS )Ú	NamespaceÚ c             C   s
   || _ d S )N)Ú	namespace)r   r   r   r   r   r   *   s    zNamespace.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   ,   s    zNamespace.__str__c             C   s
   | j |kS )N)r   )r   Úotherr   r   r   Ú__eq__.   s    zNamespace.__eq__c             C   s
   || j kS )N)r   )r   Úitemr   r   r   Ú__contains__0   s    zNamespace.__contains__c             C   s   | j dkr| j | _d S )Nr   )r   r
   )r   r   r   r   r   r   2   s    
zNamespace.writeN)r   )r   r   r   r   r   r    r"   r   r   r   r   r   r   )   s
   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVariablec             C   s   || _ || _d S )N)r   r   )r   r   r   r   r   r   r   6   s    zVariable.__init__c             C   s   d| j › dS )Nz<var=ú>)r   )r   r   r   r   r   9   s    zVariable.__str__c             C   s:   | j dkr.| j  |¡ | j j› d| j› | _n| j| _d S )Nr   Ú.)r   r   r
   r   )r   r   r   r   r   r   ;   s    
zVariable.writeN)r   r   r   r   r   r   r   r   r   r   r#   5   s   r#   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSubVariablec             C   s   || _ || _d S )N)ÚobjÚattr)r   r'   r(   r   r   r   r   A   s    zSubVariable.__init__c             C   s   d| j › d| j› dS )Nz<obj=z  attr=r$   )r'   r(   )r   r   r   r   r   D   s    zSubVariable.__str__c             C   st   | j  |¡ | j j}d|ks0d|ks0|d dkrX| d| j j› d¡ d| jj› | _n| j j› d| jj› | _d S )Nr%   ú[é    )r   r   zmov AX u         ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²zAX.)r'   r   r
   r   r(   r   )r   r   Z	olocationr   r   r   r   F   s    zSubVariable.writeN)r   r   r   r   r   r   r   r   r   r   r&   @   s   r&   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSlicec             C   s   || _ || _|| _d S )N)Ú	start_objÚend_objÚstep_obj)r   r,   r-   r.   r   r   r   r   N   s    zSlice.__init__c             C   s   dS )Nz<slice>r   )r   r   r   r   r   R   s    zSlice.__str__c             C   s’   |  d¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ |  d¡ |  d¡ |  d¡ d| _d S )	Nzpush [3]zmov <esp+1>[0] zmov <esp+1>[1] zmov <esp+1>[2] z	pop *argszmov **kwargs [dict]z
call slicer   )r   r,   r   r
   r-   r.   )r   r   r   r   r   r   T   s    



zSlice.writeN)r   r   r   r   r   r   r   r   r   r   r+   M   s   r+   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIndexVariablec             C   s   || _ || _d S )N)r   Ú	slice_obj)r   r   r0   r   r   r   r   a   s    zIndexVariable.__init__c             C   s   d| j › d| j› dS )Nz<Index z slice=r$   )r   r0   )r   r   r   r   r   d   s    zIndexVariable.__str__c             C   sT   | j  |¡ | d| j j› ¡ | j |¡ | d| jj› ¡ | d¡ d| _d S )Nzpush zmov BX zpop AXzAX[BX])r   r   r   r
   r0   )r   r   r   r   r   r   f   s    
zIndexVariable.writeN)r   r   r   r   r   r   r   r   r   r   r/   `   s   r/   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚListc             C   s
   || _ d S )N)Úelements)r   r2   r   r   r   r   o   s    zList.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<List  ú,r$   )r2   r   r	   Újoin)r   Úboxr'   r   r   r   r   q   s    zList.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)Úlenr2   ÚStopIteration)r   Újr   r   r   Ú__getitem__v   s    
zList.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   Ú__len__z   s    zList.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX [ú]zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   Úranger   r
   )r   r   Úir   r   r   r   |   s    
"
z
List.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r1   n   s
   r1   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚTuplec             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   …   s    zTuple.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<Tuple  r3   r$   )r2   r   r	   r4   )r   r5   r'   r   r   r   r   ‡   s    zTuple.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)r6   r2   r7   )r   r8   r   r   r   r9   Œ   s    
zTuple.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:      s    zTuple.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX (ú)zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   r<   r   r
   )r   r   r=   r   r   r   r   ’   s    
"
zTuple.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r>   „   s
   r>   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
ÚDictc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ›   s    zDict.__init__c             C   s>   g }x&| j D ]\}}| |› d|› ¡ qW dd |¡ d S )Nú:z<Dict  r3   r$   )r2   r   r4   )r   r5   ÚkeyÚvaluer   r   r   r      s    zDict.__str__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:   ¢   s    zDict.__len__c             C   st   |  d¡ xT| jD ]J\}}| |¡ |  d|j› ¡ | |¡ |  d¡ |  d|j› ¡ qW |  d¡ d| _d S )Nzpush [dict]zpush zpop BXzmov <esp+1>[BX] zpop AXr   )r   r2   r   r
   )r   r   rB   rC   r   r   r   r   ¤   s    




z
Dict.writeN)r   r   r   r   r   r:   r   r   r   r   r   r@   š   s   r@   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSetc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ¯   s    zSet.__init__c             C   s   dS )Nz<set>r   )r   r   r   r   r   ±   s    zSet.__str__c             C   s0   t | jƒ}| |¡ | d|j› ¡ d| _d S )Nzex_func AX "set" r   )r>   r2   r   r   r
   )r   r   Z_tupler   r   r   r   ³   s    

z	Set.writeN)r   r   r   r   r   r   r   r   r   r   rD   ®   s   rD   c             C   s   yt | ƒ}dS    dS d S )NTF)r   )ÚnumÚer   r   r   Ú	is_number¹   s
     rG   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚLambdac             C   s   || _ || _|| _d S )N)ÚparamsÚ
return_objr   )r   rI   rJ   r   r   r   r   r   ¿   s    zLambda.__init__c             C   s   dS )Nz<lambda>r   )r   r   r   r   r   Ã   s    zLambda.__str__c             C   s¦   dt |ƒ› }t| jdƒ}tdƒ}x | jD ]}| dt|dƒ¡ q*W |j |¡ t	|| j|| j
ƒ}| |¡ | j
dkr~|| _n$| j
 |¡ | j
j› d|› }|| _d S )Nz&lambda_Úreturnr   Úvarr%   )r6   Ú	BacktrackrJ   ÚInforI   Úadd_infor#   Ú	codelinesr   ÚDefr   r   r
   )r   r   Ztem_nameZ_returnÚ
block_inforB   Z_defZlocr   r   r   r   Å   s    

zLambda.writeN)r   r   r   r   r   r   r   r   r   r   rH   ¾   s   rH   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rQ   c             C   s8   || _ || _|| _|j| _|j| _d| jk| _d| _d S )Nú^)r   r*   )r   rI   r   rP   ÚlocalsÚ
local_varsÚin_classÚ
orig_lines)r   ZfnamerI   rR   r   r   r   r   r   Ö   s    zDef.__init__c             C   sH   d| j › }g }x| jD ]}| t|ƒ¡ qW |dd |¡ d 7 }|S )Nz<Def ú{r   ú})r   rP   r   r	   r4   )r   r   Zvtextr'   r   r   r   r   ß   s    zDef.__str__c       *         s`	  dd„ }| j dkrf| j  |¡ t|ƒdt|ƒd | j jdg}| d¡ | d| j j› d| j› d	¡ n&t|ƒ| jt|ƒd
 d dg}| d¡ | ¡  t|ƒ}| d¡ | j› d|› | _| d¡ | d¡ d}g }d }t| j	ƒ}xà|D ]Ö}	| j
r|d kr|	}qê|	d d… dkrxd |¡}
| d|	dd … › d|
› d¡ | j	|	 | j	|	dd … < | j	|	= | |	dd … ¡ qê|	d dkrØ| d|	d
d … › d|› ¡ | j	|	 | j	|	d
d … < | j	|	= | |	d
d … ¡ qê| |	¡ | d¡ t|ƒ}| d¡ | d|	› d¡ t|ƒ}| d¡ | j	|	  |¡ | d|	› d| j	|	 j› ¡ | dt|ƒd › ¡ dt|ƒd
 › d||< | d|	› d|› d¡ | d¡ dt|ƒd
 › d ||< |d
7 }qêW d}i }x | j	D ]}	|d
7 }|||	< qÖW x6| jD ],}|| j	krø||krø|d
7 }|||< qøW |d
 |d!< d"|d
 › d#|d › d#|d$ › d%| j› d&|d! › 
||d < g }|  ¡ x>| j	D ]4}	|	|kr†| d'| j› d(||	 › d)|	› d*¡ q†W t|ƒ}| d¡ | d¡ d+}t|ƒ}x| jD ]}| |¡ qîW ‡ ‡fd,d-„}‡fd.d/„}g ‰g ‰ g g‰g }g }g }d0d1„ }x2tt|ƒ| ƒD ]}|||  }d|ksxd2|kr‚||ƒ}n
| d#¡}|d d3kr®| || ¡ qRnL|d d4krĞˆd5  |d
 ¡ n*|d d6krú| |d
 ¡ | || ¡ |d d7krd8|d< d9}n|d d:krDˆ  || g f¡ ˆ g ¡ nä|d d;krfˆ || g f¡ nÂ|d d<kr(|d
 d=krĞˆ d5 \}}t|ƒdkrÂ||7 }d%| j› d}|| | ||< ˆ d5= ˆd5= nT|d
 d>krRˆd5 \} }t|ƒdkr||7 }d%| j› d}!||  |! || < ˆd5= qRx0tt|ƒƒD ]}"|"dks8||" dkrZq8||" d d?krpq8||" d d@kr„P |||" ƒ\}}#||ƒs8||kr8|dkr¶P n ||krädA| j› dB|# ||"< ||d! ƒ nr|| j	krdA| j› d(|| › dC|# ||"< ||| ƒ n8|| jkr8dA| j› d(|| › dC|# ||"< ||| ƒ q8W d# |¡||| < qRW g }$x.t|d
 ƒD ]}||kr†|$ t|ƒ¡ q†W x|D ]}%d||%< q®W t|ƒ}&t|ƒdkr|d5 |&d
 krx^|D ]}'d|&d
 › dD||'< qîW n:x|D ]}'d|&› ||'< qW |r>| dE¡ n
| dF¡ |rÒttdGdƒttdHdƒgƒti ƒƒ}(t|(dIƒ})|) |¡ | dJ¡ dK|d › d%| j› d||< dt|ƒd
 › dL||d
 < | dM¡ nd||< d||d
 < | dN¡ |	r| dO| j› d¡ n&| dO| j› d&d d |$¡ d ¡ | dP¡ | ¡  dt|ƒd
 › dQ||< d S )RNc             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r*   é   r   )r6   )ÚstringÚspÚkÚnr   r   r   Úget_nameç   s    
zDef.write.<locals>.get_namer   ÚBXé   r*   zmov r%   z BXrZ   Ú_zpush **kwargsz
push *argsz**r3   z**kwargs <esp+2>["z"] <esp+2> "r   Ú*z*args <esp+2>["z"] <esp+1> zcmp CX 0ztf <esp+2> "in" "zmov <esp+2>["z"] zjmp z$jmp z "!="z"] <esp+1>[r;   zdec CXz "t"é   z	Function ú é   z "z" zmov <ú+z> <esp+2>["z"]Fc                s`   t ˆ ƒdkr.| ˆ d d kr.ˆ d d  | ¡ t ˆƒdkr\| ˆd d kr\ˆd d  | ¡ d S )Nr*   éÿÿÿÿrZ   )r6   r   )rE   )Úadd_FunctionÚadd_Generatorr   r   Úsave_genF  s    zDef.write.<locals>.save_genc                s   xˆ D ]}| |krdS qW dS )NTFr   )ZwordÚitems)Úglobal_wordsr   r   Ú	in_globalL  s    
zDef.write.<locals>.in_globalc             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr*   )r   r   rZ   ú\re   )r6   r   )Úliner5   r]   r^   ÚpÚcr   r   r   Ú
parse_lineW  s"    
  zDef.write.<locals>.parse_liner   rK   Úglobalrh   ÚnonlocalÚyieldÚYieldTÚFunctionÚ	GeneratorÚendz
"Function"z"Generator")r   r   ú;ú<z+0>r$   u            ;returné»z	mov AX ""zmov AX Noner7   r   Úraiseu+   stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡ŒzGenerator AX u*         ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ipzend "Generator"u,   $mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸zend "Function" "zpop ipu              ;è·³éæ­¤å‡½æ•¸)r   r   r6   r
   r   r   Úadd_tabÚfunc_varÚtuplerI   rV   r4   rU   rP   r<   Úsplitr	   ÚFuncCallr#   r1   r@   rM   Údel_tab)*r   r   r_   Zdeclare_funcZskip_ipr=   ZkeyboxÚ	class_objrI   rB   Zkey_textZ
skip_paramZskip_param2Z	local_numZ
local_dictrL   Z
return_ipsÚyield_ipZ
have_yieldrq   r'   rk   rn   Znonlocal__wordsZnonlocal_ipsZ	not_abortrs   rp   ÚdealZf_rowrl   Zfunc_add_textZg_rowZgen_add_textr8   ÚbackZ
need_abortZnon_ipZendipZripZstopiterationÚ_raiser   )ri   rj   rm   r   r   æ   sV   

 





 




<

*



 
 
  

 


"



&
z	Def.writeN)r   r   r   r   r   r   r   r   r   r   rQ   Õ   s   	rQ   c               @   s.   e Zd Zddd„Zdd„ Zdd„ Zd	d
„ ZdS )r‚   Nr   c             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )r   ÚargsÚkwargsÚs_argsÚs_kwargsrW   )r   r   r‰   rŠ   r‹   rŒ   r   r   r   r   Ô  s    zFuncCall.__init__c             C   s   d| j › d| j› d| j› dS )Nz<Call z args=z kwargs=r$   )r   r‰   rŠ   )r   r   r   r   r   Û  s    zFuncCall.__str__c             C   s   t tddƒt|ƒƒS )Nr   r   )r/   r#   r   )r   r!   r   r   r   r9   İ  s    zFuncCall.__getitem__c                s>  ‡ ‡‡fdd„}ˆ   dˆj¡ ˆj ˆ ¡ dˆjjkˆ_ˆjjd d… dkpVdˆjjk‰ˆrpˆ   dˆjj› ¡ ˆjr$ˆjj d	¡\}}ˆ   d
|› d|› d¡ tˆ ƒ}ˆ   d¡ |ˆj|ƒ tˆ ƒ}ˆ   d¡ dtˆ ƒd › dˆ |< t	ˆjj
dd … ƒ}||ˆjjƒ dtˆ ƒd › ˆ |< n|ˆjˆjjƒ dˆ_d S )Nc                sf  ˆ   dt| ƒ› d¡ |  ˆ ¡ ˆ j d| j› d|› dˆjd ˆjd krˆˆj ˆ ¡ ˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆ   d	¡ ˆj ˆ ¡ tˆjƒd
krˆ   dˆjj› ¡ xHˆjD ]>}| ˆ ¡ ˆ   d¡ ˆ   d|j› ¡ ˆ   d¡ ˆ   d¡ qÀW ˆ   d¡ nˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆrRˆ   d¡ ˆ   d¡ nˆ   d|› ¡ d S )Nzpush u           ;å„²å­˜CXu     ;ç‚ºcall u
    åšæº–å‚™)Úsimplifyzex_func AX "list" zex_func BX "len" AXz$mov <esp+2> "+" BXz$mov <esp+1> "+" AXr*   zmov *args [1]zmov *args[0] zmov **kwargs [dict]zcall <esp+1>.updatezpop **kwargszmov **kwargs z	pop *argsu   pop CX     ;å–å›CXzpop AXzcall AXzcall )r   r6   r   r
   rV   r‹   rŠ   rŒ   )r‰   Z	call_namerŒ   )r   Úneed_push_namer   r   r   Údeal_cx_args_kwargsà  s4    
 









z+FuncCall.write.<locals>.deal_cx_args_kwargsr   rS   ra   r   ú&zpush r%   ztf z "Ctn" "r   r*   z$jmp rZ   z "t"zjmp )r   rW   r   r   r
   rV   r   r6   r‰   r1   r2   )r   r   r   Úspacer   Zjmp_if_trueZ	jmp_leaver‰   r   )r   r   r   r   r   ß  s*      

zFuncCall.write)Nr   )r   r   r   r   r   r9   r   r   r   r   r   r‚   Ó  s   
r‚   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rM   c             C   s   || _ || _d| _d S )N)r   r*   )ÚAÚcmdrW   )r   rC   r“   r   r   r   r     s    zBacktrack.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r     s    zBacktrack.__str__c             C   sL   | j  |¡ | j jdkr,| d| j j› ¡ | | j› d| j¡ d| _d S )Nr   zmov AX z AX)r’   r   r
   r   r“   rW   )r   r   r   r   r   r     s
    zBacktrack.writeN)r   r   r   r   r   r   r   r   r   r   rM     s   rM   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVar_declarec             C   s   || _ || _d S )N)rC   r“   )r   rC   r“   r   r   r   r   "  s    zVar_declare.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   rC   )r   r   r   r   r   %  s    zVar_declare.__str__c             C   s¤   | j  |¡ | jdkr†d| j jkrN| j j d¡\}}| d|› d|› d¡ q | j jd d… dkrn| d¡ q | d	| j j› d
¡ n| | j› d| j j› ¡ d S )NÚdelr%   zdel 2 z "r   rf   zAX[zdel 1 AX BXzdel 0 z Nonere   )rC   r   r“   r
   r   r   )r   r   r„   rB   r   r   r   r   '  s    
zVar_declare.writeN)r   r   r   r   r   r   r   r   r   r   r”   !  s   r”   c               @   s&   e Zd Zd
dd„Zdd„ Zdd„ Zd	S )Ú
Try_Exceptr   r   c             C   s(   || _ || _|| _|| _|| _g | _d S )N)Útry_codelinesÚexcept_objectsÚelse_codelinesÚfinally_codelinesr   rW   )r   r—   r˜   r™   rš   r   r   r   r   r   4  s    zTry_Except.__init__c             C   s   dS )Nz<Try Except>r   )r   r   r   r   r   ;  s    zTry_Except.__str__c       &      C   s  d}t |ƒ}| d| j| ¡ t |ƒ}| d¡ g g g dœ}g }t |ƒ}| ¡  x| jD ]}| |¡ qXW | ¡  |d7 }xDtt |ƒ| ƒD ]0}	|||	   d¡d }
|
dkrŒ| ||	 ¡ qŒW | d¡ t |ƒ}| d¡ | j	dkr| j	 |¡ | j	j
› d}nd}d}d	t |ƒd › }g }g }g }xltt | jƒd ƒD ]T}	|dkr^|||< d}nd
t |ƒd › d||< |	t | jƒk r|| d| j| ¡ |d7 }| j|	 }|d  |¡ | d|d j
› ¡ t |ƒ}| d¡ |d d kr| d|› |d › d¡ | d¡ | t |ƒ¡ | d¡ | ¡  x|d D ]}| |¡ q<W | ¡  | d¡ | t |ƒ¡ | d¡ n| t |ƒ¡ | d¡ q@W xV|D ]N}dt |ƒd › d||< | d¡ | d¡ | |¡ | d|› d¡ q W g }dt |ƒd › d||< t | jƒdkr†| d| j| ¡ |d7 }| ¡  | t |ƒ¡ | d¡ x| jD ]}| |¡ q`W | d¡ | ¡  t |ƒd }x|D ]}d|› d||< q˜W | d¡ | d¡ | t |ƒ¡ | d¡ i }xbtt |ƒ| ƒD ]N}	t|||	  ƒtkrô|||	   d¡d }
|
|krô||
  ||	 ¡ qôW d}x°|D ]¨}t || ƒdkrPt |ƒd }x || D ]}d|› ||< q|W |dkrª| d¡ n
| d¡ | d¡ | d|› ¡ | t |ƒ¡ | d¡ |||< |d7 }qPW t |ƒd }x|D ]}d	|› ||< qW x|D ]}d|› d||< q,W | d¡ | d¡ t |ƒd }d|› ||< x|D ]}d|› d ||< qzW | d!|› ¡ t |ƒ} t | jƒdkr| d"¡ | d¡ | d| j| ¡ |d7 }| ¡  x| jD ]}| |¡ qúW | ¡  g g g dœ}!xbtt |ƒ|  ƒD ]N}	t|| |	  ƒtkr4|| |	   d¡d }
|
|!kr4|!|
  | |	 ¡ q4W t | jƒdkr | d#¡ | d$¡ i }"x8|D ]0}| d%|› ¡ || |"t |ƒ< | d¡ q´W | d&¡ t |ƒ}#| d¡ | d$¡ ttd'dƒd(ƒ}$|$ |¡ xh|!D ]`}t |!| ƒdkr.t |ƒd }x&|!| D ]}d|› d)|› ||< qZW | d*¡ | |¡ q.W xH|"D ]@}%d
t |ƒd › d+||%< | d#¡ | d$¡ | |"|% ¡ q˜W d
t |ƒd › d+||#< | d$¡ | d,¡ d S )-Nr*   )ÚcontinueÚbreakrK   rZ   re   rv   z	try "end"r   r%   ztry z$jmp z "f"zerror zmov z $Exceptionzmov $Exception 0ra   zjmp u    ;è™•ç†tryä¸­çš„yieldu-   yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡u#        ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œu!       ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°elseu     ;è·³åˆ°push 1u   push None  ;æ¨å…¥Noneu   push 1     ;ä»£è¡¨æ­£å¸¸rK   zpush AXz	push Nonezpush z ;push 0zpush 0zfinally u       ;è·³åˆ°finallyz	finally -zpush $Exceptionzpop $Exceptionzpop AXzcmp AX zcmp AX 1z
$Exceptionr}   u"          ;è·³è‡³finallyä¸­çš„äº‹ä»¶:z$mov esp "+" 3z "=="zend "finally_yield")r6   r   rW   r~   r—   r   rƒ   r<   r   r   r
   r˜   r™   Útyper	   rš   rM   r#   )&r   r   ÚolZto_finally_ipZto_except_ipZSDZ	yield_boxZstart_pr'   r=   r“   Z	try_leaveÚispacerF   Ztry_except_ipZ
try_push_0Z
jmp_push_0Z
jmp_push_1Z
error_datar…   Zjmp_to_finallyZpush_1Zjp0Zstype_SDÚstyperB   Újmp_ipÚipZpush_0Ztp0Z
finally_ipZjtfZ	finally_pZfinally_eventsZleave_SDZjmp_to_leaverˆ   Úlipr   r   r   r   =  s>   













































zTry_Except.writeN)r   r   r   )r   r   r   r   r   r   r   r   r   r   r–   3  s   
r–   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWithc             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )Úcall_objÚorig_as_nameÚas_nameÚwith_codelinesr   rW   )r   r¥   r¦   r§   r¨   r   r   r   r   r   ô  s    zWith.__init__c             C   s   dS )Nz<with>r   )r   r   r   r   r   û  s    zWith.__str__c       	      C   s0  |  d| j¡ | ¡  | j |¡ | j |¡ |  d| jj› d| jj› ¡ tt| jj› ddƒt	g ƒt
i ƒƒ}| |¡ | jd kr¶|  d|j› ¡ | j |¡ |  d| jj› ¡ | j}g }g }tt| jj› ddƒt	td ƒtd ƒtd ƒgƒt
i ƒƒ}|g}t||||ƒ}dddg|_| |¡ | ¡  d S )	Nr   zmov re   z
.__enter__zpush zpop z	.__exit__)r   r*   )r   rW   r~   r¦   r   r¥   r
   r‚   r#   r1   r@   r§   r¨   ÚTFNr–   rƒ   )	r   r   Z_enter_callr—   r˜   r™   Z
_exit_callrš   Z_try_exceptr   r   r   r   ı  s(    $

6
z
With.writeN)r   r   r   r   r   r   r   r   r   r   r¤   ó  s   r¤   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚStopc             C   s   d S )Nr   )r   r   r   r   r     s    zStop.__init__c             C   s   dS )Nz<$stop>r   )r   r   r   r   r     s    zStop.__str__c             C   s   |  d¡ d S )NÚstop)r   )r   r   r   r   r   r     s    z
Stop.writeN)r   r   r   r   r   r   r   r   r   r   rª     s   rª   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚCommandc             C   s
   || _ d S )N)Úcmd_list)r   r­   r   r   r   r     s    zCommand.__init__c             C   s   dS )Nz
<cmd_list>r   )r   r   r   r   r     s    zCommand.__str__c             C   s   x| j D ]}| |¡ qW d S )N)r­   r   )r   r   r“   r   r   r   r   !  s    zCommand.writeN)r   r   r   r   r   r   r   r   r   r   r¬     s   r¬   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_if_elsec             C   s   || _ || _|| _d S )N)ÚeventÚ	true_itemÚ
false_item)r   r¯   r°   r±   r   r   r   r   %  s    zsub_if_else.__init__c             C   s   dS )Nz<A if else B>r   )r   r   r   r   r   )  s    zsub_if_else.__str__c             C   sà   | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | jjdkrb| d| jj› d¡ t|ƒ}| d¡ dt|ƒd › d	||< | j |¡ | jjdkr¾|jd| jj› d
dd dt|ƒd › d||< d| _d S )Nzcmp z 1r*   r   zmov AX z   ;true itemz$jmp rZ   u    "!="   ;è·³åˆ°falsez   ;false item)r   zjmp u      ;é›¢é–‹sub_if_else)r¯   r   r   r
   r6   r°   r±   )r   r   Z	jne_falseÚleave_ipr   r   r   r   +  s    

zsub_if_else.writeN)r   r   r   r   r   r   r   r   r   r   r®   $  s   r®   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIf_elsec             C   s   || _ || _g | _d S )N)Úif_itemsr™   rW   )r   r´   r™   r   r   r   r   >  s    zIf_else.__init__c             C   sÌ   d| j d d › dg}x$| j d d D ]}| t|ƒ¡ q(W xL| j dd … D ]:}| d|d › d¡ x|d D ]}| t|ƒ¡ qrW qNW t| jƒdkrÂ| d¡ x| jD ]}| t|ƒ¡ q¬W d |¡S )Nzif r*   rA   rZ   zelif zelse:r   )r´   r   r	   r6   r™   r4   )r   r   r'   r=   r   r   r   r   B  s      
 zIf_else.__str__c       	      C   s6  g }d}x´| j D ]ª\}}| d| j| ¡ |d7 }| |¡ | d|j› d¡ | ¡  t|ƒ}| d¡ x|D ]}| |¡ qpW | t|ƒ¡ | d¡ dt|ƒd › d||< | ¡  qW t| jƒdkr
| d| j| ¡ | ¡  x| jD ]}| |¡ qğW | ¡  x&|D ]}dt|ƒd › d	||< qW d S )
Nr*   r   rZ   zcmp z 1z$jmp u#    "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·zjmp u           ;è·³è‡³åº•éƒ¨)	r´   r   rW   r   r
   r~   r6   rƒ   r™   )	r   r   Úneed_set_endr   r¯   ÚblockÚjipr'   r¢   r   r   r   r   L  s0    


 
 
zIf_else.writeN)r   r   r   r   r   r   r   r   r   r   r³   =  s   
r³   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWhilec             C   s   || _ || _|| _d| _d S )N)r   r*   )r¯   rP   r™   rW   )r   r¯   rP   r™   r   r   r   r   d  s    zWhile.__init__c             C   s   d| j › d| j› S )Nzevent:z do:)r¯   rP   )r   r   r   r   r   i  s    zWhile.__str__c             C   sd  t |ƒ}| d| j¡ | j |¡ | d| jj› d¡ | ¡  t |ƒ}| d¡ g }x†| jD ]|}t |ƒ}| |¡ xdtt |ƒ| ƒD ]P}|||   	d¡d }|dkrÀd|d › ||| < q†|d	kr†| || ¡ q†W q^W | d|d › d
¡ t |ƒd }	d|	› d||< x| j
D ]}| |¡ qW t |ƒd }
x|D ]}d|
› d||< q>W | ¡  d S )Nr   zcmp z 1r*   re   r›   zjmp rZ   rœ   u                  ;continueé‡ä¾†z$jmp z "!="u             ;breakå‡º)r6   r   rW   r¯   r   r
   r~   rP   r<   r   r™   rƒ   )r   r   Úagain_ipÚout_ipÚ	break_boxr'   rq   r=   r“   Z
to_else_ipÚbreak_ipÚb_ipr   r   r   r   k  s4    


zWhile.writeN)r   r   r   r   r   r   r   r   r   r   r¸   c  s   r¸   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_for_loopc             C   s"   || _ || _|| _|| _|| _d S )N)ÚexpressÚvnamesÚbase_objÚif_objÚis_list)r   r¿   rÀ   rÁ   rÂ   rÃ   r   r   r   r   ‰  s
    zsub_for_loop.__init__c             C   s   dS )Nz<sub for loop>r   )r   r   r   r   r     s    zsub_for_loop.__str__c       	      C   s  t | jdƒ}| jd krLt| j|gggg ƒ}dddg|_t| j| j|gg ƒ}nt| j| j|gg ƒ}tdƒ}x| jD ]}| 	d|¡ qpW | 
|d¡ t|ƒ}td|› i |dƒ}| 
|¡ | d¡ | d¡ | d¡ | d	¡ | d
¡ | d|› ¡ | jr
| d¡ d| _d S )Nrv   )r   r*   r   rL   z&generator_u   push 0        ;å„²å­˜CXzpush [0]zmov **kwargs [dict]z	pop *argsu   pop CX     ;å–å›CXzcall &generator_zex_func AX "list" AXr   )rM   r¿   rÂ   r³   rW   ÚFor_looprÀ   rÁ   rN   rO   r   r6   rQ   r   rÃ   r
   )	r   r   Z_yieldZ_ifZ	_for_loopÚinforL   ÚidÚfDefr   r   r   r   ‘  s,    







zsub_for_loop.writeN)r   r   r   r   r   r   r   r   r   r   r¾   ˆ  s   r¾   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rÄ   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r*   )rÀ   rÁ   rP   r™   rW   )r   rÀ   rÁ   rP   r™   r   r   r   r   ®  s
    zFor_loop.__init__c             C   s   dS )Nz
<For loop>r   )r   r   r   r   r   ´  s    zFor_loop.__str__c             C   sf  | j  |¡ | d| j j› | j¡ | ¡  | d¡ t|ƒ}| d¡ t|ƒ}| d¡ t| jƒdkr”| jd  |¡ | d| jd j› d¡ nHxFtt| jƒƒD ]4}| j|  |¡ | d| j| j› d|› d	¡ q¤W g }g }x¦| j	D ]œ}t|ƒ}| |¡ x„tt|ƒ| ƒD ]p}|||   
d
¡d }	|	dkrPd|d › ||| < n2|	dkrj| || ¡ n|	dkr| || ¡ qW qìW | d|d › ¡ t|ƒdkrìt|ƒ}
x |D ]}d|
d › ||< q¼W | d¡ | d¡ t|ƒd }d|› d||< x| jD ]}| |¡ qW t|ƒd }x|D ]}d|› d||< q6W | d¡ | ¡  d S )Nzex_func AX "iter" zpush AXzfetch AX <esp+1>r*   rZ   zmov z AXz AX[r;   re   r›   zjmp rœ   rK   zinc espz	return AXz$jmp z "f"u             ;breakå‡ºè¿´åœˆ)rÁ   r   r   r
   rW   r~   r6   rÀ   r<   rP   r   r™   rƒ   )r   r   r¹   r²   r=   r»   Z
return_boxr'   rq   r“   Zreturn_leave_ipZr_iprº   r¼   r½   r   r   r   r   ¶  sV    


$








zFor_loop.writeN)r   r   r   r   r   r   r   r   r   r   rÄ   ­  s   rÄ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMarkc             C   s
   || _ d S )N)Úmark)r   rÉ   r   r   r   r   ì  s    zMark.__init__c             C   s   d| j › dS )Nz<mark r$   )rÉ   )r   r   r   r   r   î  s    zMark.__str__c             C   s   |  | j¡ d S )N)r   rÉ   )r   r   r   r   r   r   ğ  s    z
Mark.writeN)r   r   r   r   r   r   r   r   r   r   rÈ   ë  s   rÈ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚPassc             C   s   d S )Nr   )r   r   r   r   r   ó  s    zPass.__init__c             C   s   dS )Nz<pass>r   )r   r   r   r   r   õ  s    zPass.__str__c             C   s   d S )Nr   )r   r   r   r   r   r   ÷  s    z
Pass.writeN)r   r   r   r   r   r   r   r   r   r   rÊ   ò  s   rÊ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r©   c             C   s
   || _ d S )N)rC   )r   rC   r   r   r   r   ú  s    zTFN.__init__c             C   s   d| j › dS )Nr|   r$   )rC   )r   r   r   r   r   ü  s    zTFN.__str__c             C   s   | j | _d S )N)rC   r
   )r   r   r   r   r   r   ş  s    z	TFN.writeN)r   r   r   r   r   r   r   r   r   r   r©   ù  s   r©   c               @   s&   e Zd Zddd„Zdd„ Zdd„ ZdS )	ÚClassNc             C   s2   || _ |j| _|j| _|| _|| _|| _d| _d S )N)r   r*   )r   ÚfuncsZ	functionsrP   r   Ú	class_espÚfatherrW   )r   r   rÅ   r   rÍ   rÎ   r   r   r   r     s    zClass.__init__c             C   s   d| j › dS )Nz<class r$   )r   )r   r   r   r   r     s    zClass.__str__c       
   	   C   sP  | j dkrn| j  |¡ | dt|ƒd › d| j j› d| j› d| j¡ | j j› d| j› }| d|› d	¡ n2| j}| d
|› dt|ƒd › d| j› d| j¡ | d|› d| j› d¡ | ¡  t|ƒ}| d¡ | d¡ | dt|ƒd › d¡ | d| j› d¡ | d¡ | dt|ƒd › ¡ | d| j› d¡ | d¡ | d¡ | d¡ | d¡ | d¡ | j	d kr t
| j	ƒtkrš| j	j}n| j	g}x\|D ]T}| |¡ | d¡ | d¡ | d ¡ | d!| j› d"¡ | d#|j› ¡ q¨W | d$| j› d%|› ¡ x| jD ]}| |¡ q W | d&| j› d"¡ | d'¡ | d(¡ | d)¡ | d*¡ | d+¡ t|ƒ}| d¡ | d,¡ | dt|ƒd- › d¡ t|ƒ}| d¡ | d.¡ | d&| j› d"¡ t|ƒd- }	d|	› d/||< d|	› ||< | d0| j› d1¡ | d2¡ dt|ƒd- › ||< d3| _| ¡  d S )4Nr   zFunction BX rf   re   z "z" 1r%   zmov z BXz	Function ra   z None "zname z "<class '__main__.z'>"r*   ztf $Inheritance "equ" Nonez$jmp z "t"zmov <z> $Inheritancezpush 1zjmp z	> [class]zpush 0zmov $Inheritance Nonezpush CXz
push *argszpush **kwargszmov **kwargs <esp+1>zmov *args <esp+2>zmov CX <esp+3>zmov $Inheritance <r$   zcall ztype <z> zmov AX <zpop **kwargsz	pop *argszpop CXzpop BXzcmp BX 1ztf AX "Ctn" "__init__"rZ   zcall AX.__init__z "=="zend "Function" "r   zpop ipr   )r   r   r   r6   r
   rÍ   rW   r   r~   rÎ   r   r>   r2   rP   rƒ   )
r   r   Zclass_paramZskip_class_ipr†   rÎ   r'   Zleave_init_ipZskip_init_iprz   r   r   r   r     st    
0,























zClass.write)N)r   r   r   r   r   r   r   r   r   r   rË      s   

rË   c             C   sÌ   |   |¡ | jd d… dks&| jdkr\| d¡ |  |¡ | d|j› ¡ | d¡ d}nl| jd d… dkr¸| d¡ | d	¡ |  |¡ | d
|j› ¡ | d¡ | d¡ d}n|  |¡ |j}|S )Nrf   zAX.r   zpush AXzmov BX zpop AXr`   zAX[zpush BXzmov DX zpop BXÚDX)r   r
   r   )r’   ÚBr   Ú	blocationr   r   r   Útwo_object_write\  s$    









rÒ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMultiple_Movc             C   s@   || _ || _|dkr"d| _d| _nd| _|d d… | _d| _d S )Nú=r*   ÚmovrZ   rh   )r   r*   )Úobj_listÚtargetÚctyper“   rW   )r   rÖ   r×   Úopr   r   r   r   ‡  s    zMultiple_Mov.__init__c             C   s   dS )Nz<Multiple mov>r   )r   r   r   r   r   ‘  s    zMultiple_Mov.__str__c             C   s,  |  d| j¡ | j |¡ |  d| jj› ¡ xî| jD ]ä}t|ƒttfkrÊxÎt	t
|ƒƒD ]l}||  |¡ | jdkr”|  d|| j› d|› d¡ qX| jdkrX|  d|| j› d	| j› d
|› d¡ qXW q6| |¡ | jdkrô|  d|j› d¡ q6| jdkr6|  d|j› d	| j› d¡ q6W |  d¡ d S )Nr   zpush r*   zmov z	 <esp+1>[r;   rZ   z$mov z "z
" <esp+1>[z <esp+1>z	" <esp+1>zinc esp)r   rW   r×   r   r
   rÖ   r   r>   r1   r<   r6   rØ   r“   )r   r   r'   r=   r   r   r   r   “  s"    
 
,


 zMultiple_Mov.writeN)r   r   r   r   r   r   r   r   r   r   rÓ   †  s   
rÓ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOperc             C   s   || _ || _|| _d S )N)r’   rĞ   Úsymbol)r   r’   rĞ   rÛ   r   r   r   r   ¨  s    zOper.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r’   rÛ   rĞ   )r   r   r   r   r   ­  s    zOper.__str__c             C   s\   | j  |¡ | d| j j› ¡ | j |¡ | d| j› d| jj› ¡ | d¡ d| _d S )Nzpush zoper <esp+1> "z" zpop AXr   )r’   r   r   r
   rĞ   rÛ   )r   r   r   r   r   r   ¯  s    
z
Oper.writeN)r   r   r   r   r   r   r   r   r   r   rÚ   §  s   rÚ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚTfc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   ¸  s    zTf.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   ½  s    z
Tf.__str__c             C   sF   t | j| j|ƒ}| d| jj› d| j› d|› ¡ | d¡ d| _d S )Nztf z "z" z	mov AX TFr   )rÒ   r’   rĞ   r   r
   r“   )r   r   rÑ   r   r   r   r   ¿  s    "
zTf.writeN)r   r   r   r   r   r   r   r   r   r   rÜ   ·  s   rÜ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAndOrc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   Æ  s    zAndOr.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   Ê  s    zAndOr.__str__c             C   sB  | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | d| jj› d¡ t|ƒ}| d¡ | jdkrĞ| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< nh| jdkr8| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< d| _d S )Nzcmp z 1r*   Úandzmov AX 1zjmp rZ   zmov AX 0)r   z$jmp z "!="Úorz "=="r   )r’   r   r   r
   r6   rĞ   r“   )r   r   r·   r£   Zto_falseZto_truer   r   r   r   Ì  s.    




zAndOr.writeN)r   r   r   r   r   r   r   r   r   r   rİ   Å  s   rİ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚDenyc             C   s   || _ || _d S )N)r’   r“   )r   r’   r“   r   r   r   r   å  s    zDeny.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r   é  s    zDeny.__str__c             C   sJ   | j  |¡ | j jdkr,| d| j j› ¡ | d| j› d¡ d| _d S )Nr   zmov AX z
$oper AX "r   )r’   r   r
   r   r“   )r   r   r   r   r   r   ë  s
    z
Deny.writeN)r   r   r   r   r   r   r   r   r   r   rà   ä  s   rà   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBoolc             C   s
   || _ d S )N)Úenebox)r   Z
enequalboxr   r   r   r   ó  s    zBool.__init__c             C   s$   d}x| j D ]}|t|ƒ7 }qW |S )Nr   )râ   r	   )r   r   r=   r   r   r   r   õ  s    zBool.__str__c             C   sğ  d}| j d  |¡ | d| j d j› ¡ g }g }ddddddd	œ}x|t| j ƒd
 k rL| j |d   |¡ | d¡ | j |d
  dkrÌ| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ n<| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ | d¡ |d t| j ƒk rB| d| j |d  j› ¡ |d7 }qJW | d¡ | dt|ƒd
 › ¡ t|ƒd
 }|jdd
d x,|D ]$}d|› d|d
 › d||d < qW x,|D ]$}d|› d|d
 › d||d < q¾W d| _d S )Nr*   zpush ÚfÚtz<=z>=r|   r$   )z==z!=r$   r|   z>=z<=rZ   ra   zpop DX)z==z!=ztf DX "equ" zcmp DX rf   zmov AX Truezjmp zmov AX False)r   z$jmp z "r   r   )râ   r   r   r
   r6   )r   r   r]   rµ   Zneed_set_tfZcmp_dictrz   r=   r   r   r   r   ú  s6    
" 


$
$z
Bool.writeN)r   r   r   r   r   r   r   r   r   r   rá   ò  s   rá   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAssertc             C   s   || _ || _d| _d S )N)r   r*   )r¯   ÚmsgrW   )r   r¯   ræ   r   r   r   r     s    zAssert.__init__c             C   s   d| j › d| j› dS )Nz<assert z, r$   )r¯   ræ   )r   r   r   r   r     s    zAssert.__str__c             C   sj   |  d| j¡ t| jdƒ}ttddƒt| jgƒti ƒƒ}t	|dƒ}t
||gggg ƒ}dg|_| |¡ d S )Nr   ÚnotÚAssertionErrorr}   )r   r*   )r   rW   rà   r¯   r‚   r#   r1   ræ   r@   rM   r³   r   )r   r   Z	not_eventZassertionerrorrˆ   rÂ   r   r   r   r      s    
zAssert.writeN)r   r   r   r   r   r   r   r   r   r   rå     s   rå   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSTRc             C   s
   || _ d S )N)r'   )r   r'   r   r   r   r   )  s    zSTR.__init__c             C   s   d| j › dS )Nz<STR: r$   )r'   )r   r   r   r   r   +  s    zSTR.__str__c             C   s*   | j  |¡ | d| j j› ¡ d| _d S )Nzex_func AX "str" r   )r'   r   r   r
   )r   r   r   r   r   r   -  s    z	STR.writeN)r   r   r   r   r   r   r   r   r   r   ré   (  s   ré   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rN   c             C   s(   g | _ i | _i | _i | _g | _|| _d S )N)rT   ÚvarsrÌ   ÚclassesrP   r   )r   r   r   r   r   r   3  s    zInfo.__init__c             C   s^   |dkr|| j |j< n*|dkr,|| j|j< n|dkr@|| j|j< |j| jkrZ| j |j¡ d S )NrL   ÚfuncÚclass)rê   r   rÌ   rë   rT   r   )r   r   r'   r   r   r   rO   :  s    zInfo.add_infoc             C   s>   |  j |j 7  _ | j |j¡ | j |j¡ | j |j¡ d S )N)rT   rê   ÚupdaterÌ   rë   )r   rÅ   r   r   r   rî   C  s    zInfo.updatec             C   s   dd„ }| j  |¡ ||_d S )Nc             S   sJ   g }x:| D ]2}t |ƒtkr*| d| ¡ q
| t|ƒd ¡ q
W d |¡S )Nre   r   )r   r   r   r	   r4   )Zorig_codeliner5   r'   r   r   r   Ú	deal_origI  s    
zInfo.write.<locals>.deal_orig)rP   r   rW   )r   ÚcodelineÚorig_codelinesrï   r   r   r   r   H  s    z
Info.writeN)r   r   r   r   rO   rî   r   r   r   r   r   rN   2  s   	rN   N)+r   r   r   r   r   r   r#   r&   r+   r/   r1   r>   r@   rD   rG   rH   rQ   r‚   rM   r”   r–   r¤   rª   r¬   r®   r³   r¸   r¾   rÄ   rÈ   rÊ   r©   rË   rÒ   rÓ   rÚ   rÜ   rİ   rà   rá   rå   ré   rN   r   r   r   r   Ú<module>   sZ      A A"&%%>\*!'
26850*122*package.cpython-37.pycB
    Á¾Ueøç  ã               @   s¼   d dl mZmZmZ d dlmZmZ d dlmZ d dl	T dd„ Z
dd	d
„Zdd„ Zdd„ Zddd„Zeƒ fdd„ZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZeƒ ZG dd„ dƒZdS ) é    )ÚlistdirÚgetcwdÚchdir)ÚisdirÚisfile)ÚCode)Ú*c           "      s	  dN‡ ‡fdd„	}dddddd	d
dddddddddddddddddddddd d!d"d#d$d%g"}d&d'd(d)d*d+d,d-d.d/œ	}d&t ˆƒ }}g }d&}d&}ˆ d0¡}	d'g‰ d&ˆ d& |	ˆ d& d'  fg}
xB||k rúˆ| }|d1krH|}d2}x(||k rˆ| |kr|d'7 }qàP qàW ˆ||… }d3|kr.|
 t|ƒ¡ n|
 t|ƒ¡ |d'8 }n¨|d4krº|d( |k rˆ||d) … }|d5kr|
 |¡ |d)7 }qº|d' |k rÊˆ||d( … }|d6krÊ|
 |¡ |d(7 }qº|
 |¡ |d7krè|d'7 }n|d8krú|d'8 }|dkrğ|d&krğ|d&kr"|d'8 }n”yˆ d0|¡}W n   t ˆƒ}Y nX || d'krğ| |
¡ |
d& d& d* ˆ d& |	ˆ d& d'  fg}
|d'7 }xˆ| d9kr¬|d'7 }q’W |d'8 }n6|d:krøx&||k rêˆ| d0krê|d'7 }qÆW |d'8 }nø|d;krF||ƒ\}}t |
ƒd&kr8t|
d< ƒtkr8|
 d=¡ |
 |¡ nª|d0krøˆ d&  d'7  < |d&krğt |
ƒd'kr‚| |
¡ g }
|d'7 }||k rìd&}x.||k rÊˆ| d9krÊ|d'7 }|d'7 }qW |
 |ˆ d& |	ˆ d& d'  f¡ |d'8 }nø|d>krr|d' |k rrˆ|d'  d;krr|d'7 }||d?d@\}}t |
ƒd&krdt|
d< ƒtkrd|
 d=¡ |
 |¡ n~|dAkrî|d' |k rîˆ|d'  d;krî|d'7 }||ƒ\}}t |
ƒd&krÚt|
d< ƒtkrÚ|
 d=¡ |
 t|j	ƒ¡ n|dBkrä|d' |k räˆ|d'  d;krä|
 dC¡ ˆ|d'  }|d( }x.ˆ| |ksXˆ|d'  dDkrd|d'7 }q8W ˆ|d( |… }t |ƒ}d&}g }x4||k r¼|| d0kr²ˆ d&  d'7  < || dEkr
||d'  dEkrè| dE¡ |d'7 }q°t |
ƒd&krt|
d< ƒtkr|
 d=¡ |
 tdF 
|¡ƒ¡ g }|d'7 }|}d&}d'}x‚|d&krÀ|| }|d&kr”|dEkrp|d'7 }n"|dGkr„|d'8 }n|dHkr´|}n ||kr´||d'  dDkr´d&}|d'7 }q@W |d'8 }|||… }t|ƒd& d'd … }|
d=tdIƒdCg| dJd=g 7 }
n¦|| dGkrF|||d( … dKkrF| || ¡ |d'7 }nj|| dDkrz| || ¡ |d'7 }| || ¡ n6|| d;kr¢| dD¡ | || ¡ n| || ¡ |d'7 }qŠW |
 tdF 
|¡ƒ¡ |
 dJ¡ |}n|d9krğg }dL}x8||k r.ˆ| |kr(| ˆ| ¡ |d'7 }nP qøW dF 
|¡}||krÈ|dkr^|
 tdƒ¡ nV|dkrx|
 td?ƒ¡ n<|dkr’|
 td ƒ¡ n"|d%krª|
 tƒ ¡ n
|
 |¡ |d krè|d'7 }n ||krÚdM| }|
 t|ƒ¡ |d'8 }|d'7 }qºW t |
ƒd'k	r| |
¡ |S )ONTc       	         s¸  ˆ|  }| d7 } | }xHˆ|  }|dkr6ˆ d  d7  < |dkrH| d7 } n
||krRP | d7 } qW ˆ|| … }|dkrv|r‚|dkr’|r’t ||d| fS |dkr(|r(g }dt|ƒ }}x\||k r|| dkrÖ| d¡ || dkrø| || ¡ |d7 }| || ¡ |d7 }q¶W t d |¡|d| fS |dkr´|s´g }dt|ƒ }}xV||k r || dkrn| d¡ | || ¡ || dkr”| d¡ |d7 }qLW t d |¡ƒ| fS d S )	Né   Ú
r   ú\ú'ú")ÚchangeÚ )ÚStringÚlenÚappendÚjoin)	Úkr   ÚcÚpÚc2Zget_textÚtextZckÚn)ÚclineÚcode© ú/C:\Users\allen\Desktop\py\py\apython\package.pyÚdeal_string   sL    



zparse_code.<locals>.deal_stringÚdefÚwhileÚforÚinÚifÚelifÚelseÚclassÚbreakÚcontinueÚreturnú:ÚandÚnotÚorÚTrueÚFalseÚNoneÚfromÚimportÚasÚisÚwithÚraiseÚtryÚexceptÚfinallyÚyieldÚlambdaÚdelÚglobalÚnonlocalÚassertz$stopr   r	   é   é   é   é   é   é   é   )	ZAXZBXZCXZDXZipZespÚspZZRZTFr
   Z
0123456789z0123456789.Ú.z+-*/,()[]{}!=%:><.&^|~)z**=z//=z>>=z<<=)z+=z-=z*=z/=z==z!=z**ú>ú<z>=z<=z%=z//z>>z<<z&=z^=z|=)ú(ú[ú{)ú)ú]ú}ú ú#)r   r   éÿÿÿÿú+ÚrF)r   ÚbÚfrK   r   rM   r   rP   )r   r   z$strrN   z}}z+-*/,()[]{}!=%:><.&^|~\# 
:z$$)T)r   Úsplitr   ÚFloatÚIntegerÚindexÚtyper   ÚByter   r   Ú
parse_codeÚVar_nameÚTFNZStop) r   r   Zkey_wordZ	data_dictr   r   Ú	codelinesZin_bracketsZ	in_lambdaZ	orig_codeÚcodeliner   r   ZnumbersZnumberZc3r   ÚqÚstringZ	space_numZsymbolÚgetZsnZskZtextboxZslockZscZvartextZsub_codelineZv_nameZban_wordZelement_namer   )r   r   r   r^      sd   (



 






 

 

 
( 

 




 * 
* 
*
"
 






 $







 
 
 
 

 



r^   Fr   c             C   s”   d}t | ƒ}t|ƒ}xr||k r†| | }|dkrN||kr:|S ||krN|rJ|S dS |dk rZ|S |dkrl|d7 }n|dkr||d8 }|d7 }qW |r|S dS )Nr   rS   )rK   rL   rM   r	   )rN   rO   rP   )r   Úlist)rb   r   ÚelementsÚendÚstopr   r   Úelementr   r   r   Únext_elementù   s,    
  
  rk   c             C   s  t | ƒ}||krdS |}|d7 }d}d}xš||k rÂ| | |ksJ| | dkrÂ| | |kr¬d}|d7 }x\||k r¨|dkr¨| | |krŠ|d7 }n| | |kr|d8 }|d7 }qdW q*| | dkr*|d7 }q*W | ||… }t |ƒdkrt|d ƒtkrt|d j|ƒ|fS |d |fS nôt|d ƒtkrT|d jdkrTt|dd	… |ƒ}	t|	ƒ|fS |d d
kr|}
d}t|d ƒtkrt|d j|ƒ|d< ddlm} |ƒ d }xRt |ƒdkrú|| dkrhg }g }d }g }||d  dkr.xJ|t |ƒk r*||d  dkrP|d }t||dƒ}t|||… |ƒ}| 	t
||d  jƒ|f¡ nÆ||d  dkr¦|d }t||dƒ}t|||… |ƒ}|d kr˜|}nt||dƒ}np||d  dkræ|d }t||dƒ}| 	t|||… |ƒ¡ n0|d }t||dƒ}t|||… |ƒ}| 	|¡ || dkrìP qìW n|d7 }t|d t|ƒt|ƒ||ƒg||d d …  }nv|| dkr¤|d }g }x°t||dƒ}|| dkrØ||kr²td ƒ}nt|||… |ƒ}|d }| 	|¡ nVt |ƒdkrút|||… |ƒ}n2||kr| 	td ƒ¡ n| 	t|||… |ƒ¡ P q„W t|ƒtkr‚t |ƒdk rj|td ƒgdt |ƒ  7 }t|d |d |d ƒ}t|d |ƒg||d d …  }n:|| dkrŞt|d |d ƒ}|g|dd …  }|d8 }|ƒ |kròtdƒ‚d}qªW |d |
fS d S )N)NrS   r	   )rL   rK   )rO   rN   rH   r   r@   z$strrS   z([.)ÚtimerK   rN   ú=rA   z,)r   rT   z**rL   z:]r*   z335 get error)r   r\   r_   ÚVariableÚnameÚparse_codelineZSTRrl   rk   r   r   ÚOperÚFuncCallÚListÚDictr`   rf   ZSliceÚIndexVariableÚSubVariableÚ	Exception)rb   r   Ú	namespacer   r   ZleftbZrightbr   re   Úobjrc   rl   ÚstÚargsÚkwargsZs_argsZs_kwargsÚvalueZcollectZsubattrr   r   r   Úget_var  sÀ    " 
 "


 
2


"
r~   c             C   sT   | | d d }|d }t | ƒ}x.||krN|d7 }||kr<P | | d d }q"W |S )Nr   r	   )r   )ra   ÚrowZspace_nZs_nÚRowr   r   r   Únext_codelinez  s    
 r   c       %         sÌ	  d}x0|t | ƒk r6| | }|dkr,|}i }|d7 }t | ƒ}x–||k rÖ| | }t|ƒtkrÂtd ƒ||j< |d |k rÂ| |d  dkrÂ|d }t| |dƒ}t| ||… ˆ ƒ||j< | | dkrÂP |dkrÌP |d7 }qBW t| |dd	d
}	t| |d |	… dƒ}
t||
ˆ ƒ}| d |… |g | |	d …  } d}|d7 }qW d}xÜ|t | ƒk r|dks€t| |d  ƒtkr| |d  dkr| | }|dkrŞt| |d dƒ}	t| |d |	… ˆ ƒ}| d |… |g | |	d d …  } n0|dkr6t| |d dƒ}	t| |d |	… ˆ d	d}| d |… |g | |	d d …  } nØ|dkrt| |d dgƒ}	t| |d |	… ˆ d	d}|j	}d|ksŠt |ƒdkräg }d}t |ƒ}x>||k rØ|| }|d7 }|| }|d7 }| 
||f¡ qœW t|ƒ}nt|ƒ}| d |… |g | |	d d …  } |d7 }q@W d}x®|t | ƒk rÎ| | }t|ƒtkrX|dkrXt|ƒS t|ƒtkrv|dkrvtƒ S t | ƒ}t| |ˆ ƒ\}}	| d |… |g | |	d …  } t | ƒ|k rÂ|d8 }|d7 }q"W dd„ }‡ fdd„}dd„ }d}x´|t | ƒk r¤| | }|dkr˜|d7 }|}x t| | ƒtkr>|d7 }q W t| ||d … ˆ ƒ}t| |d  |dƒ}| d |d … |g | |d d …  } |d }|d7 }qòW || dddgtƒ} || d tƒ} || d!tƒ} || d"tƒ} || d#gtƒ} || d$gtƒ} || d%gtƒ} d}xº|t | ƒk rÄ| | }|d&kr¸| |d  g}|}xF|d&kr„||| |d  g7 }|d7 }|t | ƒk r~| | }nP q@W t|ƒ}| d |d … |g | |d …  } |d }|d7 }qW d}xÂ|t | ƒk r| | }|d'krt| |d(gd	d
}n~|d(krÈ|dkr‚| |d  d)kr|tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d d …  } |d8 }nJt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }nº|d*kr‚|dkr‚| |d  d)kr8tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d+ d …  } nBt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qÎW || d)gtƒ} || d,tƒ} d}x@|t | ƒk rğ| | }|d-kr\t| |d.gƒ}| |d  }t| |d |… ˆ ƒ}t| |d/d	d
}t| |d |… ˆ ƒ}t|||ƒ}| d |d … |g | |d …  } d}nˆ|d'krä| |d  }t| |d(gƒ} t| |d | … ˆ d	d}!| | d  }"t| | d-gƒ}#|#d0krÄd }$n| |#d  }$t||!|"|$|ƒ}|S |d7 }q²W || d1gtƒ} || d2tƒ} || d3tƒ} d}xP|t | ƒd k 	rl| | d/k	rF| |= n|d7 }|t | ƒd k	r|	sP 	qW t | ƒdk	r | d0 d/k	r |	r˜| d0= nt| ƒS |	r®t| ƒS t | ƒdk	rÄ| d S t| ƒS )4Nr   r;   r	   rm   r@   z,:r*   )ú,rN   T)rh   r   )rN   rO   rP   rK   rN   rL   rO   )Úis_listrM   rP   )r'   r(   Úpassc             S   s  d}xø|t | ƒk rü| | }||kròt| |d  ƒtkrò|dkrº|dksZt| |d  ƒtkrò|dkrœ|| |d  |ƒ}| d |… |g | |d d …  } d}qò| d |… | |d d …  } n8|| |d  |ƒ}| d |… |g | |d d …  } d}|d7 }qW | S )Nr   r	   )rT   ú-r…   r@   rS   )r   r\   Ústr)rb   Úop_boxÚoperatorr   r   re   r   r   r   Údeal_single_operatorÚ  s     ""z,parse_codeline.<locals>.deal_single_operatorc                sh   d}x^|t | ƒk rb| | }||krXt| |d d … ˆ ƒ}|||ƒ}| d |… |g } d}|d7 }qW | S )Nr   r	   rS   )r   rp   )rb   r‡   rˆ   r   r   r}   re   )rx   r   r   Údeal_single_operator_allí  s    
z0parse_codeline.<locals>.deal_single_operator_allc             S   s„   d}xz|t | ƒk r~| | }||krt|dkrt|| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qW | S )Nr   r	   r@   )r   )rb   r‡   rˆ   r   r   re   r   r   r   Údeal_operatorø  s    &z%parse_codeline.<locals>.deal_operatorz**ú~r…   rT   )r   ú/ú%z//)rT   r…   )z<<z>>ú&ú^ú|)z==z!=rI   rJ   z>=z<=r!   r"   r,   r4   rA   )r+   r-   r#   r%   r‚   rS   r:   )r)   r6   )r<   r=   r>   )r   r\   r_   r`   ro   rk   rp   ZLambdar†   rg   r   rt   ÚSetZMarkZPassr~   rq   ÚDenyÚBoolÚTfÚAndOrZsub_if_elseZsub_for_loopZ	BacktrackZVar_declareÚTuplers   )%rb   rx   rƒ   r   r   Zp2Ú	paramsboxr   r   rc   Z
return_objZ
lambda_objZobjecctre   ZcontentÚ	deal_lineZ
elementboxÚkeyr}   ÚlÚvarr‰   rŠ   r‹   ry   ZeneboxZelse_kZ	true_itemZ	event_objZend_kZ
false_itemZexpressZin_kÚvnamesÚbase_objÚif_kZif_objr   )rx   r   rp   „  sb   

  2
&
$

"
 &

"


"&
&


"(&
"

    rp   c       ;      C   s&  t |ƒ}d}t| ƒ}x
||k r | | }|d dkrd|d j}i }d}t|ƒ}	d}
xš||	k rğ|| }|dkr†||d  dkr†|}
n`t|ƒtkræ|
|j }td ƒ||< ||d  d	krâ|d }t||d
ƒ}t|||… |ƒ||< d}
|d7 }qXW t| |ƒ}t	| |d |… t
ƒ d}t||||ƒ}|j|_| d|¡ | ||d d |d d f¡ |d }n²|d dkrD|d j}|d dkr¬t|ddgƒ}t|d|… |ƒ}nd }t| |ƒ}t jd7  _|› dtj› }t	| |d |… t
d|› dƒd}t|||||ƒ}| d|¡ | ||d d |d d f¡ |d }nÒ|d dkr¾g }g }g }d}x:||k r| | }|d dkr|dks|d dkr0|d7 }| |d d |d d f¡ t|dd… |ƒ}t|ƒtkrìtdƒ}t| |ƒ}| |d |… }t	||ƒ}| |¡ | ||jf¡ |}nj|d dkr˜| |d d |d d f¡ t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ |}P nP qfW |d8 }| t||ƒ|¡ 
nX|d dkr¶t|dd… |ƒ}t|ƒtkrôtdƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k r~| | d dkr~|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }| t|||ƒ|d d |d d f¡ |d }	n`|d dkrg }d}xft|| ƒtksî|| dkr2t|| ƒtkr&t|| j|ƒ}| d|¡ | |¡ |d7 }qÎW t||d d… |ƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k rÔ| | d dkrÔ|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }t||||ƒ} | | |d d |d d f¡ |d }n|d dkrRdt_i }!dt|ƒ }}	xê||	k r"t|| ƒtkr|| j}"xF|d |	k r¦||d  dkr¦|"d||d  j› 7 }"|d7 }qbW d }#|d |	k rî||d  dkrî||d  j}#t|#|ƒ}|d7 }nt|" d¡d |ƒ}|#|!|"< | d|¡ |d7 }q:W t|!|ƒ}$| |$|d d |d d f¡ nÄ|d dkrºdt_g }%|d j}"d}t|ƒ}	xF|d |	k rÆ||d  dkrÆ|"d||d  j› 7 }"|d7 }q‚W |d7 }x¶||	k r†t|| ƒtkrb|| j}&|d |	k r4||d  dkr4|&||d  jf}'|d7 }n|&|&f}'|% |'¡ t|'d |ƒ}| d|¡ n|| d krz|% d!¡ |d7 }qÒW t|"|%||ƒ}(| |(|d d |d d f¡ n\|d d"kr,|d d |d d fg}t| |ƒ}t	| |d |… |ƒ}|j})| |¡ g }*|}xô||k 
r| | d d#k
r| | }| |d d |d d f¡ t|dd$ƒ}|| d%k	rª|d dk	ršt|d|… |ƒ}+n
td&|ƒ}+d }#n t|d|… |ƒ}+||d  j}#t| |ƒ}t	| |d |… |ƒ}|* |+|#|jf¡ | |¡ |}	qW ||k 
r„| | d dk
r„| | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j}| |¡ ng }|}||k r | | d d'kr | | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j},| |¡ ng },t |)|*||,|ƒ}-| |-|¡ |d }nê|d d(krFd}t||dd%gƒ}t|||… |ƒ}.t jd7  _td)tj› |ƒ}/| d|/¡ || dkrÚt||d%gƒ}0t||d |0… |ƒ}#t|#ƒtkrŞ| d|#¡ nd }#t| |ƒ}t	| |d |… |ƒ}| |¡ t!|.|/|#|j|ƒ}1| |1|d d |d d f¡ |d }nĞ|d d*krât|ddgd+d,}t|d|… |ƒ}|t|ƒk r¬|| dkr¬t||d d … |ƒ}2nt"dƒ}2t#||2ƒ}3| |3|d d |d d f¡ n4t|dd-d.gd/}4||4 }5g }6d}7x¢|4dkr¦t||7|4… |ƒ}8t|8ƒtt$fkr`xD|8D ] }t|ƒtkr:| d|¡ q:W nt|8ƒtkrz| d|8¡ |4d }7|6 |8¡ t||4d d	d.gd/}4qW t||7d … |ƒ}9t|6ƒdkrê| |9|d d |d d f¡ n,t%|6|9|5ƒ}:| |:|d d |d d f¡ |d7 }qW |S )0Nr   r	   r   r@   rB   r   )r   z**)rK   r‚   rm   z,))rx   Úfuncr&   rA   rK   rN   r   rJ   rI   r#   r$   rS   r%   r    r!   r‚   rœ   r2   rH   r3   r1   r   )r   r   r7   r8   )r*   r3   r*   rw   r9   r5   z
%with_obj_r?   T)rh   )rm   z+=z-=z*=z/=z%=z//=z**=z<<=z>>=z&=z^=z|=r;   )ri   )&ZInfor   ro   r\   r_   r`   rk   rp   r   Úparse_blockÚ	NamespaceZDefÚlocalsZ
local_varsÚadd_infoÚwriteÚimporterÚclass_nZClassr   r—   rZ   Úupdatera   ZIf_elseZWhilern   ZFor_loopÚ	need_loadrX   ÚImportÚFrom_ImportZ
Try_ExceptZWithr   ZAssertrs   ZMultiple_Mov);ra   rx   Úinfor   r€   rb   Z	func_namer˜   r   r   Zprer   Z
param_namer   rc   ZpinfoZfDefZ	classnameZfatherZ	class_espre   ZeventboxZelse_codelinesZorig_codelinesrŸ   ZeventZblockZwhile_codelinesr   rœ   r   Zfp_codelinesZfor_loopÚpackage_dictÚmodule_nameÚas_nameZ
import_objÚobject_namesZobject_nameÚdealZfrom_import_objZtry_codelinesZexcept_objectsZ	error_objZfinally_codelinesZ
try_exceptZcall_objZorig_as_nameÚq2Zwith_objÚmsgZ
assert_objZequalÚopZvariableboxÚsÚvarsÚtargetZmov_objr   r   r   r¡   ~  s   



 

$ & 





 




("





 
" 


$
"
 


$









 
$

" r¡   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r«   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r   )r®   r°   rx   Únow_infoÚ
orig_lines)Úselfr®   r°   rx   r¸   r   r   r   Ú__init__Ä  s
    zFrom_Import.__init__c             C   s   d| j › d| j› dS )Nz<From z import rI   )r®   r°   )rº   r   r   r   Ú__str__Ê  s    zFrom_Import.__str__c             C   sŠ  t  | j¡}| d| j¡ |d dkrTdt|ƒ› }| j|i}t|| jƒ}| |¡ | d|d › d¡ | jdkr| j |¡ | d| jj	› ¡ d}d	}nd}d
}x¼| j
D ]²}|d dkr8t j|d  }	|	dkræt j|d  }
n|	j}
xr|
D ]@}| d|› |› d|› d|› d¡ t|| jƒ}| j d|¡ qòW q®| d|› |d › d|› d|d › ¡ q®W | jdkr|| d¡ n
| d¡ d S )Nr   r	   r   z&tem_import_zpush $importer["z"]zpush z<esp+1>.z<esp+2>z<esp+1>r   zbuilt-inzmov rQ   rH   z    ;import *rœ   z$mov esp "+" 2zinc esp)r¦   Úget_pathr®   r   r¹   r   rª   rx   r¥   Úlocationr°   ÚinfosÚmodule_dictr£   rn   r¸   r¤   )rº   ÚcodesZmodule_dataZtem_module_namer­   Z_importZmodule_spaceZispacerœ   r¬   r£   Z	local_varZvariabler   r   r   r¥   Ì  s:    



",zFrom_Import.writeN)Ú__name__Ú
__module__Ú__qualname__r»   r¼   r¥   r   r   r   r   r«   Ã  s   r«   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rª   c             C   s   || _ || _d| _d S )N)r   r   )r­   rx   r¹   )rº   r­   rx   r   r   r   r»   î  s    zImport.__init__c             C   s   d| j › dS )Nz	<Import: rI   )r­   )rº   r   r   r   r¼   ò  s    zImport.__str__c             C   s¾  | j dkr&| j  |¡ | j j› d}nd}|}xˆ| jD ]|}| j| }| d¡}x\tt|ƒƒD ]J}d |d |d … ¡}t 	|¡}	t|ƒ}
d|| › d|
› }|	d dkr:| 
d|› d|	d › d	¡ |d krö| 
d|› || › d
|› ¡ n8|t|ƒd kr$| 
d|› |› d
|› ¡ n
| 
d¡ |› d}qb|	d dkrtj 
|	d ¡ | 
d|› d|	d › d¡ | 
d|	d › d|› ¡ |d krÆ| 
d|› || › d
|› d|› || › ¡ n,|t|ƒd krò| 
d|› |› d
|› ¡ dtj|	d < |› d}qb|	d dkrbtj 
|	d ¡ | 
d¡ | 
d|	d › d|› ¡ |d kr„| 
d|› || › d
|› d|› || › ¡ n8|t|ƒd kr²| 
d|› |› d
|› ¡ n
| 
d¡ | |	d ¡ t|	d dtjd ¡ }t|ƒ}t|ƒ}x|jD ]}| |¡ qúW |tj|	d < | ¡  i }g }d}xB|jD ]8}||kr8| 
|¡ d|› d|› d||< |d7 }q8W d |¡}d|› d|› d|› d||
< dd„ }dd„ }|
d 7 }
xğtt|ƒ|
 ƒD ]Ü}||
|  }d|ksèd!|krò||ƒ}n||
|   d
¡}x†tt|ƒƒD ]v}|dks|| dkr2q|| d d"krHq|| d d#kr\P ||| ƒ\}}||kr|| | ||< qW d
 |¡||
| < qÄW |› d}qbW |}q8W d S )$Nr   rH   r	   r   Ú_r   zmov z $importer["z"]rQ   r„   r@   zmodule z "r   zmov $importer["z"] u	     ;å®šç¾©zbuilt-inrU   )ÚencodingrJ   rT   rI   r‚   z
namespace z" "c             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r   r	   r   )r   )rd   rG   r   r   r   r   r   Úget_name7  s    
zImport.write.<locals>.get_namec             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr   )r   r   r	   r   rQ   )r   r   )ÚlineÚboxr   r   r   r   r   r   r   Ú
parse_line?  s"    
  z Import.write.<locals>.parse_linerA   r   )r   r   ú;)rx   r¥   r¾   r­   rX   Úranger   r   r¦   r½   r   Úloadedr¿   Ú
add_newtabÚopenrÆ   Úreadr^   r¡   ra   Ú
del_newtabr£   )rº   rÁ   Z
last_layerZ	tem_layerr®   r¯   ZmboxÚmZdealnameZ	deal_datar   Znamespace_stack_namer   ra   r¬   ry   Zparams_dictrÉ   Zvar_krœ   Zvar_textrÇ   rÊ   ÚirÈ   r±   ÚjZbackr   r   r   r¥   ô  s    



 

.

.




 
zImport.writeN)rÂ   rÃ   rÄ   r»   r¼   r¥   r   r   r   r   rª   í  s   rª   c                 sÆ   ‡ fdd„‰ i } t tƒ d ddd ¡  d¡}x’|D ]Š}t|dd	d
d}|t|ƒk r4|| dkr4t||d d	d
d}||d |… }t||d dƒ}||kr¶ˆ ||d d … ƒ| |< q4i | |< q4W | S )Nc                sö   i }t | ƒ}d}xà||k rğx ||k r:| | dkr:|d7 }qW t| |ddd}| ||… }x ||k rx| | dkrx|d7 }qZW ||k rÀ| | dkrÀt| |d d	ƒ}ˆ | |d |… ƒ||< |d }q||ksÔ| | d
kræi ||< |d }qtdƒ‚qW |S )Nr   z, r	   z( ,T)rh   rQ   rK   rN   r‚   Zunknow)r   rk   rw   )rÈ   Z	line_dictr   r   rc   rj   r²   )r™   r   r   r™   d  s&    
  

zRead_ex_func.<locals>.deal_linez\apython\ex_func.pyrU   zutf-8)rÆ   r
   r   z #T)rh   rQ   r	   rR   )rÏ   r   rĞ   rX   rk   r   )rÀ   Zex_func_contentrÈ   r   r   r®   rc   r   )r™   r   ÚRead_ex_funcc  s    
rÕ   c               @   s.   e Zd Zdd„ Zdd„ Zdd„ Zdd	d
„ZdS )ÚImporterc             C   s   t ƒ | _|  ¡  d S )N)rÕ   rÀ   Úreset)rº   r   r   r   r»   ƒ  s    zImporter.__init__c                s$   ‡ ‡fdd„‰|  d¡‰ ˆ| jdƒS )Nc                sÀ   |t ˆ ƒd kr¤d}xŠt| ƒD ]~}| › d|›  dd¡}t|ƒrt| d¡d dkrt|dkrt|d d… ˆ | krt|}qt|ƒrd	t|ƒkr|ˆ | kr|d
 }qW |S ˆ| › dˆ | › |d ƒS )Nr	   r   r   r   rH   rS   Úpyéıÿÿÿz__init__.pyz/__init__.py)r   r   Úreplacer   rX   r   )Z	nowfolderr   ÚfilepathÚfileZroad)ÚfboxÚ
get_moduler   r   rŞ   ‡  s    6 z)Importer.__get_module.<locals>.get_modulerH   r   )rX   Úwork_folder)rº   r®   r   )rİ   rŞ   r   Z__get_module†  s    
zImporter.__get_modulec             C   sb   || j kr(|| jkr|› dgS |› dgS |  |¡}|| jkrD|dgS |dkrV|› dgS |dgS d S )Nr   r@   r   r	   )rÀ   rÍ   Ú_Importer__get_module)rº   r®   rÛ   r   r   r   r½   ”  s    






zImporter.get_pathr   Úcp950c             C   sh   d| _ || _| dd¡ d¡d }||kr4tƒ | _n|d t|ƒ d … | _|| _g | _i | _	d| _
d S )Nr   r   r   rS   r	   )r©   rÆ   rÚ   rX   r   rß   r   ZnowpathrÍ   r¿   r§   )rº   ZpyfilerÆ   Zpy_file_namer   r   r   r×   ¡  s    
zImporter.resetN)r   rá   )rÂ   rÃ   rÄ   r»   rà   r½   r×   r   r   r   r   rÖ   ‚  s   rÖ   c               @   s8   e Zd Zddd„Zdd„ Zdd„ Zdd	d
„Zdd„ ZdS )ÚPackagerrá   c             C   s*   t ƒ | _|| _dg g| _t d| j¡ d S )NTÚmodule)r   r   rÆ   ÚREPL_boxr¦   r×   )rº   rÆ   r   r   r   r»   °  s    
zPackager.__init__c             C   sÀ   |  d¡d }| dd¡  d¡d }|d t|ƒ … }t|ƒdkrNt|ƒ |}d|krtt|dƒ ¡ }|  d¡| j_nHt|d| jd	 ¡ }| j |¡ t	 
|| j¡ d| _|  |¡ | j ¡  d S )
NrH   rS   r   r   r   ZecrU   r
   )rÆ   )rX   rÚ   r   r   rÏ   rĞ   r   rÆ   rÎ   r¦   r×   Úadd_need_loadÚ	load_coderÑ   )rº   rÛ   ZftypeÚfilenamerß   r   r   r   r   Úloadµ  s    
zPackager.loadc             C   sÂ   | j  d¡ |dkrLt| jd ƒdkr@d | jd ¡}|  |¡ dg g| _nbt|ƒ}|d }|d dkr„d| jd< | jd	  |¡ n*| jd s | jd	  |¡ n| j|dd
 | j  ¡  | jd S )NÚREPLr   r	   r   r
   T)r   r&   r#   r    r!   r7   r5   FrS   )Úrepl)	r   rÎ   r   rä   r   ræ   r^   r   rÑ   )rº   Úcmdr   ra   rb   r   r   r   ré   È  s     



zPackager.REPLFc             C   sâ   t |ƒ}t|ƒ| _tjr4| jdkr4| j d¡ d| _t| jj	ƒdkrŞx| jj	D ]}| 
| j¡ qNW |rŞt| jj	d ƒtttttttttttttttttfkrŞt| jj	d ƒtksÂ| jj	d jdkrŞ| j d| jj	d j› ¡ d S )Nr   zmov $importer [dict]r	   rS   Úprintzprint )r^   r¡   r¬   r¦   r©   rå   r   r   r   ra   r¥   r\   rZ   rY   r   r]   rn   rv   ru   rs   r—   rt   r’   rr   rq   r•   r–   r“   r”   ro   r¾   )rº   r   rê   ra   ry   r   r   r   ræ   Ü  s    
:&zPackager.load_codec             C   s    t |dƒ ¡ }| d¡| j_d S )NrU   r
   )rÏ   rĞ   rX   r   )rº   Zec_filer   r   r   r   Z__load_easy_codeè  s    zPackager.__load_easy_codeN)rá   )F)rÂ   rÃ   rÄ   r»   rè   ré   ræ   Z_Packager__load_easy_coder   r   r   r   râ   ¯  s
   

râ   N)Fr   )F)Úosr   r   r   Úos.pathr   r   Zapython.coder   Zapython.moduler^   rk   r~   r   rp   r¢   r¡   r«   rª   rÕ   rÖ   r¦   râ   r   r   r   r   Ú<module>   s&    s
m

 {  G*v+1912*123*__init__.cpython-37.pycB
    AÁUe7  ã               @   s*   d dl mZ d dlmZ G dd„ dƒZdS )é    )ÚPackager)ÚExecuterc               @   sH   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zd
d„ Zdd„ Zddd„Z	dS )ÚApythonúutf-8c             C   s$   t |ƒ| _| jj| _t| jƒ| _d S )N)r   ÚpackagerÚcoder   Úexecuter)ÚselfÚencoding© r   ú0C:\Users\allen\Desktop\py\py\apython\__init__.pyÚ__init__   s    

zApython.__init__c             C   s   | j j}| ¡  d S )N)r   r   Zdisplay)r	   r   r   r   r   Úparse   s    zApython.parsec             C   s2   d  | jj¡}t|dƒ |¡ td|› dƒ d S )NÚ
Úwz[92mApython:save z[0m)Újoinr   ÚopenÚwriteÚprint)r	   Úfilepathr   r   r   r   Úsave   s    zApython.savec             C   s   | j  |¡ d S )N)r   Úload)r	   r   r   r   r   r      s    zApython.loadc             C   sŒ   d}t | jjƒ}xvyt|ƒ}W n2 tk
r<   tdƒ wY n tk
rP   P Y nX | j |¡}|r€| j 	|¡ t | jjƒ}d}qd}qW d S )Nz>>>z
KeyboardInterruptz...)
Úlenr   ÚinputÚKeyboardInterruptr   ÚEOFErrorr   ÚREPLr   ZREPL_run)r	   ÚhintÚprocessÚcmdZneed_executer   r   r   r      s     zApython.REPLc             C   s*   t | jjƒ}| j |¡ | jj|d d S )N)Zrow)r   r   r   Z	load_coder   Úrun)r	   r   r   r   r   r   Úinteraactive#   s    zApython.interaactiver   é   c             C   s   | j  ||¡ d S )N)r   r    )r	   ZtfÚ
stack_sizer   r   r   r    '   s    zApython.runN)r   )r   r"   )
Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r!   r    r   r   r   r   r      s   
r   N)Zapython.packager   Zapython.executerr   r   r   r   r   r   Ú<module>   s   368*122*è®Šæ•¸å‘½åè¦å‰‡.txt$name            ç³»çµ±è®Šæ•¸ï¼Œéç³»çµ±åƒæ•¸ä¸å¯ä½¿ç”¨
&name_len(code)  æš«æ™‚è®Šæ•¸ï¼Œç†è«–ä¸Šå› ç‚ºipä¸é‡è¤‡ï¼Œæ‰€ä»¥ä¸é‡è¤‡ï¼Œä¸å¯ç”¨æ–¼å †ç–Šè®Šæ•¸ï¼Œåªèƒ½ç”¨æ–¼å®£å‘ŠæŸç‰©ä»¶æ™‚
%name_id         ä¸å…·ååƒæ•¸ï¼Œidç‚ºimporterçš„è®Šå‹•id
name^id          classåƒæ•¸ï¼Œç•¶namepaceç‚ºæ­¤æ™‚ï¼Œä»£è¡¨æ­¤ç‰©ä»¶åœ¨classä¹‹ä¸­799063*110*apython.ecmov $importer [dict]
namespace &apython_1 "&apython_1" "Packager,Executer,Apython"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"] &apython_1
mov &tem_import_1 &apython_1
mov &apython_4 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &package_6 "&package_6" "listdir,getcwd,chdir,isdir,isfile,Code,parse_code,next_element,get_var,next_codeline,parse_codeline,parse_block,From_Import,Import,Read_ex_func,Importer,importer,Packager,Integer,Float,String,Byte,Var_name,Namespace,Variable,SubVariable,Slice,IndexVariable,List,Tuple,Dict,Set,is_number,Lambda,Def,FuncCall,Backtrack,Var_declare,Try_Except,With,Stop,Command,sub_if_else,If_else,While,sub_for_loop,For_loop,Mark,Pass,TFN,Class,two_object_write,Multiple_Mov,Oper,Tf,AndOr,Deny,Bool,Assert,STR,Info"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/package.py"] &package_6
mov &tem_import_4 &package_6
module &os_9 "os"
mov $importer["os"] &os_9
mov &tem_import_9 &os_9
push $importer["os"]
mov <&package_6+0> <esp+1>.listdir
mov <&package_6+1> <esp+1>.getcwd
mov <&package_6+2> <esp+1>.chdir
inc esp
mov &os_17 $importer["os"]
pass
module &path_19 "os.path"
mov $importer["os.path"] &path_19
mov &tem_import_17 &path_19
push $importer["os.path"]
mov <&package_6+3> <esp+1>.isdir
mov <&package_6+4> <esp+1>.isfile
inc esp
mov &apython_26 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &code_28 "&code_28" "Undefine,Code"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/code.py"] &code_28
mov &tem_import_26 &code_28
mov &apython_31 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &executer_33 "&executer_33" "Undefine,class_obj,Func,generator,atype,built_in_functions,Error_class,else_built_in,bifs,key,Executer,Ex_module,Namespace_stack,namespace_stack_var,bcolors,built_in_operator,time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"] &executer_33
mov &tem_import_31 &executer_33
mov &apython_36 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &built_in_38 "&built_in_38" "bcolors,built_in_operator,time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/built_in.py"] &built_in_38
mov &tem_import_36 &built_in_38
mov &apython_41 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &ex_func_43 "&ex_func_43" "time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/ex_func.py"] &ex_func_43
mov &tem_import_41 &ex_func_43
module &time_46 "time"
mov $importer["time"] &time_46
mov <&ex_func_43+0> &time_46  ;©w¸qtime
module &math_49 "math"
mov $importer["math"] &math_49
mov <&ex_func_43+1> &math_49  ;©w¸qmath
mov &os_52 $importer["os"]
mov <&ex_func_43+2> &os_52
mov &os_54 $importer["os"]
mov <&ex_func_43+2> &os_54
mov &path_56 $importer["os.path"]
mov &os_54.path &path_56
module &sys_58 "sys"
mov $importer["sys"] &sys_58
mov <&ex_func_43+3> &sys_58  ;©w¸qsys
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/ex_func.py"]
mov <&built_in_38+2> <esp+1>.time    ;import *
mov <&built_in_38+3> <esp+1>.math    ;import *
mov <&built_in_38+4> <esp+1>.os    ;import *
mov <&built_in_38+5> <esp+1>.sys    ;import *
inc esp
Function <&built_in_38+0> 69 None "bcolors^15" 1
name <&built_in_38+0> "<class '__main__.bcolors'>"
jmp 107
tf $Inheritance "equ" None
$jmp 74 "t"
mov <bcolors^15> $Inheritance
push 1
jmp 76
mov <bcolors^15> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <bcolors^15> <&built_in_38+0>
push "[92m"
mov <bcolors^15>.OK <esp+1>
inc esp
push "[93m"
mov <bcolors^15>.WARNING <esp+1>
inc esp
push "[91m"
mov <bcolors^15>.FAIL <esp+1>
inc esp
push "[0m"
mov <bcolors^15>.RESET <esp+1>
inc esp
mov AX <bcolors^15>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 105 "=="
tf AX "Ctn" "__init__"
$jmp 103 "t"
jmp 105
call AX.__init__
mov AX <bcolors^15>
end "Function" "bcolors^15"
pop ip
Function <&built_in_38+1> 109 None "built_in_operator_109" 6
jmp 2884           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 117 "!="
tf <esp+2> "in" "obj"
$jmp 119 "t"
mov <esp+2>["obj"] None
jmp 119
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 125 "!="
tf <esp+2> "in" "op"
$jmp 127 "t"
mov <esp+2>["op"] None
jmp 127
mov <esp+2>["op"] <esp+1>[1]
dec CX
mov <built_in_operator_109+1> <esp+2>["obj"]
mov <built_in_operator_109+2> <esp+2>["op"]


push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <built_in_operator_109+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <built_in_operator_109+3> <esp+1>
inc esp
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'str'>"
$jmp 153 "f"
mov AX True
jmp 154
mov AX False
cmp AX 1
$jmp 652 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 161 "f"
mov AX True
jmp 162
mov AX False
cmp AX 1
$jmp 167 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.join
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 172 "f"
mov AX True
jmp 173
mov AX False
cmp AX 1
$jmp 178 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 183 "f"
mov AX True
jmp 184
mov AX False
cmp AX 1
$jmp 189 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.split
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 194 "f"
mov AX True
jmp 195
mov AX False
cmp AX 1
$jmp 200 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "format"
$jmp 205 "f"
mov AX True
jmp 206
mov AX False
cmp AX 1
$jmp 211 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.format
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "encode"
$jmp 216 "f"
mov AX True
jmp 217
mov AX False
cmp AX 1
$jmp 222 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.encode
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "replace"
$jmp 227 "f"
mov AX True
jmp 228
mov AX False
cmp AX 1
$jmp 233 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.replace
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "capitalize"
$jmp 238 "f"
mov AX True
jmp 239
mov AX False
cmp AX 1
$jmp 244 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.capitalize
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "casefold"
$jmp 249 "f"
mov AX True
jmp 250
mov AX False
cmp AX 1
$jmp 255 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.casefold
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "center"
$jmp 260 "f"
mov AX True
jmp 261
mov AX False
cmp AX 1
$jmp 266 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.center
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "endswith"
$jmp 271 "f"
mov AX True
jmp 272
mov AX False
cmp AX 1
$jmp 277 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.endswith
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "expandtabs"
$jmp 282 "f"
mov AX True
jmp 283
mov AX False
cmp AX 1
$jmp 288 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.expandtabs
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "find"
$jmp 293 "f"
mov AX True
jmp 294
mov AX False
cmp AX 1
$jmp 299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.find
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "format_map"
$jmp 304 "f"
mov AX True
jmp 305
mov AX False
cmp AX 1
$jmp 310 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.format_map
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalnum"
$jmp 315 "f"
mov AX True
jmp 316
mov AX False
cmp AX 1
$jmp 321 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalnum
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalpha"
$jmp 326 "f"
mov AX True
jmp 327
mov AX False
cmp AX 1
$jmp 332 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalpha
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isascii"
$jmp 337 "f"
mov AX True
jmp 338
mov AX False
cmp AX 1
$jmp 343 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isascii
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdecimal"
$jmp 348 "f"
mov AX True
jmp 349
mov AX False
cmp AX 1
$jmp 354 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdecimal
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdigit"
$jmp 359 "f"
mov AX True
jmp 360
mov AX False
cmp AX 1
$jmp 365 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdigit
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isidentifier"
$jmp 370 "f"
mov AX True
jmp 371
mov AX False
cmp AX 1
$jmp 376 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isidentifier
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "islower"
$jmp 381 "f"
mov AX True
jmp 382
mov AX False
cmp AX 1
$jmp 387 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.islower
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isnumeric"
$jmp 392 "f"
mov AX True
jmp 393
mov AX False
cmp AX 1
$jmp 398 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isnumeric
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isprintable"
$jmp 403 "f"
mov AX True
jmp 404
mov AX False
cmp AX 1
$jmp 409 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isprintable
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isspace"
$jmp 414 "f"
mov AX True
jmp 415
mov AX False
cmp AX 1
$jmp 420 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isspace
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "istitle"
$jmp 425 "f"
mov AX True
jmp 426
mov AX False
cmp AX 1
$jmp 431 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.istitle
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isupper"
$jmp 436 "f"
mov AX True
jmp 437
mov AX False
cmp AX 1
$jmp 442 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isupper
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ljust"
$jmp 447 "f"
mov AX True
jmp 448
mov AX False
cmp AX 1
$jmp 453 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.ljust
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lower"
$jmp 458 "f"
mov AX True
jmp 459
mov AX False
cmp AX 1
$jmp 464 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lower
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lstrip"
$jmp 469 "f"
mov AX True
jmp 470
mov AX False
cmp AX 1
$jmp 475 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lstrip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "maketrans"
$jmp 480 "f"
mov AX True
jmp 481
mov AX False
cmp AX 1
$jmp 486 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.maketrans
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "partition"
$jmp 491 "f"
mov AX True
jmp 492
mov AX False
cmp AX 1
$jmp 497 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.partition
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rfind"
$jmp 502 "f"
mov AX True
jmp 503
mov AX False
cmp AX 1
$jmp 508 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rfind
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rindex"
$jmp 513 "f"
mov AX True
jmp 514
mov AX False
cmp AX 1
$jmp 519 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rindex
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rjust"
$jmp 524 "f"
mov AX True
jmp 525
mov AX False
cmp AX 1
$jmp 530 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rjust
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rpartition"
$jmp 535 "f"
mov AX True
jmp 536
mov AX False
cmp AX 1
$jmp 541 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rpartition
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rsplit"
$jmp 546 "f"
mov AX True
jmp 547
mov AX False
cmp AX 1
$jmp 552 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rsplit
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rstrip"
$jmp 557 "f"
mov AX True
jmp 558
mov AX False
cmp AX 1
$jmp 563 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rstrip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitlines"
$jmp 568 "f"
mov AX True
jmp 569
mov AX False
cmp AX 1
$jmp 574 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.splitlines
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "startswith"
$jmp 579 "f"
mov AX True
jmp 580
mov AX False
cmp AX 1
$jmp 585 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.startswith
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strip"
$jmp 590 "f"
mov AX True
jmp 591
mov AX False
cmp AX 1
$jmp 596 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.strip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "swapcase"
$jmp 601 "f"
mov AX True
jmp 602
mov AX False
cmp AX 1
$jmp 607 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.swapcase
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "title"
$jmp 612 "f"
mov AX True
jmp 613
mov AX False
cmp AX 1
$jmp 618 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.title
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "translate"
$jmp 623 "f"
mov AX True
jmp 624
mov AX False
cmp AX 1
$jmp 629 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.translate
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "upper"
$jmp 634 "f"
mov AX True
jmp 635
mov AX False
cmp AX 1
$jmp 640 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.upper
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "zfill"
$jmp 645 "f"
mov AX True
jmp 646
mov AX False
cmp AX 1
$jmp 651 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.zfill
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'list'>"
$jmp 657 "f"
mov AX True
jmp 658
mov AX False
cmp AX 1
$jmp 782 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "append"
$jmp 665 "f"
mov AX True
jmp 666
mov AX False
cmp AX 1
$jmp 671 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.append
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 676 "f"
mov AX True
jmp 677
mov AX False
cmp AX 1
$jmp 682 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 687 "f"
mov AX True
jmp 688
mov AX False
cmp AX 1
$jmp 693 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 698 "f"
mov AX True
jmp 699
mov AX False
cmp AX 1
$jmp 704 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.remove
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "insert"
$jmp 709 "f"
mov AX True
jmp 710
mov AX False
cmp AX 1
$jmp 715 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.insert
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 720 "f"
mov AX True
jmp 721
mov AX False
cmp AX 1
$jmp 726 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 731 "f"
mov AX True
jmp 732
mov AX False
cmp AX 1
$jmp 737 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 742 "f"
mov AX True
jmp 743
mov AX False
cmp AX 1
$jmp 748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "extend"
$jmp 753 "f"
mov AX True
jmp 754
mov AX False
cmp AX 1
$jmp 759 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.extend
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "reverse"
$jmp 764 "f"
mov AX True
jmp 765
mov AX False
cmp AX 1
$jmp 770 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.reverse
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sort"
$jmp 775 "f"
mov AX True
jmp 776
mov AX False
cmp AX 1
$jmp 781 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.sort
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'tuple'>"
$jmp 787 "f"
mov AX True
jmp 788
mov AX False
cmp AX 1
$jmp 813 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 795 "f"
mov AX True
jmp 796
mov AX False
cmp AX 1
$jmp 801 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 812        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 806 "f"
mov AX True
jmp 807
mov AX False
cmp AX 1
$jmp 812 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 812        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'dict'>"
$jmp 818 "f"
mov AX True
jmp 819
mov AX False
cmp AX 1
$jmp 943 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 826 "f"
mov AX True
jmp 827
mov AX False
cmp AX 1
$jmp 832 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "get"
$jmp 837 "f"
mov AX True
jmp 838
mov AX False
cmp AX 1
$jmp 843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.get
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 848 "f"
mov AX True
jmp 849
mov AX False
cmp AX 1
$jmp 854 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 859 "f"
mov AX True
jmp 860
mov AX False
cmp AX 1
$jmp 865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "update"
$jmp 870 "f"
mov AX True
jmp 871
mov AX False
cmp AX 1
$jmp 876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.update
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "keys"
$jmp 881 "f"
mov AX True
jmp 882
mov AX False
cmp AX 1
$jmp 887 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.keys
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fromkeys"
$jmp 892 "f"
mov AX True
jmp 893
mov AX False
cmp AX 1
$jmp 898 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.fromkeys
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "items"
$jmp 903 "f"
mov AX True
jmp 904
mov AX False
cmp AX 1
$jmp 909 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.items
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "popitem"
$jmp 914 "f"
mov AX True
jmp 915
mov AX False
cmp AX 1
$jmp 920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.popitem
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setdefault"
$jmp 925 "f"
mov AX True
jmp 926
mov AX False
cmp AX 1
$jmp 931 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.setdefault
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "values"
$jmp 936 "f"
mov AX True
jmp 937
mov AX False
cmp AX 1
$jmp 942 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.values
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'bytes'>"
$jmp 948 "f"
mov AX True
jmp 949
mov AX False
cmp AX 1
$jmp 1370 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 956 "f"
mov AX True
jmp 957
mov AX False
cmp AX 1
$jmp 962 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.join
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 967 "f"
mov AX True
jmp 968
mov AX False
cmp AX 1
$jmp 973 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 978 "f"
mov AX True
jmp 979
mov AX False
cmp AX 1
$jmp 984 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.split
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 989 "f"
mov AX True
jmp 990
mov AX False
cmp AX 1
$jmp 995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "decode"
$jmp 1000 "f"
mov AX True
jmp 1001
mov AX False
cmp AX 1
$jmp 1006 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.decode
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "replace"
$jmp 1011 "f"
mov AX True
jmp 1012
mov AX False
cmp AX 1
$jmp 1017 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.replace
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "capitalize"
$jmp 1022 "f"
mov AX True
jmp 1023
mov AX False
cmp AX 1
$jmp 1028 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.capitalize
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "center"
$jmp 1033 "f"
mov AX True
jmp 1034
mov AX False
cmp AX 1
$jmp 1039 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.center
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "endswith"
$jmp 1044 "f"
mov AX True
jmp 1045
mov AX False
cmp AX 1
$jmp 1050 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.endswith
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "expandtabs"
$jmp 1055 "f"
mov AX True
jmp 1056
mov AX False
cmp AX 1
$jmp 1061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.expandtabs
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "find"
$jmp 1066 "f"
mov AX True
jmp 1067
mov AX False
cmp AX 1
$jmp 1072 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.find
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalnum"
$jmp 1077 "f"
mov AX True
jmp 1078
mov AX False
cmp AX 1
$jmp 1083 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalnum
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalpha"
$jmp 1088 "f"
mov AX True
jmp 1089
mov AX False
cmp AX 1
$jmp 1094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalpha
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isascii"
$jmp 1099 "f"
mov AX True
jmp 1100
mov AX False
cmp AX 1
$jmp 1105 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isascii
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdigit"
$jmp 1110 "f"
mov AX True
jmp 1111
mov AX False
cmp AX 1
$jmp 1116 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdigit
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "islower"
$jmp 1121 "f"
mov AX True
jmp 1122
mov AX False
cmp AX 1
$jmp 1127 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.islower
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isspace"
$jmp 1132 "f"
mov AX True
jmp 1133
mov AX False
cmp AX 1
$jmp 1138 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isspace
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "istitle"
$jmp 1143 "f"
mov AX True
jmp 1144
mov AX False
cmp AX 1
$jmp 1149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.istitle
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isupper"
$jmp 1154 "f"
mov AX True
jmp 1155
mov AX False
cmp AX 1
$jmp 1160 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isupper
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ljust"
$jmp 1165 "f"
mov AX True
jmp 1166
mov AX False
cmp AX 1
$jmp 1171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.ljust
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lower"
$jmp 1176 "f"
mov AX True
jmp 1177
mov AX False
cmp AX 1
$jmp 1182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lower
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lstrip"
$jmp 1187 "f"
mov AX True
jmp 1188
mov AX False
cmp AX 1
$jmp 1193 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lstrip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "maketrans"
$jmp 1198 "f"
mov AX True
jmp 1199
mov AX False
cmp AX 1
$jmp 1204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.maketrans
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "partition"
$jmp 1209 "f"
mov AX True
jmp 1210
mov AX False
cmp AX 1
$jmp 1215 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.partition
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rfind"
$jmp 1220 "f"
mov AX True
jmp 1221
mov AX False
cmp AX 1
$jmp 1226 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rfind
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rindex"
$jmp 1231 "f"
mov AX True
jmp 1232
mov AX False
cmp AX 1
$jmp 1237 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rindex
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rjust"
$jmp 1242 "f"
mov AX True
jmp 1243
mov AX False
cmp AX 1
$jmp 1248 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rjust
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rpartition"
$jmp 1253 "f"
mov AX True
jmp 1254
mov AX False
cmp AX 1
$jmp 1259 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rpartition
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rsplit"
$jmp 1264 "f"
mov AX True
jmp 1265
mov AX False
cmp AX 1
$jmp 1270 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rsplit
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rstrip"
$jmp 1275 "f"
mov AX True
jmp 1276
mov AX False
cmp AX 1
$jmp 1281 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rstrip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitlines"
$jmp 1286 "f"
mov AX True
jmp 1287
mov AX False
cmp AX 1
$jmp 1292 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.splitlines
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "startswith"
$jmp 1297 "f"
mov AX True
jmp 1298
mov AX False
cmp AX 1
$jmp 1303 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.startswith
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strip"
$jmp 1308 "f"
mov AX True
jmp 1309
mov AX False
cmp AX 1
$jmp 1314 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.strip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "swapcase"
$jmp 1319 "f"
mov AX True
jmp 1320
mov AX False
cmp AX 1
$jmp 1325 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.swapcase
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "title"
$jmp 1330 "f"
mov AX True
jmp 1331
mov AX False
cmp AX 1
$jmp 1336 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.title
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "translate"
$jmp 1341 "f"
mov AX True
jmp 1342
mov AX False
cmp AX 1
$jmp 1347 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.translate
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "upper"
$jmp 1352 "f"
mov AX True
jmp 1353
mov AX False
cmp AX 1
$jmp 1358 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.upper
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "zfill"
$jmp 1363 "f"
mov AX True
jmp 1364
mov AX False
cmp AX 1
$jmp 1369 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.zfill
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'set'>"
$jmp 1375 "f"
mov AX True
jmp 1376
mov AX False
cmp AX 1
$jmp 1566 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 1383 "f"
mov AX True
jmp 1384
mov AX False
cmp AX 1
$jmp 1389 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "add"
$jmp 1394 "f"
mov AX True
jmp 1395
mov AX False
cmp AX 1
$jmp 1400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.add
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 1405 "f"
mov AX True
jmp 1406
mov AX False
cmp AX 1
$jmp 1411 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.remove
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 1416 "f"
mov AX True
jmp 1417
mov AX False
cmp AX 1
$jmp 1422 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 1427 "f"
mov AX True
jmp 1428
mov AX False
cmp AX 1
$jmp 1433 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "update"
$jmp 1438 "f"
mov AX True
jmp 1439
mov AX False
cmp AX 1
$jmp 1444 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "difference"
$jmp 1449 "f"
mov AX True
jmp 1450
mov AX False
cmp AX 1
$jmp 1455 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.difference
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "difference_update"
$jmp 1460 "f"
mov AX True
jmp 1461
mov AX False
cmp AX 1
$jmp 1466 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.difference_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "discard"
$jmp 1471 "f"
mov AX True
jmp 1472
mov AX False
cmp AX 1
$jmp 1477 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.discard
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "intersection"
$jmp 1482 "f"
mov AX True
jmp 1483
mov AX False
cmp AX 1
$jmp 1488 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.intersection
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "intersection_update"
$jmp 1493 "f"
mov AX True
jmp 1494
mov AX False
cmp AX 1
$jmp 1499 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.intersection_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdisjoint"
$jmp 1504 "f"
mov AX True
jmp 1505
mov AX False
cmp AX 1
$jmp 1510 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdisjoint
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "issubset"
$jmp 1515 "f"
mov AX True
jmp 1516
mov AX False
cmp AX 1
$jmp 1521 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.issubset
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "issuperset"
$jmp 1526 "f"
mov AX True
jmp 1527
mov AX False
cmp AX 1
$jmp 1532 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.issuperset
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "symmetric_difference"
$jmp 1537 "f"
mov AX True
jmp 1538
mov AX False
cmp AX 1
$jmp 1543 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.symmetric_difference
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "symmetric_difference_update"
$jmp 1548 "f"
mov AX True
jmp 1549
mov AX False
cmp AX 1
$jmp 1554 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.symmetric_difference_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "union"
$jmp 1559 "f"
mov AX True
jmp 1560
mov AX False
cmp AX 1
$jmp 1565 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.union
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class '_io.TextIOWrapper'>"
$jmp 1571 "f"
mov AX True
jmp 1572
mov AX False
cmp AX 1
$jmp 1762 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "write"
$jmp 1579 "f"
mov AX True
jmp 1580
mov AX False
cmp AX 1
$jmp 1585 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.write
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tell"
$jmp 1590 "f"
mov AX True
jmp 1591
mov AX False
cmp AX 1
$jmp 1596 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tell
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "read"
$jmp 1601 "f"
mov AX True
jmp 1602
mov AX False
cmp AX 1
$jmp 1607 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.read
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "close"
$jmp 1612 "f"
mov AX True
jmp 1613
mov AX False
cmp AX 1
$jmp 1618 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.close
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "seek"
$jmp 1623 "f"
mov AX True
jmp 1624
mov AX False
cmp AX 1
$jmp 1629 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.seek
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fileno"
$jmp 1634 "f"
mov AX True
jmp 1635
mov AX False
cmp AX 1
$jmp 1640 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.fileno
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "flush"
$jmp 1645 "f"
mov AX True
jmp 1646
mov AX False
cmp AX 1
$jmp 1651 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.flush
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isatty"
$jmp 1656 "f"
mov AX True
jmp 1657
mov AX False
cmp AX 1
$jmp 1662 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isatty
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readable"
$jmp 1667 "f"
mov AX True
jmp 1668
mov AX False
cmp AX 1
$jmp 1673 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readline"
$jmp 1678 "f"
mov AX True
jmp 1679
mov AX False
cmp AX 1
$jmp 1684 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readline
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readlines"
$jmp 1689 "f"
mov AX True
jmp 1690
mov AX False
cmp AX 1
$jmp 1695 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readlines
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "seekable"
$jmp 1700 "f"
mov AX True
jmp 1701
mov AX False
cmp AX 1
$jmp 1706 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.seekable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "truncate"
$jmp 1711 "f"
mov AX True
jmp 1712
mov AX False
cmp AX 1
$jmp 1717 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.truncate
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "writable"
$jmp 1722 "f"
mov AX True
jmp 1723
mov AX False
cmp AX 1
$jmp 1728 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.writable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "writelines"
$jmp 1733 "f"
mov AX True
jmp 1734
mov AX False
cmp AX 1
$jmp 1739 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.writelines
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "__enter__"
$jmp 1744 "f"
mov AX True
jmp 1745
mov AX False
cmp AX 1
$jmp 1750 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.__enter__
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "__exit__"
$jmp 1755 "f"
mov AX True
jmp 1756
mov AX False
cmp AX 1
$jmp 1761 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.__exit__
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
tf <built_in_operator_109+3> "in" "Ex_module"
mov AX TF
cmp AX 1
$jmp 2758 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <built_in_operator_109+1>.module_name
mov <built_in_operator_109+4> <esp+1>
inc esp
mov DX <built_in_operator_109+4>
tf DX "equ" "time"
$jmp 1774 "f"
mov AX True
jmp 1775
mov AX False
cmp AX 1
$jmp 1877 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "time"
$jmp 1782 "f"
mov AX True
jmp 1783
mov AX False
cmp AX 1
$jmp 1788 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.time
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sleep"
$jmp 1793 "f"
mov AX True
jmp 1794
mov AX False
cmp AX 1
$jmp 1799 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.sleep
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ctime"
$jmp 1804 "f"
mov AX True
jmp 1805
mov AX False
cmp AX 1
$jmp 1810 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.ctime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "localtime"
$jmp 1815 "f"
mov AX True
jmp 1816
mov AX False
cmp AX 1
$jmp 1821 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.localtime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "gmtime"
$jmp 1826 "f"
mov AX True
jmp 1827
mov AX False
cmp AX 1
$jmp 1832 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.gmtime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "mktime"
$jmp 1837 "f"
mov AX True
jmp 1838
mov AX False
cmp AX 1
$jmp 1843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.mktime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "asctime"
$jmp 1848 "f"
mov AX True
jmp 1849
mov AX False
cmp AX 1
$jmp 1854 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.asctime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strftime"
$jmp 1859 "f"
mov AX True
jmp 1860
mov AX False
cmp AX 1
$jmp 1865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.strftime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strptime"
$jmp 1870 "f"
mov AX True
jmp 1871
mov AX False
cmp AX 1
$jmp 1876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.strptime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "math"
$jmp 1882 "f"
mov AX True
jmp 1883
mov AX False
cmp AX 1
$jmp 2205 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pi"
$jmp 1890 "f"
mov AX True
jmp 1891
mov AX False
cmp AX 1
$jmp 1896 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.pi
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "e"
$jmp 1901 "f"
mov AX True
jmp 1902
mov AX False
cmp AX 1
$jmp 1907 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.e
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ceil"
$jmp 1912 "f"
mov AX True
jmp 1913
mov AX False
cmp AX 1
$jmp 1918 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.ceil
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "floor"
$jmp 1923 "f"
mov AX True
jmp 1924
mov AX False
cmp AX 1
$jmp 1929 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.floor
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copysign"
$jmp 1934 "f"
mov AX True
jmp 1935
mov AX False
cmp AX 1
$jmp 1940 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.copysign
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fabs"
$jmp 1945 "f"
mov AX True
jmp 1946
mov AX False
cmp AX 1
$jmp 1951 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fabs
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fmod"
$jmp 1956 "f"
mov AX True
jmp 1957
mov AX False
cmp AX 1
$jmp 1962 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fmod
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fsum"
$jmp 1967 "f"
mov AX True
jmp 1968
mov AX False
cmp AX 1
$jmp 1973 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fsum
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "gcd"
$jmp 1978 "f"
mov AX True
jmp 1979
mov AX False
cmp AX 1
$jmp 1984 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.gcd
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "pow"
$jmp 1989 "f"
mov AX True
jmp 1990
mov AX False
cmp AX 1
$jmp 1995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.pow
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sqrt"
$jmp 2000 "f"
mov AX True
jmp 2001
mov AX False
cmp AX 1
$jmp 2006 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.sqrt
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "factorial"
$jmp 2011 "f"
mov AX True
jmp 2012
mov AX False
cmp AX 1
$jmp 2017 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.factorial
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "degrees"
$jmp 2022 "f"
mov AX True
jmp 2023
mov AX False
cmp AX 1
$jmp 2028 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.degrees
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "radians"
$jmp 2033 "f"
mov AX True
jmp 2034
mov AX False
cmp AX 1
$jmp 2039 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.radians
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sin"
$jmp 2044 "f"
mov AX True
jmp 2045
mov AX False
cmp AX 1
$jmp 2050 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.sin
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "cos"
$jmp 2055 "f"
mov AX True
jmp 2056
mov AX False
cmp AX 1
$jmp 2061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.cos
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tan"
$jmp 2066 "f"
mov AX True
jmp 2067
mov AX False
cmp AX 1
$jmp 2072 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.tan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "asin"
$jmp 2077 "f"
mov AX True
jmp 2078
mov AX False
cmp AX 1
$jmp 2083 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.asin
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "acos"
$jmp 2088 "f"
mov AX True
jmp 2089
mov AX False
cmp AX 1
$jmp 2094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.acos
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "atan"
$jmp 2099 "f"
mov AX True
jmp 2100
mov AX False
cmp AX 1
$jmp 2105 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.atan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exp"
$jmp 2110 "f"
mov AX True
jmp 2111
mov AX False
cmp AX 1
$jmp 2116 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.exp
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log"
$jmp 2121 "f"
mov AX True
jmp 2122
mov AX False
cmp AX 1
$jmp 2127 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log1p"
$jmp 2132 "f"
mov AX True
jmp 2133
mov AX False
cmp AX 1
$jmp 2138 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log1p
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log2"
$jmp 2143 "f"
mov AX True
jmp 2144
mov AX False
cmp AX 1
$jmp 2149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log2
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log10"
$jmp 2154 "f"
mov AX True
jmp 2155
mov AX False
cmp AX 1
$jmp 2160 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log10
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isclose"
$jmp 2165 "f"
mov AX True
jmp 2166
mov AX False
cmp AX 1
$jmp 2171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isclose
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isfinite"
$jmp 2176 "f"
mov AX True
jmp 2177
mov AX False
cmp AX 1
$jmp 2182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isfinite
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isinf"
$jmp 2187 "f"
mov AX True
jmp 2188
mov AX False
cmp AX 1
$jmp 2193 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isinf
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isnan"
$jmp 2198 "f"
mov AX True
jmp 2199
mov AX False
cmp AX 1
$jmp 2204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isnan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "os"
$jmp 2210 "f"
mov AX True
jmp 2211
mov AX False
cmp AX 1
$jmp 2368 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "getcwd"
$jmp 2218 "f"
mov AX True
jmp 2219
mov AX False
cmp AX 1
$jmp 2224 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.getcwd
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "listdir"
$jmp 2229 "f"
mov AX True
jmp 2230
mov AX False
cmp AX 1
$jmp 2235 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.listdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "mkdir"
$jmp 2240 "f"
mov AX True
jmp 2241
mov AX False
cmp AX 1
$jmp 2246 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.mkdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "chdir"
$jmp 2251 "f"
mov AX True
jmp 2252
mov AX False
cmp AX 1
$jmp 2257 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.chdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rmdir"
$jmp 2262 "f"
mov AX True
jmp 2263
mov AX False
cmp AX 1
$jmp 2268 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.rmdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "open"
$jmp 2273 "f"
mov AX True
jmp 2274
mov AX False
cmp AX 1
$jmp 2279 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.open
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "write"
$jmp 2284 "f"
mov AX True
jmp 2285
mov AX False
cmp AX 1
$jmp 2290 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.write
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rename"
$jmp 2295 "f"
mov AX True
jmp 2296
mov AX False
cmp AX 1
$jmp 2301 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.rename
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 2306 "f"
mov AX True
jmp 2307
mov AX False
cmp AX 1
$jmp 2312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.remove
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stat"
$jmp 2317 "f"
mov AX True
jmp 2318
mov AX False
cmp AX 1
$jmp 2323 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.stat
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "close"
$jmp 2328 "f"
mov AX True
jmp 2329
mov AX False
cmp AX 1
$jmp 2334 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.close
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "path"
$jmp 2339 "f"
mov AX True
jmp 2340
mov AX False
cmp AX 1
$jmp 2345 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "system"
$jmp 2350 "f"
mov AX True
jmp 2351
mov AX False
cmp AX 1
$jmp 2356 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.system
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "walk"
$jmp 2361 "f"
mov AX True
jmp 2362
mov AX False
cmp AX 1
$jmp 2367 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.walk
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "os.path"
$jmp 2373 "f"
mov AX True
jmp 2374
mov AX False
cmp AX 1
$jmp 2605 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "isdir"
$jmp 2381 "f"
mov AX True
jmp 2382
mov AX False
cmp AX 1
$jmp 2388 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isdir
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isfile"
$jmp 2393 "f"
mov AX True
jmp 2394
mov AX False
cmp AX 1
$jmp 2400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isfile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "abspath"
$jmp 2405 "f"
mov AX True
jmp 2406
mov AX False
cmp AX 1
$jmp 2412 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.abspath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "basename"
$jmp 2417 "f"
mov AX True
jmp 2418
mov AX False
cmp AX 1
$jmp 2424 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.basename
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "dirname"
$jmp 2429 "f"
mov AX True
jmp 2430
mov AX False
cmp AX 1
$jmp 2436 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.dirname
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exists"
$jmp 2441 "f"
mov AX True
jmp 2442
mov AX False
cmp AX 1
$jmp 2448 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.exists
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getatime"
$jmp 2453 "f"
mov AX True
jmp 2454
mov AX False
cmp AX 1
$jmp 2460 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getatime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getmtime"
$jmp 2465 "f"
mov AX True
jmp 2466
mov AX False
cmp AX 1
$jmp 2472 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getmtime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getctime"
$jmp 2477 "f"
mov AX True
jmp 2478
mov AX False
cmp AX 1
$jmp 2484 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getctime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getsize"
$jmp 2489 "f"
mov AX True
jmp 2490
mov AX False
cmp AX 1
$jmp 2496 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getsize
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isabs"
$jmp 2501 "f"
mov AX True
jmp 2502
mov AX False
cmp AX 1
$jmp 2508 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isabs
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 2513 "f"
mov AX True
jmp 2514
mov AX False
cmp AX 1
$jmp 2520 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.join
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "realpath"
$jmp 2525 "f"
mov AX True
jmp 2526
mov AX False
cmp AX 1
$jmp 2532 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.realpath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "relpath"
$jmp 2537 "f"
mov AX True
jmp 2538
mov AX False
cmp AX 1
$jmp 2544 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.relpath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "samefile"
$jmp 2549 "f"
mov AX True
jmp 2550
mov AX False
cmp AX 1
$jmp 2556 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.samefile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sameopenfile"
$jmp 2561 "f"
mov AX True
jmp 2562
mov AX False
cmp AX 1
$jmp 2568 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.sameopenfile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "samestat"
$jmp 2573 "f"
mov AX True
jmp 2574
mov AX False
cmp AX 1
$jmp 2580 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.samestat
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 2585 "f"
mov AX True
jmp 2586
mov AX False
cmp AX 1
$jmp 2592 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.split
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitext"
$jmp 2597 "f"
mov AX True
jmp 2598
mov AX False
cmp AX 1
$jmp 2604 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.splitext
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "sys"
$jmp 2610 "f"
mov AX True
jmp 2611
mov AX False
cmp AX 1
$jmp 2757 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "argv"
$jmp 2618 "f"
mov AX True
jmp 2619
mov AX False
cmp AX 1
$jmp 2624 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.argv
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "platform"
$jmp 2629 "f"
mov AX True
jmp 2630
mov AX False
cmp AX 1
$jmp 2635 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.platform
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "version_info"
$jmp 2640 "f"
mov AX True
jmp 2641
mov AX False
cmp AX 1
$jmp 2646 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.version_info
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "path"
$jmp 2651 "f"
mov AX True
jmp 2652
mov AX False
cmp AX 1
$jmp 2657 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.path
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stdin"
$jmp 2662 "f"
mov AX True
jmp 2663
mov AX False
cmp AX 1
$jmp 2668 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stdin
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stdout"
$jmp 2673 "f"
mov AX True
jmp 2674
mov AX False
cmp AX 1
$jmp 2679 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stdout
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stderr"
$jmp 2684 "f"
mov AX True
jmp 2685
mov AX False
cmp AX 1
$jmp 2690 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stderr
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "displayhook"
$jmp 2695 "f"
mov AX True
jmp 2696
mov AX False
cmp AX 1
$jmp 2701 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.displayhook
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exceptionhook"
$jmp 2706 "f"
mov AX True
jmp 2707
mov AX False
cmp AX 1
$jmp 2712 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.exceptionhook
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setrecursionlimit"
$jmp 2717 "f"
mov AX True
jmp 2718
mov AX False
cmp AX 1
$jmp 2723 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setrecursionlimit
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setswitchinterval"
$jmp 2728 "f"
mov AX True
jmp 2729
mov AX False
cmp AX 1
$jmp 2734 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setswitchinterval
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "settrace"
$jmp 2739 "f"
mov AX True
jmp 2740
mov AX False
cmp AX 1
$jmp 2745 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.settrace
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setprofile"
$jmp 2750 "f"
mov AX True
jmp 2751
mov AX False
cmp AX 1
$jmp 2756 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setprofile
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
push <built_in_operator_109+1>.__name__
mov <built_in_operator_109+5> <esp+1>
inc esp
mov DX <built_in_operator_109+2>
tf DX "equ" "__name__"
$jmp 2766 "f"
mov AX True
jmp 2767
mov AX False
cmp AX 1
$jmp 2772 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+5>
jmp 2881
jmp 2772        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+5>
tf DX "equ" "localtime"
$jmp 2777 "f"
mov AX True
jmp 2778
mov AX False
cmp AX 1
$jmp 2858 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_year"
$jmp 2785 "f"
mov AX True
jmp 2786
mov AX False
cmp AX 1
$jmp 2791 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_year
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_mon"
$jmp 2796 "f"
mov AX True
jmp 2797
mov AX False
cmp AX 1
$jmp 2802 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_mon
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_mday"
$jmp 2807 "f"
mov AX True
jmp 2808
mov AX False
cmp AX 1
$jmp 2813 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_mday
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_hour"
$jmp 2818 "f"
mov AX True
jmp 2819
mov AX False
cmp AX 1
$jmp 2824 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_hour
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_min"
$jmp 2829 "f"
mov AX True
jmp 2830
mov AX False
cmp AX 1
$jmp 2835 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_min
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_sec"
$jmp 2840 "f"
mov AX True
jmp 2841
mov AX False
cmp AX 1
$jmp 2846 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_sec
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_wday"
$jmp 2851 "f"
mov AX True
jmp 2852
mov AX False
cmp AX 1
$jmp 2857 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_wday
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
jmp 2858        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <&built_in_38+0>.FAIL
oper <esp+1> "+" AX
oper <esp+1> "+" "apython built_in error:\n    "
ex_func AX "str" <built_in_operator_109+1>
oper <esp+1> "+" AX
oper <esp+1> "+" " has no attribute "
ex_func AX "str" <built_in_operator_109+2>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <&built_in_38+0>.RESET
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX Exception
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "built_in_operator_109" "0,1,2,3,4,5"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/built_in.py"]
mov <&executer_33+14> <esp+1>.bcolors    ;import *
mov <&executer_33+15> <esp+1>.built_in_operator    ;import *
mov <&executer_33+16> <esp+1>.time    ;import *
mov <&executer_33+17> <esp+1>.math    ;import *
mov <&executer_33+18> <esp+1>.os    ;import *
mov <&executer_33+19> <esp+1>.sys    ;import *
inc esp
Function <&executer_33+0> 2895 None "Undefine^7" 1
name <&executer_33+0> "<class '__main__.Undefine'>"
jmp 2957
tf $Inheritance "equ" None
$jmp 2900 "t"
mov <Undefine^7> $Inheritance
push 1
jmp 2902
mov <Undefine^7> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Undefine^7> <&executer_33+0>
Function BX 2910 <Undefine^7> "__init___2910" 2
mov <Undefine^7>.__init__ BX
jmp 2924           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "[91m"
mov <__init___2910+0>.Fail <esp+1>
inc esp
push "[0m"
mov <__init___2910+0>.RESET <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___2910" "0,1"
pop ip
Function BX 2927 <Undefine^7> "__str___2927" 2
mov <Undefine^7>.__str__ BX
jmp 2943           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___2927+0>.Fail
oper <esp+1> "+" AX
oper <esp+1> "+" "<undefined>"
ex_func AX "str" <__str___2927+0>.RESET
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 2940         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___2927" "0,1"
pop ip
mov AX <Undefine^7>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 2955 "=="
tf AX "Ctn" "__init__"
$jmp 2953 "t"
jmp 2955
call AX.__init__
mov AX <Undefine^7>
end "Function" "Undefine^7"
pop ip
Function <&executer_33+1> 2960 None "class_obj^8" 1
name <&executer_33+1> "<class '__main__.class_obj'>"
jmp 3702
tf $Inheritance "equ" None
$jmp 2965 "t"
mov <class_obj^8> $Inheritance
push 1
jmp 2967
mov <class_obj^8> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <class_obj^8> <&executer_33+1>
Function BX 2975 <class_obj^8> "__init___2975" 3
mov <class_obj^8>.__init__ BX
jmp 3004           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 2983 "!="
tf <esp+2> "in" "ram"
$jmp 2985 "t"
mov <esp+2>["ram"] None
jmp 2985
mov <esp+2>["ram"] <esp+1>[0]
dec CX
mov <__init___2975+2> <esp+2>["ram"]


push <__init___2975+2>
mov <__init___2975+0>.ram <esp+1>
inc esp
push None
mov <__init___2975+0>.atype <esp+1>
inc esp
push [dict]
mov <__init___2975+0>.vars <esp+1>
inc esp
push 0
mov <__init___2975+0>.print_lock <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___2975" "0,1,2"
pop ip
Function BX 3007 <class_obj^8> "__str___3007" 2
mov <class_obj^8>.__str__ BX
jmp 3047           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__str___3007+0>.print_lock
tf DX "equ" 0
$jmp 3016 "f"
mov AX True
jmp 3017
mov AX False
cmp AX 1
$jmp 3025 "!="
tf <__str___3007+0>.vars "in" "__str__"
mov AX TF
cmp AX 1
$jmp 3025 "!="
mov AX 1
jmp 3026
mov AX 0
cmp AX 1
$jmp 3042 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__str___3007+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__str___3007+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__str__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3044         ;returnÂI
jmp 3042        ;¸õ¦Ü©³³¡
mov AX "<class_obj>"
jmp 3044         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___3007" "0,1"
pop ip
Function BX 3050 <class_obj^8> "__add___3050" 3
mov <class_obj^8>.__add__ BX
jmp 3100           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3058 "!="
tf <esp+2> "in" "other"
$jmp 3060 "t"
mov <esp+2>["other"] None
jmp 3060
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__add___3050+2> <esp+2>["other"]


mov DX <__add___3050+0>.print_lock
tf DX "equ" 0
$jmp 3068 "f"
mov AX True
jmp 3069
mov AX False
cmp AX 1
$jmp 3077 "!="
tf <__add___3050+0>.vars "in" "__add__"
mov AX TF
cmp AX 1
$jmp 3077 "!="
mov AX 1
jmp 3078
mov AX 0
cmp AX 1
$jmp 3096 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__add___3050+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__add___3050+0>
push [1]
mov <esp+1>[0] <__add___3050+2>
pop <esp+1>[1]
mov <esp+1>[2] "__add__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3097
jmp 3096        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__add___3050" "0,1,2"
pop ip
Function BX 3103 <class_obj^8> "__sub___3103" 3
mov <class_obj^8>.__sub__ BX
jmp 3153           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3111 "!="
tf <esp+2> "in" "other"
$jmp 3113 "t"
mov <esp+2>["other"] None
jmp 3113
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__sub___3103+2> <esp+2>["other"]


mov DX <__sub___3103+0>.print_lock
tf DX "equ" 0
$jmp 3121 "f"
mov AX True
jmp 3122
mov AX False
cmp AX 1
$jmp 3130 "!="
tf <__sub___3103+0>.vars "in" "__sub__"
mov AX TF
cmp AX 1
$jmp 3130 "!="
mov AX 1
jmp 3131
mov AX 0
cmp AX 1
$jmp 3149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__sub___3103+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__sub___3103+0>
push [1]
mov <esp+1>[0] <__sub___3103+2>
pop <esp+1>[1]
mov <esp+1>[2] "__sub__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3150
jmp 3149        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__sub___3103" "0,1,2"
pop ip
Function BX 3156 <class_obj^8> "__len___3156" 2
mov <class_obj^8>.__len__ BX
jmp 3195           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__len___3156+0>.print_lock
tf DX "equ" 0
$jmp 3165 "f"
mov AX True
jmp 3166
mov AX False
cmp AX 1
$jmp 3174 "!="
tf <__len___3156+0>.vars "in" "__len__"
mov AX TF
cmp AX 1
$jmp 3174 "!="
mov AX 1
jmp 3175
mov AX 0
cmp AX 1
$jmp 3191 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__len___3156+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__len___3156+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__len__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3192
jmp 3191        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___3156" "0,1"
pop ip
Function BX 3198 <class_obj^8> "__setitem___3198" 4
mov <class_obj^8>.__setitem__ BX
jmp 3258           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3206 "!="
tf <esp+2> "in" "key"
$jmp 3208 "t"
mov <esp+2>["key"] None
jmp 3208
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3214 "!="
tf <esp+2> "in" "value"
$jmp 3216 "t"
mov <esp+2>["value"] None
jmp 3216
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___3198+2> <esp+2>["key"]
mov <__setitem___3198+3> <esp+2>["value"]


mov DX <__setitem___3198+0>.print_lock
tf DX "equ" 0
$jmp 3225 "f"
mov AX True
jmp 3226
mov AX False
cmp AX 1
$jmp 3234 "!="
tf <__setitem___3198+0>.vars "in" "__setitem__"
mov AX TF
cmp AX 1
$jmp 3234 "!="
mov AX 1
jmp 3235
mov AX 0
cmp AX 1
$jmp 3254 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__setitem___3198+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__setitem___3198+0>
push [2]
mov <esp+1>[0] <__setitem___3198+2>
mov <esp+1>[1] <__setitem___3198+3>
pop <esp+1>[1]
mov <esp+1>[2] "__setitem__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3255
jmp 3254        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___3198" "0,1,2,3"
pop ip
Function BX 3261 <class_obj^8> "__getitem___3261" 3
mov <class_obj^8>.__getitem__ BX
jmp 3311           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3269 "!="
tf <esp+2> "in" "item"
$jmp 3271 "t"
mov <esp+2>["item"] None
jmp 3271
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___3261+2> <esp+2>["item"]


mov DX <__getitem___3261+0>.print_lock
tf DX "equ" 0
$jmp 3279 "f"
mov AX True
jmp 3280
mov AX False
cmp AX 1
$jmp 3288 "!="
tf <__getitem___3261+0>.vars "in" "__getitem__"
mov AX TF
cmp AX 1
$jmp 3288 "!="
mov AX 1
jmp 3289
mov AX 0
cmp AX 1
$jmp 3307 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__getitem___3261+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__getitem___3261+0>
push [1]
mov <esp+1>[0] <__getitem___3261+2>
pop <esp+1>[1]
mov <esp+1>[2] "__getitem__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3308
jmp 3307        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___3261" "0,1,2"
pop ip
Function BX 3314 <class_obj^8> "__contains___3314" 3
mov <class_obj^8>.__contains__ BX
jmp 3364           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3322 "!="
tf <esp+2> "in" "item"
$jmp 3324 "t"
mov <esp+2>["item"] None
jmp 3324
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___3314+2> <esp+2>["item"]


mov DX <__contains___3314+0>.print_lock
tf DX "equ" 0
$jmp 3332 "f"
mov AX True
jmp 3333
mov AX False
cmp AX 1
$jmp 3341 "!="
tf <__contains___3314+0>.vars "in" "__contains__"
mov AX TF
cmp AX 1
$jmp 3341 "!="
mov AX 1
jmp 3342
mov AX 0
cmp AX 1
$jmp 3360 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__contains___3314+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__contains___3314+0>
push [1]
mov <esp+1>[0] <__contains___3314+2>
pop <esp+1>[1]
mov <esp+1>[2] "__contains__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3361
jmp 3360        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___3314" "0,1,2"
pop ip
Function BX 3367 <class_obj^8> "__next___3367" 2
mov <class_obj^8>.__next__ BX
jmp 3425           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__next___3367+0>.print_lock
tf DX "equ" 0
$jmp 3376 "f"
mov AX True
jmp 3377
mov AX False
cmp AX 1
$jmp 3385 "!="
tf <__next___3367+0>.vars "in" "__next__"
mov AX TF
cmp AX 1
$jmp 3385 "!="
mov AX 1
jmp 3386
mov AX 0
cmp AX 1
$jmp 3402 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next___3367+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next___3367+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__next__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3422
jmp 3421        ;¸õ¦Ü©³³¡
tf <__next___3367+0>.vars "in" "__getitem__"
mov AX TF
cmp AX 1
$jmp 3421 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push False
mov <__next___3367+0>.error <esp+1>
inc esp
push 1
$mov <__next___3367+0>.item_k "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__next___3367+0>.item_k
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__next___3367+0>.__getitem__
jmp 3422
jmp 3421        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next___3367" "0,1"
pop ip
Function BX 3428 <class_obj^8> "__iter___3428" 2
mov <class_obj^8>.__iter__ BX
jmp 3473           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX 1
$oper AX "-"
push AX
mov <__iter___3428+0>.item_k <esp+1>
inc esp
mov DX <__iter___3428+0>.print_lock
tf DX "equ" 0
$jmp 3442 "f"
mov AX True
jmp 3443
mov AX False
cmp AX 1
$jmp 3451 "!="
tf <__iter___3428+0>.vars "in" "__iter__"
mov AX TF
cmp AX 1
$jmp 3451 "!="
mov AX 1
jmp 3452
mov AX 0
cmp AX 1
$jmp 3468 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__iter___3428+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__iter___3428+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__iter__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3470         ;returnÂI
jmp 3468        ;¸õ¦Ü©³³¡
mov AX <__iter___3428+0>
jmp 3470         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__iter___3428" "0,1"
pop ip
Function BX 3476 <class_obj^8> "__exit___3476" 5
mov <class_obj^8>.__exit__ BX
jmp 3546           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3484 "!="
tf <esp+2> "in" "exc_type"
$jmp 3486 "t"
mov <esp+2>["exc_type"] None
jmp 3486
mov <esp+2>["exc_type"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3492 "!="
tf <esp+2> "in" "exc_val"
$jmp 3494 "t"
mov <esp+2>["exc_val"] None
jmp 3494
mov <esp+2>["exc_val"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3500 "!="
tf <esp+2> "in" "exc_tb"
$jmp 3502 "t"
mov <esp+2>["exc_tb"] None
jmp 3502
mov <esp+2>["exc_tb"] <esp+1>[2]
dec CX
mov <__exit___3476+2> <esp+2>["exc_type"]
mov <__exit___3476+3> <esp+2>["exc_val"]
mov <__exit___3476+4> <esp+2>["exc_tb"]


mov DX <__exit___3476+0>.print_lock
tf DX "equ" 0
$jmp 3512 "f"
mov AX True
jmp 3513
mov AX False
cmp AX 1
$jmp 3521 "!="
tf <__exit___3476+0>.vars "in" "__exit__"
mov AX TF
cmp AX 1
$jmp 3521 "!="
mov AX 1
jmp 3522
mov AX 0
cmp AX 1
$jmp 3542 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__exit___3476+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__exit___3476+0>
push [3]
mov <esp+1>[0] <__exit___3476+2>
mov <esp+1>[1] <__exit___3476+3>
mov <esp+1>[2] <__exit___3476+4>
pop <esp+1>[1]
mov <esp+1>[2] "__exit__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3543
jmp 3542        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__exit___3476" "0,1,2,3,4"
pop ip
Function BX 3549 <class_obj^8> "__call___3549" 4
mov <class_obj^8>.__call__ BX
jmp 3593           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___3549+2> <esp+2>["args"]
mov <__call___3549+3> <esp+2>["kwargs"]


mov DX <__call___3549+0>.print_lock
tf DX "equ" 0
$jmp 3562 "f"
mov AX True
jmp 3563
mov AX False
cmp AX 1
$jmp 3571 "!="
tf <__call___3549+0>.vars "in" "__call__"
mov AX TF
cmp AX 1
$jmp 3571 "!="
mov AX 1
jmp 3572
mov AX 0
cmp AX 1
$jmp 3589 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__call___3549+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <__call___3549+0>
mov <esp+1>[1] <__call___3549+2>
mov <esp+1>[2] "__call__"
mov <esp+1>[3] <__call___3549+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3590
jmp 3589        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___3549" "0,1,2,3"
pop ip
Function BX 3596 <class_obj^8> "__del___3596" 2
mov <class_obj^8>.__del__ BX
jmp 3635           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__del___3596+0>.print_lock
tf DX "equ" 0
$jmp 3605 "f"
mov AX True
jmp 3606
mov AX False
cmp AX 1
$jmp 3614 "!="
tf <__del___3596+0>.vars "in" "__del__"
mov AX TF
cmp AX 1
$jmp 3614 "!="
mov AX 1
jmp 3615
mov AX 0
cmp AX 1
$jmp 3631 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__del___3596+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__del___3596+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__del__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3632
jmp 3631        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__del___3596" "0,1"
pop ip
Function BX 3638 <class_obj^8> "__eq___3638" 3
mov <class_obj^8>.__eq__ BX
jmp 3688           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3646 "!="
tf <esp+2> "in" "other"
$jmp 3648 "t"
mov <esp+2>["other"] None
jmp 3648
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__eq___3638+2> <esp+2>["other"]


mov DX <__eq___3638+0>.print_lock
tf DX "equ" 0
$jmp 3656 "f"
mov AX True
jmp 3657
mov AX False
cmp AX 1
$jmp 3665 "!="
tf <__eq___3638+0>.vars "in" "__eq__"
mov AX TF
cmp AX 1
$jmp 3665 "!="
mov AX 1
jmp 3666
mov AX 0
cmp AX 1
$jmp 3684 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__eq___3638+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__eq___3638+0>
push [1]
mov <esp+1>[0] <__eq___3638+2>
pop <esp+1>[1]
mov <esp+1>[2] "__eq__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3685
jmp 3684        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__eq___3638" "0,1,2"
pop ip
mov AX <class_obj^8>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 3700 "=="
tf AX "Ctn" "__init__"
$jmp 3698 "t"
jmp 3700
call AX.__init__
mov AX <class_obj^8>
end "Function" "class_obj^8"
pop ip
Function <&executer_33+2> 3705 None "Func^9" 1
name <&executer_33+2> "<class '__main__.Func'>"
jmp 3894
tf $Inheritance "equ" None
$jmp 3710 "t"
mov <Func^9> $Inheritance
push 1
jmp 3712
mov <Func^9> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Func^9> <&executer_33+2>
Function BX 3720 <Func^9> "__init___3720" 8
mov <Func^9>.__init__ BX
jmp 3807           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3728 "!="
tf <esp+2> "in" "ram"
$jmp 3730 "t"
mov <esp+2>["ram"] None
jmp 3730
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3736 "!="
tf <esp+2> "in" "$$ip"
$jmp 3738 "t"
mov <esp+2>["$$ip"] None
jmp 3738
mov <esp+2>["$$ip"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3744 "!="
tf <esp+2> "in" "class_obj"
$jmp 3746 "t"
mov <esp+2>["class_obj"] None
jmp 3746
mov <esp+2>["class_obj"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 3752 "!="
tf <esp+2> "in" "func_var"
$jmp 3754 "t"
mov <esp+2>["func_var"] None
jmp 3754
mov <esp+2>["func_var"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 3760 "!="
tf <esp+2> "in" "stack_len"
$jmp 3762 "t"
mov <esp+2>["stack_len"] None
jmp 3762
mov <esp+2>["stack_len"] <esp+1>[4]
dec CX
cmp CX 0
$jmp 3768 "!="
tf <esp+2> "in" "import_funcs"
$jmp 3770 "t"
mov <esp+2>["import_funcs"] None
jmp 3770
mov <esp+2>["import_funcs"] <esp+1>[5]
dec CX
mov <__init___3720+2> <esp+2>["ram"]
mov <__init___3720+3> <esp+2>["$$ip"]
mov <__init___3720+4> <esp+2>["class_obj"]
mov <__init___3720+5> <esp+2>["func_var"]
mov <__init___3720+6> <esp+2>["stack_len"]
mov <__init___3720+7> <esp+2>["import_funcs"]


push "Function"
mov <__init___3720+0>.name <esp+1>
inc esp
push "Function"
mov <__init___3720+0>.atype <esp+1>
inc esp
push <__init___3720+2>
mov <__init___3720+0>.ram <esp+1>
inc esp
push [dict]
mov BX "ip"
mov <esp+1>[BX] <__init___3720+3>
mov BX "class_obj"
mov <esp+1>[BX] <__init___3720+4>
mov <__init___3720+0>.vars <esp+1>
inc esp
push <__init___3720+5>
mov <__init___3720+0>.stack_name <esp+1>
inc esp
push <__init___3720+6>
mov <__init___3720+0>.stack_len <esp+1>
inc esp
push <__init___3720+7>
mov <__init___3720+0>.import_funcs <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___3720" "0,1,2,3,4,5,6,7"
pop ip
Function BX 3810 <Func^9> "__str___3810" 2
mov <Func^9>.__str__ BX
jmp 3825           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___3810+0>.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
jmp 3822         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___3810" "0,1"
pop ip
Function BX 3828 <Func^9> "__call___3828" 5
mov <Func^9>.__call__ BX
jmp 3880           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___3828+2> <esp+2>["args"]
mov <__call___3828+3> <esp+2>["kwargs"]


push <__call___3828+2>
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.args_location
pop AX
mov AX[BX] <esp+1>
inc esp
push <__call___3828+3>
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.kwargs_location
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_run
push 5        ;Àx¦sCX
push [5]
push <__call___3828+0>.vars
mov BX "ip"
pop AX
mov <esp+1>[0] AX[BX]
push <__call___3828+0>.vars
mov BX "class_obj"
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <__call___3828+0>.stack_name
mov <esp+1>[3] <__call___3828+0>.stack_len
mov <esp+1>[4] <__call___3828+0>.import_funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__call___3828+4> <esp+1>
inc esp
mov AX <__call___3828+4>
jmp 3877         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___3828" "0,1,2,3,4"
pop ip
mov AX <Func^9>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 3892 "=="
tf AX "Ctn" "__init__"
$jmp 3890 "t"
jmp 3892
call AX.__init__
mov AX <Func^9>
end "Function" "Func^9"
pop ip
Function <&executer_33+3> 3897 None "generator^10" 1
name <&executer_33+3> "<class '__main__.generator'>"
jmp 4450
tf $Inheritance "equ" None
$jmp 3902 "t"
mov <generator^10> $Inheritance
push 1
jmp 3904
mov <generator^10> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <generator^10> <&executer_33+3>
Function BX 3912 <generator^10> "__init___3912" 6
mov <generator^10>.__init__ BX
jmp 4024           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3920 "!="
tf <esp+2> "in" "ram"
$jmp 3922 "t"
mov <esp+2>["ram"] None
jmp 3922
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3928 "!="
tf <esp+2> "in" "start_ip"
$jmp 3930 "t"
mov <esp+2>["start_ip"] None
jmp 3930
mov <esp+2>["start_ip"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3936 "!="
tf <esp+2> "in" "import_funcs"
$jmp 3938 "t"
mov <esp+2>["import_funcs"] None
jmp 3938
mov <esp+2>["import_funcs"] <esp+1>[2]
dec CX
mov <__init___3912+2> <esp+2>["ram"]
mov <__init___3912+3> <esp+2>["start_ip"]
mov <__init___3912+4> <esp+2>["import_funcs"]


push <__init___3912+2>
mov <__init___3912+0>.ram <esp+1>
inc esp
push <__init___3912+3>
mov <__init___3912+0>.next_ip <esp+1>
inc esp
push <__init___3912+4>
mov <__init___3912+0>.import_funcs <esp+1>
inc esp
push [0]
mov <__init___3912+0>.ex_stack <esp+1>
inc esp
push 0
mov <__init___3912+0>.enter <esp+1>
inc esp
push True
mov <__init___3912+0>.next_lock <esp+1>
inc esp
push False
mov <__init___3912+0>.send <esp+1>
inc esp
push None
mov <__init___3912+0>.send_obj <esp+1>
inc esp
push [0]
mov <__init___3912+0>.finally_box <esp+1>
inc esp
Function <__init___3912+5> 3972 None "send_3972" 2 "__init___3912"
jmp 4015           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3980 "!="
tf <esp+2> "in" "value"
$jmp 3982 "t"
mov <esp+2>["value"] None
jmp 3982
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <send_3972+1> <esp+2>["value"]


mov AX <__init___3912+0>.next_lock
$oper AX "not"
cmp AX 1
$jmp 4003 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
mov <__init___3912+0>.send <esp+1>
inc esp
push <send_3972+1>
mov <__init___3912+0>.send_obj <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___3912+0>.__next
jmp 4012
jmp 4003        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "can't send non-None value to a just-started generator"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call TypeError
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "send_3972" "0,1"
pop ip
push [dict]
mov BX "send"
mov <esp+1>[BX] <__init___3912+5>
mov <__init___3912+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___3912" "0,1,2,3,4"
pop ip
Function BX 4027 <generator^10> "__str___4027" 2
mov <generator^10>.__str__ BX
jmp 4036           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<generator_obj>"
jmp 4033         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___4027" "0,1"
pop ip
Function BX 4039 <generator^10> "__getitem___4039" 3
mov <generator^10>.__getitem__ BX
jmp 4062           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4047 "!="
tf <esp+2> "in" "item"
$jmp 4049 "t"
mov <esp+2>["item"] None
jmp 4049
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___4039+2> <esp+2>["item"]


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__getitem___4039+0>.__next
jmp 4059         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___4039" "0,1,2"
pop ip
Function BX 4065 <generator^10> "__next___4065" 2
mov <generator^10>.__next__ BX
jmp 4088           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push False
mov <__next___4065+0>.next_lock <esp+1>
inc esp
cmp <__next___4065+0>.send 1
$jmp 4078 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
mov <__next___4065+0>.send_obj <esp+1>
inc esp
jmp 4078        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__next___4065+0>.__next
jmp 4085         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next___4065" "0,1"
pop ip
Function BX 4091 <generator^10> "__next_4091" 9
mov <generator^10>.__next BX
jmp 4263           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__next_4091+0>.enter
tf DX "equ" 1
$jmp 4100 "f"
mov AX True
jmp 4101
mov AX False
cmp AX 1
$jmp 4106 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX StopIteration
raise AX
jmp 4259        ;¸õ¦Ü©³³¡
push 1
mov <__next_4091+0>.enter <esp+1>
inc esp
mov AX <__next_4091+0>.send
$oper AX "not"
cmp AX 1
$jmp 4132 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next_4091+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.yield_run
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next_4091+0>.next_ip
mov <esp+1>[1] <__next_4091+0>.ex_stack
mov <esp+1>[2] <__next_4091+0>.import_funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__next_4091+2> <esp+1>[0]
mov <__next_4091+0>.ex_stack <esp+1>[1]
mov <__next_4091+3> <esp+1>[2]
mov <__next_4091+4> <esp+1>[3]
inc esp
jmp 4153        ;¸õ¦Ü©³³¡
mov AX <__next_4091+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.yield_run
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next_4091+0>.next_ip
mov <esp+1>[1] <__next_4091+0>.ex_stack
mov <esp+1>[2] <__next_4091+0>.import_funcs
push [dict]
mov BX "send_obj"
mov <esp+1>[BX] <__next_4091+0>.send_obj
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__next_4091+2> <esp+1>[0]
mov <__next_4091+0>.ex_stack <esp+1>[1]
mov <__next_4091+3> <esp+1>[2]
mov <__next_4091+4> <esp+1>[3]
inc esp
mov DX <__next_4091+2>
tf DX "equ" None
$jmp 4158 "t"
mov AX True
jmp 4159
mov AX False
cmp AX 1
$jmp 4257 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__next_4091+2>
mov <__next_4091+0>.next_ip <esp+1>[0]
mov <__next_4091+5> <esp+1>[1]
inc esp
ex_func AX "iter" <__next_4091+5>
push AX
fetch AX <esp+1>
$jmp 4250 "f"
mov <__next_4091+6> AX
push <__next_4091+6>
mov BX 0
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
cmp DX AX
$jmp 4181 "<="
mov AX True
jmp 4182
mov AX False
cmp AX 1
$jmp 4208 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__next_4091+4>
push <__next_4091+6>
mov BX 1
pop AX
oper <esp+1> "-" AX[BX]
mov <__next_4091+7> <esp+1>
inc esp
mov AX <__next_4091+0>.finally_box      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push [2]
push <__next_4091+6>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <__next_4091+7>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4249        ;¸õ¦Ü©³³¡
ex_func AX "iter" <__next_4091+0>.finally_box
push AX
fetch AX <esp+1>
$jmp 4248 "f"
mov <__next_4091+8> AX
push <__next_4091+8>
mov BX 0
pop AX
push AX[BX]
push 1        ;Àx¦sCX
push [1]
push <__next_4091+6>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call abs
pop DX
tf DX "equ" AX
$jmp 4232 "f"
mov AX True
jmp 4233
mov AX False
cmp AX 1
$jmp 4247 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next_4091+0>.finally_box      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.remove
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__next_4091+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4248          ;break¥X°j°é
jmp 4247        ;¸õ¦Ü©³³¡
jmp 4210
inc esp
jmp 4167
inc esp
push 0
mov <__next_4091+0>.enter <esp+1>
inc esp
mov AX <__next_4091+3>
jmp 4260
jmp 4257        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next_4091" "0,1,2,3,4,5,6,7,8"
pop ip
Function BX 4266 <generator^10> "__del___4266" 6
mov <generator^10>.__del__ BX
jmp 4436           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


ex_func AX "iter" <__del___4266+0>.finally_box
push AX
fetch AX <esp+1>
$jmp 4431 "f"
mov <__del___4266+2> AX
push <__del___4266+2>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "+" 1
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push [dict]
mov <__del___4266+3> <esp+1>
inc esp
ex_func AX "iter" <__del___4266+0>.import_funcs
push AX
fetch AX <esp+1>
$jmp 4316 "f"
mov <__del___4266+4> AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
push AX[BX]
push <__del___4266+3>
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__del___4266+0>.import_funcs
mov BX <__del___4266+4>
pop AX
push AX[BX]
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4292
inc esp
push 1        ;Àx¦sCX
push [1]
push <__del___4266+2>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4346 "f"
mov <__del___4266+5> AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
push <__del___4266+0>.ex_stack
mov BX <__del___4266+5>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4329
inc esp
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
finally 4401
try 4381
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.one_run
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "finally yield run"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
try "end"
jmp 4396    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 4395 "f"
mov e $Exception
mov $Exception 0
try 4399
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
try "end"
jmp 4396  ;¸õ¨ìpush 1
jmp 4399 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 4401    ;¸õ¨ìfinally
push None
push 0
finally -4401
push $Exception
mov $Exception 0
ex_func AX "iter" <__del___4266+3>
push AX
fetch AX <esp+1>
$jmp 4420 "f"
mov <__del___4266+4> AX
push <__del___4266+3>
mov BX <__del___4266+4>
pop AX
push AX[BX]
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4406
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 4428 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
jmp 4272
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__del___4266" "0,1,2,3,4,5"
pop ip
mov AX <generator^10>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 4448 "=="
tf AX "Ctn" "__init__"
$jmp 4446 "t"
jmp 4448
call AX.__init__
mov AX <generator^10>
end "Function" "generator^10"
pop ip
Function <&executer_33+4> 4452 None "atype_4452" 2
jmp 4516           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4460 "!="
tf <esp+2> "in" "obj"
$jmp 4462 "t"
mov <esp+2>["obj"] None
jmp 4462
mov <esp+2>["obj"] <esp+1>[0]
dec CX
mov <atype_4452+1> <esp+2>["obj"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4452+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+1>
$jmp 4477 "f"
mov AX True
jmp 4478
mov AX False
cmp AX 1
$jmp 4483 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <atype_4452+1>.atype
jmp 4513         ;returnÂI
jmp 4505        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4452+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+2>
$jmp 4495 "f"
mov AX True
jmp 4496
mov AX False
cmp AX 1
$jmp 4505 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<class \'__main__."
ex_func AX "str" <atype_4452+1>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "\'>"
pop AX
jmp 4513         ;returnÂI
jmp 4505        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4452+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
jmp 4513         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "atype_4452" "0,1"
pop ip
push [66]
mov <esp+1>[0] abs
mov <esp+1>[1] all
mov <esp+1>[2] any
mov <esp+1>[3] ascii
mov <esp+1>[4] bin
mov <esp+1>[5] bool
mov <esp+1>[6] breakpoint
mov <esp+1>[7] bytearray
mov <esp+1>[8] bytes
mov <esp+1>[9] callable
mov <esp+1>[10] chr
mov <esp+1>[11] classmethod
mov <esp+1>[12] compile
mov <esp+1>[13] complex
mov <esp+1>[14] delattr
mov <esp+1>[15] dict
mov <esp+1>[16] dir
mov <esp+1>[17] divmod
mov <esp+1>[18] enumerate
mov <esp+1>[19] eval
mov <esp+1>[20] exec
mov <esp+1>[21] filter
mov <esp+1>[22] float
mov <esp+1>[23] format
mov <esp+1>[24] frozenset
mov <esp+1>[25] getattr
mov <esp+1>[26] globals
mov <esp+1>[27] hasattr
mov <esp+1>[28] hash
mov <esp+1>[29] hex
mov <esp+1>[30] id
mov <esp+1>[31] input
mov <esp+1>[32] int
mov <esp+1>[33] isinstance
mov <esp+1>[34] issubclass
mov <esp+1>[35] iter
mov <esp+1>[36] len
mov <esp+1>[37] list
mov <esp+1>[38] locals
mov <esp+1>[39] map
mov <esp+1>[40] max
mov <esp+1>[41] memoryview
mov <esp+1>[42] min
mov <esp+1>[43] next
mov <esp+1>[44] object
mov <esp+1>[45] oct
mov <esp+1>[46] open
mov <esp+1>[47] ord
mov <esp+1>[48] pow
mov <esp+1>[49] print
mov <esp+1>[50] property
mov <esp+1>[51] range
mov <esp+1>[52] repr
mov <esp+1>[53] reversed
mov <esp+1>[54] round
mov <esp+1>[55] set
mov <esp+1>[56] setattr
mov <esp+1>[57] slice
mov <esp+1>[58] sorted
mov <esp+1>[59] staticmethod
mov <esp+1>[60] str
mov <esp+1>[61] sum
mov <esp+1>[62] super
mov <esp+1>[63] tuple
mov <esp+1>[64] vars
mov <esp+1>[65] zip
mov <&executer_33+5> <esp+1>
inc esp
push [14]
mov <esp+1>[0] NameError
mov <esp+1>[1] IndexError
mov <esp+1>[2] TypeError
mov <esp+1>[3] SyntaxError
mov <esp+1>[4] ValueError
mov <esp+1>[5] KeyboardInterrupt
mov <esp+1>[6] AssertionError
mov <esp+1>[7] Exception
mov <esp+1>[8] RecursionError
mov <esp+1>[9] KeyError
mov <esp+1>[10] ZeroDivisionError
mov <esp+1>[11] AttributeError
mov <esp+1>[12] IndentationError
mov <esp+1>[13] UnboundLocalError
mov <&executer_33+6> <esp+1>
inc esp
push [5]
mov <esp+1>[0] StopIteration
mov <esp+1>[1] StopAsyncIteration
mov <esp+1>[2] SyntaxWarning
mov <esp+1>[3] FileNotFoundError
mov <esp+1>[4] ModuleNotFoundError
mov <&executer_33+7> <esp+1>
inc esp
push [dict]
mov BX "help"
mov <esp+1>[BX] help
mov BX "IOError"
mov <esp+1>[BX] IOError
mov BX "type"
mov <esp+1>[BX] <&executer_33+4>
mov <&executer_33+8> <esp+1>
inc esp
push <&executer_33+5>
oper <esp+1> "+" <&executer_33+6>
oper <esp+1> "+" <&executer_33+7>
pop AX
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4635 "f"
mov <&executer_33+9> AX
push <&executer_33+9>
push <&executer_33+8>
mov BX <&executer_33+9>.__name__
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4625
inc esp
Function <&executer_33+10> 4639 None "Executer^11" 1
name <&executer_33+10> "<class '__main__.Executer'>"
jmp 10719
tf $Inheritance "equ" None
$jmp 4644 "t"
mov <Executer^11> $Inheritance
push 1
jmp 4646
mov <Executer^11> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Executer^11> <&executer_33+10>
Function BX 4654 <Executer^11> "__init___4654" 3
mov <Executer^11>.__init__ BX
jmp 4689           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4662 "!="
tf <esp+2> "in" "code"
$jmp 4664 "t"
mov <esp+2>["code"] None
jmp 4664
mov <esp+2>["code"] <esp+1>[0]
dec CX
mov <__init___4654+2> <esp+2>["code"]


push <__init___4654+2>
mov <__init___4654+0>.code <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+8>.copy
push AX
mov <__init___4654+0>.ex_function <esp+1>
inc esp
push [0]
mov <__init___4654+0>.run_layer <esp+1>
inc esp
push [dict]
mov <__init___4654+0>.func_stack <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___4654" "0,1,2"
pop ip
Function BX 4692 <Executer^11> "set_4692" 5
mov <Executer^11>.set BX
jmp 4730           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4700 "!="
tf <esp+2> "in" "var_name"
$jmp 4702 "t"
mov <esp+2>["var_name"] None
jmp 4702
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 4708 "!="
tf <esp+2> "in" "value"
$jmp 4710 "t"
mov <esp+2>["value"] None
jmp 4710
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <set_4692+2> <esp+2>["var_name"]
mov <set_4692+3> <esp+2>["value"]


push <set_4692+0>.data_dict
mov BX <set_4692+2>
pop AX
push AX[BX]
mov <set_4692+4> <esp+1>
inc esp
push <set_4692+3>
push <set_4692+0>.data
mov BX <set_4692+4>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "set_4692" "0,1,2,3,4"
pop ip
Function BX 4733 <Executer^11> "push_4733" 3
mov <Executer^11>.push BX
jmp 4765           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4741 "!="
tf <esp+2> "in" "value"
$jmp 4743 "t"
mov <esp+2>["value"] None
jmp 4743
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <push_4733+2> <esp+2>["value"]


push <push_4733+2>
push <push_4733+0>.data
push <push_4733+0>.data
mov BX 5
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <push_4733+0>.data
mov BX 5
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "push_4733" "0,1,2"
pop ip
Function BX 4768 <Executer^11> "pop_4768" 2
mov <Executer^11>.pop BX
jmp 4789           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1
push <pop_4768+0>.data
mov BX 5
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <pop_4768+0>.data
push <pop_4768+0>.data
mov BX 5
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 4786         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "pop_4768" "0,1"
pop ip
Function BX 4792 <Executer^11> "login_4792" 3
mov <Executer^11>.login BX
jmp 4831           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4800 "!="
tf <esp+2> "in" "var_name"
$jmp 4802 "t"
mov <esp+2>["var_name"] None
jmp 4802
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
mov <login_4792+2> <esp+2>["var_name"]


tf <login_4792+0>.var_dict "in" <login_4792+2>
mov AX TF
cmp AX 1
$jmp 4815 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <login_4792+0>.var_dict
mov BX <login_4792+2>
pop AX
mov AX AX[BX]
jmp 4828         ;returnÂI
jmp 4815        ;¸õ¦Ü©³³¡
push <login_4792+0>.used_size
push <login_4792+0>.var_dict
mov BX <login_4792+2>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <login_4792+0>.used_size "+" <esp+1>
inc esp
push <login_4792+0>.used_size
oper <esp+1> "-" 1
pop AX
jmp 4828         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "login_4792" "0,1,2"
pop ip
Function BX 4834 <Executer^11> "get_var_location_4834" 3
mov <Executer^11>.get_var_location BX
jmp 4855           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4842 "!="
tf <esp+2> "in" "var_name"
$jmp 4844 "t"
mov <esp+2>["var_name"] None
jmp 4844
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
mov <get_var_location_4834+2> <esp+2>["var_name"]


push <get_var_location_4834+0>.var_dict
mov BX <get_var_location_4834+2>
pop AX
mov AX AX[BX]
jmp 4852         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_var_location_4834" "0,1,2"
pop ip
Function BX 4858 <Executer^11> "pushaw_4858" 3
mov <Executer^11>.pushaw BX
jmp 4898           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 5
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4893 "f"
mov <pushaw_4858+2> AX
push <pushaw_4858+0>.data
mov BX <pushaw_4858+2>
pop AX
push AX[BX]
push <pushaw_4858+0>.data
push <pushaw_4858+0>.data
mov BX <pushaw_4858+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <pushaw_4858+0>.data
mov BX <pushaw_4858+0>.$$esp
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 4871
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "pushaw_4858" "0,1,2"
pop ip
Function BX 4901 <Executer^11> "popaw_4901" 3
mov <Executer^11>.popaw BX
jmp 4943           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 5
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4938 "f"
mov <popaw_4901+2> AX
push 1
push <popaw_4901+0>.data
mov BX <popaw_4901+0>.$$esp
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <popaw_4901+0>.data
push <popaw_4901+0>.data
mov BX <popaw_4901+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <popaw_4901+0>.data
push 4
oper <esp+1> "-" <popaw_4901+2>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4914
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "popaw_4901" "0,1,2"
pop ip
Function BX 4946 <Executer^11> "__setitem___4946" 4
mov <Executer^11>.__setitem__ BX
jmp 5251           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4954 "!="
tf <esp+2> "in" "location"
$jmp 4956 "t"
mov <esp+2>["location"] None
jmp 4956
mov <esp+2>["location"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 4962 "!="
tf <esp+2> "in" "value"
$jmp 4964 "t"
mov <esp+2>["value"] None
jmp 4964
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___4946+2> <esp+2>["location"]
mov <__setitem___4946+3> <esp+2>["value"]


push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 4976 "f"
mov AX True
jmp 4977
mov AX False
cmp AX 1
$jmp 4989 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 4997 "f"
mov AX True
jmp 4998
mov AX False
cmp AX 1
$jmp 5017 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___4946+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 5025 "f"
mov AX True
jmp 5026
mov AX False
cmp AX 1
$jmp 5047 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 5055 "f"
mov AX True
jmp 5056
mov AX False
cmp AX 1
$jmp 5076 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 5084 "f"
mov AX True
jmp 5085
mov AX False
cmp AX 1
$jmp 5112 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___4946+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 5120 "f"
mov AX True
jmp 5121
mov AX False
cmp AX 1
$jmp 5150 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.data
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 5158 "f"
mov AX True
jmp 5159
mov AX False
cmp AX 1
$jmp 5177 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.func_stack
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 5185 "f"
mov AX True
jmp 5186
mov AX False
cmp AX 1
$jmp 5211 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.func_stack
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___4946+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
push <__setitem___4946+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 5219 "f"
mov AX True
jmp 5220
mov AX False
cmp AX 1
$jmp 5247 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___4946+3>
push <__setitem___4946+0>.func_stack
push <__setitem___4946+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___4946+0>.data
push <__setitem___4946+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5247        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___4946" "0,1,2,3"
pop ip
Function BX 5254 <Executer^11> "call_obj_function_5254" 9
mov <Executer^11>.call_obj_function BX
jmp 5397           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5262 "!="
tf <esp+2> "in" "obj"
$jmp 5264 "t"
mov <esp+2>["obj"] None
jmp 5264
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5270 "!="
tf <esp+2> "in" "args"
$jmp 5272 "t"
mov <esp+2>["args"] None
jmp 5272
mov <esp+2>["args"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5278 "!="
tf <esp+2> "in" "funcname"
$jmp 5280 "t"
mov <esp+2>["funcname"] None
jmp 5280
mov <esp+2>["funcname"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5286 "!="
tf <esp+2> "in" "kwargs"
$jmp 5288 "t"
mov <esp+2>["kwargs"] None
jmp 5288
mov <esp+2>["kwargs"] <esp+1>[3]
dec CX
mov <call_obj_function_5254+2> <esp+2>["obj"]
mov <call_obj_function_5254+3> <esp+2>["args"]
mov <call_obj_function_5254+4> <esp+2>["funcname"]
mov <call_obj_function_5254+5> <esp+2>["kwargs"]


push <call_obj_function_5254+0>.data
mov BX <call_obj_function_5254+0>.$$esp
pop AX
push AX[BX]
mov <call_obj_function_5254+6> <esp+1>
inc esp
mov DX <call_obj_function_5254+5>
tf DX "equ" None
$jmp 5305 "f"
mov AX True
jmp 5306
mov AX False
cmp AX 1
$jmp 5312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
mov <call_obj_function_5254+5> <esp+1>
inc esp
jmp 5312        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5254+0>.pushaw
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <call_obj_function_5254+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
push <call_obj_function_5254+0>.data
mov BX 2
pop AX
mov AX[BX] <esp+1>
inc esp
push <call_obj_function_5254+2>.vars
mov BX <call_obj_function_5254+4>
pop AX
push AX[BX]
mov <call_obj_function_5254+7> <esp+1>
inc esp
push None
mov <call_obj_function_5254+8> <esp+1>
inc esp
finally 5368
try 5362
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <call_obj_function_5254+3>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <call_obj_function_5254+5>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5254+7>
push AX
mov <call_obj_function_5254+8> <esp+1>
inc esp
try "end"
jmp 5363    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5366 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5368    ;¸õ¨ìfinally
push None
push 0
finally -5368
push $Exception
mov $Exception 0
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5254+0>.popaw
push <call_obj_function_5254+6>
push <call_obj_function_5254+0>.data
mov BX <call_obj_function_5254+0>.$$esp
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5390 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX <call_obj_function_5254+8>
jmp 5394         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "call_obj_function_5254" "0,1,2,3,4,5,6,7,8"
pop ip
Function BX 5400 <Executer^11> "yield_run_5400" 16
mov <Executer^11>.yield_run BX
jmp 5630           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5408 "!="
tf <esp+2> "in" "$$ip"
$jmp 5410 "t"
mov <esp+2>["$$ip"] None
jmp 5410
mov <esp+2>["$$ip"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5416 "!="
tf <esp+2> "in" "ex_stack"
$jmp 5418 "t"
mov <esp+2>["ex_stack"] None
jmp 5418
mov <esp+2>["ex_stack"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5424 "!="
tf <esp+2> "in" "import_funcs"
$jmp 5426 "t"
mov <esp+2>["import_funcs"] None
jmp 5426
mov <esp+2>["import_funcs"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5432 "!="
tf <esp+2> "in" "send_obj"
$jmp 5434 "t"
mov <esp+2>["send_obj"] None
jmp 5434
mov <esp+2>["send_obj"] <esp+1>[3]
dec CX
mov <yield_run_5400+2> <esp+2>["$$ip"]
mov <yield_run_5400+3> <esp+2>["ex_stack"]
mov <yield_run_5400+4> <esp+2>["import_funcs"]
mov <yield_run_5400+5> <esp+2>["send_obj"]


push <yield_run_5400+0>.data
mov BX <yield_run_5400+0>.$$ip
pop AX
push AX[BX]
mov <yield_run_5400+6> <esp+1>
inc esp
push <yield_run_5400+2>
push <yield_run_5400+0>.data
mov BX <yield_run_5400+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push [dict]
mov <yield_run_5400+7> <esp+1>
inc esp
ex_func AX "iter" <yield_run_5400+4>
push AX
fetch AX <esp+1>
$jmp 5479 "f"
mov <yield_run_5400+8> AX
push <yield_run_5400+0>.func_stack
mov BX <yield_run_5400+8>
pop AX
push AX[BX]
push <yield_run_5400+7>
mov BX <yield_run_5400+8>
pop AX
mov AX[BX] <esp+1>
inc esp
push <yield_run_5400+4>
mov BX <yield_run_5400+8>
pop AX
push AX[BX]
push <yield_run_5400+0>.func_stack
mov BX <yield_run_5400+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5457
inc esp
push <yield_run_5400+0>.data
mov BX <yield_run_5400+0>.$$esp
pop AX
push AX[BX]
mov <yield_run_5400+9> <esp+1>
inc esp
ex_func AX "iter" <yield_run_5400+3>
push AX
fetch AX <esp+1>
$jmp 5499 "f"
mov <yield_run_5400+10> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <yield_run_5400+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5400+0>.push
jmp 5488
inc esp
push None
mov <yield_run_5400+11> <esp+1>
inc esp
push False
mov <yield_run_5400+12> <esp+1>
inc esp
finally 5535
try 5529
push <yield_run_5400+5>
push <yield_run_5400+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "yield run"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5400+0>.__run
push AX
mov <yield_run_5400+13> <esp+1>
inc esp
push True
mov <yield_run_5400+12> <esp+1>
inc esp
try "end"
jmp 5530    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5533 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5535    ;¸õ¨ìfinally
push None
push 0
finally -5535
push $Exception
mov $Exception 0
push <yield_run_5400+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
cmp <yield_run_5400+12> 1
$jmp 5553 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <yield_run_5400+0>.data
mov BX 0
pop AX
push AX[BX]
mov <yield_run_5400+11> <esp+1>
inc esp
jmp 5553        ;¸õ¦Ü©³³¡
push [0]
mov <yield_run_5400+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <yield_run_5400+9>
push <yield_run_5400+0>.data
mov BX <yield_run_5400+0>.$$esp
pop AX
oper <esp+1> "-" AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 5588 "f"
mov <yield_run_5400+15> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] 0
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5400+0>.pop
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5400+14>.insert
jmp 5570
inc esp
ex_func AX "iter" <yield_run_5400+7>
push AX
fetch AX <esp+1>
$jmp 5604 "f"
mov <yield_run_5400+8> AX
push <yield_run_5400+7>
mov BX <yield_run_5400+8>
pop AX
push AX[BX]
push <yield_run_5400+0>.func_stack
mov BX <yield_run_5400+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5591
inc esp
push <yield_run_5400+6>
push <yield_run_5400+0>.data
mov BX <yield_run_5400+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5618 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push (4)
mov <esp+1>[0] <yield_run_5400+13>
mov <esp+1>[1] <yield_run_5400+14>
mov <esp+1>[2] <yield_run_5400+11>
mov <esp+1>[3] <yield_run_5400+9>
pop AX
jmp 5627         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "yield_run_5400" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
pop ip
Function BX 5633 <Executer^11> "func_run_5633" 14
mov <Executer^11>.func_run BX
jmp 5865           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5641 "!="
tf <esp+2> "in" "$$ip"
$jmp 5643 "t"
mov <esp+2>["$$ip"] None
jmp 5643
mov <esp+2>["$$ip"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5649 "!="
tf <esp+2> "in" "class_obj"
$jmp 5651 "t"
mov <esp+2>["class_obj"] None
jmp 5651
mov <esp+2>["class_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5657 "!="
tf <esp+2> "in" "stack_name"
$jmp 5659 "t"
mov <esp+2>["stack_name"] None
jmp 5659
mov <esp+2>["stack_name"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5665 "!="
tf <esp+2> "in" "stack_len"
$jmp 5667 "t"
mov <esp+2>["stack_len"] None
jmp 5667
mov <esp+2>["stack_len"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 5673 "!="
tf <esp+2> "in" "import_funcs"
$jmp 5675 "t"
mov <esp+2>["import_funcs"] None
jmp 5675
mov <esp+2>["import_funcs"] <esp+1>[4]
dec CX
mov <func_run_5633+2> <esp+2>["$$ip"]
mov <func_run_5633+3> <esp+2>["class_obj"]
mov <func_run_5633+4> <esp+2>["stack_name"]
mov <func_run_5633+5> <esp+2>["stack_len"]
mov <func_run_5633+6> <esp+2>["import_funcs"]


push <func_run_5633+0>.data
mov BX <func_run_5633+0>.$$ip
pop AX
push AX[BX]
mov <func_run_5633+7> <esp+1>
inc esp
push <func_run_5633+0>.data
mov BX <func_run_5633+0>.$$esp
pop AX
push AX[BX]
mov <func_run_5633+8> <esp+1>
inc esp
push [dict]
mov <func_run_5633+9> <esp+1>
inc esp
ex_func AX "iter" <func_run_5633+6>
push AX
fetch AX <esp+1>
$jmp 5721 "f"
mov <func_run_5633+10> AX
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+10>
pop AX
push AX[BX]
push <func_run_5633+9>
mov BX <func_run_5633+10>
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5633+6>
mov BX <func_run_5633+10>
pop AX
push AX[BX]
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5699
inc esp
tf <func_run_5633+0>.func_stack "in" <func_run_5633+4>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 5734 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5734        ;¸õ¦Ü©³³¡
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+4>
pop AX
push AX[BX]
mov <func_run_5633+11> <esp+1>
inc esp
push [1]
mov <esp+1>[0] 0
oper <esp+1> "*" <func_run_5633+5>
mov <func_run_5633+12> <esp+1>
inc esp
push <func_run_5633+3>
push <func_run_5633+12>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5633+12>
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5633+2>
oper <esp+1> "+" 1
push <func_run_5633+0>.data
mov BX <func_run_5633+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <func_run_5633+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <func_run_5633+0>.push
push None
mov <func_run_5633+13> <esp+1>
inc esp
finally 5802
try 5796
push 1        ;Àx¦sCX
push [1]
push "Func<"
ex_func AX "str" <func_run_5633+2>
oper <esp+1> "+" AX
oper <esp+1> "+" "> run"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <func_run_5633+0>.__run
try "end"
jmp 5797    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5800 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5802    ;¸õ¨ìfinally
push None
push 0
finally -5802
push $Exception
mov $Exception 0
push <func_run_5633+0>.data
mov BX 0
pop AX
push AX[BX]
mov <func_run_5633+13> <esp+1>
inc esp
push <func_run_5633+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <func_run_5633+7>
push <func_run_5633+0>.data
mov BX <func_run_5633+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5633+11>
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <func_run_5633+6>
push AX
fetch AX <esp+1>
$jmp 5844 "f"
mov <func_run_5633+10> AX
push <func_run_5633+9>
mov BX <func_run_5633+10>
pop AX
push AX[BX]
push <func_run_5633+0>.func_stack
mov BX <func_run_5633+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5831
inc esp
push <func_run_5633+8>
push <func_run_5633+0>.data
mov BX <func_run_5633+0>.$$esp
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5858 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX <func_run_5633+13>
jmp 5862         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "func_run_5633" "0,1,2,3,4,5,6,7,8,9,10,11,12,13"
pop ip
Function BX 5868 <Executer^11> "__getitem___5868" 5
mov <Executer^11>.__getitem__ BX
jmp 6583           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5876 "!="
tf <esp+2> "in" "location"
$jmp 5878 "t"
mov <esp+2>["location"] None
jmp 5878
mov <esp+2>["location"] <esp+1>[0]
dec CX
mov <__getitem___5868+2> <esp+2>["location"]


push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 5889 "f"
mov AX True
jmp 5890
mov AX False
cmp AX 1
$jmp 5901 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 5909 "f"
mov AX True
jmp 5910
mov AX False
cmp AX 1
$jmp 6044 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__getitem___5868+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+12>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 5957 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+2>
mov BX 2
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 5954 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 5954        ;¸õ¦Ü©³³¡
mov AX <__getitem___5868+0>.undefined
jmp 6580
jmp 6043        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 5969 "f"
mov AX True
jmp 5970
mov AX False
cmp AX 1
$jmp 5991 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push ""
push <__getitem___5868+0>.inverse_data_dict
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " is undefined"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6043        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+11>
$jmp 6003 "f"
mov AX True
jmp 6004
mov AX False
cmp AX 1
$jmp 6015 "!="
push <__getitem___5868+2>
mov BX 2
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6015 "!="
mov AX 1
jmp 6016
mov AX 0
cmp AX 1
$jmp 6027 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6043        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5868+3>
push <__getitem___5868+2>
mov BX 2
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+15>
push AX
mov <__getitem___5868+4> <esp+1>
inc esp
mov AX <__getitem___5868+4>
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 6052 "f"
mov AX True
jmp 6053
mov AX False
cmp AX 1
$jmp 6073 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 6081 "f"
mov AX True
jmp 6082
mov AX False
cmp AX 1
$jmp 6101 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 6109 "f"
mov AX True
jmp 6110
mov AX False
cmp AX 1
$jmp 6252 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
mov <__getitem___5868+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+12>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 6165 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+2>
mov BX 3
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6162 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6162        ;¸õ¦Ü©³³¡
mov AX <__getitem___5868+0>.undefined
jmp 6580
jmp 6251        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 6177 "f"
mov AX True
jmp 6178
mov AX False
cmp AX 1
$jmp 6199 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push ""
push <__getitem___5868+0>.inverse_data_dict
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " is undefined"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6251        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+11>
$jmp 6211 "f"
mov AX True
jmp 6212
mov AX False
cmp AX 1
$jmp 6223 "!="
push <__getitem___5868+2>
mov BX 3
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6223 "!="
mov AX 1
jmp 6224
mov AX 0
cmp AX 1
$jmp 6235 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6251        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5868+3>
push <__getitem___5868+2>
mov BX 3
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+15>
push AX
mov <__getitem___5868+4> <esp+1>
inc esp
mov AX <__getitem___5868+4>
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 6260 "f"
mov AX True
jmp 6261
mov AX False
cmp AX 1
$jmp 6289 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.data
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 6297 "f"
mov AX True
jmp 6298
mov AX False
cmp AX 1
$jmp 6315 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.func_stack
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 6323 "f"
mov AX True
jmp 6324
mov AX False
cmp AX 1
$jmp 6454 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.func_stack
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__getitem___5868+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+12>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 6377 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+2>
mov BX 3
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6374 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6374        ;¸õ¦Ü©³³¡
mov AX <__getitem___5868+0>.undefined
jmp 6580
jmp 6453        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 6389 "f"
mov AX True
jmp 6390
mov AX False
cmp AX 1
$jmp 6401 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "this variable is undefined"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6453        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+11>
$jmp 6413 "f"
mov AX True
jmp 6414
mov AX False
cmp AX 1
$jmp 6425 "!="
push <__getitem___5868+2>
mov BX 3
pop AX
tf <__getitem___5868+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6425 "!="
mov AX 1
jmp 6426
mov AX 0
cmp AX 1
$jmp 6437 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+3>.vars
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6453        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5868+3>
push <__getitem___5868+2>
mov BX 3
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+15>
push AX
mov <__getitem___5868+4> <esp+1>
inc esp
mov AX <__getitem___5868+4>
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 6462 "f"
mov AX True
jmp 6463
mov AX False
cmp AX 1
$jmp 6489 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5868+0>.func_stack
push <__getitem___5868+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5868+0>.data
push <__getitem___5868+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 10
$jmp 6497 "f"
mov AX True
jmp 6498
mov AX False
cmp AX 1
$jmp 6509 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
mov <esp+1>[0] 0
push <__getitem___5868+2>
mov BX 1
pop AX
oper <esp+1> "*" AX[BX]
pop AX
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 11
$jmp 6517 "f"
mov AX True
jmp 6518
mov AX False
cmp AX 1
$jmp 6523 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX [dict]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 12
$jmp 6531 "f"
mov AX True
jmp 6532
mov AX False
cmp AX 1
$jmp 6543 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
mov <esp+1>[0] 0
push <__getitem___5868+2>
mov BX 1
pop AX
oper <esp+1> "*" AX[BX]
pop AX
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
push <__getitem___5868+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 13
$jmp 6551 "f"
mov AX True
jmp 6552
mov AX False
cmp AX 1
$jmp 6579 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__getitem___5868+0>.class_objs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5868+0>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+1>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <__getitem___5868+0>.class_objs
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]
jmp 6580
jmp 6579        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___5868" "0,1,2,3,4"
pop ip
Function BX 6586 <Executer^11> "__error_print_6586" 5
mov <Executer^11>.__error_print BX
jmp 6626           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6594 "!="
tf <esp+2> "in" "msg"
$jmp 6596 "t"
mov <esp+2>["msg"] None
jmp 6596
mov <esp+2>["msg"] <esp+1>[0]
dec CX
mov <__error_print_6586+2> <esp+2>["msg"]


push "[91m"
mov <__error_print_6586+3> <esp+1>
inc esp
push "[0m"
mov <__error_print_6586+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__error_print_6586+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__error_print_6586+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__error_print_6586+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__error_print_6586" "0,1,2,3,4"
pop ip
Function BX 6629 <Executer^11> "__ok_print_6629" 5
mov <Executer^11>.__ok_print BX
jmp 6669           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6637 "!="
tf <esp+2> "in" "msg"
$jmp 6639 "t"
mov <esp+2>["msg"] None
jmp 6639
mov <esp+2>["msg"] <esp+1>[0]
dec CX
mov <__ok_print_6629+2> <esp+2>["msg"]


push "[92m"
mov <__ok_print_6629+3> <esp+1>
inc esp
push "[0m"
mov <__ok_print_6629+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__ok_print_6629+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__ok_print_6629+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__ok_print_6629+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__ok_print_6629" "0,1,2,3,4"
pop ip
Function BX 6672 <Executer^11> "one_run_6672" 3
mov <Executer^11>.one_run BX
jmp 6696           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6680 "!="
tf <esp+2> "in" "comment"
$jmp 6682 "t"
mov <esp+2>["comment"] None
jmp 6682
mov <esp+2>["comment"] <esp+1>[0]
dec CX
mov <one_run_6672+2> <esp+2>["comment"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <one_run_6672+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <one_run_6672+0>.__run
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "one_run_6672" "0,1,2"
pop ip
Function BX 6699 <Executer^11> "run_6699" 10
mov <Executer^11>.run BX
jmp 7154           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6707 "!="
tf <esp+2> "in" "tf"
$jmp 6709 "t"
mov <esp+2>["tf"] 0
jmp 6709
mov <esp+2>["tf"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 6715 "!="
tf <esp+2> "in" "stack_size"
$jmp 6717 "t"
mov <esp+2>["stack_size"] 10240
jmp 6717
mov <esp+2>["stack_size"] <esp+1>[1]
dec CX
mov <run_6699+2> <esp+2>["tf"]
mov <run_6699+3> <esp+2>["stack_size"]


mov AX <run_6699+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.parse_code
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <run_6699+0>.codes <esp+1>[0]
mov <run_6699+0>.data <esp+1>[1]
mov <run_6699+0>.data_dict <esp+1>[2]
inc esp
push [dict]
mov <run_6699+0>.inverse_data_dict <esp+1>
inc esp
ex_func AX "iter" <run_6699+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 6753 "f"
mov <run_6699+4> AX
push <run_6699+4>
push <run_6699+0>.inverse_data_dict
push <run_6699+0>.data_dict
mov BX <run_6699+4>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 6740
inc esp
push <run_6699+3>
mov <run_6699+0>.stack_size <esp+1>
inc esp
push [1]
mov <esp+1>[0] 0
oper <esp+1> "*" <run_6699+3>
$mov <run_6699+0>.data "+" <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "esp"
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.set
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "ip"
mov <esp+1>[1] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.set
push <run_6699+0>.data_dict
mov BX "esp"
pop AX
push AX[BX]
mov <run_6699+0>.$$esp <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "ip"
pop AX
push AX[BX]
mov <run_6699+0>.$$ip <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "ZR"
pop AX
push AX[BX]
mov <run_6699+0>.$$ZR <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "TF"
pop AX
push AX[BX]
mov <run_6699+0>.$$TF <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "$Exception"
pop AX
push AX[BX]
mov <run_6699+0>.ER <esp+1>
inc esp
push 0
push <run_6699+0>.data
mov BX <run_6699+0>.ER
pop AX
mov AX[BX] <esp+1>
inc esp
push 0
mov <run_6699+0>.error_line <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "*args"
pop AX
push AX[BX]
mov <run_6699+0>.args_location <esp+1>
inc esp
push <run_6699+0>.data_dict
mov BX "**kwargs"
pop AX
push AX[BX]
mov <run_6699+0>.kwargs_location <esp+1>
inc esp
push <run_6699+2>
mov <run_6699+0>.tf <esp+1>
inc esp
push [0]
mov <run_6699+0>.class_objs <esp+1>
inc esp
push [dict]
mov <run_6699+0>.func_stack <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
push AX
mov <run_6699+0>.undefined <esp+1>
inc esp
ex_func AX "iter" <run_6699+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 6872 "f"
mov <run_6699+5> AX
tf <run_6699+0>.ex_function "in" <run_6699+5>
mov AX TF
cmp AX 1
$jmp 6871 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <run_6699+0>.ex_function
mov BX <run_6699+5>
pop AX
push AX[BX]
push <run_6699+0>.data
push <run_6699+0>.data_dict
mov BX <run_6699+5>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 6871        ;¸õ¦Ü©³³¡
jmp 6851
inc esp
finally 7141
try 6929
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "normal"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__run
push <run_6699+0>.data
mov BX <run_6699+0>.$$esp
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 6893 "f"
mov AX True
jmp 6894
mov AX False
cmp AX 1
$jmp 6913 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <run_6699+2>
cmp DX 0
$jmp 6901 "<="
mov AX True
jmp 6902
mov AX False
cmp AX 1
$jmp 6912 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\nµ{¦¡µ²§ô--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__ok_print
jmp 6912        ;¸õ¦Ü©³³¡
jmp 6927        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "µ{¦¡Äµ§i:°ïÅ|¥¼ÁÙ­ì---------->   "
push <run_6699+0>.data
mov BX <run_6699+0>.$$esp
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__error_print
try "end"
jmp 7136    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 7135 "f"
mov e $Exception
mov $Exception 0
try 7139
Function <run_6699+6> 6936 None "fetch_error_6936" 5 "run_6699"
jmp 7006           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6944 "!="
tf <esp+2> "in" "e"
$jmp 6946 "t"
mov <esp+2>["e"] None
jmp 6946
mov <esp+2>["e"] <esp+1>[0]
dec CX
mov <fetch_error_6936+1> <esp+2>["e"]


push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <fetch_error_6936+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <fetch_error_6936+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "'"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <fetch_error_6936+2>.index
push AX
mov <fetch_error_6936+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "'"
push <fetch_error_6936+3>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <fetch_error_6936+2>.index
push AX
mov <fetch_error_6936+4> <esp+1>
inc esp
push <fetch_error_6936+2>
push [3]
push <fetch_error_6936+3>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <fetch_error_6936+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov AX AX[BX]
jmp 7003         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "fetch_error_6936" "0,1,2,3,4"
pop ip
push <run_6699+0>.data
mov BX <run_6699+0>.ER
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 7014 "f"
mov AX True
jmp 7015
mov AX False
cmp AX 1
$jmp 7024 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <run_6699+0>.data
mov BX <run_6699+0>.$$ip
pop AX
push AX[BX]
mov <run_6699+7> <esp+1>
inc esp
jmp 7027        ;¸õ¦Ü©³³¡
push <run_6699+0>.error_line
mov <run_6699+7> <esp+1>
inc esp
mov AX <run_6699+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.get_error_msg
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <run_6699+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <run_6699+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "\nTrackback:\nFILE: "
push <run_6699+8>
mov BX "file"
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" ",  line:"
push 1        ;Àx¦sCX
push [1]
push <run_6699+8>
mov BX "row"
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__error_print
push 1        ;Àx¦sCX
push [1]
push "   "
push <run_6699+8>
mov BX "code"
pop AX
oper <esp+1> "+" AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__error_print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <run_6699+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <run_6699+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 7098 "<="
mov AX True
jmp 7099
mov AX False
cmp AX 1
$jmp 7106 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push ": "
oper <esp+1> "+" <run_6699+9>
mov <run_6699+9> <esp+1>
inc esp
jmp 7106        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+6>
push AX
oper <esp+1> "+" <run_6699+9>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6699+0>.__error_print
mov DX <run_6699+2>
cmp DX 0
$jmp 7127 "<="
mov AX True
jmp 7128
mov AX False
cmp AX 1
$jmp 7133 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX e
raise AX
jmp 7133        ;¸õ¦Ü©³³¡
try "end"
jmp 7136  ;¸õ¨ìpush 1
jmp 7139 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 7141    ;¸õ¨ìfinally
push None
push 0
finally -7141
pop AX
cmp AX 1
$jmp 7148 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "run_6699" "0,1,2,3,4,5,7,8,9"
pop ip
Function BX 7157 <Executer^11> "__run_7157" 54
mov <Executer^11>.__run BX
jmp 10705           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 7165 "!="
tf <esp+2> "in" "run_comment"
$jmp 7167 "t"
mov <esp+2>["run_comment"] None
jmp 7167
mov <esp+2>["run_comment"] <esp+1>[0]
dec CX
mov <__run_7157+2> <esp+2>["run_comment"]


mov AX <__run_7157+0>.run_layer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
Function <__run_7157+3> 7182 None "obj_lock_7182" 3 "__run_7157"
jmp 7209           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 7190 "!="
tf <esp+2> "in" "lock"
$jmp 7192 "t"
mov <esp+2>["lock"] None
jmp 7192
mov <esp+2>["lock"] <esp+1>[0]
dec CX
mov <obj_lock_7182+1> <esp+2>["lock"]


ex_func AX "iter" <__run_7157+0>.class_objs
push AX
fetch AX <esp+1>
$jmp 7204 "f"
mov <obj_lock_7182+2> AX
push <obj_lock_7182+1>
mov <obj_lock_7182+2>.print_lock <esp+1>
inc esp
jmp 7197
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "obj_lock_7182" "0,1,2"
pop ip
Function <__run_7157+4> 7211 None "cpu_state_7211" 8 "__run_7157"
jmp 7486           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "data: "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
ex_func AX "iter" <__run_7157+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 7351 "f"
mov <cpu_state_7211+1> AX
push "\"0123456789-"
oper <esp+1> "+" "'"
push <cpu_state_7211+1>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7255 "!="
push (3)
mov <esp+1>[0] "None"
mov <esp+1>[1] "True"
mov <esp+1>[2] "False"
mov BX <cpu_state_7211+1>
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7255 "!="
mov AX 1
jmp 7256
mov AX 0
cmp AX 1
$jmp 7265 "!="
tf <__run_7157+0>.ex_function "in" <cpu_state_7211+1>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7265 "!="
mov AX 1
jmp 7266
mov AX 0
cmp AX 1
$jmp 7292 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <cpu_state_7211+1>
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
push <__run_7157+0>.data
push <__run_7157+0>.data_dict
mov BX <cpu_state_7211+1>
pop AX
mov BX AX[BX]
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
push [dict]
mov BX "end"
mov <esp+1>[BX] "  "
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7292        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "TF"
mov <esp+1>[1] "**kwargs"
mov BX <cpu_state_7211+1>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 7312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7312        ;¸õ¦Ü©³³¡
mov DX <cpu_state_7211+1>
tf DX "equ" "$Exception"
$jmp 7317 "f"
mov AX True
jmp 7318
mov AX False
cmp AX 1
$jmp 7331 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7331        ;¸õ¦Ü©³³¡
mov DX <cpu_state_7211+1>
tf DX "equ" "$Inheritance"
$jmp 7336 "f"
mov AX True
jmp 7337
mov AX False
cmp AX 1
$jmp 7350 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n¦Û¥ÑÅÜ¼Æ:\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7350        ;¸õ¦Ü©³³¡
jmp 7227
inc esp
push "\n\nstack:["
mov <cpu_state_7211+2> <esp+1>
inc esp
push 7
mov <cpu_state_7211+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 25
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 7426 "f"
mov <cpu_state_7211+4> AX
push <__run_7157+0>.data
mov AX <cpu_state_7211+4>
$oper AX "-"
push AX
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <cpu_state_7211+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <cpu_state_7211+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
oper <esp+1> "+" ","
mov <cpu_state_7211+6> <esp+1>
inc esp
push <cpu_state_7211+4>
oper <esp+1> "+" 1
push 1        ;Àx¦sCX
push [1]
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call abs
pop DX
cmp DX AX
$jmp 7408 ">="
mov AX True
jmp 7409
mov AX False
cmp AX 1
$jmp 7422 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <cpu_state_7211+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
$mov <cpu_state_7211+3> "+" <esp+1>
inc esp
jmp 7422        ;¸õ¦Ü©³³¡
push <cpu_state_7211+6>
$mov <cpu_state_7211+2> "+" <esp+1>
inc esp
jmp 7367
inc esp
push 1        ;Àx¦sCX
push [1]
push <cpu_state_7211+2>
push [3]
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
push " "
oper <esp+1> "*" <cpu_state_7211+3>
oper <esp+1> "+" "^"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
ex_func AX "iter" <__run_7157+0>.func_stack
push AX
fetch AX <esp+1>
$jmp 7481 "f"
mov <cpu_state_7211+7> AX
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <cpu_state_7211+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ": "
push <__run_7157+0>.func_stack
mov BX <cpu_state_7211+7>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7460
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "cpu_state_7211" "0,1,2,3,4,5,6,7"
pop ip
Function <__run_7157+5> 7488 None "get_status_7488" 2 "__run_7157"
jmp 7591           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+3>
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <get_status_7488+1> <esp+1>
inc esp
mov AX <__run_7157+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.display
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_status_7488+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+4>
push 1        ;Àx¦sCX
push [1]
push "run_layer:"
ex_func AX "str" <__run_7157+0>.run_layer
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push <get_status_7488+1>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+0>.codes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 7545 ">="
mov AX True
jmp 7546
mov AX False
cmp AX 1
$jmp 7573 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] "\n·Ç³Æ°õ¦æ:"
mov AX <__run_7157+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov BX <get_status_7488+1>
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] "                  ¹ïÀ³:"
push <__run_7157+0>.codes
mov BX <get_status_7488+1>
pop AX
mov <esp+1>[3] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "-------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7580        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "µ{§Ç¤wµ²§ô\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+3>
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_status_7488" "0,1"
pop ip
push <__run_7157+0>.$$ip
mov <__run_7157+6> <esp+1>
inc esp
push <__run_7157+0>.$$esp
mov <__run_7157+7> <esp+1>
inc esp
push <__run_7157+0>.$$ZR
mov <__run_7157+8> <esp+1>
inc esp
push <__run_7157+0>.$$TF
mov <__run_7157+9> <esp+1>
inc esp
push <__run_7157+0>.ER
mov <__run_7157+10> <esp+1>
inc esp
push <__run_7157+0>.args_location
mov <__run_7157+11> <esp+1>
inc esp
push <__run_7157+0>.kwargs_location
mov <__run_7157+12> <esp+1>
inc esp
push [0]
mov <__run_7157+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+0>.codes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <__run_7157+14> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov DX AX[BX]
cmp DX <__run_7157+14>
$jmp 7633 ">="
mov AX True
jmp 7634
mov AX False
cmp AX 1
$jmp 10686 "!="
push <__run_7157+0>.codes
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+15> <esp+1>
inc esp
mov DX <__run_7157+0>.tf
tf DX "equ" 1
$jmp 7650 "f"
mov AX True
jmp 7651
mov AX False
cmp AX 1
$jmp 7726 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+5>
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call input
push AX
mov <__run_7157+16> <esp+1>
inc esp
mov DX <__run_7157+16>
tf DX "equ" ""
$jmp 7673 "t"
mov AX True
jmp 7674
mov AX False
cmp AX 1
$jmp 7725 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 7688 ">="
mov AX True
jmp 7689
mov AX False
cmp AX 1
$jmp 7695 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0.5
mov <__run_7157+0>.tf <esp+1>
inc esp
jmp 7724        ;¸õ¦Ü©³³¡
mov DX <__run_7157+16>
tf DX "equ" "asd"
$jmp 7700 "f"
mov AX True
jmp 7701
mov AX False
cmp AX 1
$jmp 7714 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "°»¿ù!!--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 0.1
mov <__run_7157+0>.tf <esp+1>
inc esp
jmp 7724        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "µ{¦¡¶}©l--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+0>.__ok_print
push 0
mov <__run_7157+0>.tf <esp+1>
inc esp
jmp 7725        ;¸õ¦Ü©³³¡
jmp 7726        ;¸õ¦Ü©³³¡
mov DX <__run_7157+0>.tf
tf DX "equ" 0.1
$jmp 7731 "f"
mov AX True
jmp 7732
mov AX False
cmp AX 1
$jmp 7770 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <__run_7157+17> <esp+1>
inc esp
push " "
oper <esp+1> "*" 60
mov AX <__run_7157+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.comments
mov BX <__run_7157+17>
pop AX
oper <esp+1> "+" AX[BX]
push "\r       "
mov AX <__run_7157+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov BX <__run_7157+17>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\r"
ex_func AX "str" <__run_7157+17>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
oper <esp+1> "+" AX
mov <__run_7157+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7770        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 7778 "f"
mov AX True
jmp 7779
mov AX False
cmp AX 1
$jmp 7797 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 7805 "f"
mov AX True
jmp 7806
mov AX False
cmp AX 1
$jmp 8106 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+19> <esp+1>
inc esp
mov DX <__run_7157+19>
tf DX "equ" 0
$jmp 7822 "f"
mov AX True
jmp 7823
mov AX False
cmp AX 1
$jmp 7841 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 1
$jmp 7846 "f"
mov AX True
jmp 7847
mov AX False
cmp AX 1
$jmp 7865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 2
$jmp 7870 "f"
mov AX True
jmp 7871
mov AX False
cmp AX 1
$jmp 7889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "*" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 3
$jmp 7894 "f"
mov AX True
jmp 7895
mov AX False
cmp AX 1
$jmp 7913 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "/" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 4
$jmp 7918 "f"
mov AX True
jmp 7919
mov AX False
cmp AX 1
$jmp 7937 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "**" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 5
$jmp 7942 "f"
mov AX True
jmp 7943
mov AX False
cmp AX 1
$jmp 7961 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "%" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 6
$jmp 7966 "f"
mov AX True
jmp 7967
mov AX False
cmp AX 1
$jmp 7985 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "//" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 7
$jmp 7990 "f"
mov AX True
jmp 7991
mov AX False
cmp AX 1
$jmp 8009 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "<<" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 8
$jmp 8014 "f"
mov AX True
jmp 8015
mov AX False
cmp AX 1
$jmp 8033 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] ">>" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 9
$jmp 8038 "f"
mov AX True
jmp 8039
mov AX False
cmp AX 1
$jmp 8057 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "&" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 10
$jmp 8062 "f"
mov AX True
jmp 8063
mov AX False
cmp AX 1
$jmp 8081 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "^" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 11
$jmp 8086 "f"
mov AX True
jmp 8087
mov AX False
cmp AX 1
$jmp 8105 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "|" <esp+1>
inc esp
jmp 8105        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 8114 "f"
mov AX True
jmp 8115
mov AX False
cmp AX 1
$jmp 8499 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+19> <esp+1>
inc esp
mov DX <__run_7157+19>
tf DX "equ" 0
$jmp 8131 "f"
mov AX True
jmp 8132
mov AX False
cmp AX 1
$jmp 8157 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "+" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 1
$jmp 8162 "f"
mov AX True
jmp 8163
mov AX False
cmp AX 1
$jmp 8188 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "-" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 2
$jmp 8193 "f"
mov AX True
jmp 8194
mov AX False
cmp AX 1
$jmp 8219 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "*" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 3
$jmp 8224 "f"
mov AX True
jmp 8225
mov AX False
cmp AX 1
$jmp 8250 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "/" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 4
$jmp 8255 "f"
mov AX True
jmp 8256
mov AX False
cmp AX 1
$jmp 8281 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "**" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 5
$jmp 8286 "f"
mov AX True
jmp 8287
mov AX False
cmp AX 1
$jmp 8312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "%" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 6
$jmp 8317 "f"
mov AX True
jmp 8318
mov AX False
cmp AX 1
$jmp 8343 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "//" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 7
$jmp 8348 "f"
mov AX True
jmp 8349
mov AX False
cmp AX 1
$jmp 8374 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "<<" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 8
$jmp 8379 "f"
mov AX True
jmp 8380
mov AX False
cmp AX 1
$jmp 8405 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> ">>" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 9
$jmp 8410 "f"
mov AX True
jmp 8411
mov AX False
cmp AX 1
$jmp 8436 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "&" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 10
$jmp 8441 "f"
mov AX True
jmp 8442
mov AX False
cmp AX 1
$jmp 8467 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "^" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 11
$jmp 8472 "f"
mov AX True
jmp 8473
mov AX False
cmp AX 1
$jmp 8498 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "|" AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8498        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 8507 "f"
mov AX True
jmp 8508
mov AX False
cmp AX 1
$jmp 8530 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "-" AX[BX]
push <__run_7157+0>.data
mov BX <__run_7157+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 8538 "f"
mov AX True
jmp 8539
mov AX False
cmp AX 1
$jmp 8554 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 8562 "f"
mov AX True
jmp 8563
mov AX False
cmp AX 1
$jmp 8801 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+19> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+8>
pop AX
push AX[BX]
mov <__run_7157+20> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
push AX[BX]
mov <__run_7157+21> <esp+1>
inc esp
mov DX <__run_7157+19>
tf DX "equ" "=="
$jmp 8591 "f"
mov AX True
jmp 8592
mov AX False
cmp AX 1
$jmp 8604 "!="
mov DX <__run_7157+20>
tf DX "equ" 0
$jmp 8599 "f"
mov AX True
jmp 8600
mov AX False
cmp AX 1
$jmp 8604 "!="
mov AX 1
jmp 8605
mov AX 0
cmp AX 1
$jmp 8630 "=="
mov DX <__run_7157+19>
tf DX "equ" "!="
$jmp 8612 "f"
mov AX True
jmp 8613
mov AX False
cmp AX 1
$jmp 8625 "!="
mov DX <__run_7157+20>
tf DX "equ" 0
$jmp 8620 "t"
mov AX True
jmp 8621
mov AX False
cmp AX 1
$jmp 8625 "!="
mov AX 1
jmp 8626
mov AX 0
cmp AX 1
$jmp 8630 "=="
mov AX 0
jmp 8631
mov AX 1
cmp AX 1
$jmp 8656 "=="
mov DX <__run_7157+19>
tf DX "equ" ">="
$jmp 8638 "f"
mov AX True
jmp 8639
mov AX False
cmp AX 1
$jmp 8651 "!="
mov DX <__run_7157+20>
cmp DX 0
$jmp 8646 "<"
mov AX True
jmp 8647
mov AX False
cmp AX 1
$jmp 8651 "!="
mov AX 1
jmp 8652
mov AX 0
cmp AX 1
$jmp 8656 "=="
mov AX 0
jmp 8657
mov AX 1
cmp AX 1
$jmp 8682 "=="
mov DX <__run_7157+19>
tf DX "equ" "<="
$jmp 8664 "f"
mov AX True
jmp 8665
mov AX False
cmp AX 1
$jmp 8677 "!="
mov DX <__run_7157+20>
cmp DX 0
$jmp 8672 ">"
mov AX True
jmp 8673
mov AX False
cmp AX 1
$jmp 8677 "!="
mov AX 1
jmp 8678
mov AX 0
cmp AX 1
$jmp 8682 "=="
mov AX 0
jmp 8683
mov AX 1
cmp AX 1
$jmp 8708 "=="
mov DX <__run_7157+19>
tf DX "equ" ">"
$jmp 8690 "f"
mov AX True
jmp 8691
mov AX False
cmp AX 1
$jmp 8703 "!="
mov DX <__run_7157+20>
cmp DX 0
$jmp 8698 "<="
mov AX True
jmp 8699
mov AX False
cmp AX 1
$jmp 8703 "!="
mov AX 1
jmp 8704
mov AX 0
cmp AX 1
$jmp 8708 "=="
mov AX 0
jmp 8709
mov AX 1
cmp AX 1
$jmp 8734 "=="
mov DX <__run_7157+19>
tf DX "equ" "<"
$jmp 8716 "f"
mov AX True
jmp 8717
mov AX False
cmp AX 1
$jmp 8729 "!="
mov DX <__run_7157+20>
cmp DX 0
$jmp 8724 ">="
mov AX True
jmp 8725
mov AX False
cmp AX 1
$jmp 8729 "!="
mov AX 1
jmp 8730
mov AX 0
cmp AX 1
$jmp 8734 "=="
mov AX 0
jmp 8735
mov AX 1
cmp AX 1
$jmp 8750 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8800        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" "t"
$jmp 8755 "f"
mov AX True
jmp 8756
mov AX False
cmp AX 1
$jmp 8762 "!="
cmp <__run_7157+21> 1
$jmp 8762 "!="
mov AX 1
jmp 8763
mov AX 0
cmp AX 1
$jmp 8784 "=="
mov DX <__run_7157+19>
tf DX "equ" "f"
$jmp 8770 "f"
mov AX True
jmp 8771
mov AX False
cmp AX 1
$jmp 8779 "!="
mov AX <__run_7157+21>
$oper AX "not"
cmp AX 1
$jmp 8779 "!="
mov AX 1
jmp 8780
mov AX 0
cmp AX 1
$jmp 8784 "=="
mov AX 0
jmp 8785
mov AX 1
cmp AX 1
$jmp 8800 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8800        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 8809 "f"
mov AX True
jmp 8810
mov AX False
cmp AX 1
$jmp 8994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+22> <esp+1>
inc esp
mov DX <__run_7157+22>
tf DX "equ" None
$jmp 8826 "f"
mov AX True
jmp 8827
mov AX False
cmp AX 1
$jmp 8839 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+15>
mov BX 1
pop AX
push AX[BX]
mov BX 3
pop AX
push AX[BX]
mov <__run_7157+22> <esp+1>
inc esp
jmp 8839        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+22>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+2>
$jmp 8851 "f"
mov AX True
jmp 8852
mov AX False
cmp AX 1
$jmp 8882 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.data
mov BX <__run_7157+11>
pop AX
push AX[BX]
mov <__run_7157+23> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+12>
pop AX
push AX[BX]
mov <__run_7157+24> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7157+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7157+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+22>
jmp 8993        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+22>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 8894 "f"
mov AX True
jmp 8895
mov AX False
cmp AX 1
$jmp 8948 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.data
mov BX <__run_7157+11>
pop AX
push AX[BX]
mov <__run_7157+23> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+12>
pop AX
push AX[BX]
mov <__run_7157+24> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <__run_7157+25> <esp+1>
inc esp
push <__run_7157+0>.ex_function
mov BX <__run_7157+22>
pop AX
push AX[BX]
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7157+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7157+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7157+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7157+25>
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8993        ;¸õ¦Ü©³³¡
push <__run_7157+0>.data
mov BX <__run_7157+11>
pop AX
push AX[BX]
mov <__run_7157+23> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+12>
pop AX
push AX[BX]
mov <__run_7157+24> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+0>.$$ip
pop AX
push AX[BX]
mov <__run_7157+25> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7157+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7157+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+22>
push AX
push <__run_7157+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7157+25>
push <__run_7157+0>.data
mov BX <__run_7157+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 9002 "f"
mov AX True
jmp 9003
mov AX False
cmp AX 1
$jmp 9027 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>.data
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 9035 "f"
mov AX True
jmp 9036
mov AX False
cmp AX 1
$jmp 9060 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7157+0>.data
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 9
$jmp 9068 "f"
mov AX True
jmp 9069
mov AX False
cmp AX 1
$jmp 9206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+26> <esp+1>
inc esp
mov DX <__run_7157+26>
tf DX "equ" 0
$jmp 9085 "f"
mov AX True
jmp 9086
mov AX False
cmp AX 1
$jmp 9110 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov DX AX[BX]
pop BX
pop AX
tf AX[BX] "in" DX
push TF
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9205        ;¸õ¦Ü©³³¡
mov DX <__run_7157+26>
tf DX "equ" 1
$jmp 9115 "f"
mov AX True
jmp 9116
mov AX False
cmp AX 1
$jmp 9144 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 9136 "f"
mov AX True
jmp 9137
mov AX False
push AX
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9205        ;¸õ¦Ü©³³¡
mov DX <__run_7157+26>
tf DX "equ" 2
$jmp 9149 "f"
mov AX True
jmp 9150
mov AX False
cmp AX 1
$jmp 9175 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
tf AX.vars "in" BX
push TF
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9205        ;¸õ¦Ü©³³¡
mov DX <__run_7157+26>
tf DX "equ" 3
$jmp 9180 "f"
mov AX True
jmp 9181
mov AX False
cmp AX 1
$jmp 9205 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov DX AX[BX]
pop BX
pop AX
tf AX[BX] "is" DX
push TF
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9205        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 10
$jmp 9214 "f"
mov AX True
jmp 9215
mov AX False
cmp AX 1
$jmp 9227 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 11
$jmp 9235 "f"
mov AX True
jmp 9236
mov AX False
cmp AX 1
$jmp 9248 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 12
$jmp 9256 "f"
mov AX True
jmp 9257
mov AX False
cmp AX 1
$jmp 9381 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+19> <esp+1>
inc esp
mov DX <__run_7157+19>
tf DX "equ" 0
$jmp 9273 "f"
mov AX True
jmp 9274
mov AX False
cmp AX 1
$jmp 9328 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
finally 9318
try 9297
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "not"
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9313    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 9312 "f"
mov $Exception 0
try 9316
push False
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9313  ;¸õ¨ìpush 1
jmp 9316 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 9318    ;¸õ¨ìfinally
push None
push 0
finally -9318
pop AX
cmp AX 1
$jmp 9325 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
jmp 9380        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 1
$jmp 9333 "f"
mov AX True
jmp 9334
mov AX False
cmp AX 1
$jmp 9354 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "-"
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9380        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 2
$jmp 9359 "f"
mov AX True
jmp 9360
mov AX False
cmp AX 1
$jmp 9380 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "~"
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9380        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 13
$jmp 9389 "f"
mov AX True
jmp 9390
mov AX False
cmp AX 1
$jmp 9438 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <__run_7157+25> <esp+1>
inc esp
push <__run_7157+0>.ex_function
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push 1        ;Àx¦sCX
push [1]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7157+25>
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 14
$jmp 9446 "f"
mov AX True
jmp 9447
mov AX False
cmp AX 1
$jmp 9549 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+27> <esp+1>
inc esp
mov DX <__run_7157+27>
tf DX "equ" "end"
$jmp 9463 "f"
mov AX True
jmp 9464
mov AX False
cmp AX 1
$jmp 9469 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 10702
jmp 9469        ;¸õ¦Ü©³³¡
push 1
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
push AX[BX]
mov <__run_7157+28> <esp+1>
inc esp
finally 9533
try 9496
push 1        ;Àx¦sCX
push [1]
push "try "
ex_func AX "str" <__run_7157+27>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+0>.__run
try "end"
jmp 9528    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 9527 "f"
mov e $Exception
mov $Exception 0
try 9531
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <__run_7157+0>.error_line <esp+1>
inc esp
push <__run_7157+28>
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push e
push <__run_7157+0>.data
mov BX <__run_7157+10>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7157+27>
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9528  ;¸õ¨ìpush 1
jmp 9531 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 9533    ;¸õ¨ìfinally
push None
push 0
finally -9533
pop AX
cmp AX 1
$jmp 9540 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <__run_7157+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 15
$jmp 9557 "f"
mov AX True
jmp 9558
mov AX False
cmp AX 1
$jmp 9583 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+29> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <__run_7157+29>
push <__run_7157+0>.data
mov BX <__run_7157+0>.$$esp
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+13>.append
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 16
$jmp 9591 "f"
mov AX True
jmp 9592
mov AX False
cmp AX 1
$jmp 9603 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
raise AX
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 17
$jmp 9611 "f"
mov AX True
jmp 9612
mov AX False
cmp AX 1
$jmp 9705 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+30> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" list
$jmp 9635 "f"
mov AX True
jmp 9636
mov AX False
cmp AX 1
$jmp 9667 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <__run_7157+30> "in" Exception
mov AX TF
cmp AX 1
$jmp 9649 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9666        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <__run_7157+0>.data
mov BX <__run_7157+10>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
tf <__run_7157+30> "in" AX
push TF
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9704        ;¸õ¦Ü©³³¡
mov DX <__run_7157+30>
tf DX "equ" Exception
$jmp 9672 "f"
mov AX True
jmp 9673
mov AX False
cmp AX 1
$jmp 9682 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9704        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <__run_7157+0>.data
mov BX <__run_7157+10>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <__run_7157+30>
$jmp 9697 "f"
mov AX True
jmp 9698
mov AX False
push AX
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 18
$jmp 9713 "f"
mov AX True
jmp 9714
mov AX False
cmp AX 1
$jmp 9788 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+31> <esp+1>
inc esp
push 3
mov <__run_7157+32> <esp+1>
inc esp
push [dict]
mov <__run_7157+33> <esp+1>
inc esp
push <__run_7157+32>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 9744 ">="
mov AX True
jmp 9745
mov AX False
cmp AX 1
$jmp 9769 "!="
push <__run_7157+0>
push <__run_7157+15>
mov BX <__run_7157+32>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+34> <esp+1>
inc esp
push <__run_7157+0>.func_stack
mov BX <__run_7157+34>
pop AX
push AX[BX]
push <__run_7157+33>
mov BX <__run_7157+34>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7157+32> "+" <esp+1>
inc esp
jmp 9731               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__run_7157+0>
mov <esp+1>[1] <__run_7157+31>
mov <esp+1>[2] <__run_7157+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+3>
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 19
$jmp 9796 "f"
mov AX True
jmp 9797
mov AX False
cmp AX 1
$jmp 9832 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "finally yield run"
$jmp 9809 "f"
mov AX True
jmp 9810
mov AX False
cmp AX 1
$jmp 9821 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "Exception ignored in: <generator object>\nRuntimeError: generator ignored GeneratorExit"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 9821        ;¸õ¦Ü©³³¡
push (2)
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <__run_7157+13>
pop AX
jmp 10702
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 20
$jmp 9840 "f"
mov AX True
jmp 9841
mov AX False
cmp AX 1
$jmp 9931 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
push AX[BX]
mov <__run_7157+28> <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
push AX[BX]
mov <__run_7157+25> <esp+1>
inc esp
finally 9909
try 9890
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+35> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+35>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call next
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push True
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9904    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error StopIteration
$jmp 9903 "f"
mov e $Exception
mov $Exception 0
try 9907
push False
push <__run_7157+0>.data
mov BX <__run_7157+9>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9904  ;¸õ¨ìpush 1
jmp 9907 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 9909    ;¸õ¨ìfinally
push None
push 0
finally -9909
pop AX
cmp AX 1
$jmp 9916 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <__run_7157+28>
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7157+25>
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 21
$jmp 9939 "f"
mov AX True
jmp 9940
mov AX False
cmp AX 1
$jmp 9959 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] "ip---->"
push <__run_7157+0>.data
mov BX <__run_7157+0>.$$ip
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] "esp------>"
push <__run_7157+0>.data
mov BX <__run_7157+0>.$$esp
pop AX
mov <esp+1>[3] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 22
$jmp 9967 "f"
mov AX True
jmp 9968
mov AX False
cmp AX 1
$jmp 10096 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+36> <esp+1>
inc esp
mov DX <__run_7157+36>
tf DX "equ" "finally_yield"
$jmp 9984 "f"
mov AX True
jmp 9985
mov AX False
cmp AX 1
$jmp 10002 "!="
push <__run_7157+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "finally yield run"
$jmp 9997 "f"
mov AX True
jmp 9998
mov AX False
cmp AX 1
$jmp 10002 "!="
mov AX 1
jmp 10003
mov AX 0
cmp AX 1
$jmp 10008 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 10702
jmp 10095        ;¸õ¦Ü©³³¡
mov DX <__run_7157+36>
tf DX "equ" "Function"
$jmp 10013 "f"
mov AX True
jmp 10014
mov AX False
cmp AX 1
$jmp 10095 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+34> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 10037 "<="
mov AX True
jmp 10038
mov AX False
cmp AX 1
$jmp 10094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7157+37> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] int
mov <esp+1>[1] <__run_7157+37>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call map
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call list
push AX
mov <__run_7157+38> <esp+1>
inc esp
ex_func AX "iter" <__run_7157+38>
push AX
fetch AX <esp+1>
$jmp 10092 "f"
mov <__run_7157+39> AX
push None
push <__run_7157+0>.func_stack
mov BX <__run_7157+34>
pop AX
push AX[BX]
mov BX <__run_7157+39>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10079
inc esp
jmp 10094        ;¸õ¦Ü©³³¡
jmp 10095        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 23
$jmp 10104 "f"
mov AX True
jmp 10105
mov AX False
cmp AX 1
$jmp 10132 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.encode
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 24
$jmp 10140 "f"
mov AX True
jmp 10141
mov AX False
cmp AX 1
$jmp 10228 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+19> <esp+1>
inc esp
mov DX <__run_7157+19>
tf DX "equ" 0
$jmp 10157 "f"
mov AX True
jmp 10158
mov AX False
cmp AX 1
$jmp 10176 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10227        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 1
$jmp 10181 "f"
mov AX True
jmp 10182
mov AX False
cmp AX 1
$jmp 10201 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
del 1 AX BX
jmp 10227        ;¸õ¦Ü©³³¡
mov DX <__run_7157+19>
tf DX "equ" 2
$jmp 10206 "f"
mov AX True
jmp 10207
mov AX False
cmp AX 1
$jmp 10227 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
del 1 AX BX
jmp 10227        ;¸õ¦Ü©³³¡
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 25
$jmp 10236 "f"
mov AX True
jmp 10237
mov AX False
cmp AX 1
$jmp 10341 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+40> <esp+1>
inc esp
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+41> <esp+1>
inc esp
push <__run_7157+0>
push <__run_7157+15>
mov BX 4
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+42> <esp+1>
inc esp
push <__run_7157+0>
push <__run_7157+15>
mov BX 5
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+43> <esp+1>
inc esp
push 6
mov <__run_7157+32> <esp+1>
inc esp
push [dict]
mov <__run_7157+33> <esp+1>
inc esp
push <__run_7157+32>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7157+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 10294 ">="
mov AX True
jmp 10295
mov AX False
cmp AX 1
$jmp 10319 "!="
push <__run_7157+0>
push <__run_7157+15>
mov BX <__run_7157+32>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+34> <esp+1>
inc esp
push <__run_7157+0>.func_stack
mov BX <__run_7157+34>
pop AX
push AX[BX]
push <__run_7157+33>
mov BX <__run_7157+34>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7157+32> "+" <esp+1>
inc esp
jmp 10281               ;continue­«¨Ó
push 6        ;Àx¦sCX
push [6]
mov <esp+1>[0] <__run_7157+0>
mov <esp+1>[1] <__run_7157+40>
mov <esp+1>[2] <__run_7157+41>
mov <esp+1>[3] <__run_7157+42>
mov <esp+1>[4] <__run_7157+43>
mov <esp+1>[5] <__run_7157+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+2>
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 26
$jmp 10349 "f"
mov AX True
jmp 10350
mov AX False
cmp AX 1
$jmp 10353 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 28
$jmp 10361 "f"
mov AX True
jmp 10362
mov AX False
cmp AX 1
$jmp 10450 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7157+44> <esp+1>
inc esp
push 0
mov <__run_7157+45> <esp+1>
inc esp
push [dict]
mov <__run_7157+46> <esp+1>
inc esp
ex_func AX "iter" <__run_7157+44>
push AX
fetch AX <esp+1>
$jmp 10404 "f"
mov <__run_7157+47> AX
push <__run_7157+45>
push <__run_7157+46>
mov BX <__run_7157+47>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7157+45> "+" <esp+1>
inc esp
jmp 10391
inc esp
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
mov <esp+1>[0] AX
oper <esp+1> "*" <__run_7157+45>
mov <__run_7157+48> <esp+1>
inc esp
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+49> <esp+1>
inc esp
push <__run_7157+48>
push <__run_7157+0>.func_stack
mov BX <__run_7157+49>
pop AX
mov AX[BX] <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__run_7157+0>
mov <esp+1>[1] <__run_7157+49>
mov <esp+1>[2] <__run_7157+46>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+12>
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 29
$jmp 10458 "f"
mov AX True
jmp 10459
mov AX False
cmp AX 1
$jmp 10493 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push [3]
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 30
$jmp 10501 "f"
mov AX True
jmp 10502
mov AX False
cmp AX 1
$jmp 10567 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7157+50> <esp+1>
inc esp
push <__run_7157+0>
push <__run_7157+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7157+51> <esp+1>
inc esp
push [dict]
mov <__run_7157+52> <esp+1>
inc esp
ex_func AX "iter" <__run_7157+50>
push AX
fetch AX <esp+1>
$jmp 10556 "f"
mov <__run_7157+53> AX
tf <__run_7157+51> "in" <__run_7157+53>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 10555 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+50>
mov BX <__run_7157+53>
pop AX
push AX[BX]
push <__run_7157+52>
mov BX <__run_7157+53>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10555        ;¸õ¦Ü©³³¡
jmp 10537
inc esp
push <__run_7157+52>
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 31
$jmp 10575 "f"
mov AX True
jmp 10576
mov AX False
cmp AX 1
$jmp 10601 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+11>
push AX
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 32
$jmp 10609 "f"
mov AX True
jmp 10610
mov AX False
cmp AX 1
$jmp 10629 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.atype <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push <__run_7157+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 33
$jmp 10637 "f"
mov AX True
jmp 10638
mov AX False
cmp AX 1
$jmp 10657 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7157+0>
push <__run_7157+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7157+0>
push <__run_7157+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.name <esp+1>
inc esp
jmp 10657        ;¸õ¦Ü©³³¡
push 1
push <__run_7157+0>.data
mov BX <__run_7157+6>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7157+0>.data
mov BX <__run_7157+7>
pop AX
mov AX AX[BX]
$oper AX "-"
mov DX AX
cmp DX <__run_7157+0>.stack_size
$jmp 10673 "<="
mov AX True
jmp 10674
mov AX False
cmp AX 1
$jmp 10685 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "maxinum recursion depth exceeded"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call RecursionError
raise AX
jmp 10685        ;¸õ¦Ü©³³¡
jmp 7625               ;continue­«¨Ó
mov DX <__run_7157+0>.tf
cmp DX 0
$jmp 10691 "<="
mov AX True
jmp 10692
mov AX False
cmp AX 1
$jmp 10701 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7157+5>
jmp 10701        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__run_7157" "0,1,2,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53"
pop ip
mov AX <Executer^11>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 10717 "=="
tf AX "Ctn" "__init__"
$jmp 10715 "t"
jmp 10717
call AX.__init__
mov AX <Executer^11>
end "Function" "Executer^11"
pop ip
Function <&executer_33+11> 10722 None "Ex_module^12" 1
name <&executer_33+11> "<class '__main__.Ex_module'>"
jmp 10812
tf $Inheritance "equ" None
$jmp 10727 "t"
mov <Ex_module^12> $Inheritance
push 1
jmp 10729
mov <Ex_module^12> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Ex_module^12> <&executer_33+11>
Function BX 10737 <Ex_module^12> "__init___10737" 3
mov <Ex_module^12>.__init__ BX
jmp 10763           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 10745 "!="
tf <esp+2> "in" "module_name"
$jmp 10747 "t"
mov <esp+2>["module_name"] None
jmp 10747
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <__init___10737+2> <esp+2>["module_name"]


push <__init___10737+2>
mov <__init___10737+0>.module_name <esp+1>
inc esp
push "Ex_module"
mov <__init___10737+0>.__name__ <esp+1>
inc esp
push [dict]
mov <__init___10737+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___10737" "0,1,2"
pop ip
Function BX 10766 <Ex_module^12> "__str___10766" 2
mov <Ex_module^12>.__str__ BX
jmp 10775           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX <__str___10766+0>.module_name
jmp 10772         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___10766" "0,1"
pop ip
Function BX 10778 <Ex_module^12> "__call___10778" 4
mov <Ex_module^12>.__call__ BX
jmp 10798           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___10778+2> <esp+2>["args"]
mov <__call___10778+3> <esp+2>["kwargs"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "'module' object is not callable"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call TypeError
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___10778" "0,1,2,3"
pop ip
mov AX <Ex_module^12>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 10810 "=="
tf AX "Ctn" "__init__"
$jmp 10808 "t"
jmp 10810
call AX.__init__
mov AX <Ex_module^12>
end "Function" "Ex_module^12"
pop ip
Function <&executer_33+12> 10815 None "Namespace_stack^13" 1
name <&executer_33+12> "<class '__main__.Namespace_stack'>"
jmp 10910
tf $Inheritance "equ" None
$jmp 10820 "t"
mov <Namespace_stack^13> $Inheritance
push 1
jmp 10822
mov <Namespace_stack^13> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Namespace_stack^13> <&executer_33+12>
Function BX 10830 <Namespace_stack^13> "__init___10830" 5
mov <Namespace_stack^13>.__init__ BX
jmp 10880           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 10838 "!="
tf <esp+2> "in" "ram"
$jmp 10840 "t"
mov <esp+2>["ram"] None
jmp 10840
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 10846 "!="
tf <esp+2> "in" "stack_name"
$jmp 10848 "t"
mov <esp+2>["stack_name"] None
jmp 10848
mov <esp+2>["stack_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 10854 "!="
tf <esp+2> "in" "var_dict"
$jmp 10856 "t"
mov <esp+2>["var_dict"] None
jmp 10856
mov <esp+2>["var_dict"] <esp+1>[2]
dec CX
mov <__init___10830+2> <esp+2>["ram"]
mov <__init___10830+3> <esp+2>["stack_name"]
mov <__init___10830+4> <esp+2>["var_dict"]


push <__init___10830+3>
mov <__init___10830+0>.stack_name <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__init___10830+2>
mov <esp+1>[1] <__init___10830+3>
mov <esp+1>[2] <__init___10830+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+13>
push AX
mov <__init___10830+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___10830" "0,1,2,3,4"
pop ip
Function BX 10883 <Namespace_stack^13> "__str___10883" 2
mov <Namespace_stack^13>.__str__ BX
jmp 10896           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "module \""
ex_func AX "str" <__str___10883+0>.stack_name
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 10893         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___10883" "0,1"
pop ip
mov AX <Namespace_stack^13>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 10908 "=="
tf AX "Ctn" "__init__"
$jmp 10906 "t"
jmp 10908
call AX.__init__
mov AX <Namespace_stack^13>
end "Function" "Namespace_stack^13"
pop ip
Function <&executer_33+13> 10913 None "namespace_stack_var^14" 1
name <&executer_33+13> "<class '__main__.namespace_stack_var'>"
jmp 11120
tf $Inheritance "equ" None
$jmp 10918 "t"
mov <namespace_stack_var^14> $Inheritance
push 1
jmp 10920
mov <namespace_stack_var^14> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <namespace_stack_var^14> <&executer_33+13>
Function BX 10928 <namespace_stack_var^14> "__init___10928" 5
mov <namespace_stack_var^14>.__init__ BX
jmp 10972           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 10936 "!="
tf <esp+2> "in" "ram"
$jmp 10938 "t"
mov <esp+2>["ram"] None
jmp 10938
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 10944 "!="
tf <esp+2> "in" "stack_name"
$jmp 10946 "t"
mov <esp+2>["stack_name"] None
jmp 10946
mov <esp+2>["stack_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 10952 "!="
tf <esp+2> "in" "var_dict"
$jmp 10954 "t"
mov <esp+2>["var_dict"] None
jmp 10954
mov <esp+2>["var_dict"] <esp+1>[2]
dec CX
mov <__init___10928+2> <esp+2>["ram"]
mov <__init___10928+3> <esp+2>["stack_name"]
mov <__init___10928+4> <esp+2>["var_dict"]


push <__init___10928+2>
mov <__init___10928+0>.ram <esp+1>
inc esp
push <__init___10928+3>
mov <__init___10928+0>.name <esp+1>
inc esp
push <__init___10928+4>
mov <__init___10928+0>.var_dict <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___10928" "0,1,2,3,4"
pop ip
Function BX 10975 <namespace_stack_var^14> "__contains___10975" 3
mov <namespace_stack_var^14>.__contains__ BX
jmp 10994           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 10983 "!="
tf <esp+2> "in" "item"
$jmp 10985 "t"
mov <esp+2>["item"] None
jmp 10985
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___10975+2> <esp+2>["item"]


tf <__contains___10975+0>.var_dict "in" <__contains___10975+2>
mov AX TF
jmp 10991         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___10975" "0,1,2"
pop ip
Function BX 10997 <namespace_stack_var^14> "__setitem___10997" 5
mov <namespace_stack_var^14>.__setitem__ BX
jmp 11075           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11005 "!="
tf <esp+2> "in" "key"
$jmp 11007 "t"
mov <esp+2>["key"] None
jmp 11007
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11013 "!="
tf <esp+2> "in" "value"
$jmp 11015 "t"
mov <esp+2>["value"] None
jmp 11015
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___10997+2> <esp+2>["key"]
mov <__setitem___10997+3> <esp+2>["value"]


tf <__setitem___10997+0>.var_dict "in" <__setitem___10997+2>
mov AX TF
cmp AX 1
$jmp 11037 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___10997+3>
mov AX <__setitem___10997+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___10997+0>.name
pop AX
push AX[BX]
push <__setitem___10997+0>.var_dict
mov BX <__setitem___10997+2>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 11071        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov AX <__setitem___10997+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___10997+0>.name
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <__setitem___10997+4> <esp+1>
inc esp
push <__setitem___10997+4>
push <__setitem___10997+0>.var_dict
mov BX <__setitem___10997+2>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <__setitem___10997+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___10997+0>.name
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__setitem___10997+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___10997" "0,1,2,3,4"
pop ip
Function BX 11078 <namespace_stack_var^14> "__getitem___11078" 3
mov <namespace_stack_var^14>.__getitem__ BX
jmp 11106           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11086 "!="
tf <esp+2> "in" "item"
$jmp 11088 "t"
mov <esp+2>["item"] None
jmp 11088
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___11078+2> <esp+2>["item"]


mov AX <__getitem___11078+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__getitem___11078+0>.name
pop AX
push AX[BX]
push <__getitem___11078+0>.var_dict
mov BX <__getitem___11078+2>
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 11103         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___11078" "0,1,2"
pop ip
mov AX <namespace_stack_var^14>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 11118 "=="
tf AX "Ctn" "__init__"
$jmp 11116 "t"
jmp 11118
call AX.__init__
mov AX <namespace_stack_var^14>
end "Function" "namespace_stack_var^14"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"]
mov <&code_28+0> <esp+1>.Undefine
inc esp
Function <&code_28+1> 11126 None "Code^6" 1
name <&code_28+1> "<class '__main__.Code'>"
jmp 14691
tf $Inheritance "equ" None
$jmp 11131 "t"
mov <Code^6> $Inheritance
push 1
jmp 11133
mov <Code^6> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Code^6> <&code_28+1>
Function BX 11141 <Code^6> "__init___11141" 2
mov <Code^6>.__init__ BX
jmp 11160           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push (2)
mov <esp+1>[0] "AX"
mov <esp+1>[1] "BX"
mov <__init___11141+0>.tem <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___11141+0>.clean
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___11141" "0,1"
pop ip
Function BX 11163 <Code^6> "clean_11163" 2
mov <Code^6>.clean BX
jmp 11197           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <clean_11163+0>.code <esp+1>
inc esp
push [0]
mov <clean_11163+0>.comments <esp+1>
inc esp
push 0
mov <clean_11163+0>.simplify <esp+1>
inc esp
push [0]
mov <clean_11163+0>.base_num <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <clean_11163+0>.base_esp <esp+1>
inc esp
push [0]
mov <clean_11163+0>.file_ed <esp+1>
inc esp
push (3)
mov <esp+1>[0] 0
mov <esp+1>[1] 0
mov <esp+1>[2] 0
mov <clean_11163+0>.base <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "clean_11163" "0,1"
pop ip
Function BX 11200 <Code^6> "__apply_file_11200" 3
mov <Code^6>.__apply_file BX
jmp 11243           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11208 "!="
tf <esp+2> "in" "name"
$jmp 11210 "t"
mov <esp+2>["name"] None
jmp 11210
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <__apply_file_11200+2> <esp+2>["name"]


tf <__apply_file_11200+0>.file_ed "in" <__apply_file_11200+2>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 11229 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__apply_file_11200+0>.file_ed      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__apply_file_11200+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11229        ;¸õ¦Ü©³³¡
mov AX <__apply_file_11200+0>.file_ed      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.index
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__apply_file_11200+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11240         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__apply_file_11200" "0,1,2"
pop ip
Function BX 11246 <Code^6> "add_newtab_11246" 4
mov <Code^6>.add_newtab BX
jmp 11288           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11254 "!="
tf <esp+2> "in" "name"
$jmp 11256 "t"
mov <esp+2>["name"] None
jmp 11256
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <add_newtab_11246+2> <esp+2>["name"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <add_newtab_11246+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <add_newtab_11246+0>.__apply_file
push AX
mov <add_newtab_11246+3> <esp+1>
inc esp
mov AX <add_newtab_11246+0>.base_num      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <add_newtab_11246+3>
push [1]
mov <esp+1>[0] 0
pop <esp+1>[1]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_newtab_11246" "0,1,2,3"
pop ip
Function BX 11291 <Code^6> "del_newtab_11291" 2
mov <Code^6>.del_newtab BX
jmp 11305           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push <del_newtab_11291+0>.base_num
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "del_newtab_11291" "0,1"
pop ip
Function BX 11308 <Code^6> "add_tab_11308" 2
mov <Code^6>.add_tab BX
jmp 11316           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_tab_11308" "0,1"
pop ip
Function BX 11319 <Code^6> "del_tab_11319" 2
mov <Code^6>.del_tab BX
jmp 11327           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "del_tab_11319" "0,1"
pop ip
Function BX 11330 <Code^6> "get_error_msg_11330" 5
mov <Code^6>.get_error_msg BX
jmp 11424           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11338 "!="
tf <esp+2> "in" "row"
$jmp 11340 "t"
mov <esp+2>["row"] None
jmp 11340
mov <esp+2>["row"] <esp+1>[0]
dec CX
mov <get_error_msg_11330+2> <esp+2>["row"]


push <get_error_msg_11330+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_error_msg_11330+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 11356 ">="
mov AX True
jmp 11357
mov AX False
cmp AX 1
$jmp 11408 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_error_msg_11330+0>.comments
mov BX <get_error_msg_11330+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
push AX[BX]
mov <get_error_msg_11330+3> <esp+1>
inc esp
push <get_error_msg_11330+0>.comments
mov BX <get_error_msg_11330+3>
pop AX
push AX[BX]
mov <get_error_msg_11330+4> <esp+1>
inc esp
push [dict]
push "file"
push <get_error_msg_11330+0>.file_ed
push <get_error_msg_11330+4>
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
push "row"
push <get_error_msg_11330+4>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
push "code"
push <get_error_msg_11330+4>
mov BX 1
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
pop AX
jmp 11421         ;returnÂI
jmp 11421        ;¸õ¦Ü©³³¡
push [dict]
mov BX "file"
mov <esp+1>[BX] ""
mov BX "row"
mov <esp+1>[BX] <get_error_msg_11330+2>
push "code"
push <get_error_msg_11330+0>.code
mov BX <get_error_msg_11330+2>
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
pop AX
jmp 11421         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_error_msg_11330" "0,1,2,3,4"
pop ip
Function BX 11427 <Code^6> "append_11427" 11
mov <Code^6>.append BX
jmp 12272           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11435 "!="
tf <esp+2> "in" "command"
$jmp 11437 "t"
mov <esp+2>["command"] None
jmp 11437
mov <esp+2>["command"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11443 "!="
tf <esp+2> "in" "comment"
$jmp 11445 "t"
mov <esp+2>["comment"] None
jmp 11445
mov <esp+2>["comment"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 11451 "!="
tf <esp+2> "in" "simplify"
$jmp 11453 "t"
mov <esp+2>["simplify"] 0
jmp 11453
mov <esp+2>["simplify"] <esp+1>[2]
dec CX
mov <append_11427+2> <esp+2>["command"]
mov <append_11427+3> <esp+2>["comment"]
mov <append_11427+4> <esp+2>["simplify"]


mov DX <append_11427+3>
tf DX "equ" None
$jmp 11463 "t"
mov AX True
jmp 11464
mov AX False
cmp AX 1
$jmp 11479 "!="
push <append_11427+3>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 11474 "t"
mov AX True
jmp 11475
mov AX False
cmp AX 1
$jmp 11479 "!="
mov AX 1
jmp 11480
mov AX 0
cmp AX 1
$jmp 11552 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+3>
mov <append_11427+5> <esp+1>[0]
mov <append_11427+6> <esp+1>[1]
inc esp
push <append_11427+6>
push <append_11427+0>.base_num
mov BX <append_11427+0>.base_esp
pop AX
push AX[BX]
mov BX 1
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <append_11427+0>.base_num
mov BX <append_11427+0>.base_esp
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call sum
push AX
mov <append_11427+7> <esp+1>
inc esp
push <append_11427+0>.base_num
mov BX <append_11427+0>.base_esp
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <append_11427+8> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <append_11427+8>
mov <esp+1>[1] <append_11427+7>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[2] AX
mov <append_11427+0>.base <esp+1>
inc esp
mov AX <append_11427+0>.comments      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <append_11427+0>.base
mov <esp+1>[1] <append_11427+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11552        ;¸õ¦Ü©³³¡
mov DX <append_11427+2>
tf DX "equ" ""
$jmp 11557 "f"
mov AX True
jmp 11558
mov AX False
cmp AX 1
$jmp 11563 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 12269
jmp 11563        ;¸õ¦Ü©³³¡
mov DX <append_11427+0>.simplify
tf DX "equ" 0
$jmp 11568 "f"
mov AX True
jmp 11569
mov AX False
cmp AX 1
$jmp 11581 "!="
mov DX <append_11427+4>
tf DX "equ" 0
$jmp 11576 "f"
mov AX True
jmp 11577
mov AX False
cmp AX 1
$jmp 11581 "!="
mov AX 1
jmp 11582
mov AX 0
cmp AX 1
$jmp 11594 "!="
mov DX <append_11427+3>
tf DX "equ" None
$jmp 11589 "f"
mov AX True
jmp 11590
mov AX False
cmp AX 1
$jmp 11594 "!="
mov AX 1
jmp 11595
mov AX 0
cmp AX 1
$jmp 11614 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 11609 "<="
mov AX True
jmp 11610
mov AX False
cmp AX 1
$jmp 11614 "!="
mov AX 1
jmp 11615
mov AX 0
cmp AX 1
$jmp 11634 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 11629 "f"
mov AX True
jmp 11630
mov AX False
cmp AX 1
$jmp 11634 "!="
mov AX 1
jmp 11635
mov AX 0
cmp AX 1
$jmp 11659 "!="
push 1        ;Àx¦sCX
push [1]
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 11654 "f"
mov AX True
jmp 11655
mov AX False
cmp AX 1
$jmp 11659 "!="
mov AX 1
jmp 11660
mov AX 0
cmp AX 1
$jmp 12206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <append_11427+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <append_11427+2>.split
push AX
mov <append_11427+10> <esp+1>
inc esp
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 11698 "f"
mov AX True
jmp 11699
mov AX False
cmp AX 1
$jmp 11714 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 11709 "f"
mov AX True
jmp 11710
mov AX False
cmp AX 1
$jmp 11714 "!="
mov AX 1
jmp 11715
mov AX 0
cmp AX 1
$jmp 11763 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 11735 "t"
mov AX True
jmp 11736
mov AX False
cmp AX 1
$jmp 11762 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11427+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <append_11427+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11762        ;¸õ¦Ü©³³¡
jmp 12205        ;¸õ¦Ü©³³¡
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 11771 "f"
mov AX True
jmp 11772
mov AX False
cmp AX 1
$jmp 11787 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 11782 "f"
mov AX True
jmp 11783
mov AX False
cmp AX 1
$jmp 11787 "!="
mov AX 1
jmp 11788
mov AX 0
cmp AX 1
$jmp 11807 "!="
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 11802 "f"
mov AX True
jmp 11803
mov AX False
cmp AX 1
$jmp 11807 "!="
mov AX 1
jmp 11808
mov AX 0
cmp AX 1
$jmp 11843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <append_11427+9>
mov BX 1
pop AX
tf <append_11427+0>.tem "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 11842 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11427+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11842        ;¸õ¦Ü©³³¡
jmp 12205        ;¸õ¦Ü©³³¡
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 11851 "f"
mov AX True
jmp 11852
mov AX False
cmp AX 1
$jmp 11867 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 11862 "f"
mov AX True
jmp 11863
mov AX False
cmp AX 1
$jmp 11867 "!="
mov AX 1
jmp 11868
mov AX 0
cmp AX 1
$jmp 11887 "!="
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 11882 "f"
mov AX True
jmp 11883
mov AX False
cmp AX 1
$jmp 11887 "!="
mov AX 1
jmp 11888
mov AX 0
cmp AX 1
$jmp 11899 "!="
push <append_11427+9>
mov BX 1
pop AX
tf <append_11427+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 11899 "!="
mov AX 1
jmp 11900
mov AX 0
cmp AX 1
$jmp 11926 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "push "
push <append_11427+9>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12205        ;¸õ¦Ü©³³¡
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 11934 "f"
mov AX True
jmp 11935
mov AX False
cmp AX 1
$jmp 11950 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 11945 "f"
mov AX True
jmp 11946
mov AX False
cmp AX 1
$jmp 11950 "!="
mov AX 1
jmp 11951
mov AX 0
cmp AX 1
$jmp 11970 "!="
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 11965 "f"
mov AX True
jmp 11966
mov AX False
cmp AX 1
$jmp 11970 "!="
mov AX 1
jmp 11971
mov AX 0
cmp AX 1
$jmp 11982 "!="
push <append_11427+9>
mov BX 1
pop AX
tf <append_11427+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 11982 "!="
mov AX 1
jmp 11983
mov AX 0
cmp AX 1
$jmp 12009 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "pop "
push <append_11427+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12205        ;¸õ¦Ü©³³¡
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12017 "f"
mov AX True
jmp 12018
mov AX False
cmp AX 1
$jmp 12033 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12028 "f"
mov AX True
jmp 12029
mov AX False
cmp AX 1
$jmp 12033 "!="
mov AX 1
jmp 12034
mov AX 0
cmp AX 1
$jmp 12053 "!="
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12048 "f"
mov AX True
jmp 12049
mov AX False
cmp AX 1
$jmp 12053 "!="
mov AX 1
jmp 12054
mov AX 0
cmp AX 1
$jmp 12073 "!="
push <append_11427+9>
mov BX 2
pop AX
push AX[BX]
push <append_11427+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12068 "f"
mov AX True
jmp 12069
mov AX False
cmp AX 1
$jmp 12073 "!="
mov AX 1
jmp 12074
mov AX 0
cmp AX 1
$jmp 12077 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12205        ;¸õ¦Ü©³³¡
push <append_11427+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12085 "f"
mov AX True
jmp 12086
mov AX False
cmp AX 1
$jmp 12101 "!="
push <append_11427+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12096 "f"
mov AX True
jmp 12097
mov AX False
cmp AX 1
$jmp 12101 "!="
mov AX 1
jmp 12102
mov AX 0
cmp AX 1
$jmp 12121 "!="
push <append_11427+9>
mov BX 1
pop AX
push AX[BX]
push <append_11427+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12116 "f"
mov AX True
jmp 12117
mov AX False
cmp AX 1
$jmp 12121 "!="
mov AX 1
jmp 12122
mov AX 0
cmp AX 1
$jmp 12133 "!="
push <append_11427+9>
mov BX 1
pop AX
tf <append_11427+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12133 "!="
mov AX 1
jmp 12134
mov AX 0
cmp AX 1
$jmp 12166 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11427+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11427+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <append_11427+9>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12205        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "add"
mov <esp+1>[1] "sub"
push <append_11427+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 12191 "!="
push <append_11427+10>
mov BX 2
pop AX
mov DX AX[BX]
tf DX "equ" "0"
$jmp 12186 "f"
mov AX True
jmp 12187
mov AX False
cmp AX 1
$jmp 12191 "!="
mov AX 1
jmp 12192
mov AX 0
cmp AX 1
$jmp 12195 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12205        ;¸õ¦Ü©³³¡
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12216        ;¸õ¦Ü©³³¡
mov AX <append_11427+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <append_11427+0>.simplify
cmp DX 0
$jmp 12221 "<="
mov AX True
jmp 12222
mov AX False
cmp AX 1
$jmp 12228 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <append_11427+0>.simplify "-" <esp+1>
inc esp
jmp 12228        ;¸õ¦Ü©³³¡
push <append_11427+4>
$mov <append_11427+0>.simplify "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11427+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 12251 "<="
mov AX True
jmp 12252
mov AX False
cmp AX 1
$jmp 12268 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11427+0>.comments      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <append_11427+0>.base
mov <esp+1>[1] ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12268        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "append_11427" "0,1,2,3,4,5,6,7,8,9,10"
pop ip
Function BX 12275 <Code^6> "display_12275" 10
mov <Code^6>.display BX
jmp 12558           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12285 "!="
tf <esp+2> "in" "now_ip"
$jmp 12287 "t"
mov AX 1
$oper AX "-"
mov <esp+2>["now_ip"] AX
jmp 12287
mov <esp+2>["now_ip"] <esp+1>[0]
dec CX
mov <display_12275+2> <esp+2>["now_ip"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "--------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <display_12275+3> <esp+1>
inc esp
mov DX <display_12275+2>
cmp DX <display_12275+3>
$jmp 12312 ">="
mov AX True
jmp 12313
mov AX False
cmp AX 1
$jmp 12328 "!="
push <display_12275+2>
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 12323 "t"
mov AX True
jmp 12324
mov AX False
cmp AX 1
$jmp 12328 "!="
mov AX 1
jmp 12329
mov AX 0
cmp AX 1
$jmp 12349 "!="
push <display_12275+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 12344 ">="
mov AX True
jmp 12345
mov AX False
cmp AX 1
$jmp 12349 "!="
mov AX 1
jmp 12350
mov AX 0
cmp AX 1
$jmp 12365 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <display_12275+0>.comments
mov BX <display_12275+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
push AX[BX]
mov <display_12275+4> <esp+1>
inc esp
jmp 12368        ;¸õ¦Ü©³³¡
push <display_12275+3>
mov <display_12275+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 12546 "f"
mov <display_12275+5> AX
mov DX <display_12275+2>
tf DX "equ" <display_12275+5>
$jmp 12385 "f"
mov AX True
jmp 12386
mov AX False
cmp AX 1
$jmp 12390 "!="   ;¸õ¨ìfalse
mov AX " ¡´ "   ;true item
jmp 12391   ;Â÷¶}sub_if_else
mov AX "   "   ;false item
push AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
push " "
push 4
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
pop AX
oper <esp+1> "+" AX
oper <esp+1> "+" "|"
push <display_12275+0>.code
mov BX <display_12275+5>
pop AX
oper <esp+1> "+" AX[BX]
mov <display_12275+6> <esp+1>
inc esp
push " "
oper <esp+1> "*" 70
mov <display_12275+7> <esp+1>
inc esp
push <display_12275+0>.comments
mov BX <display_12275+5>
pop AX
push AX[BX]
mov <display_12275+8> <esp+1>
inc esp
push <display_12275+8>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 12446 "t"
mov AX True
jmp 12447
mov AX False
cmp AX 1
$jmp 12504 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <display_12275+5>
tf DX "equ" <display_12275+4>
$jmp 12454 "f"
mov AX True
jmp 12455
mov AX False
cmp AX 1
$jmp 12459 "!="   ;¸õ¨ìfalse
mov AX " ¡´ "   ;true item
jmp 12460   ;Â÷¶}sub_if_else
mov AX "   "   ;false item
push AX
push 1        ;Àx¦sCX
push [1]
push <display_12275+8>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
push " "
push 4
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12275+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
pop AX
oper <esp+1> "+" AX
oper <esp+1> "+" "| "
push <display_12275+8>
mov BX 1
pop AX
oper <esp+1> "+" AX[BX]
mov <display_12275+9> <esp+1>
inc esp
jmp 12507        ;¸õ¦Ü©³³¡
push ""
mov <display_12275+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <display_12275+7>
push <display_12275+9>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 40
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" "\r"
oper <esp+1> "+" <display_12275+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov DX <display_12275+5>
cmp DX 100
$jmp 12533 "<="
mov AX True
jmp 12534
mov AX False
cmp AX 1
$jmp 12545 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "row more than 100"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 12546          ;break¥X°j°é
jmp 12545        ;¸õ¦Ü©³³¡
jmp 12377
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "--------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "display_12275" "0,1,2,3,4,5,6,7,8,9"
pop ip
Function BX 12561 <Code^6> "parse_code_12561" 24
mov <Code^6>.parse_code BX
jmp 14600           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


Function <parse_code_12561+2> 12567 None "deal_string_12567" 5 "parse_code_12561"
jmp 12656           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12575 "!="
tf <esp+2> "in" "codeline"
$jmp 12577 "t"
mov <esp+2>["codeline"] None
jmp 12577
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 12583 "!="
tf <esp+2> "in" "k"
$jmp 12585 "t"
mov <esp+2>["k"] None
jmp 12585
mov <esp+2>["k"] <esp+1>[1]
dec CX
mov <deal_string_12567+1> <esp+2>["codeline"]
mov <deal_string_12567+2> <esp+2>["k"]


push <deal_string_12567+1>
mov BX <deal_string_12567+2>
pop AX
push AX[BX]
mov <deal_string_12567+3> <esp+1>
inc esp
push 1
$mov <deal_string_12567+2> "+" <esp+1>
inc esp
push <deal_string_12567+2>
mov <deal_string_12567+4> <esp+1>
inc esp
cmp True 1
$jmp 12635 "!="
push <deal_string_12567+1>
mov BX <deal_string_12567+2>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 12611 "f"
mov AX True
jmp 12612
mov AX False
cmp AX 1
$jmp 12618 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <deal_string_12567+2> "+" <esp+1>
inc esp
jmp 12631        ;¸õ¦Ü©³³¡
push <deal_string_12567+1>
mov BX <deal_string_12567+2>
pop AX
mov DX AX[BX]
tf DX "equ" <deal_string_12567+3>
$jmp 12626 "f"
mov AX True
jmp 12627
mov AX False
cmp AX 1
$jmp 12631 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12635          ;break¥X
jmp 12631        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_12567+2> "+" <esp+1>
inc esp
jmp 12601               ;continue­«¨Ó
push (2)
push <deal_string_12567+3>
push <deal_string_12567+1>
push [3]
mov <esp+1>[0] <deal_string_12567+4>
mov <esp+1>[1] <deal_string_12567+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" <deal_string_12567+3>
pop <esp+1>[0]
mov <esp+1>[1] <deal_string_12567+2>
pop AX
jmp 12653         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_string_12567" "0,1,2,3,4"
pop ip
Function <parse_code_12561+3> 12658 None "login_item_12658" 7 "parse_code_12561"
jmp 12940           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12666 "!="
tf <esp+2> "in" "item"
$jmp 12668 "t"
mov <esp+2>["item"] None
jmp 12668
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <login_item_12658+1> <esp+2>["item"]


tf <parse_code_12561+5> "in" <login_item_12658+1>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 12932 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+0>.data
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <parse_code_12561+0>.data_n
pop DX
cmp DX 100
$jmp 12690 ">="
mov AX True
jmp 12691
mov AX False
cmp AX 1
$jmp 12705 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&code_28+0>
mov <esp+1>[0] AX
oper <esp+1> "*" 1024
$mov <parse_code_12561+0>.data "+" <esp+1>
inc esp
jmp 12705        ;¸õ¦Ü©³³¡
push <parse_code_12561+0>.data_n
push <parse_code_12561+5>
mov BX <login_item_12658+1>
pop AX
mov AX[BX] <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <login_item_12658+1>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 12889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <login_item_12658+1>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <login_item_12658+2> <esp+1>
inc esp
push <login_item_12658+1>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 12746 "f"
mov AX True
jmp 12747
mov AX False
cmp AX 1
$jmp 12882 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
mov BX "\\n"
mov <esp+1>[BX] "\n"
mov BX "\\r"
mov <esp+1>[BX] "\r"
mov BX "\\t"
mov <esp+1>[BX] "\t"
mov BX "\\a"
mov <esp+1>[BX] "\a"
mov BX "\\b"
mov <esp+1>[BX] "\b"
mov BX "\\f"
mov <esp+1>[BX] "\f"
mov BX "\\v"
mov <esp+1>[BX] "\v"
mov BX "\\\""
mov <esp+1>[BX] "\""
mov BX "\\\'"
mov <esp+1>[BX] "\'"
mov BX "\\\\"
mov <esp+1>[BX] "\\"
mov <login_item_12658+3> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12658+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <login_item_12658+4> <esp+1>[0]
mov <login_item_12658+5> <esp+1>[1]
inc esp
push [0]
mov <login_item_12658+6> <esp+1>
inc esp
mov DX <login_item_12658+4>
cmp DX <login_item_12658+5>
$jmp 12793 ">="
mov AX True
jmp 12794
mov AX False
cmp AX 1
$jmp 12868 "!="
push <login_item_12658+2>
mov BX <login_item_12658+4>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 12804 "f"
mov AX True
jmp 12805
mov AX False
cmp AX 1
$jmp 12825 "!="
push <login_item_12658+2>
push [3]
mov <esp+1>[0] <login_item_12658+4>
push <login_item_12658+4>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
tf <login_item_12658+3> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12825 "!="
mov AX 1
jmp 12826
mov AX 0
cmp AX 1
$jmp 12854 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <login_item_12658+3>
push <login_item_12658+2>
push [3]
mov <esp+1>[0] <login_item_12658+4>
push <login_item_12658+4>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <login_item_12658+6>.append
push 1
$mov <login_item_12658+4> "+" <esp+1>
inc esp
jmp 12864        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <login_item_12658+2>
mov BX <login_item_12658+4>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <login_item_12658+6>.append
push 1
$mov <login_item_12658+4> "+" <esp+1>
inc esp
jmp 12788               ;continue­«¨Ó
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12658+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <login_item_12658+2> <esp+1>
inc esp
jmp 12882        ;¸õ¦Ü©³³¡
push <login_item_12658+2>
push <parse_code_12561+0>.data
mov BX <parse_code_12561+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 12928        ;¸õ¦Ü©³³¡
push <login_item_12658+1>
mov BX 0
pop AX
tf "0123456789-" "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12928 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <login_item_12658+1> "in" "."
mov AX TF
cmp AX 1
$jmp 12914 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12658+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
push <parse_code_12561+0>.data
mov BX <parse_code_12561+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 12927        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12658+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
push AX
push <parse_code_12561+0>.data
mov BX <parse_code_12561+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 12928        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_12561+0>.data_n "+" <esp+1>
inc esp
jmp 12932        ;¸õ¦Ü©³³¡
push <parse_code_12561+5>
mov BX <login_item_12658+1>
pop AX
mov AX AX[BX]
jmp 12937         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "login_item_12658" "0,1,2,3,4,5,6"
pop ip
push [dict]
push "mov"
push (2)
mov <esp+1>[0] 0
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "$mov"
push (2)
mov <esp+1>[0] 1
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "oper"
push (2)
mov <esp+1>[0] 2
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "cmp"
push (2)
mov <esp+1>[0] 3
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "jmp"
push (2)
mov <esp+1>[0] 4
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "$jmp"
push (2)
mov <esp+1>[0] 5
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "call"
push (2)
mov <esp+1>[0] 6
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "push"
push (2)
mov <esp+1>[0] 7
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "pop"
push (2)
mov <esp+1>[0] 8
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "tf"
push (2)
mov <esp+1>[0] 9
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "inc"
push (2)
mov <esp+1>[0] 10
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "dec"
push (2)
mov <esp+1>[0] 11
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "$oper"
push (2)
mov <esp+1>[0] 12
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "ex_func"
push (2)
mov <esp+1>[0] 13
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "try"
push (2)
mov <esp+1>[0] 14
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "finally"
push (2)
mov <esp+1>[0] 15
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "raise"
push (2)
mov <esp+1>[0] 16
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "error"
push (2)
mov <esp+1>[0] 17
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "Generator"
push (2)
mov <esp+1>[0] 18
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "Yield"
push (2)
mov <esp+1>[0] 19
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "fetch"
push (2)
mov <esp+1>[0] 20
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "stop"
push (2)
mov <esp+1>[0] 21
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "end"
push (2)
mov <esp+1>[0] 22
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "byte"
push (2)
mov <esp+1>[0] 23
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "del"
push (2)
mov <esp+1>[0] 24
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "Function"
push (2)
mov <esp+1>[0] 25
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "global"
push (2)
mov <esp+1>[0] 26
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "namespace"
push (2)
mov <esp+1>[0] 28
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "pass"
push (2)
mov <esp+1>[0] 26
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "*args"
push (2)
mov <esp+1>[0] 29
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "**kwargs"
push (2)
mov <esp+1>[0] 30
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "module"
push (2)
mov <esp+1>[0] 31
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "type"
push (2)
mov <esp+1>[0] 32
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "name"
push (2)
mov <esp+1>[0] 33
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
mov <parse_code_12561+4> <esp+1>
inc esp
push [dict]
mov BX "AX"
mov <esp+1>[BX] 0
mov BX "BX"
mov <esp+1>[BX] 1
mov BX "CX"
mov <esp+1>[BX] 2
mov BX "DX"
mov <esp+1>[BX] 3
mov BX "ip"
mov <esp+1>[BX] 4
mov BX "esp"
mov <esp+1>[BX] 5
mov BX "sp"
mov <esp+1>[BX] 6
mov BX "ZR"
mov <esp+1>[BX] 7
mov BX "TF"
mov <esp+1>[BX] 8
mov BX "*args"
mov <esp+1>[BX] 9
mov BX "**kwargs"
mov <esp+1>[BX] 10
mov BX "$Exception"
mov <esp+1>[BX] 11
mov BX "True"
mov <esp+1>[BX] 12
mov BX "False"
mov <esp+1>[BX] 13
mov BX "None"
mov <esp+1>[BX] 14
mov BX "$Inheritance"
mov <esp+1>[BX] 15
mov <parse_code_12561+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call tuple
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_12561+0>.data_n <esp+1>
inc esp
push [1]
mov <esp+1>[0] 0
oper <esp+1> "*" <parse_code_12561+0>.data_n
mov <parse_code_12561+0>.data <esp+1>
inc esp
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&code_28+0>
mov <esp+1>[0] AX
oper <esp+1> "*" 1024
$mov <parse_code_12561+0>.data "+" <esp+1>
inc esp
push True
push <parse_code_12561+0>.data
mov BX 12
pop AX
mov AX[BX] <esp+1>
inc esp
push False
push <parse_code_12561+0>.data
mov BX 13
pop AX
mov AX[BX] <esp+1>
inc esp
push None
push <parse_code_12561+0>.data
mov BX 14
pop AX
mov AX[BX] <esp+1>
inc esp
push None
push <parse_code_12561+0>.data
mov BX 15
pop AX
mov AX[BX] <esp+1>
inc esp
push [0]
mov <parse_code_12561+6> <esp+1>
inc esp
ex_func AX "iter" <parse_code_12561+0>.code
push AX
fetch AX <esp+1>
$jmp 14590 "f"
mov <parse_code_12561+7> AX
mov DX <parse_code_12561+7>
tf DX "equ" ""
$jmp 13292 "f"
mov AX True
jmp 13293
mov AX False
cmp AX 1
$jmp 13306 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push [1]
mov <esp+1>[0] 26
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+6>.append
jmp 13284
jmp 13306        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+7>.split
push AX
mov BX 0
pop AX
push AX[BX]
mov <parse_code_12561+8> <esp+1>
inc esp
push <parse_code_12561+4>
mov BX <parse_code_12561+8>
pop AX
push AX[BX]
mov <parse_code_12561+9> <esp+1>
inc esp
push [1]
push <parse_code_12561+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_code_12561+10> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
mov <parse_code_12561+11> <esp+1>
inc esp
push 0
mov <parse_code_12561+12> <esp+1>
inc esp
push <parse_code_12561+12>
push <parse_code_12561+9>
mov BX 1
pop AX
pop DX
cmp DX AX[BX]
$jmp 13355 ">="
mov AX True
jmp 13356
mov AX False
cmp AX 1
$jmp 13395 "=="
push <parse_code_12561+9>
mov BX 1
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 13369 "f"
mov AX True
jmp 13370
mov AX False
cmp AX 1
$jmp 13390 "!="
push <parse_code_12561+11>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 13385 ">="
mov AX True
jmp 13386
mov AX False
cmp AX 1
$jmp 13390 "!="
mov AX 1
jmp 13391
mov AX 0
cmp AX 1
$jmp 13395 "=="
mov AX 0
jmp 13396
mov AX 1
cmp AX 1
$jmp 14582 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_12561+7>
mov BX <parse_code_12561+11>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 13666 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_code_12561+7>
mov <esp+1>[1] <parse_code_12561+11>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+2>
push AX
mov <parse_code_12561+13> <esp+1>[0]
mov <parse_code_12561+11> <esp+1>[1]
inc esp
mov DX <parse_code_12561+12>
tf DX "equ" 1
$jmp 13427 "f"
mov AX True
jmp 13428
mov AX False
cmp AX 1
$jmp 13645 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "$mov"
mov <esp+1>[1] "oper"
mov BX <parse_code_12561+8>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 13502 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (12)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
mov <esp+1>[2] "*"
mov <esp+1>[3] "/"
mov <esp+1>[4] "**"
mov <esp+1>[5] "%"
mov <esp+1>[6] "//"
mov <esp+1>[7] "<<"
mov <esp+1>[8] ">>"
mov <esp+1>[9] "&"
mov <esp+1>[10] "^"
mov <esp+1>[11] "|"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+13>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12561+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13644        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+8>
tf DX "equ" "tf"
$jmp 13507 "f"
mov AX True
jmp 13508
mov AX False
cmp AX 1
$jmp 13565 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (4)
mov <esp+1>[0] "in"
mov <esp+1>[1] "equ"
mov <esp+1>[2] "Ctn"
mov <esp+1>[3] "is"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+13>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12561+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13644        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+8>
tf DX "equ" "$oper"
$jmp 13570 "f"
mov AX True
jmp 13571
mov AX False
cmp AX 1
$jmp 13627 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (3)
mov <esp+1>[0] "not"
mov <esp+1>[1] "-"
mov <esp+1>[2] "~"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+13>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12561+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13644        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13662        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
push 2
$mov <parse_code_12561+11> "+" <esp+1>
inc esp
jmp 14578        ;¸õ¦Ü©³³¡
push <parse_code_12561+7>
mov BX <parse_code_12561+11>
pop AX
tf "0123456789-" "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 13743 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_12561+11>
mov <parse_code_12561+15> <esp+1>
inc esp
push <parse_code_12561+15>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 13689 ">="
mov AX True
jmp 13690
mov AX False
cmp AX 1
$jmp 13701 "!="
push <parse_code_12561+7>
mov BX <parse_code_12561+15>
pop AX
tf "-0123456789." "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 13701 "!="
mov AX 1
jmp 13702
mov AX 0
cmp AX 1
$jmp 13708 "!="
push 1
$mov <parse_code_12561+15> "+" <esp+1>
inc esp
jmp 13676               ;continue­«¨Ó
push <parse_code_12561+7>
push [3]
mov <esp+1>[0] <parse_code_12561+11>
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12561+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
push <parse_code_12561+15>
oper <esp+1> "+" 1
mov <parse_code_12561+11> <esp+1>
inc esp
jmp 14578        ;¸õ¦Ü©³³¡
push <parse_code_12561+7>
mov BX <parse_code_12561+11>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 13751 "f"
mov AX True
jmp 13752
mov AX False
cmp AX 1
$jmp 13865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "]"
mov <esp+1>[1] <parse_code_12561+11>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+7>.index
push AX
mov <parse_code_12561+15> <esp+1>
inc esp
push <parse_code_12561+7>
push [3]
push <parse_code_12561+11>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12561+17> <esp+1>
inc esp
mov DX <parse_code_12561+17>
tf DX "equ" "dict"
$jmp 13785 "f"
mov AX True
jmp 13786
mov AX False
cmp AX 1
$jmp 13801 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 11
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13860        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+17>
tf DX "equ" "class"
$jmp 13806 "f"
mov AX True
jmp 13807
mov AX False
cmp AX 1
$jmp 13822 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 13
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13860        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+17>
tf DX "equ" "func"
$jmp 13827 "f"
mov AX True
jmp 13828
mov AX False
cmp AX 1
$jmp 13843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 16
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 13860        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 10
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
push <parse_code_12561+15>
oper <esp+1> "+" 2
mov <parse_code_12561+11> <esp+1>
inc esp
jmp 14578        ;¸õ¦Ü©³³¡
push <parse_code_12561+7>
mov BX <parse_code_12561+11>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 13873 "f"
mov AX True
jmp 13874
mov AX False
cmp AX 1
$jmp 13921 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ")"
mov <esp+1>[1] <parse_code_12561+11>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+7>.index
push AX
mov <parse_code_12561+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 12
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+7>
push [3]
push <parse_code_12561+11>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
push <parse_code_12561+15>
oper <esp+1> "+" 2
mov <parse_code_12561+11> <esp+1>
inc esp
jmp 14578        ;¸õ¦Ü©³³¡
push ""
mov <parse_code_12561+18> <esp+1>
inc esp
push <parse_code_12561+7>
mov BX <parse_code_12561+11>
pop AX
mov DX AX[BX]
tf DX "equ" "<"
$jmp 13932 "f"
mov AX True
jmp 13933
mov AX False
cmp AX 1
$jmp 14037 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ">"
mov <esp+1>[1] <parse_code_12561+11>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+7>.index
push AX
mov <parse_code_12561+15> <esp+1>
inc esp
push <parse_code_12561+7>
push [3]
push <parse_code_12561+11>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12561+19> <esp+1>
inc esp
tf <parse_code_12561+19> "in" "+"
mov AX TF
cmp AX 1
$jmp 13994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+19>.split
push AX
mov <parse_code_12561+20> <esp+1>
inc esp
push [2]
push <parse_code_12561+20>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+20>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
mov <parse_code_12561+21> <esp+1>
inc esp
jmp 13999        ;¸õ¦Ü©³³¡
push [2]
mov <esp+1>[0] <parse_code_12561+19>
mov <esp+1>[1] 0
mov <parse_code_12561+21> <esp+1>
inc esp
push 1
$mov <parse_code_12561+15> "+" <esp+1>
inc esp
push <parse_code_12561+21>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "esp"
$jmp 14010 "f"
mov AX True
jmp 14011
mov AX False
cmp AX 1
$jmp 14033 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "1"
$mov <parse_code_12561+18> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
push AX
push <parse_code_12561+21>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 14036        ;¸õ¦Ü©³³¡
push "2"
mov <parse_code_12561+18> <esp+1>
inc esp
jmp 14106        ;¸õ¦Ü©³³¡
push <parse_code_12561+11>
mov <parse_code_12561+15> <esp+1>
inc esp
push <parse_code_12561+15>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14053 ">="
mov AX True
jmp 14054
mov AX False
cmp AX 1
$jmp 14066 "!="
push <parse_code_12561+7>
mov BX <parse_code_12561+15>
pop AX
tf "[ ." "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 14066 "!="
mov AX 1
jmp 14067
mov AX 0
cmp AX 1
$jmp 14073 "!="
push 1
$mov <parse_code_12561+15> "+" <esp+1>
inc esp
jmp 14040               ;continue­«¨Ó
push [1]
push <parse_code_12561+7>
push [3]
mov <esp+1>[0] <parse_code_12561+11>
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_code_12561+21> <esp+1>
inc esp
push "0"
$mov <parse_code_12561+18> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
push AX
push <parse_code_12561+21>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_code_12561+15>
oper <esp+1> "+" 1
mov <parse_code_12561+11> <esp+1>
inc esp
push <parse_code_12561+15>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14123 ">="
mov AX True
jmp 14124
mov AX False
cmp AX 1
$jmp 14139 "!="
push <parse_code_12561+7>
mov BX <parse_code_12561+15>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 14134 "f"
mov AX True
jmp 14135
mov AX False
cmp AX 1
$jmp 14139 "!="
mov AX 1
jmp 14140
mov AX 0
cmp AX 1
$jmp 14206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_12561+15> "+" <esp+1>
inc esp
push <parse_code_12561+15>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14158 ">="
mov AX True
jmp 14159
mov AX False
cmp AX 1
$jmp 14171 "!="
push <parse_code_12561+7>
mov BX <parse_code_12561+15>
pop AX
tf "[ ." "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 14171 "!="
mov AX 1
jmp 14172
mov AX 0
cmp AX 1
$jmp 14178 "!="
push 1
$mov <parse_code_12561+15> "+" <esp+1>
inc esp
jmp 14145               ;continue­«¨Ó
push <parse_code_12561+7>
push [3]
mov <esp+1>[0] <parse_code_12561+11>
mov <esp+1>[1] <parse_code_12561+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12561+22> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+22>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+21>.append
push "0"
$mov <parse_code_12561+18> "+" <esp+1>
inc esp
push <parse_code_12561+15>
oper <esp+1> "+" 1
mov <parse_code_12561+11> <esp+1>
inc esp
jmp 14206        ;¸õ¦Ü©³³¡
push <parse_code_12561+15>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14219 ">="
mov AX True
jmp 14220
mov AX False
cmp AX 1
$jmp 14235 "!="
push <parse_code_12561+7>
mov BX <parse_code_12561+15>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 14230 "f"
mov AX True
jmp 14231
mov AX False
cmp AX 1
$jmp 14235 "!="
mov AX 1
jmp 14236
mov AX 0
cmp AX 1
$jmp 14332 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_12561+7>
push <parse_code_12561+15>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 14284 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_code_12561+7>
push <parse_code_12561+15>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+2>
push AX
mov <parse_code_12561+17> <esp+1>[0]
mov <parse_code_12561+23> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+21>.append
push 1
$mov <parse_code_12561+23> "+" <esp+1>
inc esp
jmp 14324        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "]"
mov <esp+1>[1] <parse_code_12561+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+7>.index
push AX
mov <parse_code_12561+23> <esp+1>
inc esp
push <parse_code_12561+7>
push [3]
push <parse_code_12561+15>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12561+23>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12561+17> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+3>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+21>.append
push "1"
$mov <parse_code_12561+18> "+" <esp+1>
inc esp
push <parse_code_12561+23>
oper <esp+1> "+" 2
mov <parse_code_12561+11> <esp+1>
inc esp
jmp 14332        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "0"
$jmp 14337 "f"
mov AX True
jmp 14338
mov AX False
cmp AX 1
$jmp 14354 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "00"
$jmp 14359 "f"
mov AX True
jmp 14360
mov AX False
cmp AX 1
$jmp 14380 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 1
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "01"
$jmp 14385 "f"
mov AX True
jmp 14386
mov AX False
cmp AX 1
$jmp 14406 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 2
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "1"
$jmp 14411 "f"
mov AX True
jmp 14412
mov AX False
cmp AX 1
$jmp 14432 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 3
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "10"
$jmp 14437 "f"
mov AX True
jmp 14438
mov AX False
cmp AX 1
$jmp 14462 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 4
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12561+21>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "11"
$jmp 14467 "f"
mov AX True
jmp 14468
mov AX False
cmp AX 1
$jmp 14492 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 5
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12561+21>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "2"
$jmp 14497 "f"
mov AX True
jmp 14498
mov AX False
cmp AX 1
$jmp 14518 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 6
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "20"
$jmp 14523 "f"
mov AX True
jmp 14524
mov AX False
cmp AX 1
$jmp 14548 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 7
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12561+21>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
mov DX <parse_code_12561+18>
tf DX "equ" "21"
$jmp 14553 "f"
mov AX True
jmp 14554
mov AX False
cmp AX 1
$jmp 14578 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 8
push <parse_code_12561+21>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12561+21>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12561+21>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+10>.append
jmp 14578        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_12561+12> "+" <esp+1>
inc esp
jmp 13346               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12561+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12561+6>.append
jmp 13284
inc esp
push (3)
mov <esp+1>[0] <parse_code_12561+6>
mov <esp+1>[1] <parse_code_12561+0>.data
mov <esp+1>[2] <parse_code_12561+5>
pop AX
jmp 14597         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_code_12561" "0,1,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
pop ip
Function BX 14603 <Code^6> "__len___14603" 2
mov <Code^6>.__len__ BX
jmp 14618           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___14603+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 14615         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___14603" "0,1"
pop ip
Function BX 14621 <Code^6> "__getitem___14621" 3
mov <Code^6>.__getitem__ BX
jmp 14642           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14629 "!="
tf <esp+2> "in" "item"
$jmp 14631 "t"
mov <esp+2>["item"] None
jmp 14631
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___14621+2> <esp+2>["item"]


push <__getitem___14621+0>.code
mov BX <__getitem___14621+2>
pop AX
mov AX AX[BX]
jmp 14639         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___14621" "0,1,2"
pop ip
Function BX 14645 <Code^6> "__setitem___14645" 4
mov <Code^6>.__setitem__ BX
jmp 14677           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14653 "!="
tf <esp+2> "in" "key"
$jmp 14655 "t"
mov <esp+2>["key"] None
jmp 14655
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 14661 "!="
tf <esp+2> "in" "value"
$jmp 14663 "t"
mov <esp+2>["value"] None
jmp 14663
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___14645+2> <esp+2>["key"]
mov <__setitem___14645+3> <esp+2>["value"]


push <__setitem___14645+3>
push <__setitem___14645+0>.code
mov BX <__setitem___14645+2>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___14645" "0,1,2,3"
pop ip
mov AX <Code^6>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 14689 "=="
tf AX "Ctn" "__init__"
$jmp 14687 "t"
jmp 14689
call AX.__init__
mov AX <Code^6>
end "Function" "Code^6"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/code.py"]
mov <&package_6+5> <esp+1>.Code
inc esp
mov &apython_14695 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &module_14697 "&module_14697" "Integer,Float,String,Byte,Var_name,Namespace,Variable,SubVariable,Slice,IndexVariable,List,Tuple,Dict,Set,is_number,Lambda,Def,FuncCall,Backtrack,Var_declare,Try_Except,With,Stop,Command,sub_if_else,If_else,While,sub_for_loop,For_loop,Mark,Pass,TFN,Class,two_object_write,Multiple_Mov,Oper,Tf,AndOr,Deny,Bool,Assert,STR,Info"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/module.py"] &module_14697
mov &tem_import_14695 &module_14697
Function <&module_14697+0> 14702 None "Integer^16" 1
name <&module_14697+0> "<class '__main__.Integer'>"
jmp 14804
tf $Inheritance "equ" None
$jmp 14707 "t"
mov <Integer^16> $Inheritance
push 1
jmp 14709
mov <Integer^16> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Integer^16> <&module_14697+0>
Function BX 14717 <Integer^16> "__init___14717" 3
mov <Integer^16>.__init__ BX
jmp 14744           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14725 "!="
tf <esp+2> "in" "number"
$jmp 14727 "t"
mov <esp+2>["number"] None
jmp 14727
mov <esp+2>["number"] <esp+1>[0]
dec CX
mov <__init___14717+2> <esp+2>["number"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___14717+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
push AX
mov <__init___14717+0>.number <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___14717" "0,1,2"
pop ip
Function BX 14747 <Integer^16> "__str___14747" 2
mov <Integer^16>.__str__ BX
jmp 14760           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___14747+0>.number
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 14757         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___14747" "0,1"
pop ip
Function BX 14763 <Integer^16> "write_14763" 3
mov <Integer^16>.write BX
jmp 14790           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14771 "!="
tf <esp+2> "in" "codes"
$jmp 14773 "t"
mov <esp+2>["codes"] None
jmp 14773
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_14763+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_14763+0>.number
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <write_14763+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_14763" "0,1,2"
pop ip
mov AX <Integer^16>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 14802 "=="
tf AX "Ctn" "__init__"
$jmp 14800 "t"
jmp 14802
call AX.__init__
mov AX <Integer^16>
end "Function" "Integer^16"
pop ip
Function <&module_14697+1> 14807 None "Float^17" 1
name <&module_14697+1> "<class '__main__.Float'>"
jmp 14909
tf $Inheritance "equ" None
$jmp 14812 "t"
mov <Float^17> $Inheritance
push 1
jmp 14814
mov <Float^17> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Float^17> <&module_14697+1>
Function BX 14822 <Float^17> "__init___14822" 3
mov <Float^17>.__init__ BX
jmp 14849           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14830 "!="
tf <esp+2> "in" "number"
$jmp 14832 "t"
mov <esp+2>["number"] None
jmp 14832
mov <esp+2>["number"] <esp+1>[0]
dec CX
mov <__init___14822+2> <esp+2>["number"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___14822+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
mov <__init___14822+0>.number <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___14822" "0,1,2"
pop ip
Function BX 14852 <Float^17> "__str___14852" 2
mov <Float^17>.__str__ BX
jmp 14865           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___14852+0>.number
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 14862         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___14852" "0,1"
pop ip
Function BX 14868 <Float^17> "write_14868" 3
mov <Float^17>.write BX
jmp 14895           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14876 "!="
tf <esp+2> "in" "codes"
$jmp 14878 "t"
mov <esp+2>["codes"] None
jmp 14878
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_14868+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_14868+0>.number
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <write_14868+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_14868" "0,1,2"
pop ip
mov AX <Float^17>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 14907 "=="
tf AX "Ctn" "__init__"
$jmp 14905 "t"
jmp 14907
call AX.__init__
mov AX <Float^17>
end "Function" "Float^17"
pop ip
Function <&module_14697+2> 14912 None "String^18" 1
name <&module_14697+2> "<class '__main__.String'>"
jmp 15024
tf $Inheritance "equ" None
$jmp 14917 "t"
mov <String^18> $Inheritance
push 1
jmp 14919
mov <String^18> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <String^18> <&module_14697+2>
Function BX 14927 <String^18> "__init___14927" 4
mov <String^18>.__init__ BX
jmp 14959           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14935 "!="
tf <esp+2> "in" "text"
$jmp 14937 "t"
mov <esp+2>["text"] None
jmp 14937
mov <esp+2>["text"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 14943 "!="
tf <esp+2> "in" "change"
$jmp 14945 "t"
mov <esp+2>["change"] True
jmp 14945
mov <esp+2>["change"] <esp+1>[1]
dec CX
mov <__init___14927+2> <esp+2>["text"]
mov <__init___14927+3> <esp+2>["change"]


push <__init___14927+2>
mov <__init___14927+0>.text <esp+1>
inc esp
push <__init___14927+3>
mov <__init___14927+0>.change <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___14927" "0,1,2,3"
pop ip
Function BX 14962 <String^18> "__str___14962" 2
mov <String^18>.__str__ BX
jmp 14975           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "\""
ex_func AX "str" <__str___14962+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 14972         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___14962" "0,1"
pop ip
Function BX 14978 <String^18> "write_14978" 3
mov <String^18>.write BX
jmp 15010           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14986 "!="
tf <esp+2> "in" "codes"
$jmp 14988 "t"
mov <esp+2>["codes"] None
jmp 14988
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_14978+2> <esp+2>["codes"]


cmp <write_14978+0>.change 1
$jmp 15000 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "\""
ex_func AX "str" <write_14978+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_14978+0>.location <esp+1>
inc esp
jmp 15006        ;¸õ¦Ü©³³¡
push "\'"
ex_func AX "str" <write_14978+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\'"
mov <write_14978+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_14978" "0,1,2"
pop ip
mov AX <String^18>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15022 "=="
tf AX "Ctn" "__init__"
$jmp 15020 "t"
jmp 15022
call AX.__init__
mov AX <String^18>
end "Function" "String^18"
pop ip
Function <&module_14697+3> 15027 None "Byte^19" 1
name <&module_14697+3> "<class '__main__.Byte'>"
jmp 15126
tf $Inheritance "equ" None
$jmp 15032 "t"
mov <Byte^19> $Inheritance
push 1
jmp 15034
mov <Byte^19> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Byte^19> <&module_14697+3>
Function BX 15042 <Byte^19> "__init___15042" 3
mov <Byte^19>.__init__ BX
jmp 15062           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15050 "!="
tf <esp+2> "in" "text"
$jmp 15052 "t"
mov <esp+2>["text"] None
jmp 15052
mov <esp+2>["text"] <esp+1>[0]
dec CX
mov <__init___15042+2> <esp+2>["text"]


push <__init___15042+2>
mov <__init___15042+0>.text <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15042" "0,1,2"
pop ip
Function BX 15065 <Byte^19> "__str___15065" 2
mov <Byte^19>.__str__ BX
jmp 15078           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "\""
ex_func AX "str" <__str___15065+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 15075         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15065" "0,1"
pop ip
Function BX 15081 <Byte^19> "write_15081" 3
mov <Byte^19>.write BX
jmp 15112           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15089 "!="
tf <esp+2> "in" "codes"
$jmp 15091 "t"
mov <esp+2>["codes"] None
jmp 15091
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15081+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "byte AX \""
ex_func AX "str" <write_15081+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15081+2>.append
push "AX"
mov <write_15081+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15081" "0,1,2"
pop ip
mov AX <Byte^19>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15124 "=="
tf AX "Ctn" "__init__"
$jmp 15122 "t"
jmp 15124
call AX.__init__
mov AX <Byte^19>
end "Function" "Byte^19"
pop ip
Function <&module_14697+4> 15129 None "Var_name^20" 1
name <&module_14697+4> "<class '__main__.Var_name'>"
jmp 15194
tf $Inheritance "equ" None
$jmp 15134 "t"
mov <Var_name^20> $Inheritance
push 1
jmp 15136
mov <Var_name^20> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Var_name^20> <&module_14697+4>
Function BX 15144 <Var_name^20> "__init___15144" 3
mov <Var_name^20>.__init__ BX
jmp 15164           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15152 "!="
tf <esp+2> "in" "name"
$jmp 15154 "t"
mov <esp+2>["name"] None
jmp 15154
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <__init___15144+2> <esp+2>["name"]


push <__init___15144+2>
mov <__init___15144+0>.name <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15144" "0,1,2"
pop ip
Function BX 15167 <Var_name^20> "__str___15167" 2
mov <Var_name^20>.__str__ BX
jmp 15180           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15167+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15177         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15167" "0,1"
pop ip
mov AX <Var_name^20>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15192 "=="
tf AX "Ctn" "__init__"
$jmp 15190 "t"
jmp 15192
call AX.__init__
mov AX <Var_name^20>
end "Function" "Var_name^20"
pop ip
Function <&module_14697+5> 15197 None "Namespace^21" 1
name <&module_14697+5> "<class '__main__.Namespace'>"
jmp 15342
tf $Inheritance "equ" None
$jmp 15202 "t"
mov <Namespace^21> $Inheritance
push 1
jmp 15204
mov <Namespace^21> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Namespace^21> <&module_14697+5>
Function BX 15212 <Namespace^21> "__init___15212" 3
mov <Namespace^21>.__init__ BX
jmp 15232           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15220 "!="
tf <esp+2> "in" "namespace"
$jmp 15222 "t"
mov <esp+2>["namespace"] ""
jmp 15222
mov <esp+2>["namespace"] <esp+1>[0]
dec CX
mov <__init___15212+2> <esp+2>["namespace"]


push <__init___15212+2>
mov <__init___15212+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15212" "0,1,2"
pop ip
Function BX 15235 <Namespace^21> "__str___15235" 2
mov <Namespace^21>.__str__ BX
jmp 15248           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15235+0>.namespace
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15245         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15235" "0,1"
pop ip
Function BX 15251 <Namespace^21> "__eq___15251" 3
mov <Namespace^21>.__eq__ BX
jmp 15274           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15259 "!="
tf <esp+2> "in" "other"
$jmp 15261 "t"
mov <esp+2>["other"] None
jmp 15261
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__eq___15251+2> <esp+2>["other"]


mov DX <__eq___15251+0>.namespace
tf DX "equ" <__eq___15251+2>
$jmp 15269 "f"
mov AX True
jmp 15270
mov AX False
jmp 15271         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__eq___15251" "0,1,2"
pop ip
Function BX 15277 <Namespace^21> "__contains___15277" 3
mov <Namespace^21>.__contains__ BX
jmp 15296           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15285 "!="
tf <esp+2> "in" "item"
$jmp 15287 "t"
mov <esp+2>["item"] None
jmp 15287
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___15277+2> <esp+2>["item"]


tf <__contains___15277+0>.namespace "in" <__contains___15277+2>
mov AX TF
jmp 15293         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___15277" "0,1,2"
pop ip
Function BX 15299 <Namespace^21> "write_15299" 3
mov <Namespace^21>.write BX
jmp 15328           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15307 "!="
tf <esp+2> "in" "codes"
$jmp 15309 "t"
mov <esp+2>["codes"] None
jmp 15309
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15299+2> <esp+2>["codes"]


mov DX <write_15299+0>.namespace
tf DX "equ" ""
$jmp 15317 "t"
mov AX True
jmp 15318
mov AX False
cmp AX 1
$jmp 15324 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_15299+0>.namespace
mov <write_15299+0>.location <esp+1>
inc esp
jmp 15324        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15299" "0,1,2"
pop ip
mov AX <Namespace^21>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15340 "=="
tf AX "Ctn" "__init__"
$jmp 15338 "t"
jmp 15340
call AX.__init__
mov AX <Namespace^21>
end "Function" "Namespace^21"
pop ip
Function <&module_14697+6> 15345 None "Variable^22" 1
name <&module_14697+6> "<class '__main__.Variable'>"
jmp 15474
tf $Inheritance "equ" None
$jmp 15350 "t"
mov <Variable^22> $Inheritance
push 1
jmp 15352
mov <Variable^22> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Variable^22> <&module_14697+6>
Function BX 15360 <Variable^22> "__init___15360" 4
mov <Variable^22>.__init__ BX
jmp 15392           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15368 "!="
tf <esp+2> "in" "name"
$jmp 15370 "t"
mov <esp+2>["name"] None
jmp 15370
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15376 "!="
tf <esp+2> "in" "namespace"
$jmp 15378 "t"
mov <esp+2>["namespace"] None
jmp 15378
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <__init___15360+2> <esp+2>["name"]
mov <__init___15360+3> <esp+2>["namespace"]


push <__init___15360+3>
mov <__init___15360+0>.namespace <esp+1>
inc esp
push <__init___15360+2>
mov <__init___15360+0>.name <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15360" "0,1,2,3"
pop ip
Function BX 15395 <Variable^22> "__str___15395" 2
mov <Variable^22>.__str__ BX
jmp 15408           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<var="
ex_func AX "str" <__str___15395+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 15405         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15395" "0,1"
pop ip
Function BX 15411 <Variable^22> "write_15411" 3
mov <Variable^22>.write BX
jmp 15460           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15419 "!="
tf <esp+2> "in" "codes"
$jmp 15421 "t"
mov <esp+2>["codes"] None
jmp 15421
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15411+2> <esp+2>["codes"]


mov DX <write_15411+0>.namespace
tf DX "equ" ""
$jmp 15429 "t"
mov AX True
jmp 15430
mov AX False
cmp AX 1
$jmp 15453 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_15411+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15411+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_15411+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_15411+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15411+0>.location <esp+1>
inc esp
jmp 15456        ;¸õ¦Ü©³³¡
push <write_15411+0>.name
mov <write_15411+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15411" "0,1,2"
pop ip
mov AX <Variable^22>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15472 "=="
tf AX "Ctn" "__init__"
$jmp 15470 "t"
jmp 15472
call AX.__init__
mov AX <Variable^22>
end "Function" "Variable^22"
pop ip
Function <&module_14697+7> 15477 None "SubVariable^23" 1
name <&module_14697+7> "<class '__main__.SubVariable'>"
jmp 15652
tf $Inheritance "equ" None
$jmp 15482 "t"
mov <SubVariable^23> $Inheritance
push 1
jmp 15484
mov <SubVariable^23> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <SubVariable^23> <&module_14697+7>
Function BX 15492 <SubVariable^23> "__init___15492" 4
mov <SubVariable^23>.__init__ BX
jmp 15524           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15500 "!="
tf <esp+2> "in" "obj"
$jmp 15502 "t"
mov <esp+2>["obj"] None
jmp 15502
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15508 "!="
tf <esp+2> "in" "attr"
$jmp 15510 "t"
mov <esp+2>["attr"] None
jmp 15510
mov <esp+2>["attr"] <esp+1>[1]
dec CX
mov <__init___15492+2> <esp+2>["obj"]
mov <__init___15492+3> <esp+2>["attr"]


push <__init___15492+2>
mov <__init___15492+0>.obj <esp+1>
inc esp
push <__init___15492+3>
mov <__init___15492+0>.attr <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15492" "0,1,2,3"
pop ip
Function BX 15527 <SubVariable^23> "__str___15527" 2
mov <SubVariable^23>.__str__ BX
jmp 15543           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<obj="
ex_func AX "str" <__str___15527+0>.obj
oper <esp+1> "+" AX
oper <esp+1> "+" "  attr="
ex_func AX "str" <__str___15527+0>.attr
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 15540         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15527" "0,1"
pop ip
Function BX 15546 <SubVariable^23> "write_15546" 4
mov <SubVariable^23>.write BX
jmp 15638           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15554 "!="
tf <esp+2> "in" "codes"
$jmp 15556 "t"
mov <esp+2>["codes"] None
jmp 15556
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15546+2> <esp+2>["codes"]


mov AX <write_15546+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15546+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_15546+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
mov <write_15546+3> <esp+1>
inc esp
tf <write_15546+3> "in" "."
mov AX TF
cmp AX 1
$jmp 15583 "=="
tf <write_15546+3> "in" "["
mov AX TF
cmp AX 1
$jmp 15583 "=="
mov AX 0
jmp 15584
mov AX 1
cmp AX 1
$jmp 15600 "=="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_15546+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 15600 "=="
mov AX 0
jmp 15601
mov AX 1
cmp AX 1
$jmp 15623 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_15546+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15546+2>.append
push "AX."
mov AX <write_15546+0>.attr      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15546+0>.location <esp+1>
inc esp
jmp 15634        ;¸õ¦Ü©³³¡
push ""
mov AX <write_15546+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov AX <write_15546+0>.attr      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15546+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15546" "0,1,2,3"
pop ip
mov AX <SubVariable^23>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15650 "=="
tf AX "Ctn" "__init__"
$jmp 15648 "t"
jmp 15650
call AX.__init__
mov AX <SubVariable^23>
end "Function" "SubVariable^23"
pop ip
Function <&module_14697+8> 15655 None "Slice^24" 1
name <&module_14697+8> "<class '__main__.Slice'>"
jmp 15857
tf $Inheritance "equ" None
$jmp 15660 "t"
mov <Slice^24> $Inheritance
push 1
jmp 15662
mov <Slice^24> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Slice^24> <&module_14697+8>
Function BX 15670 <Slice^24> "__init___15670" 5
mov <Slice^24>.__init__ BX
jmp 15714           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15678 "!="
tf <esp+2> "in" "start_obj"
$jmp 15680 "t"
mov <esp+2>["start_obj"] None
jmp 15680
mov <esp+2>["start_obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15686 "!="
tf <esp+2> "in" "end_obj"
$jmp 15688 "t"
mov <esp+2>["end_obj"] None
jmp 15688
mov <esp+2>["end_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 15694 "!="
tf <esp+2> "in" "step_obj"
$jmp 15696 "t"
mov <esp+2>["step_obj"] None
jmp 15696
mov <esp+2>["step_obj"] <esp+1>[2]
dec CX
mov <__init___15670+2> <esp+2>["start_obj"]
mov <__init___15670+3> <esp+2>["end_obj"]
mov <__init___15670+4> <esp+2>["step_obj"]


push <__init___15670+2>
mov <__init___15670+0>.start_obj <esp+1>
inc esp
push <__init___15670+3>
mov <__init___15670+0>.end_obj <esp+1>
inc esp
push <__init___15670+4>
mov <__init___15670+0>.step_obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15670" "0,1,2,3,4"
pop ip
Function BX 15717 <Slice^24> "__str___15717" 2
mov <Slice^24>.__str__ BX
jmp 15726           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<slice>"
jmp 15723         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15717" "0,1"
pop ip
Function BX 15729 <Slice^24> "write_15729" 3
mov <Slice^24>.write BX
jmp 15843           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15737 "!="
tf <esp+2> "in" "codes"
$jmp 15739 "t"
mov <esp+2>["codes"] None
jmp 15739
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15729+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [3]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
mov AX <write_15729+0>.start_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15729+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[0] "
mov AX <write_15729+0>.start_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
mov AX <write_15729+0>.end_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15729+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[1] "
mov AX <write_15729+0>.end_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
mov AX <write_15729+0>.step_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15729+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[2] "
mov AX <write_15729+0>.step_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call slice"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15729+2>.append
push "AX"
mov <write_15729+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15729" "0,1,2"
pop ip
mov AX <Slice^24>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15855 "=="
tf AX "Ctn" "__init__"
$jmp 15853 "t"
jmp 15855
call AX.__init__
mov AX <Slice^24>
end "Function" "Slice^24"
pop ip
Function <&module_14697+9> 15860 None "IndexVariable^25" 1
name <&module_14697+9> "<class '__main__.IndexVariable'>"
jmp 16014
tf $Inheritance "equ" None
$jmp 15865 "t"
mov <IndexVariable^25> $Inheritance
push 1
jmp 15867
mov <IndexVariable^25> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <IndexVariable^25> <&module_14697+9>
Function BX 15875 <IndexVariable^25> "__init___15875" 4
mov <IndexVariable^25>.__init__ BX
jmp 15907           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15883 "!="
tf <esp+2> "in" "name"
$jmp 15885 "t"
mov <esp+2>["name"] None
jmp 15885
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15891 "!="
tf <esp+2> "in" "slice_obj"
$jmp 15893 "t"
mov <esp+2>["slice_obj"] None
jmp 15893
mov <esp+2>["slice_obj"] <esp+1>[1]
dec CX
mov <__init___15875+2> <esp+2>["name"]
mov <__init___15875+3> <esp+2>["slice_obj"]


push <__init___15875+2>
mov <__init___15875+0>.name <esp+1>
inc esp
push <__init___15875+3>
mov <__init___15875+0>.slice_obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15875" "0,1,2,3"
pop ip
Function BX 15910 <IndexVariable^25> "__str___15910" 2
mov <IndexVariable^25>.__str__ BX
jmp 15926           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Index "
ex_func AX "str" <__str___15910+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " slice="
ex_func AX "str" <__str___15910+0>.slice_obj
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 15923         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15910" "0,1"
pop ip
Function BX 15929 <IndexVariable^25> "write_15929" 3
mov <IndexVariable^25>.write BX
jmp 16000           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15937 "!="
tf <esp+2> "in" "codes"
$jmp 15939 "t"
mov <esp+2>["codes"] None
jmp 15939
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15929+2> <esp+2>["codes"]


mov AX <write_15929+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15929+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_15929+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15929+2>.append
mov AX <write_15929+0>.slice_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15929+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov BX "
mov AX <write_15929+0>.slice_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15929+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15929+2>.append
push "AX[BX]"
mov <write_15929+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15929" "0,1,2"
pop ip
mov AX <IndexVariable^25>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16012 "=="
tf AX "Ctn" "__init__"
$jmp 16010 "t"
jmp 16012
call AX.__init__
mov AX <IndexVariable^25>
end "Function" "IndexVariable^25"
pop ip
Function <&module_14697+10> 16017 None "List^26" 1
name <&module_14697+10> "<class '__main__.List'>"
jmp 16284
tf $Inheritance "equ" None
$jmp 16022 "t"
mov <List^26> $Inheritance
push 1
jmp 16024
mov <List^26> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <List^26> <&module_14697+10>
Function BX 16032 <List^26> "__init___16032" 3
mov <List^26>.__init__ BX
jmp 16052           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16040 "!="
tf <esp+2> "in" "elements"
$jmp 16042 "t"
mov <esp+2>["elements"] None
jmp 16042
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16032+2> <esp+2>["elements"]


push <__init___16032+2>
mov <__init___16032+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16032" "0,1,2"
pop ip
Function BX 16055 <List^26> "__str___16055" 4
mov <List^26>.__str__ BX
jmp 16101           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16055+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16055+0>.elements
push AX
fetch AX <esp+1>
$jmp 16082 "f"
mov <__str___16055+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16055+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16055+2>.append
jmp 16064
inc esp
push "<List  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16055+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16098         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16055" "0,1,2,3"
pop ip
Function BX 16104 <List^26> "__getitem___16104" 3
mov <List^26>.__getitem__ BX
jmp 16145           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16112 "!="
tf <esp+2> "in" "j"
$jmp 16114 "t"
mov <esp+2>["j"] None
jmp 16114
mov <esp+2>["j"] <esp+1>[0]
dec CX
mov <__getitem___16104+2> <esp+2>["j"]


push <__getitem___16104+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___16104+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 16130 ">="
mov AX True
jmp 16131
mov AX False
cmp AX 1
$jmp 16139 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___16104+0>.elements
mov BX <__getitem___16104+2>
pop AX
mov AX AX[BX]
jmp 16142
jmp 16139        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___16104" "0,1,2"
pop ip
Function BX 16148 <List^26> "__len___16148" 2
mov <List^26>.__len__ BX
jmp 16163           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16148+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16160         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16148" "0,1"
pop ip
Function BX 16166 <List^26> "write_16166" 4
mov <List^26>.write BX
jmp 16270           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16174 "!="
tf <esp+2> "in" "codes"
$jmp 16176 "t"
mov <esp+2>["codes"] None
jmp 16176
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16166+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "mov AX ["
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16166+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16166+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16166+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16166+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 16255 "f"
mov <write_16166+3> AX
push <write_16166+0>.elements
mov BX <write_16166+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16166+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>["
ex_func AX "str" <write_16166+3>
oper <esp+1> "+" AX
oper <esp+1> "+" "] "
push <write_16166+0>.elements
mov BX <write_16166+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16166+2>.append
jmp 16220
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16166+2>.append
push "AX"
mov <write_16166+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16166" "0,1,2,3"
pop ip
mov AX <List^26>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16282 "=="
tf AX "Ctn" "__init__"
$jmp 16280 "t"
jmp 16282
call AX.__init__
mov AX <List^26>
end "Function" "List^26"
pop ip
Function <&module_14697+11> 16287 None "Tuple^27" 1
name <&module_14697+11> "<class '__main__.Tuple'>"
jmp 16554
tf $Inheritance "equ" None
$jmp 16292 "t"
mov <Tuple^27> $Inheritance
push 1
jmp 16294
mov <Tuple^27> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Tuple^27> <&module_14697+11>
Function BX 16302 <Tuple^27> "__init___16302" 3
mov <Tuple^27>.__init__ BX
jmp 16322           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16310 "!="
tf <esp+2> "in" "elements"
$jmp 16312 "t"
mov <esp+2>["elements"] None
jmp 16312
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16302+2> <esp+2>["elements"]


push <__init___16302+2>
mov <__init___16302+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16302" "0,1,2"
pop ip
Function BX 16325 <Tuple^27> "__str___16325" 4
mov <Tuple^27>.__str__ BX
jmp 16371           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16325+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16325+0>.elements
push AX
fetch AX <esp+1>
$jmp 16352 "f"
mov <__str___16325+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16325+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16325+2>.append
jmp 16334
inc esp
push "<Tuple  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16325+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16368         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16325" "0,1,2,3"
pop ip
Function BX 16374 <Tuple^27> "__getitem___16374" 3
mov <Tuple^27>.__getitem__ BX
jmp 16415           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16382 "!="
tf <esp+2> "in" "j"
$jmp 16384 "t"
mov <esp+2>["j"] None
jmp 16384
mov <esp+2>["j"] <esp+1>[0]
dec CX
mov <__getitem___16374+2> <esp+2>["j"]


push <__getitem___16374+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___16374+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 16400 ">="
mov AX True
jmp 16401
mov AX False
cmp AX 1
$jmp 16409 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___16374+0>.elements
mov BX <__getitem___16374+2>
pop AX
mov AX AX[BX]
jmp 16412
jmp 16409        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___16374" "0,1,2"
pop ip
Function BX 16418 <Tuple^27> "__len___16418" 2
mov <Tuple^27>.__len__ BX
jmp 16433           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16418+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16430         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16418" "0,1"
pop ip
Function BX 16436 <Tuple^27> "write_16436" 4
mov <Tuple^27>.write BX
jmp 16540           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16444 "!="
tf <esp+2> "in" "codes"
$jmp 16446 "t"
mov <esp+2>["codes"] None
jmp 16446
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16436+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "mov AX ("
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16436+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ")"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16436+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16436+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16436+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 16525 "f"
mov <write_16436+3> AX
push <write_16436+0>.elements
mov BX <write_16436+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16436+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>["
ex_func AX "str" <write_16436+3>
oper <esp+1> "+" AX
oper <esp+1> "+" "] "
push <write_16436+0>.elements
mov BX <write_16436+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16436+2>.append
jmp 16490
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16436+2>.append
push "AX"
mov <write_16436+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16436" "0,1,2,3"
pop ip
mov AX <Tuple^27>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16552 "=="
tf AX "Ctn" "__init__"
$jmp 16550 "t"
jmp 16552
call AX.__init__
mov AX <Tuple^27>
end "Function" "Tuple^27"
pop ip
Function <&module_14697+12> 16557 None "Dict^28" 1
name <&module_14697+12> "<class '__main__.Dict'>"
jmp 16762
tf $Inheritance "equ" None
$jmp 16562 "t"
mov <Dict^28> $Inheritance
push 1
jmp 16564
mov <Dict^28> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Dict^28> <&module_14697+12>
Function BX 16572 <Dict^28> "__init___16572" 3
mov <Dict^28>.__init__ BX
jmp 16592           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16580 "!="
tf <esp+2> "in" "elements"
$jmp 16582 "t"
mov <esp+2>["elements"] None
jmp 16582
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16572+2> <esp+2>["elements"]


push <__init___16572+2>
mov <__init___16572+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16572" "0,1,2"
pop ip
Function BX 16595 <Dict^28> "__str___16595" 5
mov <Dict^28>.__str__ BX
jmp 16642           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16595+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16595+0>.elements
push AX
fetch AX <esp+1>
$jmp 16623 "f"
mov <__str___16595+3> AX[0]
mov <__str___16595+4> AX[1]
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__str___16595+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
ex_func AX "str" <__str___16595+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16595+2>.append
jmp 16604
inc esp
push "<Dict  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16595+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16639         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16595" "0,1,2,3,4"
pop ip
Function BX 16645 <Dict^28> "__len___16645" 2
mov <Dict^28>.__len__ BX
jmp 16660           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16645+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16657         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16645" "0,1"
pop ip
Function BX 16663 <Dict^28> "write_16663" 5
mov <Dict^28>.write BX
jmp 16748           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16671 "!="
tf <esp+2> "in" "codes"
$jmp 16673 "t"
mov <esp+2>["codes"] None
jmp 16673
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16663+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+2>.append
ex_func AX "iter" <write_16663+0>.elements
push AX
fetch AX <esp+1>
$jmp 16733 "f"
mov <write_16663+3> AX[0]
mov <write_16663+4> AX[1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16663+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+3>.write
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_16663+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16663+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+4>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[BX] "
ex_func AX "str" <write_16663+4>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+2>.append
jmp 16685
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16663+2>.append
push "AX"
mov <write_16663+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16663" "0,1,2,3,4"
pop ip
mov AX <Dict^28>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16760 "=="
tf AX "Ctn" "__init__"
$jmp 16758 "t"
jmp 16760
call AX.__init__
mov AX <Dict^28>
end "Function" "Dict^28"
pop ip
Function <&module_14697+13> 16765 None "Set^29" 1
name <&module_14697+13> "<class '__main__.Set'>"
jmp 16877
tf $Inheritance "equ" None
$jmp 16770 "t"
mov <Set^29> $Inheritance
push 1
jmp 16772
mov <Set^29> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Set^29> <&module_14697+13>
Function BX 16780 <Set^29> "__init___16780" 3
mov <Set^29>.__init__ BX
jmp 16800           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16788 "!="
tf <esp+2> "in" "elements"
$jmp 16790 "t"
mov <esp+2>["elements"] None
jmp 16790
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16780+2> <esp+2>["elements"]


push <__init___16780+2>
mov <__init___16780+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16780" "0,1,2"
pop ip
Function BX 16803 <Set^29> "__str___16803" 2
mov <Set^29>.__str__ BX
jmp 16812           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<set>"
jmp 16809         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16803" "0,1"
pop ip
Function BX 16815 <Set^29> "write_16815" 4
mov <Set^29>.write BX
jmp 16863           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16823 "!="
tf <esp+2> "in" "codes"
$jmp 16825 "t"
mov <esp+2>["codes"] None
jmp 16825
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16815+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16815+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+11>
push AX
mov <write_16815+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16815+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16815+3>.write
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"set\" "
ex_func AX "str" <write_16815+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16815+2>.append
push "AX"
mov <write_16815+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16815" "0,1,2,3"
pop ip
mov AX <Set^29>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16875 "=="
tf AX "Ctn" "__init__"
$jmp 16873 "t"
jmp 16875
call AX.__init__
mov AX <Set^29>
end "Function" "Set^29"
pop ip
Function <&module_14697+14> 16879 None "is_number_16879" 3
jmp 16944           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16887 "!="
tf <esp+2> "in" "num"
$jmp 16889 "t"
mov <esp+2>["num"] None
jmp 16889
mov <esp+2>["num"] <esp+1>[0]
dec CX
mov <is_number_16879+1> <esp+2>["num"]


finally 16926
try 16908
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <is_number_16879+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
mov <is_number_16879+2> <esp+1>
inc esp
mov AX True
jmp 16920
try "end"
jmp 16917    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 16916 "f"
mov $Exception 0
try 16924
mov AX False
jmp 16920
try "end"
jmp 16917  ;¸õ¨ìpush 1
jmp 16924 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 16926    ;¸õ¨ìfinally
push AX
try "end"
push 2
jmp 16926    ;¸õ¨ìfinally
push None
push 0
finally -16926
pop AX
cmp AX 2
$jmp 16935 "=="
cmp AX 1
$jmp 16938 "=="
pop AX
mov AX $Exception
raise AX
pop $Exception
pop AX
jmp 16941
pop AX
end "finally_yield"
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "is_number_16879" "0,1,2"
pop ip
Function <&module_14697+15> 16947 None "Lambda^30" 1
name <&module_14697+15> "<class '__main__.Lambda'>"
jmp 17174
tf $Inheritance "equ" None
$jmp 16952 "t"
mov <Lambda^30> $Inheritance
push 1
jmp 16954
mov <Lambda^30> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Lambda^30> <&module_14697+15>
Function BX 16962 <Lambda^30> "__init___16962" 5
mov <Lambda^30>.__init__ BX
jmp 17006           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16970 "!="
tf <esp+2> "in" "params"
$jmp 16972 "t"
mov <esp+2>["params"] None
jmp 16972
mov <esp+2>["params"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 16978 "!="
tf <esp+2> "in" "return_obj"
$jmp 16980 "t"
mov <esp+2>["return_obj"] None
jmp 16980
mov <esp+2>["return_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 16986 "!="
tf <esp+2> "in" "namespace"
$jmp 16988 "t"
mov <esp+2>["namespace"] None
jmp 16988
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
mov <__init___16962+2> <esp+2>["params"]
mov <__init___16962+3> <esp+2>["return_obj"]
mov <__init___16962+4> <esp+2>["namespace"]


push <__init___16962+2>
mov <__init___16962+0>.params <esp+1>
inc esp
push <__init___16962+3>
mov <__init___16962+0>.return_obj <esp+1>
inc esp
push <__init___16962+4>
mov <__init___16962+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16962" "0,1,2,3,4"
pop ip
Function BX 17009 <Lambda^30> "__str___17009" 2
mov <Lambda^30>.__str__ BX
jmp 17018           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<lambda>"
jmp 17015         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___17009" "0,1"
pop ip
Function BX 17021 <Lambda^30> "write_17021" 9
mov <Lambda^30>.write BX
jmp 17160           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17029 "!="
tf <esp+2> "in" "codes"
$jmp 17031 "t"
mov <esp+2>["codes"] None
jmp 17031
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_17021+2> <esp+2>["codes"]


push "&lambda_"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17021+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17021+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17021+0>.return_obj
mov <esp+1>[1] "return"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+18>
push AX
mov <write_17021+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+42>
push AX
mov <write_17021+5> <esp+1>
inc esp
ex_func AX "iter" <write_17021+0>.params
push AX
fetch AX <esp+1>
$jmp 17090 "f"
mov <write_17021+6> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17021+6>
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17021+5>.add_info
jmp 17070
inc esp
mov AX <write_17021+5>.codelines      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17021+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_17021+3>
mov <esp+1>[1] <write_17021+0>.params
mov <esp+1>[2] <write_17021+5>
mov <esp+1>[3] <write_17021+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+16>
push AX
mov <write_17021+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17021+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17021+7>.write
mov DX <write_17021+0>.namespace
tf DX "equ" ""
$jmp 17126 "f"
mov AX True
jmp 17127
mov AX False
cmp AX 1
$jmp 17133 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17021+3>
mov <write_17021+0>.location <esp+1>
inc esp
jmp 17156        ;¸õ¦Ü©³³¡
mov AX <write_17021+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17021+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_17021+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_17021+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17021+8> <esp+1>
inc esp
push <write_17021+8>
mov <write_17021+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_17021" "0,1,2,3,4,5,6,7,8"
pop ip
mov AX <Lambda^30>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 17172 "=="
tf AX "Ctn" "__init__"
$jmp 17170 "t"
jmp 17172
call AX.__init__
mov AX <Lambda^30>
end "Function" "Lambda^30"
pop ip
Function <&module_14697+16> 17177 None "Def^31" 1
name <&module_14697+16> "<class '__main__.Def'>"
jmp 19455
tf $Inheritance "equ" None
$jmp 17182 "t"
mov <Def^31> $Inheritance
push 1
jmp 17184
mov <Def^31> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Def^31> <&module_14697+16>
Function BX 17192 <Def^31> "__init___17192" 6
mov <Def^31>.__init__ BX
jmp 17260           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17200 "!="
tf <esp+2> "in" "fname"
$jmp 17202 "t"
mov <esp+2>["fname"] None
jmp 17202
mov <esp+2>["fname"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 17208 "!="
tf <esp+2> "in" "params"
$jmp 17210 "t"
mov <esp+2>["params"] None
jmp 17210
mov <esp+2>["params"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 17216 "!="
tf <esp+2> "in" "block_info"
$jmp 17218 "t"
mov <esp+2>["block_info"] None
jmp 17218
mov <esp+2>["block_info"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 17224 "!="
tf <esp+2> "in" "namespace"
$jmp 17226 "t"
mov <esp+2>["namespace"] None
jmp 17226
mov <esp+2>["namespace"] <esp+1>[3]
dec CX
mov <__init___17192+2> <esp+2>["fname"]
mov <__init___17192+3> <esp+2>["params"]
mov <__init___17192+4> <esp+2>["block_info"]
mov <__init___17192+5> <esp+2>["namespace"]


push <__init___17192+2>
mov <__init___17192+0>.name <esp+1>
inc esp
push <__init___17192+3>
mov <__init___17192+0>.params <esp+1>
inc esp
push <__init___17192+5>
mov <__init___17192+0>.namespace <esp+1>
inc esp
push <__init___17192+4>.codelines
mov <__init___17192+0>.codelines <esp+1>
inc esp
push <__init___17192+4>.locals
mov <__init___17192+0>.local_vars <esp+1>
inc esp
tf <__init___17192+0>.namespace "in" "^"
push TF
mov <__init___17192+0>.in_class <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___17192+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___17192" "0,1,2,3,4,5"
pop ip
Function BX 17263 <Def^31> "__str___17263" 5
mov <Def^31>.__str__ BX
jmp 17317           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Def "
ex_func AX "str" <__str___17263+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <__str___17263+2> <esp+1>
inc esp
push [0]
mov <__str___17263+3> <esp+1>
inc esp
ex_func AX "iter" <__str___17263+0>.codelines
push AX
fetch AX <esp+1>
$jmp 17296 "f"
mov <__str___17263+4> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___17263+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___17263+3>.append
jmp 17278
inc esp
push "{"
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___17263+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" "}"
$mov <__str___17263+2> "+" <esp+1>
inc esp
mov AX <__str___17263+2>
jmp 17314         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___17263" "0,1,2,3,4"
pop ip
Function BX 17320 <Def^31> "write_17320" 46
mov <Def^31>.write BX
jmp 19441           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17328 "!="
tf <esp+2> "in" "codes"
$jmp 17330 "t"
mov <esp+2>["codes"] None
jmp 17330
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_17320+2> <esp+2>["codes"]


Function <write_17320+3> 17335 None "get_name_17335" 5 "write_17320"
jmp 17417           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17343 "!="
tf <esp+2> "in" "string"
$jmp 17345 "t"
mov <esp+2>["string"] None
jmp 17345
mov <esp+2>["string"] <esp+1>[0]
dec CX
mov <get_name_17335+1> <esp+2>["string"]


push ".[ ;"
mov <get_name_17335+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_name_17335+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <get_name_17335+3> <esp+1>[0]
mov <get_name_17335+4> <esp+1>[1]
inc esp
mov DX <get_name_17335+3>
cmp DX <get_name_17335+4>
$jmp 17369 ">="
mov AX True
jmp 17370
mov AX False
cmp AX 1
$jmp 17409 "!="
push <get_name_17335+1>
mov BX <get_name_17335+3>
pop AX
tf <get_name_17335+2> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 17405 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push <get_name_17335+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <get_name_17335+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push <get_name_17335+1>
push [3]
mov <esp+1>[0] <get_name_17335+3>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[1] AX[BX]
pop AX
jmp 17414         ;returnÂI
jmp 17405        ;¸õ¦Ü©³³¡
push 1
$mov <get_name_17335+3> "+" <esp+1>
inc esp
jmp 17364               ;continue­«¨Ó
push (2)
mov <esp+1>[0] <get_name_17335+1>
mov <esp+1>[1] ""
pop AX
jmp 17414         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_name_17335" "0,1,2,3,4"
pop ip
mov DX <write_17320+0>.namespace
tf DX "equ" ""
$jmp 17422 "t"
mov AX True
jmp 17423
mov AX False
cmp AX 1
$jmp 17483 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_17320+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push [5]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov <esp+1>[1] "BX"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop <esp+1>[2]
mov AX <write_17320+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[3] AX.location
mov <esp+1>[4] 0
mov <write_17320+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov "
mov AX <write_17320+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_17320+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " BX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
jmp 17514        ;¸õ¦Ü©³³¡
push [5]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov <esp+1>[1] <write_17320+0>.name
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop <esp+1>[2]
mov <esp+1>[3] None
mov <esp+1>[4] 0
mov <write_17320+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push ""
ex_func AX "str" <write_17320+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "_"
ex_func AX "str" <write_17320+5>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17320+0>.func_var <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 0
mov <write_17320+6> <esp+1>
inc esp
push [0]
mov <write_17320+7> <esp+1>
inc esp
push None
mov <write_17320+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+0>.params
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call tuple
push AX
mov <write_17320+9> <esp+1>
inc esp
ex_func AX "iter" <write_17320+9>
push AX
fetch AX <esp+1>
$jmp 17950 "f"
mov <write_17320+10> AX
cmp <write_17320+0>.in_class 1
$jmp 17596 "!="
mov DX <write_17320+8>
tf DX "equ" None
$jmp 17591 "f"
mov AX True
jmp 17592
mov AX False
cmp AX 1
$jmp 17596 "!="
mov AX 1
jmp 17597
mov AX 0
cmp AX 1
$jmp 17604 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+10>
mov <write_17320+8> <esp+1>
inc esp
jmp 17581
jmp 17604        ;¸õ¦Ü©³³¡
push <write_17320+10>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 2
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "**"
$jmp 17619 "f"
mov AX True
jmp 17620
mov AX False
cmp AX 1
$jmp 17700 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_17320+11> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "**kwargs <esp+2>[\""
push <write_17320+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+2> \""
ex_func AX "str" <write_17320+11>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
push AX[BX]
push <write_17320+0>.params
push <write_17320+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
del 1 AX BX
push 1        ;Àx¦sCX
push [1]
push <write_17320+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+7>.append
jmp 17949        ;¸õ¦Ü©³³¡
push <write_17320+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 17708 "f"
mov AX True
jmp 17709
mov AX False
cmp AX 1
$jmp 17776 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "*args <esp+2>[\""
push <write_17320+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+1> "
ex_func AX "str" <write_17320+6>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
push AX[BX]
push <write_17320+0>.params
push <write_17320+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
del 1 AX BX
push 1        ;Àx¦sCX
push [1]
push <write_17320+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+7>.append
jmp 17949        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+7>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp CX 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+12> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
push "tf <esp+2> \"in\" \""
ex_func AX "str" <write_17320+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+2>[\""
ex_func AX "str" <write_17320+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
push <write_17320+0>.params
mov BX <write_17320+10>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_17320+2>
mov BX <write_17320+12>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov <esp+2>[\""
ex_func AX "str" <write_17320+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+1>["
ex_func AX "str" <write_17320+6>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "dec CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
push <write_17320+2>
mov BX <write_17320+13>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_17320+6> "+" <esp+1>
inc esp
jmp 17581
inc esp
push 0
mov <write_17320+14> <esp+1>
inc esp
push [dict]
mov <write_17320+15> <esp+1>
inc esp
ex_func AX "iter" <write_17320+0>.params
push AX
fetch AX <esp+1>
$jmp 17972 "f"
mov <write_17320+10> AX
push 1
$mov <write_17320+14> "+" <esp+1>
inc esp
push <write_17320+14>
push <write_17320+15>
mov BX <write_17320+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 17959
inc esp
ex_func AX "iter" <write_17320+0>.local_vars
push AX
fetch AX <esp+1>
$jmp 18004 "f"
mov <write_17320+16> AX
tf <write_17320+0>.params "in" <write_17320+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 17990 "!="
tf <write_17320+15> "in" <write_17320+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 17990 "!="
mov AX 1
jmp 17991
mov AX 0
cmp AX 1
$jmp 18003 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <write_17320+14> "+" <esp+1>
inc esp
push <write_17320+14>
push <write_17320+15>
mov BX <write_17320+16>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18003        ;¸õ¦Ü©³³¡
jmp 17975
inc esp
push <write_17320+14>
oper <esp+1> "+" 1
push <write_17320+4>
mov BX 4
pop AX
mov AX[BX] <esp+1>
inc esp
push "Function "
push <write_17320+4>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <write_17320+4>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <write_17320+4>
mov BX 3
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
push <write_17320+4>
mov BX 4
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_17320+2>
push <write_17320+4>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push [0]
mov <write_17320+17> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
ex_func AX "iter" <write_17320+0>.params
push AX
fetch AX <esp+1>
$jmp 18093 "f"
mov <write_17320+10> AX
mov DX <write_17320+10>
tf DX "equ" <write_17320+8>
$jmp 18068 "t"
mov AX True
jmp 18069
mov AX False
cmp AX 1
$jmp 18092 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17320+15>
mov BX <write_17320+10>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "> <esp+2>[\""
ex_func AX "str" <write_17320+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
jmp 18092        ;¸õ¦Ü©³³¡
jmp 18060
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push False
mov <write_17320+19> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+20> <esp+1>
inc esp
ex_func AX "iter" <write_17320+0>.codelines
push AX
fetch AX <esp+1>
$jmp 18144 "f"
mov <write_17320+21> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+21>.write
jmp 18133
inc esp
Function <write_17320+22> 18147 None "save_gen_18147" 2 "write_17320"
jmp 18272           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18155 "!="
tf <esp+2> "in" "num"
$jmp 18157 "t"
mov <esp+2>["num"] None
jmp 18157
mov <esp+2>["num"] <esp+1>[0]
dec CX
mov <save_gen_18147+1> <esp+2>["num"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+25>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18172 "<="
mov AX True
jmp 18173
mov AX False
cmp AX 1
$jmp 18192 "!="
push <write_17320+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push 1
mov DX <save_gen_18147+1>
pop BX
pop AX
tf AX[BX] "in" DX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18192 "!="
mov AX 1
jmp 18193
mov AX 0
cmp AX 1
$jmp 18214 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov BX 1
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_gen_18147+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18214        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18226 "<="
mov AX True
jmp 18227
mov AX False
cmp AX 1
$jmp 18246 "!="
push <write_17320+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push 1
mov DX <save_gen_18147+1>
pop BX
pop AX
tf AX[BX] "in" DX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18246 "!="
mov AX 1
jmp 18247
mov AX 0
cmp AX 1
$jmp 18268 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov BX 1
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_gen_18147+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18268        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "save_gen_18147" "0,1"
pop ip
Function <write_17320+23> 18274 None "in_global_18274" 3 "write_17320"
jmp 18308           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18282 "!="
tf <esp+2> "in" "word"
$jmp 18284 "t"
mov <esp+2>["word"] None
jmp 18284
mov <esp+2>["word"] <esp+1>[0]
dec CX
mov <in_global_18274+1> <esp+2>["word"]


ex_func AX "iter" <write_17320+26>
push AX
fetch AX <esp+1>
$jmp 18302 "f"
mov <in_global_18274+2> AX
tf <in_global_18274+2> "in" <in_global_18274+1>
mov AX TF
cmp AX 1
$jmp 18299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX True
jmp 18300
jmp 18299        ;¸õ¦Ü©³³¡
jmp 18289
inc esp
jmp 18305         ;returnÂI
inc esp
mov AX False
jmp 18305         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "in_global_18274" "0,1,2"
pop ip
push [0]
mov <write_17320+24> <esp+1>
inc esp
push [0]
mov <write_17320+25> <esp+1>
inc esp
push [1]
mov <esp+1>[0] [0]
mov <write_17320+26> <esp+1>
inc esp
push [0]
mov <write_17320+27> <esp+1>
inc esp
push [0]
mov <write_17320+28> <esp+1>
inc esp
push [0]
mov <write_17320+29> <esp+1>
inc esp
Function <write_17320+30> 18329 None "parse_line_18329" 7 "write_17320"
jmp 18479           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18337 "!="
tf <esp+2> "in" "line"
$jmp 18339 "t"
mov <esp+2>["line"] None
jmp 18339
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <parse_line_18329+1> <esp+2>["line"]


push [0]
mov <parse_line_18329+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_line_18329+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_line_18329+3> <esp+1>[0]
mov <parse_line_18329+4> <esp+1>[1]
inc esp
mov DX <parse_line_18329+3>
cmp DX <parse_line_18329+4>
$jmp 18363 ">="
mov AX True
jmp 18364
mov AX False
cmp AX 1
$jmp 18474 "!="
push <parse_line_18329+3>
mov <parse_line_18329+5> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_line_18329+1>
mov BX <parse_line_18329+5>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 18425 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_line_18329+1>
mov BX <parse_line_18329+5>
pop AX
push AX[BX]
mov <parse_line_18329+6> <esp+1>
inc esp
push <parse_line_18329+5>
oper <esp+1> "+" 1
mov <parse_line_18329+3> <esp+1>
inc esp
push <parse_line_18329+1>
mov BX <parse_line_18329+3>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_line_18329+6>
$jmp 18399 "t"
mov AX True
jmp 18400
mov AX False
cmp AX 1
$jmp 18421 "!="
push <parse_line_18329+1>
mov BX <parse_line_18329+3>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 18410 "f"
mov AX True
jmp 18411
mov AX False
cmp AX 1
$jmp 18417 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_line_18329+3> "+" <esp+1>
inc esp
jmp 18417        ;¸õ¦Ü©³³¡
push 1
$mov <parse_line_18329+3> "+" <esp+1>
inc esp
jmp 18391               ;continue­«¨Ó
push 1
$mov <parse_line_18329+3> "+" <esp+1>
inc esp
jmp 18425        ;¸õ¦Ü©³³¡
mov DX <parse_line_18329+3>
cmp DX <parse_line_18329+4>
$jmp 18430 ">="
mov AX True
jmp 18431
mov AX False
cmp AX 1
$jmp 18446 "!="
push <parse_line_18329+1>
mov BX <parse_line_18329+3>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 18441 "t"
mov AX True
jmp 18442
mov AX False
cmp AX 1
$jmp 18446 "!="
mov AX 1
jmp 18447
mov AX 0
cmp AX 1
$jmp 18453 "!="
push 1
$mov <parse_line_18329+3> "+" <esp+1>
inc esp
jmp 18425               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push <parse_line_18329+1>
push [3]
mov <esp+1>[0] <parse_line_18329+5>
mov <esp+1>[1] <parse_line_18329+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_line_18329+2>.append
push 1
$mov <parse_line_18329+3> "+" <esp+1>
inc esp
jmp 18358               ;continue­«¨Ó
mov AX <parse_line_18329+2>
jmp 18476         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_line_18329" "0,1,2,3,4,5,6"
pop ip
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_17320+20>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19078 "f"
mov <write_17320+6> AX
push <write_17320+2>
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop BX
pop AX
push AX[BX]
mov <write_17320+31> <esp+1>
inc esp
tf <write_17320+31> "in" "\""
mov AX TF
cmp AX 1
$jmp 18518 "=="
tf <write_17320+31> "in" "'"
mov AX TF
cmp AX 1
$jmp 18518 "=="
mov AX 0
jmp 18519
mov AX 1
cmp AX 1
$jmp 18532 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+30>
push AX
mov <write_17320+32> <esp+1>
inc esp
jmp 18542        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+31>.split
push AX
mov <write_17320+32> <esp+1>
inc esp
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "return"
$jmp 18550 "f"
mov AX True
jmp 18551
mov AX False
cmp AX 1
$jmp 18564 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+17>.append
jmp 18497
jmp 18625        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "global"
$jmp 18572 "f"
mov AX True
jmp 18573
mov AX False
cmp AX 1
$jmp 18594 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+26>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_17320+32>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18625        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "nonlocal"
$jmp 18602 "f"
mov AX True
jmp 18603
mov AX False
cmp AX 1
$jmp 18625 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_17320+32>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+27>.append
push 1        ;Àx¦sCX
push [1]
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+28>.append
jmp 18625        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "yield"
$jmp 18633 "f"
mov AX True
jmp 18634
mov AX False
cmp AX 1
$jmp 18646 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "Yield"
push <write_17320+32>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push True
mov <write_17320+19> <esp+1>
inc esp
jmp 18844        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "Function"
$jmp 18654 "f"
mov AX True
jmp 18655
mov AX False
cmp AX 1
$jmp 18677 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop <esp+1>[0]
mov <esp+1>[1] [0]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+25>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+26>.append
jmp 18844        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "Generator"
$jmp 18685 "f"
mov AX True
jmp 18686
mov AX False
cmp AX 1
$jmp 18701 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop <esp+1>[0]
mov <esp+1>[1] [0]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+24>.append
jmp 18844        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "end"
$jmp 18709 "f"
mov AX True
jmp 18710
mov AX False
cmp AX 1
$jmp 18844 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+32>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "\"Function\""
$jmp 18720 "f"
mov AX True
jmp 18721
mov AX False
cmp AX 1
$jmp 18780 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <write_17320+33> <esp+1>[0]
mov <write_17320+34> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+34>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18744 "<="
mov AX True
jmp 18745
mov AX False
cmp AX 1
$jmp 18767 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+34>
$mov <write_17320+29> "+" <esp+1>
inc esp
push " \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_17320+35> <esp+1>
inc esp
push <write_17320+2>
mov BX <write_17320+33>
pop AX
push AX[BX]
oper <esp+1> "+" <write_17320+35>
push <write_17320+2>
mov BX <write_17320+33>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18767        ;¸õ¦Ü©³³¡
push <write_17320+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <write_17320+26>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 18842        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "\"Generator\""
$jmp 18788 "f"
mov AX True
jmp 18789
mov AX False
cmp AX 1
$jmp 18842 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <write_17320+36> <esp+1>[0]
mov <write_17320+34> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+34>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18812 "<="
mov AX True
jmp 18813
mov AX False
cmp AX 1
$jmp 18835 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17320+34>
$mov <write_17320+29> "+" <esp+1>
inc esp
push " \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_17320+37> <esp+1>
inc esp
push <write_17320+2>
mov BX <write_17320+36>
pop AX
push AX[BX]
oper <esp+1> "+" <write_17320+37>
push <write_17320+2>
mov BX <write_17320+36>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18835        ;¸õ¦Ü©³³¡
push <write_17320+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 18842        ;¸õ¦Ü©³³¡
jmp 18497
jmp 18844        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+32>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19058 "f"
mov <write_17320+38> AX
mov DX <write_17320+38>
tf DX "equ" 0
$jmp 18868 "f"
mov AX True
jmp 18869
mov AX False
cmp AX 1
$jmp 18884 "=="
push <write_17320+32>
mov BX <write_17320+38>
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 18879 "f"
mov AX True
jmp 18880
mov AX False
cmp AX 1
$jmp 18884 "=="
mov AX 0
jmp 18885
mov AX 1
cmp AX 1
$jmp 18889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 18860
jmp 18889        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_17320+32>
mov BX <write_17320+38>
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 18906 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 18860
jmp 18906        ;¸õ¦Ü©³³¡
push <write_17320+32>
mov BX <write_17320+38>
pop AX
push AX[BX]
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ";"
$jmp 18917 "f"
mov AX True
jmp 18918
mov AX False
cmp AX 1
$jmp 18922 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19058          ;break¥X°j°é
jmp 18922        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <write_17320+32>
mov BX <write_17320+38>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+3>
push AX
mov <write_17320+16> <esp+1>[0]
mov <write_17320+39> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+23>
$oper AX "not"
cmp AX 1
$jmp 18953 "!="
tf <write_17320+27> "in" <write_17320+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18953 "!="
mov AX 1
jmp 18954
mov AX 0
cmp AX 1
$jmp 19057 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <write_17320+16>
tf DX "equ" ""
$jmp 18961 "f"
mov AX True
jmp 18962
mov AX False
cmp AX 1
$jmp 18966 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19058          ;break¥X°j°é
jmp 19056        ;¸õ¦Ü©³³¡
mov DX <write_17320+16>
tf DX "equ" <write_17320+8>
$jmp 18971 "f"
mov AX True
jmp 18972
mov AX False
cmp AX 1
$jmp 18994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+0>"
oper <esp+1> "+" <write_17320+39>
push <write_17320+32>
mov BX <write_17320+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17320+14>
oper <esp+1> "+" 4
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+22>
jmp 19056        ;¸õ¦Ü©³³¡
tf <write_17320+0>.params "in" <write_17320+16>
mov AX TF
cmp AX 1
$jmp 19025 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17320+15>
mov BX <write_17320+16>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
oper <esp+1> "+" <write_17320+39>
push <write_17320+32>
mov BX <write_17320+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17320+15>
mov BX <write_17320+16>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+22>
jmp 19056        ;¸õ¦Ü©³³¡
tf <write_17320+0>.local_vars "in" <write_17320+16>
mov AX TF
cmp AX 1
$jmp 19056 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17320+15>
mov BX <write_17320+16>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
oper <esp+1> "+" <write_17320+39>
push <write_17320+32>
mov BX <write_17320+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17320+15>
mov BX <write_17320+16>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+22>
jmp 19056        ;¸õ¦Ü©³³¡
jmp 19057        ;¸õ¦Ü©³³¡
jmp 18860
inc esp
mov AX " "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+32>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <write_17320+2>
push <write_17320+20>
oper <esp+1> "+" <write_17320+6>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18497
inc esp
push [0]
mov <write_17320+40> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17320+14>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19117 "f"
mov <write_17320+6> AX
tf <write_17320+29> "in" <write_17320+6>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 19116 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+40>.append
jmp 19116        ;¸õ¦Ü©³³¡
jmp 19093
inc esp
ex_func AX "iter" <write_17320+28>
push AX
fetch AX <esp+1>
$jmp 19130 "f"
mov <write_17320+41> AX
push ""
push <write_17320+2>
mov BX <write_17320+41>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19120
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17320+42> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 19153 "<="
mov AX True
jmp 19154
mov AX False
cmp AX 1
$jmp 19175 "!="
push <write_17320+17>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push <write_17320+42>
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 19170 "f"
mov AX True
jmp 19171
mov AX False
cmp AX 1
$jmp 19175 "!="
mov AX 1
jmp 19176
mov AX 0
cmp AX 1
$jmp 19198 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
ex_func AX "iter" <write_17320+17>
push AX
fetch AX <esp+1>
$jmp 19196 "f"
mov <write_17320+43> AX
push "jmp "
push <write_17320+42>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "         ;returnÂI"
push <write_17320+2>
mov BX <write_17320+43>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19180
inc esp
jmp 19231        ;¸õ¦Ü©³³¡
ex_func AX "iter" <write_17320+17>
push AX
fetch AX <esp+1>
$jmp 19213 "f"
mov <write_17320+43> AX
push "jmp "
ex_func AX "str" <write_17320+42>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_17320+2>
mov BX <write_17320+43>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19200
inc esp
cmp <write_17320+19> 1
$jmp 19224 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX \"\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
jmp 19231        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
cmp <write_17320+19> 1
$jmp 19346 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "StopIteration"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AX"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+17>
push AX
mov <write_17320+44> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17320+44>
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+18>
push AX
mov <write_17320+45> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+45>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "stop     ;²z½×¤W¤£·|°õ¦æ¨ì³o¤@¦æ"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push "Generator AX "
push <write_17320+18>
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_17320+2>
mov BX <write_17320+18>
pop AX
mov AX[BX] <esp+1>
inc esp
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "      ;¦]¬°¬Oyield¡Aª½±µ¸õ¨ìpop ip"
push <write_17320+2>
push <write_17320+18>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "end \"Generator\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
jmp 19360        ;¸õ¦Ü©³³¡
push ""
push <write_17320+2>
mov BX <write_17320+18>
pop AX
mov AX[BX] <esp+1>
inc esp
push ""
push <write_17320+2>
push <write_17320+18>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
cmp <write_17320+19> 1
$jmp 19381 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
jmp 19405        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_17320+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
oper <esp+1> "+" "\""
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+40>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop ip"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17320+2>.del_tab
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "           ;¸õ¹L¦¹¨ç¼Æ"
push <write_17320+2>
mov BX <write_17320+5>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_17320" "0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,27,28,29,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45"
pop ip
mov AX <Def^31>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 19453 "=="
tf AX "Ctn" "__init__"
$jmp 19451 "t"
jmp 19453
call AX.__init__
mov AX <Def^31>
end "Function" "Def^31"
pop ip
Function <&module_14697+17> 19458 None "FuncCall^32" 1
name <&module_14697+17> "<class '__main__.FuncCall'>"
jmp 20138
tf $Inheritance "equ" None
$jmp 19463 "t"
mov <FuncCall^32> $Inheritance
push 1
jmp 19465
mov <FuncCall^32> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <FuncCall^32> <&module_14697+17>
Function BX 19473 <FuncCall^32> "__init___19473" 7
mov <FuncCall^32>.__init__ BX
jmp 19546           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19481 "!="
tf <esp+2> "in" "name"
$jmp 19483 "t"
mov <esp+2>["name"] None
jmp 19483
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 19489 "!="
tf <esp+2> "in" "args"
$jmp 19491 "t"
mov <esp+2>["args"] None
jmp 19491
mov <esp+2>["args"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 19497 "!="
tf <esp+2> "in" "kwargs"
$jmp 19499 "t"
mov <esp+2>["kwargs"] None
jmp 19499
mov <esp+2>["kwargs"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 19505 "!="
tf <esp+2> "in" "s_args"
$jmp 19507 "t"
mov <esp+2>["s_args"] None
jmp 19507
mov <esp+2>["s_args"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 19513 "!="
tf <esp+2> "in" "s_kwargs"
$jmp 19515 "t"
mov <esp+2>["s_kwargs"] (0)
jmp 19515
mov <esp+2>["s_kwargs"] <esp+1>[4]
dec CX
mov <__init___19473+2> <esp+2>["name"]
mov <__init___19473+3> <esp+2>["args"]
mov <__init___19473+4> <esp+2>["kwargs"]
mov <__init___19473+5> <esp+2>["s_args"]
mov <__init___19473+6> <esp+2>["s_kwargs"]


push <__init___19473+2>
mov <__init___19473+0>.name <esp+1>
inc esp
push <__init___19473+3>
mov <__init___19473+0>.args <esp+1>
inc esp
push <__init___19473+4>
mov <__init___19473+0>.kwargs <esp+1>
inc esp
push <__init___19473+5>
mov <__init___19473+0>.s_args <esp+1>
inc esp
push <__init___19473+6>
mov <__init___19473+0>.s_kwargs <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___19473+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___19473" "0,1,2,3,4,5,6"
pop ip
Function BX 19549 <FuncCall^32> "__str___19549" 2
mov <FuncCall^32>.__str__ BX
jmp 19568           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Call "
ex_func AX "str" <__str___19549+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " args="
ex_func AX "str" <__str___19549+0>.args
oper <esp+1> "+" AX
oper <esp+1> "+" " kwargs="
ex_func AX "str" <__str___19549+0>.kwargs
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 19565         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___19549" "0,1"
pop ip
Function BX 19571 <FuncCall^32> "__getitem___19571" 3
mov <FuncCall^32>.__getitem__ BX
jmp 19611           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19579 "!="
tf <esp+2> "in" "item"
$jmp 19581 "t"
mov <esp+2>["item"] None
jmp 19581
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___19571+2> <esp+2>["item"]


push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AX"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___19571+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+0>
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+9>
jmp 19608         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___19571" "0,1,2"
pop ip
Function BX 19614 <FuncCall^32> "write_19614" 10
mov <FuncCall^32>.write BX
jmp 20124           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19622 "!="
tf <esp+2> "in" "codes"
$jmp 19624 "t"
mov <esp+2>["codes"] None
jmp 19624
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_19614+2> <esp+2>["codes"]


Function <write_19614+3> 19629 None "deal_cx_args_kwargs_19629" 4 "write_19614"
jmp 19894           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19637 "!="
tf <esp+2> "in" "args"
$jmp 19639 "t"
mov <esp+2>["args"] None
jmp 19639
mov <esp+2>["args"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 19645 "!="
tf <esp+2> "in" "call_name"
$jmp 19647 "t"
mov <esp+2>["call_name"] None
jmp 19647
mov <esp+2>["call_name"] <esp+1>[1]
dec CX
mov <deal_cx_args_kwargs_19629+1> <esp+2>["args"]
mov <deal_cx_args_kwargs_19629+2> <esp+2>["call_name"]


push 1        ;Àx¦sCX
push [1]
push "push "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_cx_args_kwargs_19629+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "        ;Àx¦sCX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_cx_args_kwargs_19629+1>.write
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <deal_cx_args_kwargs_19629+1>.location
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;¬°call "
ex_func AX "str" <deal_cx_args_kwargs_19629+2>
oper <esp+1> "+" AX
oper <esp+1> "+" " °µ·Ç³Æ"
pop <esp+1>[0]
push [dict]
mov BX "simplify"
mov <esp+1>[BX] <write_19614+0>.in_class
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
mov DX <write_19614+0>.s_args
tf DX "equ" None
$jmp 19698 "t"
mov AX True
jmp 19699
mov AX False
cmp AX 1
$jmp 19745 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_19614+0>.s_args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"list\" "
mov AX <write_19614+0>.s_args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "ex_func BX \"len\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov <esp+2> \"+\" BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov <esp+1> \"+\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
jmp 19745        ;¸õ¦Ü©³³¡
mov AX <write_19614+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+0>.s_kwargs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 19767 "<="
mov AX True
jmp 19768
mov AX False
cmp AX 1
$jmp 19836 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_19614+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
ex_func AX "iter" <write_19614+0>.s_kwargs
push AX
fetch AX <esp+1>
$jmp 19827 "f"
mov <deal_cx_args_kwargs_19629+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_cx_args_kwargs_19629+3>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov *args [1]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov *args[0] "
ex_func AX "str" <deal_cx_args_kwargs_19629+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call <esp+1>.update"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
jmp 19784
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
jmp 19848        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "mov **kwargs "
mov AX <write_19614+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX     ;¨ú¦^CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
cmp <write_19614+4> 1
$jmp 19879 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
jmp 19890        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "call "
ex_func AX "str" <deal_cx_args_kwargs_19629+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_cx_args_kwargs_19629" "0,1,2,3"
pop ip
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_19614+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <write_19614+0>.name
mov BX "^"
pop AX
tf AX.location "in" BX
push TF
mov <write_19614+0>.in_class <esp+1>
inc esp
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 2
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX"
$jmp 19935 "f"
mov AX True
jmp 19936
mov AX False
cmp AX 1
$jmp 19947 "=="
push <write_19614+0>.name
mov BX "&"
pop AX
tf AX.location "in" BX
mov AX TF
cmp AX 1
$jmp 19947 "=="
mov AX 0
jmp 19948
mov AX 1
push AX
mov <write_19614+4> <esp+1>
inc esp
cmp <write_19614+4> 1
$jmp 19966 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
jmp 19966        ;¸õ¦Ü©³³¡
cmp <write_19614+0>.in_class 1
$jmp 20108 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.location      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_19614+5> <esp+1>[0]
mov <write_19614+6> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push "tf "
ex_func AX "str" <write_19614+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"Ctn\" \""
ex_func AX "str" <write_19614+6>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_19614+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19614+0>.args
mov <esp+1>[1] <write_19614+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+3>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_19614+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
push <write_19614+2>
mov BX <write_19614+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov AX <write_19614+0>.args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.elements
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+10>
push AX
mov <write_19614+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19614+9>
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.location
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+3>
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19614+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_19614+2>
mov BX <write_19614+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 20117        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19614+0>.args
mov AX <write_19614+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.location
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19614+3>
push "AX"
mov <write_19614+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_19614" "0,1,5,6,7,8,9"
pop ip
mov AX <FuncCall^32>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20136 "=="
tf AX "Ctn" "__init__"
$jmp 20134 "t"
jmp 20136
call AX.__init__
mov AX <FuncCall^32>
end "Function" "FuncCall^32"
pop ip
Function <&module_14697+18> 20141 None "Backtrack^33" 1
name <&module_14697+18> "<class '__main__.Backtrack'>"
jmp 20293
tf $Inheritance "equ" None
$jmp 20146 "t"
mov <Backtrack^33> $Inheritance
push 1
jmp 20148
mov <Backtrack^33> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Backtrack^33> <&module_14697+18>
Function BX 20156 <Backtrack^33> "__init___20156" 4
mov <Backtrack^33>.__init__ BX
jmp 20193           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20164 "!="
tf <esp+2> "in" "value"
$jmp 20166 "t"
mov <esp+2>["value"] None
jmp 20166
mov <esp+2>["value"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20172 "!="
tf <esp+2> "in" "cmd"
$jmp 20174 "t"
mov <esp+2>["cmd"] None
jmp 20174
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___20156+2> <esp+2>["value"]
mov <__init___20156+3> <esp+2>["cmd"]


push <__init___20156+2>
mov <__init___20156+0>.A <esp+1>
inc esp
push <__init___20156+3>
mov <__init___20156+0>.cmd <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___20156+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20156" "0,1,2,3"
pop ip
Function BX 20196 <Backtrack^33> "__str___20196" 2
mov <Backtrack^33>.__str__ BX
jmp 20212           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___20196+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___20196+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 20209         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20196" "0,1"
pop ip
Function BX 20215 <Backtrack^33> "write_20215" 3
mov <Backtrack^33>.write BX
jmp 20279           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20223 "!="
tf <esp+2> "in" "codes"
$jmp 20225 "t"
mov <esp+2>["codes"] None
jmp 20225
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20215+2> <esp+2>["codes"]


mov AX <write_20215+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20215+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_20215+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 20244 "t"
mov AX True
jmp 20245
mov AX False
cmp AX 1
$jmp 20260 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_20215+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20215+2>.append
jmp 20260        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push ""
ex_func AX "str" <write_20215+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " AX"
pop <esp+1>[0]
mov <esp+1>[1] <write_20215+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20215+2>.append
push "AX"
mov <write_20215+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20215" "0,1,2"
pop ip
mov AX <Backtrack^33>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20291 "=="
tf AX "Ctn" "__init__"
$jmp 20289 "t"
jmp 20291
call AX.__init__
mov AX <Backtrack^33>
end "Function" "Backtrack^33"
pop ip
Function <&module_14697+19> 20296 None "Var_declare^34" 1
name <&module_14697+19> "<class '__main__.Var_declare'>"
jmp 20506
tf $Inheritance "equ" None
$jmp 20301 "t"
mov <Var_declare^34> $Inheritance
push 1
jmp 20303
mov <Var_declare^34> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Var_declare^34> <&module_14697+19>
Function BX 20311 <Var_declare^34> "__init___20311" 4
mov <Var_declare^34>.__init__ BX
jmp 20343           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20319 "!="
tf <esp+2> "in" "value"
$jmp 20321 "t"
mov <esp+2>["value"] None
jmp 20321
mov <esp+2>["value"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20327 "!="
tf <esp+2> "in" "cmd"
$jmp 20329 "t"
mov <esp+2>["cmd"] None
jmp 20329
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___20311+2> <esp+2>["value"]
mov <__init___20311+3> <esp+2>["cmd"]


push <__init___20311+2>
mov <__init___20311+0>.value <esp+1>
inc esp
push <__init___20311+3>
mov <__init___20311+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20311" "0,1,2,3"
pop ip
Function BX 20346 <Var_declare^34> "__str___20346" 2
mov <Var_declare^34>.__str__ BX
jmp 20362           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___20346+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___20346+0>.value
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 20359         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20346" "0,1"
pop ip
Function BX 20365 <Var_declare^34> "write_20365" 5
mov <Var_declare^34>.write BX
jmp 20492           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20373 "!="
tf <esp+2> "in" "codes"
$jmp 20375 "t"
mov <esp+2>["codes"] None
jmp 20375
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20365+2> <esp+2>["codes"]


mov AX <write_20365+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20365+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <write_20365+0>.cmd
tf DX "equ" "del"
$jmp 20393 "f"
mov AX True
jmp 20394
mov AX False
cmp AX 1
$jmp 20473 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20365+0>.value
mov BX "."
pop AX
tf AX.location "in" BX
mov AX TF
cmp AX 1
$jmp 20433 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_20365+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.location      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_20365+3> <esp+1>[0]
mov <write_20365+4> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push "del 2 "
ex_func AX "str" <write_20365+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_20365+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20365+2>.append
jmp 20472        ;¸õ¦Ü©³³¡
mov AX <write_20365+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX["
$jmp 20449 "f"
mov AX True
jmp 20450
mov AX False
cmp AX 1
$jmp 20460 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "del 1 AX BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20365+2>.append
jmp 20472        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "del 0 "
mov AX <write_20365+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " None"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20365+2>.append
jmp 20488        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <write_20365+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_20365+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20365+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20365" "0,1,2,3,4"
pop ip
mov AX <Var_declare^34>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20504 "=="
tf AX "Ctn" "__init__"
$jmp 20502 "t"
jmp 20504
call AX.__init__
mov AX <Var_declare^34>
end "Function" "Var_declare^34"
pop ip
Function <&module_14697+20> 20509 None "Try_Except^35" 1
name <&module_14697+20> "<class '__main__.Try_Except'>"
jmp 22174
tf $Inheritance "equ" None
$jmp 20514 "t"
mov <Try_Except^35> $Inheritance
push 1
jmp 20516
mov <Try_Except^35> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Try_Except^35> <&module_14697+20>
Function BX 20524 <Try_Except^35> "__init___20524" 7
mov <Try_Except^35>.__init__ BX
jmp 20595           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20532 "!="
tf <esp+2> "in" "try_codelines"
$jmp 20534 "t"
mov <esp+2>["try_codelines"] None
jmp 20534
mov <esp+2>["try_codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20540 "!="
tf <esp+2> "in" "except_objects"
$jmp 20542 "t"
mov <esp+2>["except_objects"] None
jmp 20542
mov <esp+2>["except_objects"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 20548 "!="
tf <esp+2> "in" "else_codelines"
$jmp 20550 "t"
mov <esp+2>["else_codelines"] (0)
jmp 20550
mov <esp+2>["else_codelines"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 20556 "!="
tf <esp+2> "in" "finally_codelines"
$jmp 20558 "t"
mov <esp+2>["finally_codelines"] (0)
jmp 20558
mov <esp+2>["finally_codelines"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 20564 "!="
tf <esp+2> "in" "namespace"
$jmp 20566 "t"
mov <esp+2>["namespace"] ""
jmp 20566
mov <esp+2>["namespace"] <esp+1>[4]
dec CX
mov <__init___20524+2> <esp+2>["try_codelines"]
mov <__init___20524+3> <esp+2>["except_objects"]
mov <__init___20524+4> <esp+2>["else_codelines"]
mov <__init___20524+5> <esp+2>["finally_codelines"]
mov <__init___20524+6> <esp+2>["namespace"]


push <__init___20524+2>
mov <__init___20524+0>.try_codelines <esp+1>
inc esp
push <__init___20524+3>
mov <__init___20524+0>.except_objects <esp+1>
inc esp
push <__init___20524+4>
mov <__init___20524+0>.else_codelines <esp+1>
inc esp
push <__init___20524+5>
mov <__init___20524+0>.finally_codelines <esp+1>
inc esp
push <__init___20524+6>
mov <__init___20524+0>.namespace <esp+1>
inc esp
push [0]
mov <__init___20524+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20524" "0,1,2,3,4,5,6"
pop ip
Function BX 20598 <Try_Except^35> "__str___20598" 2
mov <Try_Except^35>.__str__ BX
jmp 20607           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<Try Except>"
jmp 20604         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20598" "0,1"
pop ip
Function BX 20610 <Try_Except^35> "write_20610" 39
mov <Try_Except^35>.write BX
jmp 22160           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20618 "!="
tf <esp+2> "in" "codes"
$jmp 20620 "t"
mov <esp+2>["codes"] None
jmp 20620
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20610+2> <esp+2>["codes"]


push 0
mov <write_20610+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] 0
push <write_20610+0>.orig_lines
mov BX <write_20610+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push [dict]
push "continue"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "break"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "return"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
mov <write_20610+6> <esp+1>
inc esp
push [0]
mov <write_20610+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+8> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.add_tab
ex_func AX "iter" <write_20610+0>.try_codelines
push AX
fetch AX <esp+1>
$jmp 20711 "f"
mov <write_20610+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+9>.write
jmp 20700
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.del_tab
push 1
$mov <write_20610+3> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20610+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 20782 "f"
mov <write_20610+10> AX
push <write_20610+2>
push <write_20610+8>
oper <esp+1> "+" <write_20610+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20610+11> <esp+1>
inc esp
mov DX <write_20610+11>
tf DX "equ" "yield"
$jmp 20768 "f"
mov AX True
jmp 20769
mov AX False
cmp AX 1
$jmp 20781 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_20610+8>
oper <esp+1> "+" <write_20610+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+7>.append
jmp 20781        ;¸õ¦Ü©³³¡
jmp 20739
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+12> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
mov DX <write_20610+0>.namespace
tf DX "equ" ""
$jmp 20812 "t"
mov AX True
jmp 20813
mov AX False
cmp AX 1
$jmp 20833 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_20610+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_20610+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_20610+13> <esp+1>
inc esp
jmp 20836        ;¸õ¦Ü©³³¡
push ""
mov <write_20610+13> <esp+1>
inc esp
push 0
mov <write_20610+14> <esp+1>
inc esp
push "try "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_20610+15> <esp+1>
inc esp
push [0]
mov <write_20610+16> <esp+1>
inc esp
push [0]
mov <write_20610+17> <esp+1>
inc esp
push [0]
mov <write_20610+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+0>.except_objects
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21140 "f"
mov <write_20610+10> AX
mov DX <write_20610+14>
tf DX "equ" 0
$jmp 20890 "f"
mov AX True
jmp 20891
mov AX False
cmp AX 1
$jmp 20903 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20610+15>
push <write_20610+2>
mov BX <write_20610+5>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
mov <write_20610+14> <esp+1>
inc esp
jmp 20922        ;¸õ¦Ü©³³¡
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"f\""
push <write_20610+2>
mov BX <write_20610+5>
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_20610+10>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+0>.except_objects
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 20935 ">="
mov AX True
jmp 20936
mov AX False
cmp AX 1
$jmp 21118 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20610+0>.orig_lines
mov BX <write_20610+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1
$mov <write_20610+3> "+" <esp+1>
inc esp
push <write_20610+0>.except_objects
mov BX <write_20610+10>
pop AX
push AX[BX]
mov <write_20610+19> <esp+1>
inc esp
push <write_20610+19>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "error "
push <write_20610+19>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push <write_20610+19>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" None
$jmp 21011 "t"
mov AX True
jmp 21012
mov AX False
cmp AX 1
$jmp 21032 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_20610+13>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20610+19>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " $Exception"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21032        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Exception 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+16>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.add_tab
push <write_20610+19>
mov BX 2
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 21082 "f"
mov <write_20610+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+9>.write
jmp 21071
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.del_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+18>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21139        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+17>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 20882
inc esp
ex_func AX "iter" <write_20610+7>
push AX
fetch AX <esp+1>
$jmp 21198 "f"
mov <write_20610+20> AX
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " ;³B²ztry¤¤ªºyield"
push <write_20610+2>
mov BX <write_20610+20>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "yield AX          ;try¤¤ªºyield§ï¨ì³o¸Ì"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
ex_func AX "str" <write_20610+20>
oper <esp+1> "+" AX
oper <esp+1> "+" "     ;ªğ¦^try¤¤ªºyield¤U¤@¦æ"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21143
inc esp
push [0]
mov <write_20610+21> <esp+1>
inc esp
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;try¥¿±`µ²§ô¡A¸õ¨ìelse"
push <write_20610+2>
mov BX <write_20610+12>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21233 "<="
mov AX True
jmp 21234
mov AX False
cmp AX 1
$jmp 21305 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20610+0>.orig_lines
mov BX <write_20610+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1
$mov <write_20610+3> "+" <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.add_tab
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+16>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
ex_func AX "iter" <write_20610+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 21290 "f"
mov <write_20610+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+9>.write
jmp 21279
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.del_tab
jmp 21305        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20610+22> <esp+1>
inc esp
ex_func AX "iter" <write_20610+18>
push AX
fetch AX <esp+1>
$jmp 21331 "f"
mov <write_20610+23> AX
push "jmp "
ex_func AX "str" <write_20610+22>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;¸õ¨ìpush 1"
push <write_20610+2>
mov BX <write_20610+23>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21318
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None  ;±À¤JNone"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 1     ;¥Nªí¥¿±`"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+21>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push [dict]
mov <write_20610+24> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20610+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21454 "f"
mov <write_20610+10> AX
push 1        ;Àx¦sCX
push [1]
push <write_20610+2>
push <write_20610+8>
oper <esp+1> "+" <write_20610+10>
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 21408 "f"
mov AX True
jmp 21409
mov AX False
cmp AX 1
$jmp 21453 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20610+2>
push <write_20610+8>
oper <esp+1> "+" <write_20610+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20610+11> <esp+1>
inc esp
tf <write_20610+6> "in" <write_20610+11>
mov AX TF
cmp AX 1
$jmp 21452 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20610+6>
mov BX <write_20610+11>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_20610+8>
oper <esp+1> "+" <write_20610+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 21452        ;¸õ¦Ü©³³¡
jmp 21453        ;¸õ¦Ü©³³¡
jmp 21388
inc esp
push 2
mov <write_20610+25> <esp+1>
inc esp
ex_func AX "iter" <write_20610+6>
push AX
fetch AX <esp+1>
$jmp 21584 "f"
mov <write_20610+26> AX
push 1        ;Àx¦sCX
push [1]
push <write_20610+6>
mov BX <write_20610+26>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21478 "<="
mov AX True
jmp 21479
mov AX False
cmp AX 1
$jmp 21583 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20610+27> <esp+1>
inc esp
push <write_20610+6>
mov BX <write_20610+26>
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 21510 "f"
mov <write_20610+28> AX
push "jmp "
ex_func AX "str" <write_20610+27>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20610+2>
mov BX <write_20610+28>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21497
inc esp
mov DX <write_20610+26>
tf DX "equ" "return"
$jmp 21516 "f"
mov AX True
jmp 21517
mov AX False
cmp AX 1
$jmp 21527 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21534        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_20610+25>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+21>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push <write_20610+26>
push <write_20610+24>
mov BX <write_20610+25>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_20610+25> "+" <esp+1>
inc esp
jmp 21583        ;¸õ¦Ü©³³¡
jmp 21460
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20610+29> <esp+1>
inc esp
ex_func AX "iter" <write_20610+16>
push AX
fetch AX <esp+1>
$jmp 21611 "f"
mov <write_20610+30> AX
push "try "
ex_func AX "str" <write_20610+29>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20610+2>
mov BX <write_20610+30>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21598
inc esp
ex_func AX "iter" <write_20610+17>
push AX
fetch AX <esp+1>
$jmp 21627 "f"
mov <write_20610+23> AX
push "jmp "
ex_func AX "str" <write_20610+29>
oper <esp+1> "+" AX
oper <esp+1> "+" " ;push 0"
push <write_20610+2>
mov BX <write_20610+23>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21614
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20610+31> <esp+1>
inc esp
push "finally "
ex_func AX "str" <write_20610+31>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20610+2>
mov BX <write_20610+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_20610+21>
push AX
fetch AX <esp+1>
$jmp 21677 "f"
mov <write_20610+32> AX
push "jmp "
ex_func AX "str" <write_20610+31>
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;¸õ¨ìfinally"
push <write_20610+2>
mov BX <write_20610+32>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21664
inc esp
push 1        ;Àx¦sCX
push [1]
push "finally -"
ex_func AX "str" <write_20610+31>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+33> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+0>.finally_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21711 "<="
mov AX True
jmp 21712
mov AX False
cmp AX 1
$jmp 21769 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Exception 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20610+0>.orig_lines
mov BX <write_20610+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1
$mov <write_20610+3> "+" <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.add_tab
ex_func AX "iter" <write_20610+0>.finally_codelines
push AX
fetch AX <esp+1>
$jmp 21761 "f"
mov <write_20610+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+9>.write
jmp 21750
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.del_tab
jmp 21769        ;¸õ¦Ü©³³¡
push [dict]
push "continue"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "break"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "return"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
mov <write_20610+34> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20610+33>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21868 "f"
mov <write_20610+10> AX
push 1        ;Àx¦sCX
push [1]
push <write_20610+2>
push <write_20610+33>
oper <esp+1> "+" <write_20610+10>
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 21822 "f"
mov AX True
jmp 21823
mov AX False
cmp AX 1
$jmp 21867 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20610+2>
push <write_20610+33>
oper <esp+1> "+" <write_20610+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20610+11> <esp+1>
inc esp
tf <write_20610+34> "in" <write_20610+11>
mov AX TF
cmp AX 1
$jmp 21866 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20610+34>
mov BX <write_20610+11>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_20610+33>
oper <esp+1> "+" <write_20610+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 21866        ;¸õ¦Ü©³³¡
jmp 21867        ;¸õ¦Ü©³³¡
jmp 21802
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+0>.finally_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21881 "<="
mov AX True
jmp 21882
mov AX False
cmp AX 1
$jmp 21892 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21892        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push [dict]
mov <write_20610+35> <esp+1>
inc esp
ex_func AX "iter" <write_20610+24>
push AX
fetch AX <esp+1>
$jmp 21942 "f"
mov <write_20610+25> AX
push 1        ;Àx¦sCX
push [1]
push "cmp AX "
ex_func AX "str" <write_20610+25>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push <write_20610+24>
mov BX <write_20610+25>
pop AX
push AX[BX]
push <write_20610+35>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov BX AX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 21904
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp AX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20610+36> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "$Exception"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+18>
push AX
mov <write_20610+37> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+37>.write
ex_func AX "iter" <write_20610+34>
push AX
fetch AX <esp+1>
$jmp 22072 "f"
mov <write_20610+26> AX
push 1        ;Àx¦sCX
push [1]
push <write_20610+34>
mov BX <write_20610+26>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 22020 "<="
mov AX True
jmp 22021
mov AX False
cmp AX 1
$jmp 22071 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20610+27> <esp+1>
inc esp
push <write_20610+34>
mov BX <write_20610+26>
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 22055 "f"
mov <write_20610+28> AX
push "jmp "
ex_func AX "str" <write_20610+27>
oper <esp+1> "+" AX
oper <esp+1> "+" "       ;¸õ¦Üfinally¤¤ªº¨Æ¥ó:"
ex_func AX "str" <write_20610+26>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20610+2>
mov BX <write_20610+28>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 22039
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 3"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 22071        ;¸õ¦Ü©³³¡
jmp 22002
inc esp
ex_func AX "iter" <write_20610+35>
push AX
fetch AX <esp+1>
$jmp 22122 "f"
mov <write_20610+38> AX
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_20610+2>
mov BX <write_20610+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
push <write_20610+35>
mov BX <write_20610+38>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
jmp 22075
inc esp
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20610+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_20610+2>
mov BX <write_20610+36>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "end \"finally_yield\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20610+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20610" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38"
pop ip
mov AX <Try_Except^35>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22172 "=="
tf AX "Ctn" "__init__"
$jmp 22170 "t"
jmp 22172
call AX.__init__
mov AX <Try_Except^35>
end "Function" "Try_Except^35"
pop ip
Function <&module_14697+21> 22177 None "With^36" 1
name <&module_14697+21> "<class '__main__.With'>"
jmp 22567
tf $Inheritance "equ" None
$jmp 22182 "t"
mov <With^36> $Inheritance
push 1
jmp 22184
mov <With^36> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <With^36> <&module_14697+21>
Function BX 22192 <With^36> "__init___22192" 7
mov <With^36>.__init__ BX
jmp 22265           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22200 "!="
tf <esp+2> "in" "call_obj"
$jmp 22202 "t"
mov <esp+2>["call_obj"] None
jmp 22202
mov <esp+2>["call_obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 22208 "!="
tf <esp+2> "in" "orig_as_name"
$jmp 22210 "t"
mov <esp+2>["orig_as_name"] None
jmp 22210
mov <esp+2>["orig_as_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 22216 "!="
tf <esp+2> "in" "as_name"
$jmp 22218 "t"
mov <esp+2>["as_name"] None
jmp 22218
mov <esp+2>["as_name"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 22224 "!="
tf <esp+2> "in" "with_codelines"
$jmp 22226 "t"
mov <esp+2>["with_codelines"] None
jmp 22226
mov <esp+2>["with_codelines"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 22232 "!="
tf <esp+2> "in" "namespace"
$jmp 22234 "t"
mov <esp+2>["namespace"] None
jmp 22234
mov <esp+2>["namespace"] <esp+1>[4]
dec CX
mov <__init___22192+2> <esp+2>["call_obj"]
mov <__init___22192+3> <esp+2>["orig_as_name"]
mov <__init___22192+4> <esp+2>["as_name"]
mov <__init___22192+5> <esp+2>["with_codelines"]
mov <__init___22192+6> <esp+2>["namespace"]


push <__init___22192+2>
mov <__init___22192+0>.call_obj <esp+1>
inc esp
push <__init___22192+3>
mov <__init___22192+0>.orig_as_name <esp+1>
inc esp
push <__init___22192+4>
mov <__init___22192+0>.as_name <esp+1>
inc esp
push <__init___22192+5>
mov <__init___22192+0>.with_codelines <esp+1>
inc esp
push <__init___22192+6>
mov <__init___22192+0>.namespace <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___22192+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22192" "0,1,2,3,4,5,6"
pop ip
Function BX 22268 <With^36> "__str___22268" 2
mov <With^36>.__str__ BX
jmp 22277           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<with>"
jmp 22274         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22268" "0,1"
pop ip
Function BX 22280 <With^36> "write_22280" 10
mov <With^36>.write BX
jmp 22553           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22288 "!="
tf <esp+2> "in" "codes"
$jmp 22290 "t"
mov <esp+2>["codes"] None
jmp 22290
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22280+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_22280+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.add_tab
mov AX <write_22280+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22280+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_22280+0>.call_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22280+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
mov AX <write_22280+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_22280+0>.call_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.append
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
push ""
mov AX <write_22280+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ".__enter__"
pop <esp+1>[0]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+17>
push AX
mov <write_22280+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22280+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+3>.write
mov DX <write_22280+0>.as_name
tf DX "equ" None
$jmp 22394 "t"
mov AX True
jmp 22395
mov AX False
cmp AX 1
$jmp 22431 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_22280+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.append
mov AX <write_22280+0>.as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22280+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "pop "
mov AX <write_22280+0>.as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.append
jmp 22431        ;¸õ¦Ü©³³¡
push <write_22280+0>.with_codelines
mov <write_22280+4> <esp+1>
inc esp
push [0]
mov <write_22280+5> <esp+1>
inc esp
push [0]
mov <write_22280+6> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
push ""
mov AX <write_22280+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ".__exit__"
pop <esp+1>[0]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [3]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+31>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+31>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+31>
mov <esp+1>[2] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+17>
push AX
mov <write_22280+7> <esp+1>
inc esp
push [1]
mov <esp+1>[0] <write_22280+7>
mov <write_22280+8> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_22280+4>
mov <esp+1>[1] <write_22280+5>
mov <esp+1>[2] <write_22280+6>
mov <esp+1>[3] <write_22280+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+20>
push AX
mov <write_22280+9> <esp+1>
inc esp
push [3]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[2]
mov <write_22280+9>.orig_lines <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22280+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+9>.write
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22280+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22280" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <With^36>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22565 "=="
tf AX "Ctn" "__init__"
$jmp 22563 "t"
jmp 22565
call AX.__init__
mov AX <With^36>
end "Function" "With^36"
pop ip
Function <&module_14697+22> 22570 None "Stop^37" 1
name <&module_14697+22> "<class '__main__.Stop'>"
jmp 22646
tf $Inheritance "equ" None
$jmp 22575 "t"
mov <Stop^37> $Inheritance
push 1
jmp 22577
mov <Stop^37> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Stop^37> <&module_14697+22>
Function BX 22585 <Stop^37> "__init___22585" 2
mov <Stop^37>.__init__ BX
jmp 22593           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22585" "0,1"
pop ip
Function BX 22596 <Stop^37> "__str___22596" 2
mov <Stop^37>.__str__ BX
jmp 22605           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<$stop>"
jmp 22602         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22596" "0,1"
pop ip
Function BX 22608 <Stop^37> "write_22608" 3
mov <Stop^37>.write BX
jmp 22632           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22616 "!="
tf <esp+2> "in" "codes"
$jmp 22618 "t"
mov <esp+2>["codes"] None
jmp 22618
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22608+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "stop"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22608+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22608" "0,1,2"
pop ip
mov AX <Stop^37>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22644 "=="
tf AX "Ctn" "__init__"
$jmp 22642 "t"
jmp 22644
call AX.__init__
mov AX <Stop^37>
end "Function" "Stop^37"
pop ip
Function <&module_14697+23> 22649 None "Command^38" 1
name <&module_14697+23> "<class '__main__.Command'>"
jmp 22744
tf $Inheritance "equ" None
$jmp 22654 "t"
mov <Command^38> $Inheritance
push 1
jmp 22656
mov <Command^38> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Command^38> <&module_14697+23>
Function BX 22664 <Command^38> "__init___22664" 3
mov <Command^38>.__init__ BX
jmp 22684           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22672 "!="
tf <esp+2> "in" "cmd_list"
$jmp 22674 "t"
mov <esp+2>["cmd_list"] None
jmp 22674
mov <esp+2>["cmd_list"] <esp+1>[0]
dec CX
mov <__init___22664+2> <esp+2>["cmd_list"]


push <__init___22664+2>
mov <__init___22664+0>.cmd_list <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22664" "0,1,2"
pop ip
Function BX 22687 <Command^38> "__str___22687" 2
mov <Command^38>.__str__ BX
jmp 22696           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<cmd_list>"
jmp 22693         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22687" "0,1"
pop ip
Function BX 22699 <Command^38> "write_22699" 4
mov <Command^38>.write BX
jmp 22730           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22707 "!="
tf <esp+2> "in" "codes"
$jmp 22709 "t"
mov <esp+2>["codes"] None
jmp 22709
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22699+2> <esp+2>["codes"]


ex_func AX "iter" <write_22699+0>.cmd_list
push AX
fetch AX <esp+1>
$jmp 22725 "f"
mov <write_22699+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22699+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22699+2>.append
jmp 22714
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22699" "0,1,2,3"
pop ip
mov AX <Command^38>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22742 "=="
tf AX "Ctn" "__init__"
$jmp 22740 "t"
jmp 22742
call AX.__init__
mov AX <Command^38>
end "Function" "Command^38"
pop ip
Function <&module_14697+24> 22747 None "sub_if_else^39" 1
name <&module_14697+24> "<class '__main__.sub_if_else'>"
jmp 23016
tf $Inheritance "equ" None
$jmp 22752 "t"
mov <sub_if_else^39> $Inheritance
push 1
jmp 22754
mov <sub_if_else^39> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <sub_if_else^39> <&module_14697+24>
Function BX 22762 <sub_if_else^39> "__init___22762" 5
mov <sub_if_else^39>.__init__ BX
jmp 22806           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22770 "!="
tf <esp+2> "in" "event"
$jmp 22772 "t"
mov <esp+2>["event"] None
jmp 22772
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 22778 "!="
tf <esp+2> "in" "true_item"
$jmp 22780 "t"
mov <esp+2>["true_item"] None
jmp 22780
mov <esp+2>["true_item"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 22786 "!="
tf <esp+2> "in" "false_item"
$jmp 22788 "t"
mov <esp+2>["false_item"] None
jmp 22788
mov <esp+2>["false_item"] <esp+1>[2]
dec CX
mov <__init___22762+2> <esp+2>["event"]
mov <__init___22762+3> <esp+2>["true_item"]
mov <__init___22762+4> <esp+2>["false_item"]


push <__init___22762+2>
mov <__init___22762+0>.event <esp+1>
inc esp
push <__init___22762+3>
mov <__init___22762+0>.true_item <esp+1>
inc esp
push <__init___22762+4>
mov <__init___22762+0>.false_item <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22762" "0,1,2,3,4"
pop ip
Function BX 22809 <sub_if_else^39> "__str___22809" 2
mov <sub_if_else^39>.__str__ BX
jmp 22818           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<A if else B>"
jmp 22815         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22809" "0,1"
pop ip
Function BX 22821 <sub_if_else^39> "write_22821" 5
mov <sub_if_else^39>.write BX
jmp 23002           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22829 "!="
tf <esp+2> "in" "codes"
$jmp 22831 "t"
mov <esp+2>["codes"] None
jmp 22831
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22821+2> <esp+2>["codes"]


mov AX <write_22821+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_22821+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22821+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_22821+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22821+2>.append
mov AX <write_22821+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_22821+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 22889 "t"
mov AX True
jmp 22890
mov AX False
cmp AX 1
$jmp 22905 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_22821+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;true item"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22821+2>.append
jmp 22905        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_22821+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22821+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\"   ;¸õ¨ìfalse"
push <write_22821+2>
mov BX <write_22821+3>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <write_22821+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_22821+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 22957 "t"
mov AX True
jmp 22958
mov AX False
cmp AX 1
$jmp 22976 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_22821+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;false item"
pop <esp+1>[0]
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_22821+2>.append
jmp 22976        ;¸õ¦Ü©³³¡
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22821+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;Â÷¶}sub_if_else"
push <write_22821+2>
mov BX <write_22821+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push "AX"
mov <write_22821+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22821" "0,1,2,3,4"
pop ip
mov AX <sub_if_else^39>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23014 "=="
tf AX "Ctn" "__init__"
$jmp 23012 "t"
jmp 23014
call AX.__init__
mov AX <sub_if_else^39>
end "Function" "sub_if_else^39"
pop ip
Function <&module_14697+25> 23019 None "If_else^40" 1
name <&module_14697+25> "<class '__main__.If_else'>"
jmp 23472
tf $Inheritance "equ" None
$jmp 23024 "t"
mov <If_else^40> $Inheritance
push 1
jmp 23026
mov <If_else^40> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <If_else^40> <&module_14697+25>
Function BX 23034 <If_else^40> "__init___23034" 4
mov <If_else^40>.__init__ BX
jmp 23069           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23042 "!="
tf <esp+2> "in" "if_items"
$jmp 23044 "t"
mov <esp+2>["if_items"] None
jmp 23044
mov <esp+2>["if_items"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23050 "!="
tf <esp+2> "in" "else_codelines"
$jmp 23052 "t"
mov <esp+2>["else_codelines"] None
jmp 23052
mov <esp+2>["else_codelines"] <esp+1>[1]
dec CX
mov <__init___23034+2> <esp+2>["if_items"]
mov <__init___23034+3> <esp+2>["else_codelines"]


push <__init___23034+2>
mov <__init___23034+0>.if_items <esp+1>
inc esp
push <__init___23034+3>
mov <__init___23034+0>.else_codelines <esp+1>
inc esp
push [0]
mov <__init___23034+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23034" "0,1,2,3"
pop ip
Function BX 23072 <If_else^40> "__str___23072" 5
mov <If_else^40>.__str__ BX
jmp 23230           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [1]
push "if "
push <__str___23072+0>.if_items
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
pop <esp+1>[0]
mov <__str___23072+2> <esp+1>
inc esp
push <__str___23072+0>.if_items
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23116 "f"
mov <__str___23072+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23072+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23072+2>.append
jmp 23098
inc esp
push <__str___23072+0>.if_items
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23171 "f"
mov <__str___23072+4> AX
push 1        ;Àx¦sCX
push [1]
push "elif "
push <__str___23072+4>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23072+2>.append
push <__str___23072+4>
mov BX 1
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23169 "f"
mov <__str___23072+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23072+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23072+2>.append
jmp 23151
inc esp
jmp 23129
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23072+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 23184 "<="
mov AX True
jmp 23185
mov AX False
cmp AX 1
$jmp 23216 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "else:"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23072+2>.append
ex_func AX "iter" <__str___23072+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 23214 "f"
mov <__str___23072+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23072+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23072+2>.append
jmp 23196
inc esp
jmp 23216        ;¸õ¦Ü©³³¡
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23072+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 23227         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23072" "0,1,2,3,4"
pop ip
Function BX 23233 <If_else^40> "write_23233" 10
mov <If_else^40>.write BX
jmp 23458           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23241 "!="
tf <esp+2> "in" "codes"
$jmp 23243 "t"
mov <esp+2>["codes"] None
jmp 23243
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23233+2> <esp+2>["codes"]


push [0]
mov <write_23233+3> <esp+1>
inc esp
push 0
mov <write_23233+4> <esp+1>
inc esp
ex_func AX "iter" <write_23233+0>.if_items
push AX
fetch AX <esp+1>
$jmp 23374 "f"
mov <write_23233+5> AX[0]
mov <write_23233+6> AX[1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_23233+0>.orig_lines
mov BX <write_23233+4>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.append
push 1
$mov <write_23233+4> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+5>.write
push 1        ;Àx¦sCX
push [1]
push "cmp "
ex_func AX "str" <write_23233+5>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23233+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.append
ex_func AX "iter" <write_23233+6>
push AX
fetch AX <esp+1>
$jmp 23326 "f"
mov <write_23233+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+8>.write
jmp 23315
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\"        ;¸õ¨ì¤U¤@¥y§PÂ_"
push <write_23233+2>
mov BX <write_23233+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.del_tab
jmp 23254
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 23387 "<="
mov AX True
jmp 23388
mov AX False
cmp AX 1
$jmp 23428 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_23233+0>.orig_lines
mov BX <write_23233+4>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.add_tab
ex_func AX "iter" <write_23233+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 23420 "f"
mov <write_23233+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+8>.write
jmp 23409
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23233+2>.del_tab
jmp 23428        ;¸õ¦Ü©³³¡
ex_func AX "iter" <write_23233+3>
push AX
fetch AX <esp+1>
$jmp 23453 "f"
mov <write_23233+9> AX
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23233+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "        ;¸õ¦Ü©³³¡"
push <write_23233+2>
mov BX <write_23233+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 23430
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23233" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <If_else^40>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23470 "=="
tf AX "Ctn" "__init__"
$jmp 23468 "t"
jmp 23470
call AX.__init__
mov AX <If_else^40>
end "Function" "If_else^40"
pop ip
Function <&module_14697+26> 23475 None "While^41" 1
name <&module_14697+26> "<class '__main__.While'>"
jmp 23848
tf $Inheritance "equ" None
$jmp 23480 "t"
mov <While^41> $Inheritance
push 1
jmp 23482
mov <While^41> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <While^41> <&module_14697+26>
Function BX 23490 <While^41> "__init___23490" 5
mov <While^41>.__init__ BX
jmp 23539           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23498 "!="
tf <esp+2> "in" "event"
$jmp 23500 "t"
mov <esp+2>["event"] None
jmp 23500
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23506 "!="
tf <esp+2> "in" "codelines"
$jmp 23508 "t"
mov <esp+2>["codelines"] None
jmp 23508
mov <esp+2>["codelines"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 23514 "!="
tf <esp+2> "in" "else_codelines"
$jmp 23516 "t"
mov <esp+2>["else_codelines"] None
jmp 23516
mov <esp+2>["else_codelines"] <esp+1>[2]
dec CX
mov <__init___23490+2> <esp+2>["event"]
mov <__init___23490+3> <esp+2>["codelines"]
mov <__init___23490+4> <esp+2>["else_codelines"]


push <__init___23490+2>
mov <__init___23490+0>.event <esp+1>
inc esp
push <__init___23490+3>
mov <__init___23490+0>.codelines <esp+1>
inc esp
push <__init___23490+4>
mov <__init___23490+0>.else_codelines <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___23490+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23490" "0,1,2,3,4"
pop ip
Function BX 23542 <While^41> "__str___23542" 2
mov <While^41>.__str__ BX
jmp 23558           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "event:"
ex_func AX "str" <__str___23542+0>.event
oper <esp+1> "+" AX
oper <esp+1> "+" " do:"
ex_func AX "str" <__str___23542+0>.codelines
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 23555         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23542" "0,1"
pop ip
Function BX 23561 <While^41> "write_23561" 13
mov <While^41>.write BX
jmp 23834           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23569 "!="
tf <esp+2> "in" "codes"
$jmp 23571 "t"
mov <esp+2>["codes"] None
jmp 23571
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23561+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23561+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_23561+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.append
mov AX <write_23561+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_23561+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23561+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.append
push [0]
mov <write_23561+5> <esp+1>
inc esp
ex_func AX "iter" <write_23561+0>.codelines
push AX
fetch AX <esp+1>
$jmp 23748 "f"
mov <write_23561+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23561+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+6>.write
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_23561+7>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 23746 "f"
mov <write_23561+8> AX
push <write_23561+2>
push <write_23561+7>
oper <esp+1> "+" <write_23561+8>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_23561+9> <esp+1>
inc esp
mov DX <write_23561+9>
tf DX "equ" "continue"
$jmp 23709 "f"
mov AX True
jmp 23710
mov AX False
cmp AX 1
$jmp 23727 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "jmp "
push <write_23561+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_23561+2>
push <write_23561+7>
oper <esp+1> "+" <write_23561+8>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 23745        ;¸õ¦Ü©³³¡
mov DX <write_23561+9>
tf DX "equ" "break"
$jmp 23732 "f"
mov AX True
jmp 23733
mov AX False
cmp AX 1
$jmp 23745 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_23561+7>
oper <esp+1> "+" <write_23561+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+5>.append
jmp 23745        ;¸õ¦Ü©³³¡
jmp 23680
inc esp
jmp 23642
inc esp
push 1        ;Àx¦sCX
push [1]
push "jmp "
push <write_23561+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "               ;continue­«¨Ó"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_23561+10> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_23561+10>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_23561+2>
mov BX <write_23561+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_23561+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 23796 "f"
mov <write_23561+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+6>.write
jmp 23785
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23561+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_23561+11> <esp+1>
inc esp
ex_func AX "iter" <write_23561+5>
push AX
fetch AX <esp+1>
$jmp 23823 "f"
mov <write_23561+12> AX
push "jmp "
ex_func AX "str" <write_23561+11>
oper <esp+1> "+" AX
oper <esp+1> "+" "          ;break¥X"
push <write_23561+2>
mov BX <write_23561+12>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 23810
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23561+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23561" "0,1,2,3,4,5,6,7,8,9,10,11,12"
pop ip
mov AX <While^41>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23846 "=="
tf AX "Ctn" "__init__"
$jmp 23844 "t"
jmp 23846
call AX.__init__
mov AX <While^41>
end "Function" "While^41"
pop ip
Function <&module_14697+27> 23851 None "sub_for_loop^42" 1
name <&module_14697+27> "<class '__main__.sub_for_loop'>"
jmp 24192
tf $Inheritance "equ" None
$jmp 23856 "t"
mov <sub_for_loop^42> $Inheritance
push 1
jmp 23858
mov <sub_for_loop^42> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <sub_for_loop^42> <&module_14697+27>
Function BX 23866 <sub_for_loop^42> "__init___23866" 7
mov <sub_for_loop^42>.__init__ BX
jmp 23934           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23874 "!="
tf <esp+2> "in" "express"
$jmp 23876 "t"
mov <esp+2>["express"] None
jmp 23876
mov <esp+2>["express"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23882 "!="
tf <esp+2> "in" "vnames"
$jmp 23884 "t"
mov <esp+2>["vnames"] None
jmp 23884
mov <esp+2>["vnames"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 23890 "!="
tf <esp+2> "in" "base_obj"
$jmp 23892 "t"
mov <esp+2>["base_obj"] None
jmp 23892
mov <esp+2>["base_obj"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 23898 "!="
tf <esp+2> "in" "if_obj"
$jmp 23900 "t"
mov <esp+2>["if_obj"] None
jmp 23900
mov <esp+2>["if_obj"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 23906 "!="
tf <esp+2> "in" "is_list"
$jmp 23908 "t"
mov <esp+2>["is_list"] None
jmp 23908
mov <esp+2>["is_list"] <esp+1>[4]
dec CX
mov <__init___23866+2> <esp+2>["express"]
mov <__init___23866+3> <esp+2>["vnames"]
mov <__init___23866+4> <esp+2>["base_obj"]
mov <__init___23866+5> <esp+2>["if_obj"]
mov <__init___23866+6> <esp+2>["is_list"]


push <__init___23866+2>
mov <__init___23866+0>.express <esp+1>
inc esp
push <__init___23866+3>
mov <__init___23866+0>.vnames <esp+1>
inc esp
push <__init___23866+4>
mov <__init___23866+0>.base_obj <esp+1>
inc esp
push <__init___23866+5>
mov <__init___23866+0>.if_obj <esp+1>
inc esp
push <__init___23866+6>
mov <__init___23866+0>.is_list <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23866" "0,1,2,3,4,5,6"
pop ip
Function BX 23937 <sub_for_loop^42> "__str___23937" 2
mov <sub_for_loop^42>.__str__ BX
jmp 23946           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<sub for loop>"
jmp 23943         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23937" "0,1"
pop ip
Function BX 23949 <sub_for_loop^42> "write_23949" 10
mov <sub_for_loop^42>.write BX
jmp 24178           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23957 "!="
tf <esp+2> "in" "codes"
$jmp 23959 "t"
mov <esp+2>["codes"] None
jmp 23959
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23949+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_23949+0>.express
mov <esp+1>[1] "yield"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+18>
push AX
mov <write_23949+3> <esp+1>
inc esp
mov DX <write_23949+0>.if_obj
tf DX "equ" None
$jmp 23978 "t"
mov AX True
jmp 23979
mov AX False
cmp AX 1
$jmp 24030 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push [1]
push [2]
mov <esp+1>[0] <write_23949+0>.if_obj
push [1]
mov <esp+1>[0] <write_23949+3>
pop <esp+1>[1]
pop <esp+1>[0]
pop <esp+1>[0]
mov <esp+1>[1] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+25>
push AX
mov <write_23949+4> <esp+1>
inc esp
push [3]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[2]
mov <write_23949+4>.orig_lines <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_23949+0>.vnames
mov <esp+1>[1] <write_23949+0>.base_obj
push [1]
mov <esp+1>[0] <write_23949+4>
pop <esp+1>[2]
mov <esp+1>[3] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+28>
push AX
mov <write_23949+5> <esp+1>
inc esp
jmp 24045        ;¸õ¦Ü©³³¡
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_23949+0>.vnames
mov <esp+1>[1] <write_23949+0>.base_obj
push [1]
mov <esp+1>[0] <write_23949+3>
pop <esp+1>[2]
mov <esp+1>[3] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+28>
push AX
mov <write_23949+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+42>
push AX
mov <write_23949+6> <esp+1>
inc esp
ex_func AX "iter" <write_23949+0>.vnames
push AX
fetch AX <esp+1>
$jmp 24069 "f"
mov <write_23949+7> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <write_23949+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+6>.add_info
jmp 24057
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_23949+5>
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+6>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23949+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23949+8> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
push "&generator_"
ex_func AX "str" <write_23949+8>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] [dict]
mov <esp+1>[2] <write_23949+6>
mov <esp+1>[3] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+16>
push AX
mov <write_23949+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23949+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+9>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0        ;Àx¦sCX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [0]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX     ;¨ú¦^CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
push 1        ;Àx¦sCX
push [1]
push "call &generator_"
ex_func AX "str" <write_23949+8>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
cmp <write_23949+0>.is_list 1
$jmp 24171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "ex_func AX \"list\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23949+2>.append
jmp 24171        ;¸õ¦Ü©³³¡
push "AX"
mov <write_23949+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23949" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <sub_for_loop^42>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24190 "=="
tf AX "Ctn" "__init__"
$jmp 24188 "t"
jmp 24190
call AX.__init__
mov AX <sub_for_loop^42>
end "Function" "sub_for_loop^42"
pop ip
Function <&module_14697+28> 24195 None "For_loop^43" 1
name <&module_14697+28> "<class '__main__.For_loop'>"
jmp 24763
tf $Inheritance "equ" None
$jmp 24200 "t"
mov <For_loop^43> $Inheritance
push 1
jmp 24202
mov <For_loop^43> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <For_loop^43> <&module_14697+28>
Function BX 24210 <For_loop^43> "__init___24210" 6
mov <For_loop^43>.__init__ BX
jmp 24271           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24218 "!="
tf <esp+2> "in" "vnames"
$jmp 24220 "t"
mov <esp+2>["vnames"] None
jmp 24220
mov <esp+2>["vnames"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 24226 "!="
tf <esp+2> "in" "base_obj"
$jmp 24228 "t"
mov <esp+2>["base_obj"] None
jmp 24228
mov <esp+2>["base_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 24234 "!="
tf <esp+2> "in" "codelines"
$jmp 24236 "t"
mov <esp+2>["codelines"] None
jmp 24236
mov <esp+2>["codelines"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 24242 "!="
tf <esp+2> "in" "else_codelines"
$jmp 24244 "t"
mov <esp+2>["else_codelines"] None
jmp 24244
mov <esp+2>["else_codelines"] <esp+1>[3]
dec CX
mov <__init___24210+2> <esp+2>["vnames"]
mov <__init___24210+3> <esp+2>["base_obj"]
mov <__init___24210+4> <esp+2>["codelines"]
mov <__init___24210+5> <esp+2>["else_codelines"]


push <__init___24210+2>
mov <__init___24210+0>.vnames <esp+1>
inc esp
push <__init___24210+3>
mov <__init___24210+0>.base_obj <esp+1>
inc esp
push <__init___24210+4>
mov <__init___24210+0>.codelines <esp+1>
inc esp
push <__init___24210+5>
mov <__init___24210+0>.else_codelines <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___24210+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24210" "0,1,2,3,4,5"
pop ip
Function BX 24274 <For_loop^43> "__str___24274" 2
mov <For_loop^43>.__str__ BX
jmp 24283           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<For loop>"
jmp 24280         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24274" "0,1"
pop ip
Function BX 24286 <For_loop^43> "write_24286" 16
mov <For_loop^43>.write BX
jmp 24749           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24294 "!="
tf <esp+2> "in" "codes"
$jmp 24296 "t"
mov <esp+2>["codes"] None
jmp 24296
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24286+2> <esp+2>["codes"]


mov AX <write_24286+0>.base_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 2        ;Àx¦sCX
push [2]
push "ex_func AX \"iter\" "
mov AX <write_24286+0>.base_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] <write_24286+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24286+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "fetch AX <esp+1>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24286+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+0>.vnames
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 24381 "f"
mov AX True
jmp 24382
mov AX False
cmp AX 1
$jmp 24413 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_24286+0>.vnames
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_24286+0>.vnames
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " AX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
jmp 24465        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+0>.vnames
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 24464 "f"
mov <write_24286+5> AX
push <write_24286+0>.vnames
mov BX <write_24286+5>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_24286+0>.vnames
mov BX <write_24286+5>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " AX["
ex_func AX "str" <write_24286+5>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
jmp 24429
inc esp
push [0]
mov <write_24286+6> <esp+1>
inc esp
push [0]
mov <write_24286+7> <esp+1>
inc esp
ex_func AX "iter" <write_24286+0>.codelines
push AX
fetch AX <esp+1>
$jmp 24597 "f"
mov <write_24286+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24286+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+8>.write
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_24286+9>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 24595 "f"
mov <write_24286+5> AX
push <write_24286+2>
push <write_24286+9>
oper <esp+1> "+" <write_24286+5>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_24286+10> <esp+1>
inc esp
mov DX <write_24286+10>
tf DX "equ" "continue"
$jmp 24540 "f"
mov AX True
jmp 24541
mov AX False
cmp AX 1
$jmp 24558 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "jmp "
push <write_24286+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_24286+2>
push <write_24286+9>
oper <esp+1> "+" <write_24286+5>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24594        ;¸õ¦Ü©³³¡
mov DX <write_24286+10>
tf DX "equ" "break"
$jmp 24563 "f"
mov AX True
jmp 24564
mov AX False
cmp AX 1
$jmp 24576 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_24286+9>
oper <esp+1> "+" <write_24286+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+6>.append
jmp 24594        ;¸õ¦Ü©³³¡
mov DX <write_24286+10>
tf DX "equ" "return"
$jmp 24581 "f"
mov AX True
jmp 24582
mov AX False
cmp AX 1
$jmp 24594 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_24286+9>
oper <esp+1> "+" <write_24286+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+7>.append
jmp 24594        ;¸õ¦Ü©³³¡
jmp 24511
inc esp
jmp 24473
inc esp
push 1        ;Àx¦sCX
push [1]
push "jmp "
push <write_24286+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 24624 "<="
mov AX True
jmp 24625
mov AX False
cmp AX 1
$jmp 24671 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24286+11> <esp+1>
inc esp
ex_func AX "iter" <write_24286+7>
push AX
fetch AX <esp+1>
$jmp 24655 "f"
mov <write_24286+12> AX
push "jmp "
push <write_24286+11>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_24286+2>
mov BX <write_24286+12>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24639
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "return AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
jmp 24671        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_24286+13> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_24286+13>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"f\""
push <write_24286+2>
mov BX <write_24286+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_24286+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 24704 "f"
mov <write_24286+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+8>.write
jmp 24693
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24286+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_24286+14> <esp+1>
inc esp
ex_func AX "iter" <write_24286+6>
push AX
fetch AX <esp+1>
$jmp 24731 "f"
mov <write_24286+15> AX
push "jmp "
ex_func AX "str" <write_24286+14>
oper <esp+1> "+" AX
oper <esp+1> "+" "          ;break¥X°j°é"
push <write_24286+2>
mov BX <write_24286+15>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24718
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24286+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24286" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
pop ip
mov AX <For_loop^43>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24761 "=="
tf AX "Ctn" "__init__"
$jmp 24759 "t"
jmp 24761
call AX.__init__
mov AX <For_loop^43>
end "Function" "For_loop^43"
pop ip
Function <&module_14697+29> 24766 None "Mark^44" 1
name <&module_14697+29> "<class '__main__.Mark'>"
jmp 24858
tf $Inheritance "equ" None
$jmp 24771 "t"
mov <Mark^44> $Inheritance
push 1
jmp 24773
mov <Mark^44> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Mark^44> <&module_14697+29>
Function BX 24781 <Mark^44> "__init___24781" 3
mov <Mark^44>.__init__ BX
jmp 24801           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24789 "!="
tf <esp+2> "in" "mark"
$jmp 24791 "t"
mov <esp+2>["mark"] None
jmp 24791
mov <esp+2>["mark"] <esp+1>[0]
dec CX
mov <__init___24781+2> <esp+2>["mark"]


push <__init___24781+2>
mov <__init___24781+0>.mark <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24781" "0,1,2"
pop ip
Function BX 24804 <Mark^44> "__str___24804" 2
mov <Mark^44>.__str__ BX
jmp 24817           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<mark "
ex_func AX "str" <__str___24804+0>.mark
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 24814         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24804" "0,1"
pop ip
Function BX 24820 <Mark^44> "write_24820" 3
mov <Mark^44>.write BX
jmp 24844           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24828 "!="
tf <esp+2> "in" "codes"
$jmp 24830 "t"
mov <esp+2>["codes"] None
jmp 24830
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24820+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24820+0>.mark
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24820+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24820" "0,1,2"
pop ip
mov AX <Mark^44>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24856 "=="
tf AX "Ctn" "__init__"
$jmp 24854 "t"
jmp 24856
call AX.__init__
mov AX <Mark^44>
end "Function" "Mark^44"
pop ip
Function <&module_14697+30> 24861 None "Pass^45" 1
name <&module_14697+30> "<class '__main__.Pass'>"
jmp 24930
tf $Inheritance "equ" None
$jmp 24866 "t"
mov <Pass^45> $Inheritance
push 1
jmp 24868
mov <Pass^45> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Pass^45> <&module_14697+30>
Function BX 24876 <Pass^45> "__init___24876" 2
mov <Pass^45>.__init__ BX
jmp 24884           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24876" "0,1"
pop ip
Function BX 24887 <Pass^45> "__str___24887" 2
mov <Pass^45>.__str__ BX
jmp 24896           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<pass>"
jmp 24893         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24887" "0,1"
pop ip
Function BX 24899 <Pass^45> "write_24899" 3
mov <Pass^45>.write BX
jmp 24916           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24907 "!="
tf <esp+2> "in" "codes"
$jmp 24909 "t"
mov <esp+2>["codes"] None
jmp 24909
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24899+2> <esp+2>["codes"]


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24899" "0,1,2"
pop ip
mov AX <Pass^45>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24928 "=="
tf AX "Ctn" "__init__"
$jmp 24926 "t"
jmp 24928
call AX.__init__
mov AX <Pass^45>
end "Function" "Pass^45"
pop ip
Function <&module_14697+31> 24933 None "TFN^46" 1
name <&module_14697+31> "<class '__main__.TFN'>"
jmp 25021
tf $Inheritance "equ" None
$jmp 24938 "t"
mov <TFN^46> $Inheritance
push 1
jmp 24940
mov <TFN^46> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <TFN^46> <&module_14697+31>
Function BX 24948 <TFN^46> "__init___24948" 3
mov <TFN^46>.__init__ BX
jmp 24968           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24956 "!="
tf <esp+2> "in" "value"
$jmp 24958 "t"
mov <esp+2>["value"] None
jmp 24958
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <__init___24948+2> <esp+2>["value"]


push <__init___24948+2>
mov <__init___24948+0>.value <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24948" "0,1,2"
pop ip
Function BX 24971 <TFN^46> "__str___24971" 2
mov <TFN^46>.__str__ BX
jmp 24984           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___24971+0>.value
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 24981         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24971" "0,1"
pop ip
Function BX 24987 <TFN^46> "write_24987" 3
mov <TFN^46>.write BX
jmp 25007           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24995 "!="
tf <esp+2> "in" "codes"
$jmp 24997 "t"
mov <esp+2>["codes"] None
jmp 24997
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24987+2> <esp+2>["codes"]


push <write_24987+0>.value
mov <write_24987+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24987" "0,1,2"
pop ip
mov AX <TFN^46>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25019 "=="
tf AX "Ctn" "__init__"
$jmp 25017 "t"
jmp 25019
call AX.__init__
mov AX <TFN^46>
end "Function" "TFN^46"
pop ip
Function <&module_14697+32> 25024 None "Class^47" 1
name <&module_14697+32> "<class '__main__.Class'>"
jmp 25734
tf $Inheritance "equ" None
$jmp 25029 "t"
mov <Class^47> $Inheritance
push 1
jmp 25031
mov <Class^47> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Class^47> <&module_14697+32>
Function BX 25039 <Class^47> "__init___25039" 7
mov <Class^47>.__init__ BX
jmp 25115           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25047 "!="
tf <esp+2> "in" "name"
$jmp 25049 "t"
mov <esp+2>["name"] None
jmp 25049
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 25055 "!="
tf <esp+2> "in" "info"
$jmp 25057 "t"
mov <esp+2>["info"] None
jmp 25057
mov <esp+2>["info"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 25063 "!="
tf <esp+2> "in" "namespace"
$jmp 25065 "t"
mov <esp+2>["namespace"] None
jmp 25065
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 25071 "!="
tf <esp+2> "in" "class_esp"
$jmp 25073 "t"
mov <esp+2>["class_esp"] None
jmp 25073
mov <esp+2>["class_esp"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 25079 "!="
tf <esp+2> "in" "father"
$jmp 25081 "t"
mov <esp+2>["father"] None
jmp 25081
mov <esp+2>["father"] <esp+1>[4]
dec CX
mov <__init___25039+2> <esp+2>["name"]
mov <__init___25039+3> <esp+2>["info"]
mov <__init___25039+4> <esp+2>["namespace"]
mov <__init___25039+5> <esp+2>["class_esp"]
mov <__init___25039+6> <esp+2>["father"]


push <__init___25039+2>
mov <__init___25039+0>.name <esp+1>
inc esp
push <__init___25039+3>.funcs
mov <__init___25039+0>.functions <esp+1>
inc esp
push <__init___25039+3>.codelines
mov <__init___25039+0>.codelines <esp+1>
inc esp
push <__init___25039+4>
mov <__init___25039+0>.namespace <esp+1>
inc esp
push <__init___25039+5>
mov <__init___25039+0>.class_esp <esp+1>
inc esp
push <__init___25039+6>
mov <__init___25039+0>.father <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___25039+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25039" "0,1,2,3,4,5,6"
pop ip
Function BX 25118 <Class^47> "__str___25118" 2
mov <Class^47>.__str__ BX
jmp 25131           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<class "
ex_func AX "str" <__str___25118+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 25128         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___25118" "0,1"
pop ip
Function BX 25134 <Class^47> "write_25134" 11
mov <Class^47>.write BX
jmp 25720           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25142 "!="
tf <esp+2> "in" "codes"
$jmp 25144 "t"
mov <esp+2>["codes"] None
jmp 25144
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_25134+2> <esp+2>["codes"]


mov DX <write_25134+0>.namespace
tf DX "equ" ""
$jmp 25152 "t"
mov AX True
jmp 25153
mov AX False
cmp AX 1
$jmp 25216 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_25134+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 2        ;Àx¦sCX
push [2]
push "Function BX "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 3
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_25134+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\" 1"
pop <esp+1>[0]
mov <esp+1>[1] <write_25134+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push ""
mov AX <write_25134+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_25134+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_25134+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_25134+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " BX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
jmp 25247        ;¸õ¦Ü©³³¡
push <write_25134+0>.name
mov <write_25134+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push "Function "
ex_func AX "str" <write_25134+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " None \""
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\" 1"
pop <esp+1>[0]
mov <esp+1>[1] <write_25134+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "name "
ex_func AX "str" <write_25134+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"<class \'__main__."
ex_func AX "str" <write_25134+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "\'>\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25134+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "tf $Inheritance \"equ\" None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 3
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> $Inheritance"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> [class]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Inheritance None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
mov DX <write_25134+0>.father
tf DX "equ" None
$jmp 25402 "t"
mov AX True
jmp 25403
mov AX False
cmp AX 1
$jmp 25487 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+0>.father
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&module_14697+11>
$jmp 25417 "f"
mov AX True
jmp 25418
mov AX False
cmp AX 1
$jmp 25425 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_25134+0>.father      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.elements
mov <write_25134+5> <esp+1>
inc esp
jmp 25429        ;¸õ¦Ü©³³¡
push [1]
mov <esp+1>[0] <write_25134+0>.father
mov <write_25134+5> <esp+1>
inc esp
ex_func AX "iter" <write_25134+5>
push AX
fetch AX <esp+1>
$jmp 25485 "f"
mov <write_25134+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+6>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs <esp+1>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov *args <esp+2>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov CX <esp+3>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $Inheritance <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "call "
ex_func AX "str" <write_25134+6>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
jmp 25431
inc esp
jmp 25487        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "type <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> "
ex_func AX "str" <write_25134+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
ex_func AX "iter" <write_25134+0>.codelines
push AX
fetch AX <esp+1>
$jmp 25514 "f"
mov <write_25134+7> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+7>.write
jmp 25503
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov AX <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp BX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25134+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "tf AX \"Ctn\" \"__init__\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25134+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call AX.__init__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov AX <"
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_25134+10> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_25134+10>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_25134+2>
mov BX <write_25134+8>
pop AX
mov AX[BX] <esp+1>
inc esp
push "jmp "
ex_func AX "str" <write_25134+10>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_25134+2>
mov BX <write_25134+9>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_25134+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop ip"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.append
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25134+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_25134+2>
mov BX <write_25134+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push "AX"
mov <write_25134+0>.location <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25134+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_25134" "0,1,2,3,4,5,6,7,8,9,10"
pop ip
mov AX <Class^47>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25732 "=="
tf AX "Ctn" "__init__"
$jmp 25730 "t"
jmp 25732
call AX.__init__
mov AX <Class^47>
end "Function" "Class^47"
pop ip
Function <&module_14697+33> 25736 None "two_object_write_25736" 5
jmp 25924           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25744 "!="
tf <esp+2> "in" "A"
$jmp 25746 "t"
mov <esp+2>["A"] None
jmp 25746
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 25752 "!="
tf <esp+2> "in" "B"
$jmp 25754 "t"
mov <esp+2>["B"] None
jmp 25754
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 25760 "!="
tf <esp+2> "in" "codes"
$jmp 25762 "t"
mov <esp+2>["codes"] None
jmp 25762
mov <esp+2>["codes"] <esp+1>[2]
dec CX
mov <two_object_write_25736+1> <esp+2>["A"]
mov <two_object_write_25736+2> <esp+2>["B"]
mov <two_object_write_25736+3> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_25736+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+1>.write
push <two_object_write_25736+1>.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX."
$jmp 25789 "f"
mov AX True
jmp 25790
mov AX False
cmp AX 1
$jmp 25802 "=="
mov DX <two_object_write_25736+1>.location
tf DX "equ" "AX"
$jmp 25797 "f"
mov AX True
jmp 25798
mov AX False
cmp AX 1
$jmp 25802 "=="
mov AX 0
jmp 25803
mov AX 1
cmp AX 1
$jmp 25841 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_25736+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+2>.write
push 1        ;Àx¦sCX
push [1]
push "mov BX "
ex_func AX "str" <two_object_write_25736+2>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push "BX"
mov <two_object_write_25736+4> <esp+1>
inc esp
jmp 25919        ;¸õ¦Ü©³³¡
push <two_object_write_25736+1>.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX["
$jmp 25856 "f"
mov AX True
jmp 25857
mov AX False
cmp AX 1
$jmp 25909 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_25736+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+2>.write
push 1        ;Àx¦sCX
push [1]
push "mov DX "
ex_func AX "str" <two_object_write_25736+2>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+3>.append
push "DX"
mov <two_object_write_25736+4> <esp+1>
inc esp
jmp 25919        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_25736+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_25736+2>.write
push <two_object_write_25736+2>.location
mov <two_object_write_25736+4> <esp+1>
inc esp
mov AX <two_object_write_25736+4>
jmp 25921         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "two_object_write_25736" "0,1,2,3,4"
pop ip
Function <&module_14697+34> 25927 None "Multiple_Mov^48" 1
name <&module_14697+34> "<class '__main__.Multiple_Mov'>"
jmp 26269
tf $Inheritance "equ" None
$jmp 25932 "t"
mov <Multiple_Mov^48> $Inheritance
push 1
jmp 25934
mov <Multiple_Mov^48> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Multiple_Mov^48> <&module_14697+34>
Function BX 25942 <Multiple_Mov^48> "__init___25942" 5
mov <Multiple_Mov^48>.__init__ BX
jmp 26021           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25950 "!="
tf <esp+2> "in" "obj_list"
$jmp 25952 "t"
mov <esp+2>["obj_list"] None
jmp 25952
mov <esp+2>["obj_list"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 25958 "!="
tf <esp+2> "in" "target"
$jmp 25960 "t"
mov <esp+2>["target"] None
jmp 25960
mov <esp+2>["target"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 25966 "!="
tf <esp+2> "in" "op"
$jmp 25968 "t"
mov <esp+2>["op"] None
jmp 25968
mov <esp+2>["op"] <esp+1>[2]
dec CX
mov <__init___25942+2> <esp+2>["obj_list"]
mov <__init___25942+3> <esp+2>["target"]
mov <__init___25942+4> <esp+2>["op"]


push <__init___25942+2>
mov <__init___25942+0>.obj_list <esp+1>
inc esp
push <__init___25942+3>
mov <__init___25942+0>.target <esp+1>
inc esp
mov DX <__init___25942+4>
tf DX "equ" "="
$jmp 25984 "f"
mov AX True
jmp 25985
mov AX False
cmp AX 1
$jmp 25994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <__init___25942+0>.ctype <esp+1>
inc esp
push "mov"
mov <__init___25942+0>.cmd <esp+1>
inc esp
jmp 26012        ;¸õ¦Ü©³³¡
push 1
mov <__init___25942+0>.ctype <esp+1>
inc esp
push <__init___25942+4>
push [3]
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <__init___25942+0>.cmd <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___25942+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25942" "0,1,2,3,4"
pop ip
Function BX 26024 <Multiple_Mov^48> "__str___26024" 2
mov <Multiple_Mov^48>.__str__ BX
jmp 26033           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<Multiple mov>"
jmp 26030         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26024" "0,1"
pop ip
Function BX 26036 <Multiple_Mov^48> "write_26036" 5
mov <Multiple_Mov^48>.write BX
jmp 26255           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26044 "!="
tf <esp+2> "in" "codes"
$jmp 26046 "t"
mov <esp+2>["codes"] None
jmp 26046
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26036+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_26036+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
mov AX <write_26036+0>.target      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26036+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_26036+0>.target      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
ex_func AX "iter" <write_26036+0>.obj_list
push AX
fetch AX <esp+1>
$jmp 26243 "f"
mov <write_26036+3> AX
push (2)
mov <esp+1>[0] <&module_14697+11>
mov <esp+1>[1] <&module_14697+10>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26036+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 26192 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26036+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 26190 "f"
mov <write_26036+4> AX
push <write_26036+3>
mov BX <write_26036+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26036+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <write_26036+0>.ctype
tf DX "equ" 0
$jmp 26137 "f"
mov AX True
jmp 26138
mov AX False
cmp AX 1
$jmp 26159 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_26036+3>
mov BX <write_26036+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>["
ex_func AX "str" <write_26036+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
jmp 26189        ;¸õ¦Ü©³³¡
mov DX <write_26036+0>.ctype
tf DX "equ" 1
$jmp 26164 "f"
mov AX True
jmp 26165
mov AX False
cmp AX 1
$jmp 26189 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "$mov "
push <write_26036+3>
mov BX <write_26036+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26036+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" <esp+1>["
ex_func AX "str" <write_26036+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
jmp 26189        ;¸õ¦Ü©³³¡
jmp 26116
inc esp
jmp 26242        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26036+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+3>.write
mov DX <write_26036+0>.ctype
tf DX "equ" 0
$jmp 26204 "f"
mov AX True
jmp 26205
mov AX False
cmp AX 1
$jmp 26219 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_26036+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
jmp 26242        ;¸õ¦Ü©³³¡
mov DX <write_26036+0>.ctype
tf DX "equ" 1
$jmp 26224 "f"
mov AX True
jmp 26225
mov AX False
cmp AX 1
$jmp 26242 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "$mov "
ex_func AX "str" <write_26036+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26036+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
jmp 26242        ;¸õ¦Ü©³³¡
jmp 26081
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26036+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26036" "0,1,2,3,4"
pop ip
mov AX <Multiple_Mov^48>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26267 "=="
tf AX "Ctn" "__init__"
$jmp 26265 "t"
jmp 26267
call AX.__init__
mov AX <Multiple_Mov^48>
end "Function" "Multiple_Mov^48"
pop ip
Function <&module_14697+35> 26272 None "Oper^49" 1
name <&module_14697+35> "<class '__main__.Oper'>"
jmp 26444
tf $Inheritance "equ" None
$jmp 26277 "t"
mov <Oper^49> $Inheritance
push 1
jmp 26279
mov <Oper^49> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Oper^49> <&module_14697+35>
Function BX 26287 <Oper^49> "__init___26287" 5
mov <Oper^49>.__init__ BX
jmp 26331           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26295 "!="
tf <esp+2> "in" "A"
$jmp 26297 "t"
mov <esp+2>["A"] None
jmp 26297
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26303 "!="
tf <esp+2> "in" "B"
$jmp 26305 "t"
mov <esp+2>["B"] None
jmp 26305
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26311 "!="
tf <esp+2> "in" "symbol"
$jmp 26313 "t"
mov <esp+2>["symbol"] None
jmp 26313
mov <esp+2>["symbol"] <esp+1>[2]
dec CX
mov <__init___26287+2> <esp+2>["A"]
mov <__init___26287+3> <esp+2>["B"]
mov <__init___26287+4> <esp+2>["symbol"]


push <__init___26287+2>
mov <__init___26287+0>.A <esp+1>
inc esp
push <__init___26287+3>
mov <__init___26287+0>.B <esp+1>
inc esp
push <__init___26287+4>
mov <__init___26287+0>.symbol <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26287" "0,1,2,3,4"
pop ip
Function BX 26334 <Oper^49> "__str___26334" 2
mov <Oper^49>.__str__ BX
jmp 26353           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26334+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26334+0>.symbol
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26334+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26350         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26334" "0,1"
pop ip
Function BX 26356 <Oper^49> "write_26356" 3
mov <Oper^49>.write BX
jmp 26430           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26364 "!="
tf <esp+2> "in" "codes"
$jmp 26366 "t"
mov <esp+2>["codes"] None
jmp 26366
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26356+2> <esp+2>["codes"]


mov AX <write_26356+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26356+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_26356+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26356+2>.append
mov AX <write_26356+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26356+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "oper <esp+1> \""
ex_func AX "str" <write_26356+0>.symbol
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
mov AX <write_26356+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26356+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26356+2>.append
push "AX"
mov <write_26356+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26356" "0,1,2"
pop ip
mov AX <Oper^49>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26442 "=="
tf AX "Ctn" "__init__"
$jmp 26440 "t"
jmp 26442
call AX.__init__
mov AX <Oper^49>
end "Function" "Oper^49"
pop ip
Function <&module_14697+36> 26447 None "Tf^50" 1
name <&module_14697+36> "<class '__main__.Tf'>"
jmp 26602
tf $Inheritance "equ" None
$jmp 26452 "t"
mov <Tf^50> $Inheritance
push 1
jmp 26454
mov <Tf^50> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Tf^50> <&module_14697+36>
Function BX 26462 <Tf^50> "__init___26462" 5
mov <Tf^50>.__init__ BX
jmp 26506           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26470 "!="
tf <esp+2> "in" "A"
$jmp 26472 "t"
mov <esp+2>["A"] None
jmp 26472
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26478 "!="
tf <esp+2> "in" "B"
$jmp 26480 "t"
mov <esp+2>["B"] None
jmp 26480
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26486 "!="
tf <esp+2> "in" "cmd"
$jmp 26488 "t"
mov <esp+2>["cmd"] None
jmp 26488
mov <esp+2>["cmd"] <esp+1>[2]
dec CX
mov <__init___26462+2> <esp+2>["A"]
mov <__init___26462+3> <esp+2>["B"]
mov <__init___26462+4> <esp+2>["cmd"]


push <__init___26462+2>
mov <__init___26462+0>.A <esp+1>
inc esp
push <__init___26462+3>
mov <__init___26462+0>.B <esp+1>
inc esp
push <__init___26462+4>
mov <__init___26462+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26462" "0,1,2,3,4"
pop ip
Function BX 26509 <Tf^50> "__str___26509" 2
mov <Tf^50>.__str__ BX
jmp 26528           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26509+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26509+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26509+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26525         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26509" "0,1"
pop ip
Function BX 26531 <Tf^50> "write_26531" 4
mov <Tf^50>.write BX
jmp 26588           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26539 "!="
tf <esp+2> "in" "codes"
$jmp 26541 "t"
mov <esp+2>["codes"] None
jmp 26541
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26531+2> <esp+2>["codes"]


push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <write_26531+0>.A
mov <esp+1>[1] <write_26531+0>.B
mov <esp+1>[2] <write_26531+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+33>
push AX
mov <write_26531+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "tf "
mov AX <write_26531+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26531+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
ex_func AX "str" <write_26531+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26531+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX TF"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26531+2>.append
push "AX"
mov <write_26531+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26531" "0,1,2,3"
pop ip
mov AX <Tf^50>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26600 "=="
tf AX "Ctn" "__init__"
$jmp 26598 "t"
jmp 26600
call AX.__init__
mov AX <Tf^50>
end "Function" "Tf^50"
pop ip
Function <&module_14697+37> 26605 None "AndOr^51" 1
name <&module_14697+37> "<class '__main__.AndOr'>"
jmp 26953
tf $Inheritance "equ" None
$jmp 26610 "t"
mov <AndOr^51> $Inheritance
push 1
jmp 26612
mov <AndOr^51> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <AndOr^51> <&module_14697+37>
Function BX 26620 <AndOr^51> "__init___26620" 5
mov <AndOr^51>.__init__ BX
jmp 26664           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26628 "!="
tf <esp+2> "in" "A"
$jmp 26630 "t"
mov <esp+2>["A"] None
jmp 26630
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26636 "!="
tf <esp+2> "in" "B"
$jmp 26638 "t"
mov <esp+2>["B"] None
jmp 26638
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26644 "!="
tf <esp+2> "in" "cmd"
$jmp 26646 "t"
mov <esp+2>["cmd"] None
jmp 26646
mov <esp+2>["cmd"] <esp+1>[2]
dec CX
mov <__init___26620+2> <esp+2>["A"]
mov <__init___26620+3> <esp+2>["B"]
mov <__init___26620+4> <esp+2>["cmd"]


push <__init___26620+2>
mov <__init___26620+0>.A <esp+1>
inc esp
push <__init___26620+3>
mov <__init___26620+0>.B <esp+1>
inc esp
push <__init___26620+4>
mov <__init___26620+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26620" "0,1,2,3,4"
pop ip
Function BX 26667 <AndOr^51> "__str___26667" 2
mov <AndOr^51>.__str__ BX
jmp 26686           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26667+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26667+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26667+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26683         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26667" "0,1"
pop ip
Function BX 26689 <AndOr^51> "write_26689" 7
mov <AndOr^51>.write BX
jmp 26939           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26697 "!="
tf <esp+2> "in" "codes"
$jmp 26699 "t"
mov <esp+2>["codes"] None
jmp 26699
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26689+2> <esp+2>["codes"]


mov AX <write_26689+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_26689+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_26689+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
mov AX <write_26689+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_26689+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_26689+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
mov DX <write_26689+0>.cmd
tf DX "equ" "and"
$jmp 26785 "f"
mov AX True
jmp 26786
mov AX False
cmp AX 1
$jmp 26856 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_26689+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 0"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push "$jmp "
ex_func AX "str" <write_26689+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_26689+2>
mov BX <write_26689+3>
pop AX
mov AX[BX] <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_26689+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_26689+2>
mov BX <write_26689+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 26932        ;¸õ¦Ü©³³¡
mov DX <write_26689+0>.cmd
tf DX "equ" "or"
$jmp 26861 "f"
mov AX True
jmp 26862
mov AX False
cmp AX 1
$jmp 26932 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26689+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_26689+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 1"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_26689+2>.append
push "$jmp "
ex_func AX "str" <write_26689+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_26689+2>
mov BX <write_26689+3>
pop AX
mov AX[BX] <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_26689+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_26689+2>
mov BX <write_26689+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 26932        ;¸õ¦Ü©³³¡
push "AX"
mov <write_26689+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26689" "0,1,2,3,4,5,6"
pop ip
mov AX <AndOr^51>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26951 "=="
tf AX "Ctn" "__init__"
$jmp 26949 "t"
jmp 26951
call AX.__init__
mov AX <AndOr^51>
end "Function" "AndOr^51"
pop ip
Function <&module_14697+38> 26956 None "Deny^52" 1
name <&module_14697+38> "<class '__main__.Deny'>"
jmp 27102
tf $Inheritance "equ" None
$jmp 26961 "t"
mov <Deny^52> $Inheritance
push 1
jmp 26963
mov <Deny^52> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Deny^52> <&module_14697+38>
Function BX 26971 <Deny^52> "__init___26971" 4
mov <Deny^52>.__init__ BX
jmp 27003           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26979 "!="
tf <esp+2> "in" "A"
$jmp 26981 "t"
mov <esp+2>["A"] None
jmp 26981
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26987 "!="
tf <esp+2> "in" "cmd"
$jmp 26989 "t"
mov <esp+2>["cmd"] None
jmp 26989
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___26971+2> <esp+2>["A"]
mov <__init___26971+3> <esp+2>["cmd"]


push <__init___26971+2>
mov <__init___26971+0>.A <esp+1>
inc esp
push <__init___26971+3>
mov <__init___26971+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26971" "0,1,2,3"
pop ip
Function BX 27006 <Deny^52> "__str___27006" 2
mov <Deny^52>.__str__ BX
jmp 27022           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___27006+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___27006+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 27019         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27006" "0,1"
pop ip
Function BX 27025 <Deny^52> "write_27025" 3
mov <Deny^52>.write BX
jmp 27088           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27033 "!="
tf <esp+2> "in" "codes"
$jmp 27035 "t"
mov <esp+2>["codes"] None
jmp 27035
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27025+2> <esp+2>["codes"]


mov AX <write_27025+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27025+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_27025+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 27054 "t"
mov AX True
jmp 27055
mov AX False
cmp AX 1
$jmp 27070 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_27025+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27025+2>.append
jmp 27070        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "$oper AX \""
ex_func AX "str" <write_27025+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27025+2>.append
push "AX"
mov <write_27025+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27025" "0,1,2"
pop ip
mov AX <Deny^52>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27100 "=="
tf AX "Ctn" "__init__"
$jmp 27098 "t"
jmp 27100
call AX.__init__
mov AX <Deny^52>
end "Function" "Deny^52"
pop ip
Function <&module_14697+39> 27105 None "Bool^53" 1
name <&module_14697+39> "<class '__main__.Bool'>"
jmp 27546
tf $Inheritance "equ" None
$jmp 27110 "t"
mov <Bool^53> $Inheritance
push 1
jmp 27112
mov <Bool^53> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Bool^53> <&module_14697+39>
Function BX 27120 <Bool^53> "__init___27120" 3
mov <Bool^53>.__init__ BX
jmp 27140           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27128 "!="
tf <esp+2> "in" "enequalbox"
$jmp 27130 "t"
mov <esp+2>["enequalbox"] None
jmp 27130
mov <esp+2>["enequalbox"] <esp+1>[0]
dec CX
mov <__init___27120+2> <esp+2>["enequalbox"]


push <__init___27120+2>
mov <__init___27120+0>.enebox <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27120" "0,1,2"
pop ip
Function BX 27143 <Bool^53> "__str___27143" 4
mov <Bool^53>.__str__ BX
jmp 27172           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
mov <__str___27143+2> <esp+1>
inc esp
ex_func AX "iter" <__str___27143+0>.enebox
push AX
fetch AX <esp+1>
$jmp 27166 "f"
mov <__str___27143+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___27143+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
$mov <__str___27143+2> "+" <esp+1>
inc esp
jmp 27152
inc esp
mov AX <__str___27143+2>
jmp 27169         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27143" "0,1,2,3"
pop ip
Function BX 27175 <Bool^53> "write_27175" 9
mov <Bool^53>.write BX
jmp 27532           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27183 "!="
tf <esp+2> "in" "codes"
$jmp 27185 "t"
mov <esp+2>["codes"] None
jmp 27185
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27175+2> <esp+2>["codes"]


push 0
mov <write_27175+3> <esp+1>
inc esp
push <write_27175+0>.enebox
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
push <write_27175+0>.enebox
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push [0]
mov <write_27175+4> <esp+1>
inc esp
push [0]
mov <write_27175+5> <esp+1>
inc esp
push [dict]
mov BX "=="
mov <esp+1>[BX] "f"
mov BX "!="
mov <esp+1>[BX] "t"
mov BX ">"
mov <esp+1>[BX] "<="
mov BX "<"
mov <esp+1>[BX] ">="
mov BX ">="
mov <esp+1>[BX] "<"
mov BX "<="
mov <esp+1>[BX] ">"
mov <write_27175+6> <esp+1>
inc esp
push <write_27175+3>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+0>.enebox
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
cmp DX AX
$jmp 27256 ">="
mov AX True
jmp 27257
mov AX False
cmp AX 1
$jmp 27426 "!="
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop DX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push (2)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 27338 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "tf DX \"equ\" "
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
push <write_27175+6>
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+5>.append
jmp 27380        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "cmp DX "
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
push <write_27175+6>
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+4>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push <write_27175+3>
oper <esp+1> "+" 3
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+0>.enebox
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 27401 ">="
mov AX True
jmp 27402
mov AX False
cmp AX 1
$jmp 27422 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
push <write_27175+0>.enebox
push <write_27175+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
jmp 27422        ;¸õ¦Ü©³³¡
push 2
$mov <write_27175+3> "+" <esp+1>
inc esp
jmp 27240               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX True"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27175+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_27175+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX False"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_27175+2>.append
ex_func AX "iter" <write_27175+4>
push AX
fetch AX <esp+1>
$jmp 27499 "f"
mov <write_27175+8> AX
push "$jmp "
ex_func AX "str" <write_27175+7>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_27175+8>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_27175+2>
push <write_27175+8>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27477
inc esp
ex_func AX "iter" <write_27175+5>
push AX
fetch AX <esp+1>
$jmp 27524 "f"
mov <write_27175+8> AX
push "$jmp "
ex_func AX "str" <write_27175+7>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_27175+8>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_27175+2>
push <write_27175+8>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27502
inc esp
push "AX"
mov <write_27175+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27175" "0,1,2,3,4,5,6,7,8"
pop ip
mov AX <Bool^53>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27544 "=="
tf AX "Ctn" "__init__"
$jmp 27542 "t"
jmp 27544
call AX.__init__
mov AX <Bool^53>
end "Function" "Bool^53"
pop ip
Function <&module_14697+40> 27549 None "Assert^54" 1
name <&module_14697+40> "<class '__main__.Assert'>"
jmp 27752
tf $Inheritance "equ" None
$jmp 27554 "t"
mov <Assert^54> $Inheritance
push 1
jmp 27556
mov <Assert^54> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Assert^54> <&module_14697+40>
Function BX 27564 <Assert^54> "__init___27564" 4
mov <Assert^54>.__init__ BX
jmp 27601           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27572 "!="
tf <esp+2> "in" "event"
$jmp 27574 "t"
mov <esp+2>["event"] None
jmp 27574
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 27580 "!="
tf <esp+2> "in" "msg"
$jmp 27582 "t"
mov <esp+2>["msg"] None
jmp 27582
mov <esp+2>["msg"] <esp+1>[1]
dec CX
mov <__init___27564+2> <esp+2>["event"]
mov <__init___27564+3> <esp+2>["msg"]


push <__init___27564+2>
mov <__init___27564+0>.event <esp+1>
inc esp
push <__init___27564+3>
mov <__init___27564+0>.msg <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___27564+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27564" "0,1,2,3"
pop ip
Function BX 27604 <Assert^54> "__str___27604" 2
mov <Assert^54>.__str__ BX
jmp 27620           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<assert "
ex_func AX "str" <__str___27604+0>.event
oper <esp+1> "+" AX
oper <esp+1> "+" ", "
ex_func AX "str" <__str___27604+0>.msg
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 27617         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27604" "0,1"
pop ip
Function BX 27623 <Assert^54> "write_27623" 7
mov <Assert^54>.write BX
jmp 27738           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27631 "!="
tf <esp+2> "in" "codes"
$jmp 27633 "t"
mov <esp+2>["codes"] None
jmp 27633
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27623+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_27623+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27623+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_27623+0>.event
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+38>
push AX
mov <write_27623+3> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AssertionError"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [1]
mov <esp+1>[0] <write_27623+0>.msg
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+17>
push AX
mov <write_27623+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_27623+4>
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+18>
push AX
mov <write_27623+5> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push [1]
push [2]
mov <esp+1>[0] <write_27623+3>
push [1]
mov <esp+1>[0] <write_27623+5>
pop <esp+1>[1]
pop <esp+1>[0]
pop <esp+1>[0]
mov <esp+1>[1] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14697+25>
push AX
mov <write_27623+6> <esp+1>
inc esp
push [1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
mov <write_27623+6>.orig_lines <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27623+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27623+6>.write
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27623" "0,1,2,3,4,5,6"
pop ip
mov AX <Assert^54>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27750 "=="
tf AX "Ctn" "__init__"
$jmp 27748 "t"
jmp 27750
call AX.__init__
mov AX <Assert^54>
end "Function" "Assert^54"
pop ip
Function <&module_14697+41> 27755 None "STR^55" 1
name <&module_14697+41> "<class '__main__.STR'>"
jmp 27865
tf $Inheritance "equ" None
$jmp 27760 "t"
mov <STR^55> $Inheritance
push 1
jmp 27762
mov <STR^55> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <STR^55> <&module_14697+41>
Function BX 27770 <STR^55> "__init___27770" 3
mov <STR^55>.__init__ BX
jmp 27790           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27778 "!="
tf <esp+2> "in" "obj"
$jmp 27780 "t"
mov <esp+2>["obj"] None
jmp 27780
mov <esp+2>["obj"] <esp+1>[0]
dec CX
mov <__init___27770+2> <esp+2>["obj"]


push <__init___27770+2>
mov <__init___27770+0>.obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27770" "0,1,2"
pop ip
Function BX 27793 <STR^55> "__str___27793" 2
mov <STR^55>.__str__ BX
jmp 27806           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<STR: "
ex_func AX "str" <__str___27793+0>.obj
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 27803         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27793" "0,1"
pop ip
Function BX 27809 <STR^55> "write_27809" 3
mov <STR^55>.write BX
jmp 27851           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27817 "!="
tf <esp+2> "in" "codes"
$jmp 27819 "t"
mov <esp+2>["codes"] None
jmp 27819
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27809+2> <esp+2>["codes"]


mov AX <write_27809+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27809+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"str\" "
mov AX <write_27809+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27809+2>.append
push "AX"
mov <write_27809+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27809" "0,1,2"
pop ip
mov AX <STR^55>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27863 "=="
tf AX "Ctn" "__init__"
$jmp 27861 "t"
jmp 27863
call AX.__init__
mov AX <STR^55>
end "Function" "STR^55"
pop ip
Function <&module_14697+42> 27868 None "Info^56" 1
name <&module_14697+42> "<class '__main__.Info'>"
jmp 28197
tf $Inheritance "equ" None
$jmp 27873 "t"
mov <Info^56> $Inheritance
push 1
jmp 27875
mov <Info^56> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Info^56> <&module_14697+42>
Function BX 27883 <Info^56> "__init___27883" 3
mov <Info^56>.__init__ BX
jmp 27918           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27891 "!="
tf <esp+2> "in" "namespace"
$jmp 27893 "t"
mov <esp+2>["namespace"] None
jmp 27893
mov <esp+2>["namespace"] <esp+1>[0]
dec CX
mov <__init___27883+2> <esp+2>["namespace"]


push [0]
mov <__init___27883+0>.locals <esp+1>
inc esp
push [dict]
mov <__init___27883+0>.vars <esp+1>
inc esp
push [dict]
mov <__init___27883+0>.funcs <esp+1>
inc esp
push [dict]
mov <__init___27883+0>.classes <esp+1>
inc esp
push [0]
mov <__init___27883+0>.codelines <esp+1>
inc esp
push <__init___27883+2>
mov <__init___27883+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27883" "0,1,2"
pop ip
Function BX 27921 <Info^56> "add_info_27921" 4
mov <Info^56>.add_info BX
jmp 28008           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27929 "!="
tf <esp+2> "in" "type"
$jmp 27931 "t"
mov <esp+2>["type"] None
jmp 27931
mov <esp+2>["type"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 27937 "!="
tf <esp+2> "in" "obj"
$jmp 27939 "t"
mov <esp+2>["obj"] None
jmp 27939
mov <esp+2>["obj"] <esp+1>[1]
dec CX
mov <add_info_27921+2> <esp+2>["type"]
mov <add_info_27921+3> <esp+2>["obj"]


mov DX <add_info_27921+2>
tf DX "equ" "var"
$jmp 27948 "f"
mov AX True
jmp 27949
mov AX False
cmp AX 1
$jmp 27958 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_27921+3>
push <add_info_27921+0>.vars
mov BX <add_info_27921+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27988        ;¸õ¦Ü©³³¡
mov DX <add_info_27921+2>
tf DX "equ" "func"
$jmp 27963 "f"
mov AX True
jmp 27964
mov AX False
cmp AX 1
$jmp 27973 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_27921+3>
push <add_info_27921+0>.funcs
mov BX <add_info_27921+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27988        ;¸õ¦Ü©³³¡
mov DX <add_info_27921+2>
tf DX "equ" "class"
$jmp 27978 "f"
mov AX True
jmp 27979
mov AX False
cmp AX 1
$jmp 27988 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_27921+3>
push <add_info_27921+0>.classes
mov BX <add_info_27921+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27988        ;¸õ¦Ü©³³¡
tf <add_info_27921+0>.locals "in" <add_info_27921+3>.name
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 28004 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <add_info_27921+0>.locals      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <add_info_27921+3>.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 28004        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_info_27921" "0,1,2,3"
pop ip
Function BX 28011 <Info^56> "update_28011" 3
mov <Info^56>.update BX
jmp 28061           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28019 "!="
tf <esp+2> "in" "info"
$jmp 28021 "t"
mov <esp+2>["info"] None
jmp 28021
mov <esp+2>["info"] <esp+1>[0]
dec CX
mov <update_28011+2> <esp+2>["info"]


push <update_28011+2>.locals
$mov <update_28011+0>.locals "+" <esp+1>
inc esp
mov AX <update_28011+0>.vars      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28011+2>.vars
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <update_28011+0>.funcs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28011+2>.funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <update_28011+0>.classes      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28011+2>.classes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "update_28011" "0,1,2"
pop ip
Function BX 28064 <Info^56> "write_28064" 5
mov <Info^56>.write BX
jmp 28183           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28072 "!="
tf <esp+2> "in" "codeline"
$jmp 28074 "t"
mov <esp+2>["codeline"] None
jmp 28074
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 28080 "!="
tf <esp+2> "in" "orig_codelines"
$jmp 28082 "t"
mov <esp+2>["orig_codelines"] None
jmp 28082
mov <esp+2>["orig_codelines"] <esp+1>[1]
dec CX
mov <write_28064+2> <esp+2>["codeline"]
mov <write_28064+3> <esp+2>["orig_codelines"]


Function <write_28064+4> 28088 None "deal_orig_28088" 4 "write_28064"
jmp 28166           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28096 "!="
tf <esp+2> "in" "orig_codeline"
$jmp 28098 "t"
mov <esp+2>["orig_codeline"] None
jmp 28098
mov <esp+2>["orig_codeline"] <esp+1>[0]
dec CX
mov <deal_orig_28088+1> <esp+2>["orig_codeline"]


push [0]
mov <deal_orig_28088+2> <esp+1>
inc esp
ex_func AX "iter" <deal_orig_28088+1>
push AX
fetch AX <esp+1>
$jmp 28151 "f"
mov <deal_orig_28088+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28088+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" int
$jmp 28121 "f"
mov AX True
jmp 28122
mov AX False
cmp AX 1
$jmp 28134 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push " "
oper <esp+1> "*" <deal_orig_28088+3>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_orig_28088+2>.append
jmp 28150        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28088+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
oper <esp+1> "+" " "
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_orig_28088+2>.append
jmp 28106
inc esp
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28088+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 28163         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_orig_28088" "0,1,2,3"
pop ip
mov AX <write_28064+0>.codelines      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_28064+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <write_28064+3>
mov <write_28064+2>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_28064" "0,1,2,3"
pop ip
mov AX <Info^56>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 28195 "=="
tf AX "Ctn" "__init__"
$jmp 28193 "t"
jmp 28195
call AX.__init__
mov AX <Info^56>
end "Function" "Info^56"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/module.py"]
mov <&package_6+18> <esp+1>.Integer    ;import *
mov <&package_6+19> <esp+1>.Float    ;import *
mov <&package_6+20> <esp+1>.String    ;import *
mov <&package_6+21> <esp+1>.Byte    ;import *
mov <&package_6+22> <esp+1>.Var_name    ;import *
mov <&package_6+23> <esp+1>.Namespace    ;import *
mov <&package_6+24> <esp+1>.Variable    ;import *
mov <&package_6+25> <esp+1>.SubVariable    ;import *
mov <&package_6+26> <esp+1>.Slice    ;import *
mov <&package_6+27> <esp+1>.IndexVariable    ;import *
mov <&package_6+28> <esp+1>.List    ;import *
mov <&package_6+29> <esp+1>.Tuple    ;import *
mov <&package_6+30> <esp+1>.Dict    ;import *
mov <&package_6+31> <esp+1>.Set    ;import *
mov <&package_6+32> <esp+1>.is_number    ;import *
mov <&package_6+33> <esp+1>.Lambda    ;import *
mov <&package_6+34> <esp+1>.Def    ;import *
mov <&package_6+35> <esp+1>.FuncCall    ;import *
mov <&package_6+36> <esp+1>.Backtrack    ;import *
mov <&package_6+37> <esp+1>.Var_declare    ;import *
mov <&package_6+38> <esp+1>.Try_Except    ;import *
mov <&package_6+39> <esp+1>.With    ;import *
mov <&package_6+40> <esp+1>.Stop    ;import *
mov <&package_6+41> <esp+1>.Command    ;import *
mov <&package_6+42> <esp+1>.sub_if_else    ;import *
mov <&package_6+43> <esp+1>.If_else    ;import *
mov <&package_6+44> <esp+1>.While    ;import *
mov <&package_6+45> <esp+1>.sub_for_loop    ;import *
mov <&package_6+46> <esp+1>.For_loop    ;import *
mov <&package_6+47> <esp+1>.Mark    ;import *
mov <&package_6+48> <esp+1>.Pass    ;import *
mov <&package_6+49> <esp+1>.TFN    ;import *
mov <&package_6+50> <esp+1>.Class    ;import *
mov <&package_6+51> <esp+1>.two_object_write    ;import *
mov <&package_6+52> <esp+1>.Multiple_Mov    ;import *
mov <&package_6+53> <esp+1>.Oper    ;import *
mov <&package_6+54> <esp+1>.Tf    ;import *
mov <&package_6+55> <esp+1>.AndOr    ;import *
mov <&package_6+56> <esp+1>.Deny    ;import *
mov <&package_6+57> <esp+1>.Bool    ;import *
mov <&package_6+58> <esp+1>.Assert    ;import *
mov <&package_6+59> <esp+1>.STR    ;import *
mov <&package_6+60> <esp+1>.Info    ;import *
inc esp
Function <&package_6+6> 28244 None "parse_code_28244" 34
jmp 30451           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28252 "!="
tf <esp+2> "in" "code"
$jmp 28254 "t"
mov <esp+2>["code"] None
jmp 28254
mov <esp+2>["code"] <esp+1>[0]
dec CX
mov <parse_code_28244+1> <esp+2>["code"]


Function <parse_code_28244+2> 28259 None "deal_string_28259" 10 "parse_code_28244"
jmp 28651           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28267 "!="
tf <esp+2> "in" "k"
$jmp 28269 "t"
mov <esp+2>["k"] None
jmp 28269
mov <esp+2>["k"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 28275 "!="
tf <esp+2> "in" "change"
$jmp 28277 "t"
mov <esp+2>["change"] True
jmp 28277
mov <esp+2>["change"] <esp+1>[1]
dec CX
mov <deal_string_28259+1> <esp+2>["k"]
mov <deal_string_28259+2> <esp+2>["change"]


push <parse_code_28244+1>
mov BX <deal_string_28259+1>
pop AX
push AX[BX]
mov <deal_string_28259+3> <esp+1>
inc esp
push 1
$mov <deal_string_28259+1> "+" <esp+1>
inc esp
push <deal_string_28259+1>
mov <deal_string_28259+4> <esp+1>
inc esp
cmp True 1
$jmp 28342 "!="
push <parse_code_28244+1>
mov BX <deal_string_28259+1>
pop AX
push AX[BX]
mov <deal_string_28259+5> <esp+1>
inc esp
mov DX <deal_string_28259+5>
tf DX "equ" "\n"
$jmp 28306 "f"
mov AX True
jmp 28307
mov AX False
cmp AX 1
$jmp 28316 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28244+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 28316        ;¸õ¦Ü©³³¡
mov DX <deal_string_28259+5>
tf DX "equ" "\\"
$jmp 28321 "f"
mov AX True
jmp 28322
mov AX False
cmp AX 1
$jmp 28328 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <deal_string_28259+1> "+" <esp+1>
inc esp
jmp 28338        ;¸õ¦Ü©³³¡
mov DX <deal_string_28259+5>
tf DX "equ" <deal_string_28259+3>
$jmp 28333 "f"
mov AX True
jmp 28334
mov AX False
cmp AX 1
$jmp 28338 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 28342          ;break¥X
jmp 28338        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_28259+1> "+" <esp+1>
inc esp
jmp 28293               ;continue­«¨Ó
push <parse_code_28244+1>
push [3]
mov <esp+1>[0] <deal_string_28259+4>
mov <esp+1>[1] <deal_string_28259+1>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <deal_string_28259+6> <esp+1>
inc esp
mov DX <deal_string_28259+3>
tf DX "equ" "'"
$jmp 28360 "f"
mov AX True
jmp 28361
mov AX False
cmp AX 1
$jmp 28369 "!="
mov AX <deal_string_28259+2>
$oper AX "not"
cmp AX 1
$jmp 28369 "!="
mov AX 1
jmp 28370
mov AX 0
cmp AX 1
$jmp 28389 "=="
mov DX <deal_string_28259+3>
tf DX "equ" "\""
$jmp 28377 "f"
mov AX True
jmp 28378
mov AX False
cmp AX 1
$jmp 28384 "!="
cmp <deal_string_28259+2> 1
$jmp 28384 "!="
mov AX 1
jmp 28385
mov AX 0
cmp AX 1
$jmp 28389 "=="
mov AX 0
jmp 28390
mov AX 1
cmp AX 1
$jmp 28408 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28259+6>
push [dict]
mov BX "change"
mov <esp+1>[BX] <deal_string_28259+2>
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28259+1>
pop AX
jmp 28648
jmp 28647        ;¸õ¦Ü©³³¡
mov DX <deal_string_28259+3>
tf DX "equ" "'"
$jmp 28413 "f"
mov AX True
jmp 28414
mov AX False
cmp AX 1
$jmp 28420 "!="
cmp <deal_string_28259+2> 1
$jmp 28420 "!="
mov AX 1
jmp 28421
mov AX 0
cmp AX 1
$jmp 28531 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <deal_string_28259+7> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28259+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <deal_string_28259+8> <esp+1>[0]
mov <deal_string_28259+9> <esp+1>[1]
inc esp
mov DX <deal_string_28259+8>
cmp DX <deal_string_28259+9>
$jmp 28444 ">="
mov AX True
jmp 28445
mov AX False
cmp AX 1
$jmp 28505 "!="
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 28455 "f"
mov AX True
jmp 28456
mov AX False
cmp AX 1
$jmp 28466 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
jmp 28466        ;¸õ¦Ü©³³¡
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 28474 "f"
mov AX True
jmp 28475
mov AX False
cmp AX 1
$jmp 28491 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
push 1
$mov <deal_string_28259+8> "+" <esp+1>
inc esp
jmp 28491        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
push 1
$mov <deal_string_28259+8> "+" <esp+1>
inc esp
jmp 28439               ;continue­«¨Ó
push (2)
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28259+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
push [dict]
mov BX "change"
mov <esp+1>[BX] <deal_string_28259+2>
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28259+1>
pop AX
jmp 28648
jmp 28647        ;¸õ¦Ü©³³¡
mov DX <deal_string_28259+3>
tf DX "equ" "\""
$jmp 28536 "f"
mov AX True
jmp 28537
mov AX False
cmp AX 1
$jmp 28545 "!="
mov AX <deal_string_28259+2>
$oper AX "not"
cmp AX 1
$jmp 28545 "!="
mov AX 1
jmp 28546
mov AX 0
cmp AX 1
$jmp 28647 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <deal_string_28259+7> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28259+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <deal_string_28259+8> <esp+1>[0]
mov <deal_string_28259+9> <esp+1>[1]
inc esp
mov DX <deal_string_28259+8>
cmp DX <deal_string_28259+9>
$jmp 28569 ">="
mov AX True
jmp 28570
mov AX False
cmp AX 1
$jmp 28624 "!="
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 28580 "f"
mov AX True
jmp 28581
mov AX False
cmp AX 1
$jmp 28591 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
jmp 28591        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
push <deal_string_28259+6>
mov BX <deal_string_28259+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 28609 "f"
mov AX True
jmp 28610
mov AX False
cmp AX 1
$jmp 28620 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28259+7>.append
jmp 28620        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_28259+8> "+" <esp+1>
inc esp
jmp 28564               ;continue­«¨Ó
push (2)
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28259+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28259+1>
pop AX
jmp 28648
jmp 28647        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_string_28259" "0,1,2,3,4,5,6,7,8,9"
pop ip
push [34]
mov <esp+1>[0] "def"
mov <esp+1>[1] "while"
mov <esp+1>[2] "for"
mov <esp+1>[3] "in"
mov <esp+1>[4] "if"
mov <esp+1>[5] "elif"
mov <esp+1>[6] "else"
mov <esp+1>[7] "class"
mov <esp+1>[8] "break"
mov <esp+1>[9] "continue"
mov <esp+1>[10] "return"
mov <esp+1>[11] ":"
mov <esp+1>[12] "and"
mov <esp+1>[13] "not"
mov <esp+1>[14] "or"
mov <esp+1>[15] "True"
mov <esp+1>[16] "False"
mov <esp+1>[17] "None"
mov <esp+1>[18] "from"
mov <esp+1>[19] "import"
mov <esp+1>[20] "as"
mov <esp+1>[21] "is"
mov <esp+1>[22] "with"
mov <esp+1>[23] "raise"
mov <esp+1>[24] "try"
mov <esp+1>[25] "except"
mov <esp+1>[26] "finally"
mov <esp+1>[27] "yield"
mov <esp+1>[28] "lambda"
mov <esp+1>[29] "del"
mov <esp+1>[30] "global"
mov <esp+1>[31] "nonlocal"
mov <esp+1>[32] "assert"
mov <esp+1>[33] "$stop"
mov <parse_code_28244+3> <esp+1>
inc esp
push [dict]
mov BX "AX"
mov <esp+1>[BX] 0
mov BX "BX"
mov <esp+1>[BX] 1
mov BX "CX"
mov <esp+1>[BX] 2
mov BX "DX"
mov <esp+1>[BX] 3
mov BX "ip"
mov <esp+1>[BX] 4
mov BX "esp"
mov <esp+1>[BX] 5
mov BX "sp"
mov <esp+1>[BX] 6
mov BX "ZR"
mov <esp+1>[BX] 7
mov BX "TF"
mov <esp+1>[BX] 8
mov <parse_code_28244+4> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_code_28244+5> <esp+1>[0]
mov <parse_code_28244+6> <esp+1>[1]
inc esp
push [0]
mov <parse_code_28244+7> <esp+1>
inc esp
push 0
mov <parse_code_28244+8> <esp+1>
inc esp
push 0
mov <parse_code_28244+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+1>.split
push AX
mov <parse_code_28244+10> <esp+1>
inc esp
push [1]
mov <esp+1>[0] 1
mov <parse_code_28244+11> <esp+1>
inc esp
push [1]
push (3)
mov <esp+1>[0] 0
push <parse_code_28244+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28244+10>
push <parse_code_28244+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov <parse_code_28244+12> <esp+1>
inc esp
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 28769 ">="
mov AX True
jmp 28770
mov AX False
cmp AX 1
$jmp 30423 "!="
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
push AX[BX]
mov <parse_code_28244+13> <esp+1>
inc esp
tf "0123456789" "in" <parse_code_28244+13>
mov AX TF
cmp AX 1
$jmp 28859 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+5>
mov <parse_code_28244+14> <esp+1>
inc esp
push "0123456789."
mov <parse_code_28244+15> <esp+1>
inc esp
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 28793 ">="
mov AX True
jmp 28794
mov AX False
cmp AX 1
$jmp 28809 "!="
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
tf <parse_code_28244+15> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 28807 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 28808        ;¸õ¦Ü©³³¡
jmp 28809          ;break¥X
jmp 28788               ;continue­«¨Ó
push <parse_code_28244+1>
push [3]
mov <esp+1>[0] <parse_code_28244+14>
mov <esp+1>[1] <parse_code_28244+5>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+16> <esp+1>
inc esp
tf <parse_code_28244+16> "in" "."
mov AX TF
cmp AX 1
$jmp 28841 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+19>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 28855        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push 1
$mov <parse_code_28244+5> "-" <esp+1>
inc esp
jmp 30419        ;¸õ¦Ü©³³¡
tf "+-*/,()[]{}!=%:><.&^|~" "in" <parse_code_28244+13>
mov AX TF
cmp AX 1
$jmp 29157 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+5>
oper <esp+1> "+" 2
pop DX
cmp DX <parse_code_28244+6>
$jmp 28870 ">="
mov AX True
jmp 28871
mov AX False
cmp AX 1
$jmp 28912 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+1>
push [3]
mov <esp+1>[0] <parse_code_28244+5>
push <parse_code_28244+5>
oper <esp+1> "+" 3
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+17> <esp+1>
inc esp
push (4)
mov <esp+1>[0] "**="
mov <esp+1>[1] "//="
mov <esp+1>[2] ">>="
mov <esp+1>[3] "<<="
mov BX <parse_code_28244+17>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 28911 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push 3
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 28764
jmp 28911        ;¸õ¦Ü©³³¡
jmp 28912        ;¸õ¦Ü©³³¡
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28244+6>
$jmp 28919 ">="
mov AX True
jmp 28920
mov AX False
cmp AX 1
$jmp 28975 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+1>
push [3]
mov <esp+1>[0] <parse_code_28244+5>
push <parse_code_28244+5>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+18> <esp+1>
inc esp
push (18)
mov <esp+1>[0] "+="
mov <esp+1>[1] "-="
mov <esp+1>[2] "*="
mov <esp+1>[3] "/="
mov <esp+1>[4] "=="
mov <esp+1>[5] "!="
mov <esp+1>[6] "**"
mov <esp+1>[7] ">"
mov <esp+1>[8] "<"
mov <esp+1>[9] ">="
mov <esp+1>[10] "<="
mov <esp+1>[11] "%="
mov <esp+1>[12] "//"
mov <esp+1>[13] ">>"
mov <esp+1>[14] "<<"
mov <esp+1>[15] "&="
mov <esp+1>[16] "^="
mov <esp+1>[17] "|="
mov BX <parse_code_28244+18>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 28974 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push 2
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 28764
jmp 28974        ;¸õ¦Ü©³³¡
jmp 28975        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push (3)
mov <esp+1>[0] "("
mov <esp+1>[1] "["
mov <esp+1>[2] "{"
mov BX <parse_code_28244+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 28996 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+8> "+" <esp+1>
inc esp
jmp 29010        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
mov BX <parse_code_28244+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29010 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+8> "-" <esp+1>
inc esp
jmp 29010        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" ":"
$jmp 29015 "f"
mov AX True
jmp 29016
mov AX False
cmp AX 1
$jmp 29028 "!="
mov DX <parse_code_28244+8>
tf DX "equ" 0
$jmp 29023 "f"
mov AX True
jmp 29024
mov AX False
cmp AX 1
$jmp 29028 "!="
mov AX 1
jmp 29029
mov AX 0
cmp AX 1
$jmp 29156 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28244+9>
cmp DX 0
$jmp 29036 "<="
mov AX True
jmp 29037
mov AX False
cmp AX 1
$jmp 29043 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+9> "-" <esp+1>
inc esp
jmp 29155        ;¸õ¦Ü©³³¡
finally 29080
try 29058
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\n"
mov <esp+1>[1] <parse_code_28244+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+1>.index
push AX
mov <parse_code_28244+19> <esp+1>
inc esp
try "end"
jmp 29075    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 29074 "f"
mov $Exception 0
try 29078
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_28244+19> <esp+1>
inc esp
try "end"
jmp 29075  ;¸õ¨ìpush 1
jmp 29078 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 29080    ;¸õ¨ìfinally
push None
push 0
finally -29080
pop AX
cmp AX 1
$jmp 29087 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <parse_code_28244+19>
oper <esp+1> "-" <parse_code_28244+5>
pop DX
cmp DX 1
$jmp 29096 "<="
mov AX True
jmp 29097
mov AX False
cmp AX 1
$jmp 29155 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+7>.append
push [1]
push (3)
push <parse_code_28244+12>
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "+" 4
pop <esp+1>[0]
push <parse_code_28244+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28244+10>
push <parse_code_28244+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov <parse_code_28244+12> <esp+1>
inc esp
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 29144 "f"
mov AX True
jmp 29145
mov AX False
cmp AX 1
$jmp 29151 "!="
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 29136               ;continue­«¨Ó
push 1
$mov <parse_code_28244+5> "-" <esp+1>
inc esp
jmp 29155        ;¸õ¦Ü©³³¡
jmp 29156        ;¸õ¦Ü©³³¡
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" "#"
$jmp 29162 "f"
mov AX True
jmp 29163
mov AX False
cmp AX 1
$jmp 29197 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 29170 ">="
mov AX True
jmp 29171
mov AX False
cmp AX 1
$jmp 29186 "!="
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
mov DX AX[BX]
tf DX "equ" "\n"
$jmp 29181 "t"
mov AX True
jmp 29182
mov AX False
cmp AX 1
$jmp 29186 "!="
mov AX 1
jmp 29187
mov AX 0
cmp AX 1
$jmp 29193 "!="
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 29165               ;continue­«¨Ó
push 1
$mov <parse_code_28244+5> "-" <esp+1>
inc esp
jmp 30419        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
mov BX <parse_code_28244+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29273 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+2>
push AX
mov <parse_code_28244+20> <esp+1>[0]
mov <parse_code_28244+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29229 "<="
mov AX True
jmp 29230
mov AX False
cmp AX 1
$jmp 29254 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 29249 "f"
mov AX True
jmp 29250
mov AX False
cmp AX 1
$jmp 29254 "!="
mov AX 1
jmp 29255
mov AX 0
cmp AX 1
$jmp 29265 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 29265        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" "\n"
$jmp 29278 "f"
mov AX True
jmp 29279
mov AX False
cmp AX 1
$jmp 29394 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28244+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
mov DX <parse_code_28244+8>
tf DX "equ" 0
$jmp 29292 "f"
mov AX True
jmp 29293
mov AX False
cmp AX 1
$jmp 29393 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 29307 "<="
mov AX True
jmp 29308
mov AX False
cmp AX 1
$jmp 29318 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+7>.append
jmp 29318        ;¸õ¦Ü©³³¡
push [0]
mov <parse_code_28244+12> <esp+1>
inc esp
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 29329 ">="
mov AX True
jmp 29330
mov AX False
cmp AX 1
$jmp 29389 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <parse_code_28244+21> <esp+1>
inc esp
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 29340 ">="
mov AX True
jmp 29341
mov AX False
cmp AX 1
$jmp 29356 "!="
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 29351 "f"
mov AX True
jmp 29352
mov AX False
cmp AX 1
$jmp 29356 "!="
mov AX 1
jmp 29357
mov AX 0
cmp AX 1
$jmp 29366 "!="
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
push 1
$mov <parse_code_28244+21> "+" <esp+1>
inc esp
jmp 29335               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] <parse_code_28244+21>
push <parse_code_28244+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28244+10>
push <parse_code_28244+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 29389        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28244+5> "-" <esp+1>
inc esp
jmp 29393        ;¸õ¦Ü©³³¡
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" "r"
$jmp 29399 "f"
mov AX True
jmp 29400
mov AX False
cmp AX 1
$jmp 29414 "!="
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28244+6>
$jmp 29409 ">="
mov AX True
jmp 29410
mov AX False
cmp AX 1
$jmp 29414 "!="
mov AX 1
jmp 29415
mov AX 0
cmp AX 1
$jmp 29433 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28244+1>
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29433 "!="
mov AX 1
jmp 29434
mov AX 0
cmp AX 1
$jmp 29509 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+5>
push [dict]
mov BX "change"
mov <esp+1>[BX] False
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+2>
push AX
mov <parse_code_28244+20> <esp+1>[0]
mov <parse_code_28244+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29465 "<="
mov AX True
jmp 29466
mov AX False
cmp AX 1
$jmp 29490 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 29485 "f"
mov AX True
jmp 29486
mov AX False
cmp AX 1
$jmp 29490 "!="
mov AX 1
jmp 29491
mov AX 0
cmp AX 1
$jmp 29501 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 29501        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" "b"
$jmp 29514 "f"
mov AX True
jmp 29515
mov AX False
cmp AX 1
$jmp 29529 "!="
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28244+6>
$jmp 29524 ">="
mov AX True
jmp 29525
mov AX False
cmp AX 1
$jmp 29529 "!="
mov AX 1
jmp 29530
mov AX 0
cmp AX 1
$jmp 29548 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28244+1>
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29548 "!="
mov AX 1
jmp 29549
mov AX 0
cmp AX 1
$jmp 29628 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+2>
push AX
mov <parse_code_28244+20> <esp+1>[0]
mov <parse_code_28244+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29577 "<="
mov AX True
jmp 29578
mov AX False
cmp AX 1
$jmp 29602 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+21>
$jmp 29597 "f"
mov AX True
jmp 29598
mov AX False
cmp AX 1
$jmp 29602 "!="
mov AX 1
jmp 29603
mov AX 0
cmp AX 1
$jmp 29613 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 29613        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+20>.text
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+21>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" "f"
$jmp 29633 "f"
mov AX True
jmp 29634
mov AX False
cmp AX 1
$jmp 29648 "!="
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28244+6>
$jmp 29643 ">="
mov AX True
jmp 29644
mov AX False
cmp AX 1
$jmp 29648 "!="
mov AX 1
jmp 29649
mov AX 0
cmp AX 1
$jmp 29667 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28244+1>
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29667 "!="
mov AX 1
jmp 29668
mov AX 0
cmp AX 1
$jmp 30218 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "("
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push <parse_code_28244+1>
push <parse_code_28244+5>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_code_28244+22> <esp+1>
inc esp
push <parse_code_28244+5>
oper <esp+1> "+" 2
mov <parse_code_28244+19> <esp+1>
inc esp
push <parse_code_28244+1>
mov BX <parse_code_28244+19>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_code_28244+22>
$jmp 29697 "t"
mov AX True
jmp 29698
mov AX False
cmp AX 1
$jmp 29715 "=="
push <parse_code_28244+1>
push <parse_code_28244+19>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 29710 "f"
mov AX True
jmp 29711
mov AX False
cmp AX 1
$jmp 29715 "=="
mov AX 0
jmp 29716
mov AX 1
cmp AX 1
$jmp 29722 "!="
push 1
$mov <parse_code_28244+19> "+" <esp+1>
inc esp
jmp 29689               ;continue­«¨Ó
push <parse_code_28244+1>
push [3]
push <parse_code_28244+5>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_28244+19>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_28244+24> <esp+1>
inc esp
push 0
mov <parse_code_28244+25> <esp+1>
inc esp
push [0]
mov <parse_code_28244+26> <esp+1>
inc esp
mov DX <parse_code_28244+25>
cmp DX <parse_code_28244+24>
$jmp 29758 ">="
mov AX True
jmp 29759
mov AX False
cmp AX 1
$jmp 30183 "!="
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov DX AX[BX]
tf DX "equ" "\n"
$jmp 29769 "f"
mov AX True
jmp 29770
mov AX False
cmp AX 1
$jmp 29779 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28244+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 29779        ;¸õ¦Ü©³³¡
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov DX AX[BX]
tf DX "equ" "{"
$jmp 29787 "f"
mov AX True
jmp 29788
mov AX False
cmp AX 1
$jmp 30054 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+23>
push <parse_code_28244+25>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "{"
$jmp 29800 "f"
mov AX True
jmp 29801
mov AX False
cmp AX 1
$jmp 29814 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "{"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
jmp 30053        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29826 "<="
mov AX True
jmp 29827
mov AX False
cmp AX 1
$jmp 29851 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 29846 "f"
mov AX True
jmp 29847
mov AX False
cmp AX 1
$jmp 29851 "!="
mov AX 1
jmp 29852
mov AX 0
cmp AX 1
$jmp 29862 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 29862        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push [0]
mov <parse_code_28244+26> <esp+1>
inc esp
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
push <parse_code_28244+25>
mov <parse_code_28244+14> <esp+1>
inc esp
push 0
mov <parse_code_28244+27> <esp+1>
inc esp
push 1
mov <parse_code_28244+13> <esp+1>
inc esp
mov DX <parse_code_28244+13>
cmp DX 0
$jmp 29906 "<="
mov AX True
jmp 29907
mov AX False
cmp AX 1
$jmp 29995 "!="
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
push AX[BX]
mov <parse_code_28244+28> <esp+1>
inc esp
mov DX <parse_code_28244+27>
tf DX "equ" 0
$jmp 29920 "f"
mov AX True
jmp 29921
mov AX False
cmp AX 1
$jmp 29961 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28244+28>
tf DX "equ" "{"
$jmp 29928 "f"
mov AX True
jmp 29929
mov AX False
cmp AX 1
$jmp 29935 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+13> "+" <esp+1>
inc esp
jmp 29960        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+28>
tf DX "equ" "}"
$jmp 29940 "f"
mov AX True
jmp 29941
mov AX False
cmp AX 1
$jmp 29947 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+13> "-" <esp+1>
inc esp
jmp 29960        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "'"
mov <esp+1>[1] "\""
mov BX <parse_code_28244+28>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29960 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28244+28>
mov <parse_code_28244+27> <esp+1>
inc esp
jmp 29960        ;¸õ¦Ü©³³¡
jmp 29991        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+28>
tf DX "equ" <parse_code_28244+27>
$jmp 29966 "f"
mov AX True
jmp 29967
mov AX False
cmp AX 1
$jmp 29984 "!="
push <parse_code_28244+23>
push <parse_code_28244+25>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 29979 "t"
mov AX True
jmp 29980
mov AX False
cmp AX 1
$jmp 29984 "!="
mov AX 1
jmp 29985
mov AX 0
cmp AX 1
$jmp 29991 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <parse_code_28244+27> <esp+1>
inc esp
jmp 29991        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
jmp 29901               ;continue­«¨Ó
push 1
$mov <parse_code_28244+25> "-" <esp+1>
inc esp
push <parse_code_28244+23>
push [3]
mov <esp+1>[0] <parse_code_28244+14>
mov <esp+1>[1] <parse_code_28244+25>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+29> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+29>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov BX 0
pop AX
push AX[BX]
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28244+30> <esp+1>
inc esp
push [3]
mov <esp+1>[0] "+"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$str"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+22>
mov <esp+1>[1] AX
mov <esp+1>[2] "("
oper <esp+1> "+" <parse_code_28244+30>
push [2]
mov <esp+1>[0] ")"
mov <esp+1>[1] "+"
pop AX
oper <esp+1> "+" AX
$mov <parse_code_28244+12> "+" <esp+1>
inc esp
jmp 30179        ;¸õ¦Ü©³³¡
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov DX AX[BX]
tf DX "equ" "}"
$jmp 30062 "f"
mov AX True
jmp 30063
mov AX False
cmp AX 1
$jmp 30087 "!="
push <parse_code_28244+23>
push [3]
mov <esp+1>[0] <parse_code_28244+25>
push <parse_code_28244+25>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "}}"
$jmp 30082 "f"
mov AX True
jmp 30083
mov AX False
cmp AX 1
$jmp 30087 "!="
mov AX 1
jmp 30088
mov AX 0
cmp AX 1
$jmp 30104 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
jmp 30179        ;¸õ¦Ü©³³¡
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 30112 "f"
mov AX True
jmp 30113
mov AX False
cmp AX 1
$jmp 30139 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
jmp 30179        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30169 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
jmp 30179        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+23>
mov BX <parse_code_28244+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+26>.append
push 1
$mov <parse_code_28244+25> "+" <esp+1>
inc esp
jmp 29753               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push <parse_code_28244+19>
mov <parse_code_28244+5> <esp+1>
inc esp
jmp 30419        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+13>
tf DX "equ" " "
$jmp 30223 "t"
mov AX True
jmp 30224
mov AX False
cmp AX 1
$jmp 30419 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_code_28244+31> <esp+1>
inc esp
push "+-*/,()[]{}!=%:><.&^|~\\# \n:"
mov <parse_code_28244+32> <esp+1>
inc esp
mov DX <parse_code_28244+5>
cmp DX <parse_code_28244+6>
$jmp 30237 ">="
mov AX True
jmp 30238
mov AX False
cmp AX 1
$jmp 30264 "!="
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
tf <parse_code_28244+32> "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 30262 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28244+1>
mov BX <parse_code_28244+5>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+31>.append
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 30263        ;¸õ¦Ü©³³¡
jmp 30264          ;break¥X
jmp 30232               ;continue­«¨Ó
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_28244+33> <esp+1>
inc esp
tf <parse_code_28244+3> "in" <parse_code_28244+33>
mov AX TF
cmp AX 1
$jmp 30392 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28244+33>
tf DX "equ" "True"
$jmp 30286 "f"
mov AX True
jmp 30287
mov AX False
cmp AX 1
$jmp 30304 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] True
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30379        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+33>
tf DX "equ" "False"
$jmp 30309 "f"
mov AX True
jmp 30310
mov AX False
cmp AX 1
$jmp 30327 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] False
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30379        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+33>
tf DX "equ" "None"
$jmp 30332 "f"
mov AX True
jmp 30333
mov AX False
cmp AX 1
$jmp 30350 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30379        ;¸õ¦Ü©³³¡
mov DX <parse_code_28244+33>
tf DX "equ" "$stop"
$jmp 30355 "f"
mov AX True
jmp 30356
mov AX False
cmp AX 1
$jmp 30372 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+40>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
jmp 30379        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
mov DX <parse_code_28244+33>
tf DX "equ" "lambda"
$jmp 30384 "f"
mov AX True
jmp 30385
mov AX False
cmp AX 1
$jmp 30391 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28244+9> "+" <esp+1>
inc esp
jmp 30391        ;¸õ¦Ü©³³¡
jmp 30415        ;¸õ¦Ü©³³¡
tf <parse_code_28244+4> "in" <parse_code_28244+33>
mov AX TF
cmp AX 1
$jmp 30401 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "$$"
oper <esp+1> "+" <parse_code_28244+33>
mov <parse_code_28244+33> <esp+1>
inc esp
jmp 30401        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+22>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+12>.append
push 1
$mov <parse_code_28244+5> "-" <esp+1>
inc esp
jmp 30419        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28244+5> "+" <esp+1>
inc esp
jmp 28764               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 30435 "<="
mov AX True
jmp 30436
mov AX False
cmp AX 1
$jmp 30446 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28244+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28244+7>.append
jmp 30446        ;¸õ¦Ü©³³¡
mov AX <parse_code_28244+7>
jmp 30448         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_code_28244" "0,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33"
pop ip
Function <&package_6+7> 30453 None "next_element_30453" 9
jmp 30622           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 30461 "!="
tf <esp+2> "in" "codeline"
$jmp 30463 "t"
mov <esp+2>["codeline"] None
jmp 30463
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 30469 "!="
tf <esp+2> "in" "k"
$jmp 30471 "t"
mov <esp+2>["k"] None
jmp 30471
mov <esp+2>["k"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 30477 "!="
tf <esp+2> "in" "elements"
$jmp 30479 "t"
mov <esp+2>["elements"] None
jmp 30479
mov <esp+2>["elements"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 30485 "!="
tf <esp+2> "in" "end"
$jmp 30487 "t"
mov <esp+2>["end"] False
jmp 30487
mov <esp+2>["end"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 30493 "!="
tf <esp+2> "in" "stop"
$jmp 30495 "t"
mov <esp+2>["stop"] (0)
jmp 30495
mov <esp+2>["stop"] <esp+1>[4]
dec CX
mov <next_element_30453+1> <esp+2>["codeline"]
mov <next_element_30453+2> <esp+2>["k"]
mov <next_element_30453+3> <esp+2>["elements"]
mov <next_element_30453+4> <esp+2>["end"]
mov <next_element_30453+5> <esp+2>["stop"]


push 0
mov <next_element_30453+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_element_30453+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <next_element_30453+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_element_30453+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call list
push AX
mov <next_element_30453+3> <esp+1>
inc esp
mov DX <next_element_30453+2>
cmp DX <next_element_30453+7>
$jmp 30530 ">="
mov AX True
jmp 30531
mov AX False
cmp AX 1
$jmp 30611 "!="
push <next_element_30453+1>
mov BX <next_element_30453+2>
pop AX
push AX[BX]
mov <next_element_30453+8> <esp+1>
inc esp
mov DX <next_element_30453+6>
tf DX "equ" 0
$jmp 30544 "f"
mov AX True
jmp 30545
mov AX False
cmp AX 1
$jmp 30568 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <next_element_30453+3> "in" <next_element_30453+8>
mov AX TF
cmp AX 1
$jmp 30554 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30453+2>
jmp 30619         ;returnÂI
jmp 30567        ;¸õ¦Ü©³³¡
tf <next_element_30453+5> "in" <next_element_30453+8>
mov AX TF
cmp AX 1
$jmp 30567 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
cmp <next_element_30453+4> 1
$jmp 30563 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30453+2>
jmp 30619         ;returnÂI
jmp 30563        ;¸õ¦Ü©³³¡
mov AX 1
$oper AX "-"
jmp 30619         ;returnÂI
jmp 30567        ;¸õ¦Ü©³³¡
jmp 30568        ;¸õ¦Ü©³³¡
mov DX <next_element_30453+6>
cmp DX 0
$jmp 30573 ">="
mov AX True
jmp 30574
mov AX False
cmp AX 1
$jmp 30579 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30453+2>
jmp 30619         ;returnÂI
jmp 30579        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] "("
mov <esp+1>[1] "["
mov <esp+1>[2] "{"
mov BX <next_element_30453+8>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30593 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <next_element_30453+6> "+" <esp+1>
inc esp
jmp 30607        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
mov BX <next_element_30453+8>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30607 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <next_element_30453+6> "-" <esp+1>
inc esp
jmp 30607        ;¸õ¦Ü©³³¡
push 1
$mov <next_element_30453+2> "+" <esp+1>
inc esp
jmp 30525               ;continue­«¨Ó
cmp <next_element_30453+4> 1
$jmp 30616 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30453+7>
jmp 30619         ;returnÂI
jmp 30616        ;¸õ¦Ü©³³¡
mov AX 1
$oper AX "-"
jmp 30619         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "next_element_30453" "0,1,2,3,4,5,6,7,8"
pop ip
Function <&package_6+8> 30624 None "get_var_30624" 21
jmp 31769           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 30632 "!="
tf <esp+2> "in" "codeline"
$jmp 30634 "t"
mov <esp+2>["codeline"] None
jmp 30634
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 30640 "!="
tf <esp+2> "in" "k"
$jmp 30642 "t"
mov <esp+2>["k"] None
jmp 30642
mov <esp+2>["k"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 30648 "!="
tf <esp+2> "in" "namespace"
$jmp 30650 "t"
mov <esp+2>["namespace"] None
jmp 30650
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
mov <get_var_30624+1> <esp+2>["codeline"]
mov <get_var_30624+2> <esp+2>["k"]
mov <get_var_30624+3> <esp+2>["namespace"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <get_var_30624+4> <esp+1>
inc esp
mov DX <get_var_30624+2>
tf DX "equ" <get_var_30624+4>
$jmp 30670 "f"
mov AX True
jmp 30671
mov AX False
cmp AX 1
$jmp 30681 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
jmp 31766
jmp 30681        ;¸õ¦Ü©³³¡
push <get_var_30624+2>
mov <get_var_30624+5> <esp+1>
inc esp
push 1
$mov <get_var_30624+2> "+" <esp+1>
inc esp
push (2)
mov <esp+1>[0] "["
mov <esp+1>[1] "("
mov <get_var_30624+6> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "]"
mov <esp+1>[1] ")"
mov <get_var_30624+7> <esp+1>
inc esp
mov DX <get_var_30624+2>
cmp DX <get_var_30624+4>
$jmp 30702 ">="
mov AX True
jmp 30703
mov AX False
cmp AX 1
$jmp 30730 "!="
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
tf <get_var_30624+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 30725 "=="
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 30720 "f"
mov AX True
jmp 30721
mov AX False
cmp AX 1
$jmp 30725 "=="
mov AX 0
jmp 30726
mov AX 1
cmp AX 1
$jmp 30730 "!="
mov AX 1
jmp 30731
mov AX 0
cmp AX 1
$jmp 30810 "!="
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
tf <get_var_30624+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 30794 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <get_var_30624+8> <esp+1>
inc esp
push 1
$mov <get_var_30624+2> "+" <esp+1>
inc esp
mov DX <get_var_30624+2>
cmp DX <get_var_30624+4>
$jmp 30751 ">="
mov AX True
jmp 30752
mov AX False
cmp AX 1
$jmp 30764 "!="
mov DX <get_var_30624+8>
cmp DX 0
$jmp 30759 "<="
mov AX True
jmp 30760
mov AX False
cmp AX 1
$jmp 30764 "!="
mov AX 1
jmp 30765
mov AX 0
cmp AX 1
$jmp 30793 "!="
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
tf <get_var_30624+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 30778 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <get_var_30624+8> "+" <esp+1>
inc esp
jmp 30789        ;¸õ¦Ü©³³¡
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
tf <get_var_30624+7> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 30789 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <get_var_30624+8> "-" <esp+1>
inc esp
jmp 30789        ;¸õ¦Ü©³³¡
push 1
$mov <get_var_30624+2> "+" <esp+1>
inc esp
jmp 30746               ;continue­«¨Ó
jmp 30809        ;¸õ¦Ü©³³¡
push <get_var_30624+1>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 30802 "f"
mov AX True
jmp 30803
mov AX False
cmp AX 1
$jmp 30809 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2
$mov <get_var_30624+2> "+" <esp+1>
inc esp
jmp 30809        ;¸õ¦Ü©³³¡
jmp 30697               ;continue­«¨Ó
push <get_var_30624+1>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <get_var_30624+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 30835 "f"
mov AX True
jmp 30836
mov AX False
cmp AX 1
$jmp 30883 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 30853 "f"
mov AX True
jmp 30854
mov AX False
cmp AX 1
$jmp 30874 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30624+2>
pop AX
jmp 31766
jmp 30882        ;¸õ¦Ü©³³¡
push (2)
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+2>
pop AX
jmp 31766
jmp 31765        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 30898 "f"
mov AX True
jmp 30899
mov AX False
cmp AX 1
$jmp 30915 "!="
push <get_var_30624+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.name
tf DX "equ" "$str"
$jmp 30910 "f"
mov AX True
jmp 30911
mov AX False
cmp AX 1
$jmp 30915 "!="
mov AX 1
jmp 30916
mov AX 0
cmp AX 1
$jmp 30954 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+10> <esp+1>
inc esp
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+59>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30624+2>
pop AX
jmp 31766
jmp 31765        ;¸õ¦Ü©³³¡
push <get_var_30624+9>
mov BX 1
pop AX
tf "([." "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 31765 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
mov <get_var_30624+11> <esp+1>
inc esp
push 1
mov <get_var_30624+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 30982 "f"
mov AX True
jmp 30983
mov AX False
cmp AX 1
$jmp 31004 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
push <get_var_30624+9>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 31004        ;¸õ¦Ü©³³¡
push $importer["time"]
mov <get_var_30624+12> <esp+1>.time
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+12>
push AX
oper <esp+1> "+" 1
mov <get_var_30624+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 31029 "<="
mov AX True
jmp 31030
mov AX False
cmp AX 1
$jmp 31756 "!="
push <get_var_30624+9>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 31040 "f"
mov AX True
jmp 31041
mov AX False
cmp AX 1
$jmp 31396 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <get_var_30624+14> <esp+1>
inc esp
push [0]
mov <get_var_30624+15> <esp+1>
inc esp
push None
mov <get_var_30624+16> <esp+1>
inc esp
push [0]
mov <get_var_30624+17> <esp+1>
inc esp
push <get_var_30624+9>
push <get_var_30624+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" ")"
$jmp 31065 "t"
mov AX True
jmp 31066
mov AX False
cmp AX 1
$jmp 31347 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 31081 ">="
mov AX True
jmp 31082
mov AX False
cmp AX 1
$jmp 31346 "!="
push <get_var_30624+9>
push <get_var_30624+2>
oper <esp+1> "+" 2
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 31094 "f"
mov AX True
jmp 31095
mov AX False
cmp AX 1
$jmp 31158 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
oper <esp+1> "+" 3
mov <get_var_30624+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+9>
mov <esp+1>[1] <get_var_30624+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30624+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
push <get_var_30624+9>
push <get_var_30624+5>
oper <esp+1> "-" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30624+18>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+15>.append
jmp 31332        ;¸õ¦Ü©³³¡
push <get_var_30624+9>
push <get_var_30624+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 31168 "f"
mov AX True
jmp 31169
mov AX False
cmp AX 1
$jmp 31233 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
oper <esp+1> "+" 2
mov <get_var_30624+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+9>
mov <esp+1>[1] <get_var_30624+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30624+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+18> <esp+1>
inc esp
mov DX <get_var_30624+16>
tf DX "equ" None
$jmp 31213 "f"
mov AX True
jmp 31214
mov AX False
cmp AX 1
$jmp 31220 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+18>
mov <get_var_30624+16> <esp+1>
inc esp
jmp 31232        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+16>
mov <esp+1>[1] <get_var_30624+18>
mov <esp+1>[2] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+53>
push AX
mov <get_var_30624+16> <esp+1>
inc esp
jmp 31332        ;¸õ¦Ü©³³¡
push <get_var_30624+9>
push <get_var_30624+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "**"
$jmp 31243 "f"
mov AX True
jmp 31244
mov AX False
cmp AX 1
$jmp 31288 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
oper <esp+1> "+" 2
mov <get_var_30624+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+9>
mov <esp+1>[1] <get_var_30624+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30624+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+17>.append
jmp 31332        ;¸õ¦Ü©³³¡
push <get_var_30624+2>
oper <esp+1> "+" 1
mov <get_var_30624+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+9>
mov <esp+1>[1] <get_var_30624+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30624+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+14>.append
push <get_var_30624+9>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" ")"
$jmp 31340 "f"
mov AX True
jmp 31341
mov AX False
cmp AX 1
$jmp 31345 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 31346          ;break¥X
jmp 31345        ;¸õ¦Ü©³³¡
jmp 31068               ;continue­«¨Ó
jmp 31350        ;¸õ¦Ü©³³¡
push 1
$mov <get_var_30624+2> "+" <esp+1>
inc esp
push [1]
push 5        ;Àx¦sCX
push [5]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+28>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+30>
mov <esp+1>[2] AX
mov <esp+1>[3] <get_var_30624+16>
mov <esp+1>[4] <get_var_30624+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+35>
mov <esp+1>[0] AX
push <get_var_30624+9>
push [3]
push <get_var_30624+2>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30624+9> <esp+1>
inc esp
jmp 31729        ;¸õ¦Ü©³³¡
push <get_var_30624+9>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 31404 "f"
mov AX True
jmp 31405
mov AX False
cmp AX 1
$jmp 31682 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30624+2>
oper <esp+1> "+" 1
mov <get_var_30624+5> <esp+1>
inc esp
push [0]
mov <get_var_30624+19> <esp+1>
inc esp
cmp True 1
$jmp 31578 "!="
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30624+9>
mov <esp+1>[1] <get_var_30624+5>
mov <esp+1>[2] ":]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30624+2> <esp+1>
inc esp
push <get_var_30624+9>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 31436 "f"
mov AX True
jmp 31437
mov AX False
cmp AX 1
$jmp 31491 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <get_var_30624+2>
tf DX "equ" <get_var_30624+5>
$jmp 31444 "f"
mov AX True
jmp 31445
mov AX False
cmp AX 1
$jmp 31458 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
mov <get_var_30624+18> <esp+1>
inc esp
jmp 31479        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+18> <esp+1>
inc esp
push <get_var_30624+2>
oper <esp+1> "+" 1
mov <get_var_30624+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+19>.append
jmp 31577        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 31503 "f"
mov AX True
jmp 31504
mov AX False
cmp AX 1
$jmp 31528 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30624+19> <esp+1>
inc esp
jmp 31576        ;¸õ¦Ü©³³¡
mov DX <get_var_30624+2>
tf DX "equ" <get_var_30624+5>
$jmp 31533 "f"
mov AX True
jmp 31534
mov AX False
cmp AX 1
$jmp 31551 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+19>.append
jmp 31576        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
push [3]
mov <esp+1>[0] <get_var_30624+5>
mov <esp+1>[1] <get_var_30624+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+19>.append
jmp 31578          ;break¥X
jmp 31414               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" list
$jmp 31590 "f"
mov AX True
jmp 31591
mov AX False
cmp AX 1
$jmp 31653 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 31605 ">="
mov AX True
jmp 31606
mov AX False
cmp AX 1
$jmp 31631 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
push 3
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30624+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
$mov <get_var_30624+19> "+" <esp+1>
inc esp
jmp 31631        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <get_var_30624+19>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push <get_var_30624+19>
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
push <get_var_30624+19>
mov BX 2
pop AX
mov <esp+1>[2] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+26>
push AX
mov <get_var_30624+19> <esp+1>
inc esp
jmp 31653        ;¸õ¦Ü©³³¡
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+27>
mov <esp+1>[0] AX
push <get_var_30624+9>
push [3]
push <get_var_30624+2>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30624+9> <esp+1>
inc esp
jmp 31729        ;¸õ¦Ü©³³¡
push <get_var_30624+9>
mov BX <get_var_30624+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 31690 "f"
mov AX True
jmp 31691
mov AX False
cmp AX 1
$jmp 31729 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push <get_var_30624+9>
mov BX 2
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+25>
push AX
mov <get_var_30624+20> <esp+1>
inc esp
push [1]
mov <esp+1>[0] <get_var_30624+20>
push <get_var_30624+9>
push [3]
mov <esp+1>[0] 3
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30624+9> <esp+1>
inc esp
push 1
$mov <get_var_30624+2> "-" <esp+1>
inc esp
jmp 31729        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30624+12>
mov DX AX
cmp DX <get_var_30624+13>
$jmp 31740 "<="
mov AX True
jmp 31741
mov AX False
cmp AX 1
$jmp 31752 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "335 get error"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 31752        ;¸õ¦Ü©³³¡
push 1
mov <get_var_30624+2> <esp+1>
inc esp
jmp 31017               ;continue­«¨Ó
push (2)
push <get_var_30624+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30624+11>
pop AX
jmp 31766
jmp 31765        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_var_30624" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20"
pop ip
Function <&package_6+9> 31771 None "next_codeline_31771" 6
jmp 31858           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 31779 "!="
tf <esp+2> "in" "codelines"
$jmp 31781 "t"
mov <esp+2>["codelines"] None
jmp 31781
mov <esp+2>["codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 31787 "!="
tf <esp+2> "in" "row"
$jmp 31789 "t"
mov <esp+2>["row"] None
jmp 31789
mov <esp+2>["row"] <esp+1>[1]
dec CX
mov <next_codeline_31771+1> <esp+2>["codelines"]
mov <next_codeline_31771+2> <esp+2>["row"]


push <next_codeline_31771+1>
mov BX <next_codeline_31771+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <next_codeline_31771+3> <esp+1>
inc esp
push <next_codeline_31771+3>
oper <esp+1> "+" 1
mov <next_codeline_31771+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_codeline_31771+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <next_codeline_31771+5> <esp+1>
inc esp
mov DX <next_codeline_31771+4>
cmp DX <next_codeline_31771+3>
$jmp 31824 "<="
mov AX True
jmp 31825
mov AX False
cmp AX 1
$jmp 31853 "!="
push 1
$mov <next_codeline_31771+2> "+" <esp+1>
inc esp
mov DX <next_codeline_31771+2>
tf DX "equ" <next_codeline_31771+5>
$jmp 31835 "f"
mov AX True
jmp 31836
mov AX False
cmp AX 1
$jmp 31840 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 31853          ;break¥X
jmp 31840        ;¸õ¦Ü©³³¡
push <next_codeline_31771+1>
mov BX <next_codeline_31771+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <next_codeline_31771+4> <esp+1>
inc esp
jmp 31819               ;continue­«¨Ó
mov AX <next_codeline_31771+2>
jmp 31855         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "next_codeline_31771" "0,1,2,3,4,5"
pop ip
Function <&package_6+10> 31860 None "parse_codeline_31860" 38
jmp 34590           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 31868 "!="
tf <esp+2> "in" "codeline"
$jmp 31870 "t"
mov <esp+2>["codeline"] None
jmp 31870
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 31876 "!="
tf <esp+2> "in" "namespace"
$jmp 31878 "t"
mov <esp+2>["namespace"] None
jmp 31878
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 31884 "!="
tf <esp+2> "in" "is_list"
$jmp 31886 "t"
mov <esp+2>["is_list"] False
jmp 31886
mov <esp+2>["is_list"] <esp+1>[2]
dec CX
mov <parse_codeline_31860+1> <esp+2>["codeline"]
mov <parse_codeline_31860+2> <esp+2>["namespace"]
mov <parse_codeline_31860+3> <esp+2>["is_list"]


push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 31907 ">="
mov AX True
jmp 31908
mov AX False
cmp AX 1
$jmp 32171 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
mov DX <parse_codeline_31860+5>
tf DX "equ" "lambda"
$jmp 31921 "f"
mov AX True
jmp 31922
mov AX False
cmp AX 1
$jmp 32167 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+4>
mov <parse_codeline_31860+6> <esp+1>
inc esp
push [dict]
mov <parse_codeline_31860+7> <esp+1>
inc esp
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_31860+8> <esp+1>
inc esp
mov DX <parse_codeline_31860+4>
cmp DX <parse_codeline_31860+8>
$jmp 31948 ">="
mov AX True
jmp 31949
mov AX False
cmp AX 1
$jmp 32082 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 31969 "f"
mov AX True
jmp 31970
mov AX False
cmp AX 1
$jmp 32068 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
push <parse_codeline_31860+7>
mov BX <parse_codeline_31860+5>.name
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_codeline_31860+8>
$jmp 31992 ">="
mov AX True
jmp 31993
mov AX False
cmp AX 1
$jmp 32010 "!="
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 32005 "f"
mov AX True
jmp 32006
mov AX False
cmp AX 1
$jmp 32010 "!="
mov AX 1
jmp 32011
mov AX 0
cmp AX 1
$jmp 32067 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+4>
oper <esp+1> "+" 2
mov <parse_codeline_31860+9> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+9>
mov <esp+1>[2] ",:"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+9>
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
push <parse_codeline_31860+7>
mov BX <parse_codeline_31860+5>.name
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 32061 "f"
mov AX True
jmp 32062
mov AX False
cmp AX 1
$jmp 32066 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 32082          ;break¥X
jmp 32066        ;¸õ¦Ü©³³¡
jmp 32067        ;¸õ¦Ü©³³¡
jmp 32068        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+5>
tf DX "equ" ":"
$jmp 32073 "f"
mov AX True
jmp 32074
mov AX False
cmp AX 1
$jmp 32078 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 32082          ;break¥X
jmp 32078        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 31943               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+4>
push (2)
mov <esp+1>[0] ","
mov <esp+1>[1] ")"
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+11> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+7>
mov <esp+1>[1] <parse_codeline_31860+11>
mov <esp+1>[2] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+33>
push AX
mov <parse_codeline_31860+12> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_31860+6>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+12>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+10>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
jmp 32167        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 31894               ;continue­«¨Ó
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32187 ">="
mov AX True
jmp 32188
mov AX False
cmp AX 1
$jmp 32592 "!="
mov DX <parse_codeline_31860+4>
tf DX "equ" 0
$jmp 32195 "f"
mov AX True
jmp 32196
mov AX False
cmp AX 1
$jmp 32241 "=="
push 1        ;Àx¦sCX
push [1]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32215 "f"
mov AX True
jmp 32216
mov AX False
cmp AX 1
$jmp 32236 "!="
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 32236 "!="
mov AX 1
jmp 32237
mov AX 0
cmp AX 1
$jmp 32241 "=="
mov AX 0
jmp 32242
mov AX 1
cmp AX 1
$jmp 32588 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+13> <esp+1>
inc esp
mov DX <parse_codeline_31860+13>
tf DX "equ" "("
$jmp 32255 "f"
mov AX True
jmp 32256
mov AX False
cmp AX 1
$jmp 32326 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
jmp 32587        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+13>
tf DX "equ" "["
$jmp 32331 "f"
mov AX True
jmp 32332
mov AX False
cmp AX 1
$jmp 32405 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
jmp 32587        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+13>
tf DX "equ" "{"
$jmp 32410 "f"
mov AX True
jmp 32411
mov AX False
cmp AX 1
$jmp 32587 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
push [1]
mov <esp+1>[0] "}"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+15> <esp+1>
inc esp
push <parse_codeline_31860+15>.elements
mov <parse_codeline_31860+16> <esp+1>
inc esp
tf <parse_codeline_31860+16> "in" ":"
mov AX TF
cmp AX 1
$jmp 32479 "=="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 32474 "f"
mov AX True
jmp 32475
mov AX False
cmp AX 1
$jmp 32479 "=="
mov AX 0
jmp 32480
mov AX 1
cmp AX 1
$jmp 32546 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_codeline_31860+17> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_31860+8> <esp+1>
inc esp
mov DX <parse_codeline_31860+9>
cmp DX <parse_codeline_31860+8>
$jmp 32503 ">="
mov AX True
jmp 32504
mov AX False
cmp AX 1
$jmp 32535 "!="
push <parse_codeline_31860+16>
mov BX <parse_codeline_31860+9>
pop AX
push AX[BX]
mov <parse_codeline_31860+18> <esp+1>
inc esp
push 2
$mov <parse_codeline_31860+9> "+" <esp+1>
inc esp
push <parse_codeline_31860+16>
mov BX <parse_codeline_31860+9>
pop AX
push AX[BX]
mov <parse_codeline_31860+19> <esp+1>
inc esp
push 1
$mov <parse_codeline_31860+9> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <parse_codeline_31860+18>
mov <esp+1>[1] <parse_codeline_31860+19>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+17>.append
jmp 32498               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+30>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
jmp 32556        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+31>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
jmp 32587        ;¸õ¦Ü©³³¡
jmp 32588        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 32174               ;continue­«¨Ó
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32608 ">="
mov AX True
jmp 32609
mov AX False
cmp AX 1
$jmp 32765 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32629 "f"
mov AX True
jmp 32630
mov AX False
cmp AX 1
$jmp 32643 "!="
push (2)
mov <esp+1>[0] "break"
mov <esp+1>[1] "continue"
mov BX <parse_codeline_31860+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 32643 "!="
mov AX 1
jmp 32644
mov AX 0
cmp AX 1
$jmp 32655 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+47>
jmp 34587         ;returnÂI
jmp 32761        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32667 "f"
mov AX True
jmp 32668
mov AX False
cmp AX 1
$jmp 32680 "!="
mov DX <parse_codeline_31860+5>
tf DX "equ" "pass"
$jmp 32675 "f"
mov AX True
jmp 32676
mov AX False
cmp AX 1
$jmp 32680 "!="
mov AX 1
jmp 32681
mov AX 0
cmp AX 1
$jmp 32691 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+48>
jmp 34587         ;returnÂI
jmp 32761        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_31860+20> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+8>
push AX
mov <parse_codeline_31860+21> <esp+1>[0]
mov <parse_codeline_31860+10> <esp+1>[1]
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_31860+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+21>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+10>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX <parse_codeline_31860+20>
$jmp 32754 ">="
mov AX True
jmp 32755
mov AX False
cmp AX 1
$jmp 32761 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_codeline_31860+4> "-" <esp+1>
inc esp
jmp 32761        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 32595               ;continue­«¨Ó
Function <parse_codeline_31860+22> 32767 None "deal_single_operator_32767" 7 "parse_codeline_31860"
jmp 33043           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 32775 "!="
tf <esp+2> "in" "codeline"
$jmp 32777 "t"
mov <esp+2>["codeline"] None
jmp 32777
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 32783 "!="
tf <esp+2> "in" "op_box"
$jmp 32785 "t"
mov <esp+2>["op_box"] None
jmp 32785
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 32791 "!="
tf <esp+2> "in" "operator"
$jmp 32793 "t"
mov <esp+2>["operator"] None
jmp 32793
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_single_operator_32767+1> <esp+2>["codeline"]
mov <deal_single_operator_32767+2> <esp+2>["op_box"]
mov <deal_single_operator_32767+3> <esp+2>["operator"]


push 0
mov <deal_single_operator_32767+4> <esp+1>
inc esp
push <deal_single_operator_32767+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_single_operator_32767+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32814 ">="
mov AX True
jmp 32815
mov AX False
cmp AX 1
$jmp 33038 "!="
push <deal_single_operator_32767+1>
mov BX <deal_single_operator_32767+4>
pop AX
push AX[BX]
mov <deal_single_operator_32767+5> <esp+1>
inc esp
tf <deal_single_operator_32767+2> "in" <deal_single_operator_32767+5>
mov AX TF
cmp AX 1
$jmp 32849 "!="
push 1        ;Àx¦sCX
push [1]
push <deal_single_operator_32767+1>
push <deal_single_operator_32767+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32844 "t"
mov AX True
jmp 32845
mov AX False
cmp AX 1
$jmp 32849 "!="
mov AX 1
jmp 32850
mov AX 0
cmp AX 1
$jmp 33034 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
mov BX <deal_single_operator_32767+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 32982 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_single_operator_32767+4>
tf DX "equ" 0
$jmp 32866 "f"
mov AX True
jmp 32867
mov AX False
cmp AX 1
$jmp 32891 "=="
push 1        ;Àx¦sCX
push [1]
push <deal_single_operator_32767+1>
push <deal_single_operator_32767+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32886 "f"
mov AX True
jmp 32887
mov AX False
cmp AX 1
$jmp 32891 "=="
mov AX 0
jmp 32892
mov AX 1
cmp AX 1
$jmp 32981 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_single_operator_32767+5>
tf DX "equ" "-"
$jmp 32899 "f"
mov AX True
jmp 32900
mov AX False
cmp AX 1
$jmp 32954 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_32767+1>
push <deal_single_operator_32767+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <deal_single_operator_32767+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_32767+3>
push AX
mov <deal_single_operator_32767+6> <esp+1>
inc esp
push <deal_single_operator_32767+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_32767+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_32767+6>
pop AX
oper <esp+1> "+" AX
push <deal_single_operator_32767+1>
push [3]
push <deal_single_operator_32767+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_32767+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_32767+4> <esp+1>
inc esp
jmp 32980        ;¸õ¦Ü©³³¡
push <deal_single_operator_32767+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_32767+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <deal_single_operator_32767+1>
push [3]
push <deal_single_operator_32767+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_32767+1> <esp+1>
inc esp
jmp 32981        ;¸õ¦Ü©³³¡
jmp 33033        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_32767+1>
push <deal_single_operator_32767+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <deal_single_operator_32767+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_32767+3>
push AX
mov <deal_single_operator_32767+6> <esp+1>
inc esp
push <deal_single_operator_32767+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_32767+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_32767+6>
pop AX
oper <esp+1> "+" AX
push <deal_single_operator_32767+1>
push [3]
push <deal_single_operator_32767+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_32767+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_32767+4> <esp+1>
inc esp
jmp 33034        ;¸õ¦Ü©³³¡
push 1
$mov <deal_single_operator_32767+4> "+" <esp+1>
inc esp
jmp 32801               ;continue­«¨Ó
mov AX <deal_single_operator_32767+1>
jmp 33040         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_single_operator_32767" "0,1,2,3,4,5,6"
pop ip
Function <parse_codeline_31860+23> 33045 None "deal_single_operator_all_33045" 8 "parse_codeline_31860"
jmp 33171           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 33053 "!="
tf <esp+2> "in" "codeline"
$jmp 33055 "t"
mov <esp+2>["codeline"] None
jmp 33055
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 33061 "!="
tf <esp+2> "in" "op_box"
$jmp 33063 "t"
mov <esp+2>["op_box"] None
jmp 33063
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 33069 "!="
tf <esp+2> "in" "operator"
$jmp 33071 "t"
mov <esp+2>["operator"] None
jmp 33071
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_single_operator_all_33045+1> <esp+2>["codeline"]
mov <deal_single_operator_all_33045+2> <esp+2>["op_box"]
mov <deal_single_operator_all_33045+3> <esp+2>["operator"]


push 0
mov <deal_single_operator_all_33045+4> <esp+1>
inc esp
push <deal_single_operator_all_33045+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_single_operator_all_33045+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33092 ">="
mov AX True
jmp 33093
mov AX False
cmp AX 1
$jmp 33166 "!="
push <deal_single_operator_all_33045+1>
mov BX <deal_single_operator_all_33045+4>
pop AX
push AX[BX]
mov <deal_single_operator_all_33045+5> <esp+1>
inc esp
tf <deal_single_operator_all_33045+2> "in" <deal_single_operator_all_33045+5>
mov AX TF
cmp AX 1
$jmp 33162 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_all_33045+1>
push [3]
push <deal_single_operator_all_33045+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <deal_single_operator_all_33045+6> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <deal_single_operator_all_33045+6>
mov <esp+1>[1] <deal_single_operator_all_33045+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_all_33045+3>
push AX
mov <deal_single_operator_all_33045+7> <esp+1>
inc esp
push <deal_single_operator_all_33045+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_all_33045+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_all_33045+7>
pop AX
oper <esp+1> "+" AX
mov <deal_single_operator_all_33045+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_all_33045+4> <esp+1>
inc esp
jmp 33162        ;¸õ¦Ü©³³¡
push 1
$mov <deal_single_operator_all_33045+4> "+" <esp+1>
inc esp
jmp 33079               ;continue­«¨Ó
mov AX <deal_single_operator_all_33045+1>
jmp 33168         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_single_operator_all_33045" "0,1,2,3,4,5,6,7"
pop ip
Function <parse_codeline_31860+24> 33173 None "deal_operator_33173" 7 "parse_codeline_31860"
jmp 33309           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 33181 "!="
tf <esp+2> "in" "codeline"
$jmp 33183 "t"
mov <esp+2>["codeline"] None
jmp 33183
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 33189 "!="
tf <esp+2> "in" "op_box"
$jmp 33191 "t"
mov <esp+2>["op_box"] None
jmp 33191
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 33197 "!="
tf <esp+2> "in" "operator"
$jmp 33199 "t"
mov <esp+2>["operator"] None
jmp 33199
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_operator_33173+1> <esp+2>["codeline"]
mov <deal_operator_33173+2> <esp+2>["op_box"]
mov <deal_operator_33173+3> <esp+2>["operator"]


push 0
mov <deal_operator_33173+4> <esp+1>
inc esp
push <deal_operator_33173+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_operator_33173+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33220 ">="
mov AX True
jmp 33221
mov AX False
cmp AX 1
$jmp 33304 "!="
push <deal_operator_33173+1>
mov BX <deal_operator_33173+4>
pop AX
push AX[BX]
mov <deal_operator_33173+5> <esp+1>
inc esp
tf <deal_operator_33173+2> "in" <deal_operator_33173+5>
mov AX TF
cmp AX 1
$jmp 33300 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_operator_33173+4>
cmp DX 0
$jmp 33238 "<="
mov AX True
jmp 33239
mov AX False
cmp AX 1
$jmp 33299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
push <deal_operator_33173+1>
push <deal_operator_33173+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <deal_operator_33173+1>
push <deal_operator_33173+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <deal_operator_33173+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_operator_33173+3>
push AX
mov <deal_operator_33173+6> <esp+1>
inc esp
push <deal_operator_33173+1>
push [3]
mov <esp+1>[0] None
push <deal_operator_33173+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_operator_33173+6>
pop AX
oper <esp+1> "+" AX
push <deal_operator_33173+1>
push [3]
push <deal_operator_33173+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_operator_33173+1> <esp+1>
inc esp
push 1
$mov <deal_operator_33173+4> "-" <esp+1>
inc esp
jmp 33299        ;¸õ¦Ü©³³¡
jmp 33300        ;¸õ¦Ü©³³¡
push 1
$mov <deal_operator_33173+4> "+" <esp+1>
inc esp
jmp 33207               ;continue­«¨Ó
mov AX <deal_operator_33173+1>
jmp 33306         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_operator_33173" "0,1,2,3,4,5,6"
pop ip
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33325 ">="
mov AX True
jmp 33326
mov AX False
cmp AX 1
$jmp 33451 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
mov DX <parse_codeline_31860+5>
tf DX "equ" "**"
$jmp 33339 "f"
mov AX True
jmp 33340
mov AX False
cmp AX 1
$jmp 33447 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
push <parse_codeline_31860+4>
mov <parse_codeline_31860+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 33363 "f"
mov AX True
jmp 33364
mov AX False
cmp AX 1
$jmp 33370 "!="
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 33348               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+9>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+25> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_31860+1>
push <parse_codeline_31860+9>
oper <esp+1> "-" 2
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+25>
mov <esp+1>[2] "**"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+53>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+9>
oper <esp+1> "-" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push <parse_codeline_31860+9>
oper <esp+1> "-" 2
mov <parse_codeline_31860+4> <esp+1>
inc esp
jmp 33447        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 33312               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] "~"
mov <esp+1>[1] "-"
mov <esp+1>[2] "+"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+56>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+22>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (4)
mov <esp+1>[0] "*"
mov <esp+1>[1] "/"
mov <esp+1>[2] "%"
mov <esp+1>[3] "//"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (2)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (2)
mov <esp+1>[0] "<<"
mov <esp+1>[1] ">>"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [1]
mov <esp+1>[0] "&"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [1]
mov <esp+1>[0] "^"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [1]
mov <esp+1>[0] "|"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33572 ">="
mov AX True
jmp 33573
mov AX False
cmp AX 1
$jmp 33706 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
push (6)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
mov <esp+1>[2] ">"
mov <esp+1>[3] "<"
mov <esp+1>[4] ">="
mov <esp+1>[5] "<="
mov BX <parse_codeline_31860+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 33702 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_codeline_31860+26> <esp+1>
inc esp
push <parse_codeline_31860+4>
mov <parse_codeline_31860+9> <esp+1>
inc esp
push (6)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
mov <esp+1>[2] ">"
mov <esp+1>[3] "<"
mov <esp+1>[4] ">="
mov <esp+1>[5] "<="
mov BX <parse_codeline_31860+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 33657 "!="
push [2]
mov <esp+1>[0] <parse_codeline_31860+5>
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
$mov <parse_codeline_31860+26> "+" <esp+1>
inc esp
push 2
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33645 ">="
mov AX True
jmp 33646
mov AX False
cmp AX 1
$jmp 33655 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
jmp 33656        ;¸õ¦Ü©³³¡
jmp 33657          ;break¥X
jmp 33606               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+57>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+9>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+4>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push <parse_codeline_31860+9>
oper <esp+1> "-" 1
mov <parse_codeline_31860+4> <esp+1>
inc esp
jmp 33702        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 33559               ;continue­«¨Ó
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33722 ">="
mov AX True
jmp 33723
mov AX False
cmp AX 1
$jmp 34066 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
mov DX <parse_codeline_31860+5>
tf DX "equ" "for"
$jmp 33736 "f"
mov AX True
jmp 33737
mov AX False
cmp AX 1
$jmp 33757 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+4>
push [1]
mov <esp+1>[0] "in"
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+4> <esp+1>
inc esp
jmp 34062        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+5>
tf DX "equ" "in"
$jmp 33762 "f"
mov AX True
jmp 33763
mov AX False
cmp AX 1
$jmp 33911 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_codeline_31860+4>
cmp DX 0
$jmp 33770 "<="
mov AX True
jmp 33771
mov AX False
cmp AX 1
$jmp 33910 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "not"
$jmp 33783 "f"
mov AX True
jmp 33784
mov AX False
cmp AX 1
$jmp 33852 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 2
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
mov <esp+1>[0] AX
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+56>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+4>
oper <esp+1> "-" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 2
$mov <parse_codeline_31860+4> "-" <esp+1>
inc esp
jmp 33909        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 1
$mov <parse_codeline_31860+4> "-" <esp+1>
inc esp
jmp 33910        ;¸õ¦Ü©³³¡
jmp 34062        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+5>
tf DX "equ" "is"
$jmp 33916 "f"
mov AX True
jmp 33917
mov AX False
cmp AX 1
$jmp 34062 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_codeline_31860+4>
cmp DX 0
$jmp 33924 "<="
mov AX True
jmp 33925
mov AX False
cmp AX 1
$jmp 34061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "not"
$jmp 33937 "f"
mov AX True
jmp 33938
mov AX False
cmp AX 1
$jmp 34003 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 2
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
mov <esp+1>[0] AX
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+56>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 3
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
jmp 34057        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_31860+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 1
$mov <parse_codeline_31860+4> "-" <esp+1>
inc esp
jmp 34061        ;¸õ¦Ü©³³¡
jmp 34062        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 33709               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [1]
mov <esp+1>[0] "not"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+56>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+22>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (2)
mov <esp+1>[0] "and"
mov <esp+1>[1] "or"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+55>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+24>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 34111 ">="
mov AX True
jmp 34112
mov AX False
cmp AX 1
$jmp 34379 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
push AX[BX]
mov <parse_codeline_31860+5> <esp+1>
inc esp
mov DX <parse_codeline_31860+5>
tf DX "equ" "if"
$jmp 34125 "f"
mov AX True
jmp 34126
mov AX False
cmp AX 1
$jmp 34257 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+4>
push [1]
mov <esp+1>[0] "else"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+27> <esp+1>
inc esp
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_31860+28> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+27>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+29> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+27>
mov <esp+1>[2] ","
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+27>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+30>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+31> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+29>
mov <esp+1>[1] <parse_codeline_31860+28>
mov <esp+1>[2] <parse_codeline_31860+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+42>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_31860+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_31860+1>
push [3]
mov <esp+1>[0] <parse_codeline_31860+30>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
jmp 34375        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_31860+5>
tf DX "equ" "for"
$jmp 34262 "f"
mov AX True
jmp 34263
mov AX False
cmp AX 1
$jmp 34375 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
push <parse_codeline_31860+4>
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_31860+32> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+4>
push [1]
mov <esp+1>[0] "in"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+33> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_31860+1>
push [3]
push <parse_codeline_31860+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_31860+33>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_31860+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_31860+34> <esp+1>
inc esp
push <parse_codeline_31860+1>
push <parse_codeline_31860+33>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_31860+35> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
mov <esp+1>[1] <parse_codeline_31860+33>
push [1]
mov <esp+1>[0] "if"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_31860+36> <esp+1>
inc esp
push <parse_codeline_31860+36>
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 34343 "f"
mov AX True
jmp 34344
mov AX False
cmp AX 1
$jmp 34350 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
mov <parse_codeline_31860+37> <esp+1>
inc esp
jmp 34358        ;¸õ¦Ü©³³¡
push <parse_codeline_31860+1>
push <parse_codeline_31860+36>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_31860+37> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_codeline_31860+32>
mov <esp+1>[1] <parse_codeline_31860+34>
mov <esp+1>[2] <parse_codeline_31860+35>
mov <esp+1>[3] <parse_codeline_31860+37>
mov <esp+1>[4] <parse_codeline_31860+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+45>
push AX
mov <parse_codeline_31860+14> <esp+1>
inc esp
mov AX <parse_codeline_31860+14>
jmp 34587         ;returnÂI
jmp 34375        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
jmp 34098               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push [1]
mov <esp+1>[0] "yield"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+22>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (2)
mov <esp+1>[0] "return"
mov <esp+1>[1] "raise"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+23>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_31860+1>
push (3)
mov <esp+1>[0] "del"
mov <esp+1>[1] "global"
mov <esp+1>[2] "nonlocal"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+37>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_31860+22>
push AX
mov <parse_codeline_31860+1> <esp+1>
inc esp
push 0
mov <parse_codeline_31860+4> <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
cmp DX AX
$jmp 34443 ">="
mov AX True
jmp 34444
mov AX False
cmp AX 1
$jmp 34496 "!="
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 34454 "f"
mov AX True
jmp 34455
mov AX False
cmp AX 1
$jmp 34462 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
mov BX <parse_codeline_31860+4>
pop AX
del 1 AX BX
jmp 34465        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_31860+4> "+" <esp+1>
inc esp
push <parse_codeline_31860+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 34481 "f"
mov AX True
jmp 34482
mov AX False
cmp AX 1
$jmp 34490 "!="
mov AX <parse_codeline_31860+3>
$oper AX "not"
cmp AX 1
$jmp 34490 "!="
mov AX 1
jmp 34491
mov AX 0
cmp AX 1
$jmp 34495 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 34496          ;break¥X
jmp 34495        ;¸õ¦Ü©³³¡
jmp 34427               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 34508 "<="
mov AX True
jmp 34509
mov AX False
cmp AX 1
$jmp 34526 "!="
push <parse_codeline_31860+1>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 34521 "f"
mov AX True
jmp 34522
mov AX False
cmp AX 1
$jmp 34526 "!="
mov AX 1
jmp 34527
mov AX 0
cmp AX 1
$jmp 34547 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
cmp <parse_codeline_31860+3> 1
$jmp 34538 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 34546        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+29>
jmp 34587         ;returnÂI
jmp 34547        ;¸õ¦Ü©³³¡
cmp <parse_codeline_31860+3> 1
$jmp 34558 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+28>
jmp 34587         ;returnÂI
jmp 34558        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 34570 "f"
mov AX True
jmp 34571
mov AX False
cmp AX 1
$jmp 34579 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_31860+1>
mov BX 0
pop AX
mov AX AX[BX]
jmp 34587         ;returnÂI
jmp 34579        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_31860+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+29>
jmp 34587         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_codeline_31860" "0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,25,26,27,28,29,30,31,32,33,34,35,36,37"
pop ip
Function <&package_6+11> 34592 None "parse_block_34592" 60
jmp 37639           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 34600 "!="
tf <esp+2> "in" "codelines"
$jmp 34602 "t"
mov <esp+2>["codelines"] None
jmp 34602
mov <esp+2>["codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 34614 "!="
tf <esp+2> "in" "namespace"
$jmp 34616 "t"
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
mov <esp+2>["namespace"] AX
jmp 34616
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <parse_block_34592+1> <esp+2>["codelines"]
mov <parse_block_34592+2> <esp+2>["namespace"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+60>
push AX
mov <parse_block_34592+3> <esp+1>
inc esp
push 0
mov <parse_block_34592+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34592+5> <esp+1>
inc esp
mov DX <parse_block_34592+4>
cmp DX <parse_block_34592+5>
$jmp 34648 ">="
mov AX True
jmp 34649
mov AX False
cmp AX 1
$jmp 37634 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+4>
pop AX
push AX[BX]
mov <parse_block_34592+6> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "def"
$jmp 34665 "f"
mov AX True
jmp 34666
mov AX False
cmp AX 1
$jmp 34929 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+7> <esp+1>
inc esp
push [dict]
mov <parse_block_34592+8> <esp+1>
inc esp
push 4
mov <parse_block_34592+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34592+10> <esp+1>
inc esp
push ""
mov <parse_block_34592+11> <esp+1>
inc esp
mov DX <parse_block_34592+9>
cmp DX <parse_block_34592+10>
$jmp 34699 ">="
mov AX True
jmp 34700
mov AX False
cmp AX 1
$jmp 34834 "!="
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
push AX[BX]
mov <parse_block_34592+12> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "*"
mov <esp+1>[1] "**"
mov BX <parse_block_34592+12>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 34733 "!="
push (2)
mov <esp+1>[0] "("
mov <esp+1>[1] ","
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "-" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 34733 "!="
mov AX 1
jmp 34734
mov AX 0
cmp AX 1
$jmp 34740 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+12>
mov <parse_block_34592+11> <esp+1>
inc esp
jmp 34830        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 34752 "f"
mov AX True
jmp 34753
mov AX False
cmp AX 1
$jmp 34830 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+11>
oper <esp+1> "+" <parse_block_34592+12>.name
mov <parse_block_34592+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
push <parse_block_34592+8>
mov BX <parse_block_34592+13>
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 34782 "f"
mov AX True
jmp 34783
mov AX False
cmp AX 1
$jmp 34826 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+9>
oper <esp+1> "+" 2
mov <parse_block_34592+14> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] <parse_block_34592+14>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] <parse_block_34592+14>
mov <esp+1>[1] <parse_block_34592+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
push <parse_block_34592+8>
mov BX <parse_block_34592+13>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 34826        ;¸õ¦Ü©³³¡
push ""
mov <parse_block_34592+11> <esp+1>
inc esp
jmp 34830        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 34694               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push [dict]
push "namespace"
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34592+7>
mov <esp+1>[1] <parse_block_34592+8>
mov <esp+1>[2] <parse_block_34592+16>
mov <esp+1>[3] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+34>
push AX
mov <parse_block_34592+17> <esp+1>
inc esp
push <parse_block_34592+16>.locals
mov <parse_block_34592+17>.local_vars <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "func"
mov <esp+1>[1] <parse_block_34592+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+17>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "class"
$jmp 34937 "f"
mov AX True
jmp 34938
mov AX False
cmp AX 1
$jmp 35107 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+18> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX 3
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 34955 "f"
mov AX True
jmp 34956
mov AX False
cmp AX 1
$jmp 34994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] 4
push [1]
mov <esp+1>[0] ")"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 4
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+19> <esp+1>
inc esp
jmp 34997        ;¸õ¦Ü©³³¡
push None
mov <parse_block_34592+19> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 1
$mov <&package_6+16>.class_n "+" <esp+1>
inc esp
push ""
ex_func AX "str" <parse_block_34592+18>
oper <esp+1> "+" AX
oper <esp+1> "+" "^"
ex_func AX "str" <&package_6+16>.class_n
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <parse_block_34592+20> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push [dict]
push "namespace"
push 1        ;Àx¦sCX
push [1]
push "<"
ex_func AX "str" <parse_block_34592+20>
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34592+18>
mov <esp+1>[1] <parse_block_34592+16>
mov <esp+1>[2] <parse_block_34592+2>
mov <esp+1>[3] <parse_block_34592+20>
mov <esp+1>[4] <parse_block_34592+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+50>
push AX
mov <parse_block_34592+21> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "class"
mov <esp+1>[1] <parse_block_34592+21>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+21>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "if"
$jmp 35115 "f"
mov AX True
jmp 35116
mov AX False
cmp AX 1
$jmp 35423 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_block_34592+22> <esp+1>
inc esp
push [0]
mov <parse_block_34592+23> <esp+1>
inc esp
push [0]
mov <parse_block_34592+24> <esp+1>
inc esp
push 0
mov <parse_block_34592+25> <esp+1>
inc esp
mov DX <parse_block_34592+4>
cmp DX <parse_block_34592+5>
$jmp 35135 ">="
mov AX True
jmp 35136
mov AX False
cmp AX 1
$jmp 35403 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+4>
pop AX
push AX[BX]
mov <parse_block_34592+6> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "if"
$jmp 35152 "f"
mov AX True
jmp 35153
mov AX False
cmp AX 1
$jmp 35165 "!="
mov DX <parse_block_34592+25>
tf DX "equ" 0
$jmp 35160 "f"
mov AX True
jmp 35161
mov AX False
cmp AX 1
$jmp 35165 "!="
mov AX 1
jmp 35166
mov AX 0
cmp AX 1
$jmp 35181 "=="
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "elif"
$jmp 35176 "f"
mov AX True
jmp 35177
mov AX False
cmp AX 1
$jmp 35181 "=="
mov AX 0
jmp 35182
mov AX 1
cmp AX 1
$jmp 35316 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_block_34592+25> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+24>.append
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+29>
$jmp 35244 "f"
mov AX True
jmp 35245
mov AX False
cmp AX 1
$jmp 35258 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
push AX
mov <parse_block_34592+26> <esp+1>
inc esp
jmp 35258        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <parse_block_34592+26>
mov <esp+1>[1] <parse_block_34592+16>.codelines
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+22>.append
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 35402        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 35324 "f"
mov AX True
jmp 35325
mov AX False
cmp AX 1
$jmp 35401 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 35403          ;break¥X
jmp 35402        ;¸õ¦Ü©³³¡
jmp 35403          ;break¥X
jmp 35130               ;continue­«¨Ó
push 1
$mov <parse_block_34592+4> "-" <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+22>
mov <esp+1>[1] <parse_block_34592+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+43>
mov <esp+1>[0] AX
mov <esp+1>[1] <parse_block_34592+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "while"
$jmp 35431 "f"
mov AX True
jmp 35432
mov AX False
cmp AX 1
$jmp 35648 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+29>
$jmp 35469 "f"
mov AX True
jmp 35470
mov AX False
cmp AX 1
$jmp 35483 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
push AX
mov <parse_block_34592+26> <esp+1>
inc esp
jmp 35483        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+28> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
mov DX <parse_block_34592+15>
cmp DX <parse_block_34592+5>
$jmp 35535 ">="
mov AX True
jmp 35536
mov AX False
cmp AX 1
$jmp 35554 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 35549 "f"
mov AX True
jmp 35550
mov AX False
cmp AX 1
$jmp 35554 "!="
mov AX 1
jmp 35555
mov AX 0
cmp AX 1
$jmp 35608 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
jmp 35611        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34592+23> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+26>
mov <esp+1>[1] <parse_block_34592+28>
mov <esp+1>[2] <parse_block_34592+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+44>
mov <esp+1>[0] AX
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "for"
$jmp 35656 "f"
mov AX True
jmp 35657
mov AX False
cmp AX 1
$jmp 35946 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_block_34592+29> <esp+1>
inc esp
push 2
mov <parse_block_34592+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 35680 "f"
mov AX True
jmp 35681
mov AX False
cmp AX 1
$jmp 35696 "=="
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 35691 "f"
mov AX True
jmp 35692
mov AX False
cmp AX 1
$jmp 35696 "=="
mov AX 0
jmp 35697
mov AX 1
cmp AX 1
$jmp 35752 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 35714 "f"
mov AX True
jmp 35715
mov AX False
cmp AX 1
$jmp 35748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+29>.append
jmp 35748        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 35665               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+31> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+32> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
mov DX <parse_block_34592+15>
cmp DX <parse_block_34592+5>
$jmp 35829 ">="
mov AX True
jmp 35830
mov AX False
cmp AX 1
$jmp 35848 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 35843 "f"
mov AX True
jmp 35844
mov AX False
cmp AX 1
$jmp 35848 "!="
mov AX 1
jmp 35849
mov AX 0
cmp AX 1
$jmp 35902 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34592+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+27>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
jmp 35905        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34592+23> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34592+29>
mov <esp+1>[1] <parse_block_34592+31>
mov <esp+1>[2] <parse_block_34592+32>
mov <esp+1>[3] <parse_block_34592+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+46>
push AX
mov <parse_block_34592+33> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+33>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "import"
$jmp 35954 "f"
mov AX True
jmp 35955
mov AX False
cmp AX 1
$jmp 36183 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <&package_6+16>.need_load <esp+1>
inc esp
push [dict]
mov <parse_block_34592+34> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 2
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_block_34592+9> <esp+1>[0]
mov <parse_block_34592+10> <esp+1>[1]
inc esp
mov DX <parse_block_34592+9>
cmp DX <parse_block_34592+10>
$jmp 35981 ">="
mov AX True
jmp 35982
mov AX False
cmp AX 1
$jmp 36148 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 35999 "f"
mov AX True
jmp 36000
mov AX False
cmp AX 1
$jmp 36144 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+35> <esp+1>
inc esp
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34592+10>
$jmp 36016 ">="
mov AX True
jmp 36017
mov AX False
cmp AX 1
$jmp 36034 "!="
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 36029 "f"
mov AX True
jmp 36030
mov AX False
cmp AX 1
$jmp 36034 "!="
mov AX 1
jmp 36035
mov AX 0
cmp AX 1
$jmp 36053 "!="
push "."
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
$mov <parse_block_34592+35> "+" <esp+1>
inc esp
push 2
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 36009               ;continue­«¨Ó
push None
mov <parse_block_34592+36> <esp+1>
inc esp
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34592+10>
$jmp 36063 ">="
mov AX True
jmp 36064
mov AX False
cmp AX 1
$jmp 36081 "!="
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 36076 "f"
mov AX True
jmp 36077
mov AX False
cmp AX 1
$jmp 36081 "!="
mov AX 1
jmp 36082
mov AX 0
cmp AX 1
$jmp 36108 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+36>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+30> <esp+1>
inc esp
push 2
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 36129        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+35>.split
push AX
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+30> <esp+1>
inc esp
push <parse_block_34592+36>
push <parse_block_34592+34>
mov BX <parse_block_34592+35>
pop AX
mov AX[BX] <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
jmp 36144        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 35976               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+34>
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+13>
push AX
mov <parse_block_34592+37> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+37>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "from"
$jmp 36191 "f"
mov AX True
jmp 36192
mov AX False
cmp AX 1
$jmp 36441 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <&package_6+16>.need_load <esp+1>
inc esp
push [0]
mov <parse_block_34592+38> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+35> <esp+1>
inc esp
push 2
mov <parse_block_34592+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34592+10> <esp+1>
inc esp
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34592+10>
$jmp 36227 ">="
mov AX True
jmp 36228
mov AX False
cmp AX 1
$jmp 36245 "!="
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 36240 "f"
mov AX True
jmp 36241
mov AX False
cmp AX 1
$jmp 36245 "!="
mov AX 1
jmp 36246
mov AX 0
cmp AX 1
$jmp 36264 "!="
push "."
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
$mov <parse_block_34592+35> "+" <esp+1>
inc esp
push 2
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 36220               ;continue­«¨Ó
push 2
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
mov DX <parse_block_34592+9>
cmp DX <parse_block_34592+10>
$jmp 36272 ">="
mov AX True
jmp 36273
mov AX False
cmp AX 1
$jmp 36404 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 36290 "f"
mov AX True
jmp 36291
mov AX False
cmp AX 1
$jmp 36378 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+39> <esp+1>
inc esp
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34592+10>
$jmp 36307 ">="
mov AX True
jmp 36308
mov AX False
cmp AX 1
$jmp 36325 "!="
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 36320 "f"
mov AX True
jmp 36321
mov AX False
cmp AX 1
$jmp 36325 "!="
mov AX 1
jmp 36326
mov AX 0
cmp AX 1
$jmp 36343 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] <parse_block_34592+39>
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.name
mov <parse_block_34592+40> <esp+1>
inc esp
push 2
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 36348        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] <parse_block_34592+39>
mov <esp+1>[1] <parse_block_34592+39>
mov <parse_block_34592+40> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+40>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+38>.append
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+40>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
jmp 36400        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 36386 "f"
mov AX True
jmp 36387
mov AX False
cmp AX 1
$jmp 36400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] "*"
mov <esp+1>[1] "*"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+38>.append
jmp 36400        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34592+9> "+" <esp+1>
inc esp
jmp 36267               ;continue­«¨Ó
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34592+35>
mov <esp+1>[1] <parse_block_34592+38>
mov <esp+1>[2] <parse_block_34592+2>
mov <esp+1>[3] <parse_block_34592+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+12>
push AX
mov <parse_block_34592+41> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+41>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "try"
$jmp 36449 "f"
mov AX True
jmp 36450
mov AX False
cmp AX 1
$jmp 36971 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov <parse_block_34592+24> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+42> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
push [0]
mov <parse_block_34592+43> <esp+1>
inc esp
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
mov DX <parse_block_34592+15>
cmp DX <parse_block_34592+5>
$jmp 36526 ">="
mov AX True
jmp 36527
mov AX False
cmp AX 1
$jmp 36545 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "except"
$jmp 36540 "f"
mov AX True
jmp 36541
mov AX False
cmp AX 1
$jmp 36545 "!="
mov AX 1
jmp 36546
mov AX 0
cmp AX 1
$jmp 36735 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov <parse_block_34592+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+24>.append
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] 1
push (2)
mov <esp+1>[0] ":"
mov <esp+1>[1] "as"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+9> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 36599 "f"
mov AX True
jmp 36600
mov AX False
cmp AX 1
$jmp 36649 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+9>
oper <esp+1> "-" 1
pop DX
cmp DX 1
$jmp 36609 "<="
mov AX True
jmp 36610
mov AX False
cmp AX 1
$jmp 36634 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34592+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+44> <esp+1>
inc esp
jmp 36645        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "Exception"
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+44> <esp+1>
inc esp
push None
mov <parse_block_34592+36> <esp+1>
inc esp
jmp 36679        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34592+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+44> <esp+1>
inc esp
push <parse_block_34592+6>
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34592+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] <parse_block_34592+44>
mov <esp+1>[1] <parse_block_34592+36>
mov <esp+1>[2] <parse_block_34592+16>.codelines
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+43>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 36521               ;continue­«¨Ó
mov DX <parse_block_34592+15>
cmp DX <parse_block_34592+5>
$jmp 36740 ">="
mov AX True
jmp 36741
mov AX False
cmp AX 1
$jmp 36759 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 36754 "f"
mov AX True
jmp 36755
mov AX False
cmp AX 1
$jmp 36759 "!="
mov AX 1
jmp 36760
mov AX 0
cmp AX 1
$jmp 36835 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov <parse_block_34592+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
jmp 36838        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34592+23> <esp+1>
inc esp
push <parse_block_34592+15>
mov <parse_block_34592+4> <esp+1>
inc esp
mov DX <parse_block_34592+15>
cmp DX <parse_block_34592+5>
$jmp 36846 ">="
mov AX True
jmp 36847
mov AX False
cmp AX 1
$jmp 36865 "!="
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "finally"
$jmp 36860 "f"
mov AX True
jmp 36861
mov AX False
cmp AX 1
$jmp 36865 "!="
mov AX 1
jmp 36866
mov AX 0
cmp AX 1
$jmp 36941 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34592+1>
mov BX <parse_block_34592+15>
pop AX
push AX[BX]
mov <parse_block_34592+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push <parse_block_34592+16>.codelines
mov <parse_block_34592+45> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
jmp 36944        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34592+45> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34592+42>
mov <esp+1>[1] <parse_block_34592+43>
mov <esp+1>[2] <parse_block_34592+23>
mov <esp+1>[3] <parse_block_34592+45>
mov <esp+1>[4] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+38>
push AX
mov <parse_block_34592+46> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+46>
mov <esp+1>[1] <parse_block_34592+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "with"
$jmp 36979 "f"
mov AX True
jmp 36980
mov AX False
cmp AX 1
$jmp 37206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2
mov <parse_block_34592+9> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] <parse_block_34592+9>
push [2]
mov <esp+1>[0] "as"
mov <esp+1>[1] ":"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] <parse_block_34592+9>
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+47> <esp+1>
inc esp
push 1
$mov <&package_6+16>.class_n "+" <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push "%with_obj_"
ex_func AX "str" <&package_6+16>.class_n
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34592+48> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+48>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
push <parse_block_34592+6>
mov BX <parse_block_34592+15>
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 37055 "f"
mov AX True
jmp 37056
mov AX False
cmp AX 1
$jmp 37120 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] <parse_block_34592+15>
push [1]
mov <esp+1>[0] ":"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+49> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
push <parse_block_34592+15>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+49>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+36> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37107 "f"
mov AX True
jmp 37108
mov AX False
cmp AX 1
$jmp 37119 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
jmp 37119        ;¸õ¦Ü©³³¡
jmp 37123        ;¸õ¦Ü©³³¡
push None
mov <parse_block_34592+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+1>
mov <esp+1>[1] <parse_block_34592+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34592+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+1>
push [3]
push <parse_block_34592+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34592+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34592+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.update
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34592+47>
mov <esp+1>[1] <parse_block_34592+48>
mov <esp+1>[2] <parse_block_34592+36>
mov <esp+1>[3] <parse_block_34592+16>.codelines
mov <esp+1>[4] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+39>
push AX
mov <parse_block_34592+50> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+50>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push <parse_block_34592+15>
oper <esp+1> "-" 1
mov <parse_block_34592+4> <esp+1>
inc esp
jmp 37630        ;¸õ¦Ü©³³¡
push <parse_block_34592+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "assert"
$jmp 37214 "f"
mov AX True
jmp 37215
mov AX False
cmp AX 1
$jmp 37356 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] 1
push [1]
mov <esp+1>[0] ","
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34592+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+26> <esp+1>
inc esp
push <parse_block_34592+9>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 37268 ">="
mov AX True
jmp 37269
mov AX False
cmp AX 1
$jmp 37284 "!="
push <parse_block_34592+6>
mov BX <parse_block_34592+9>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 37279 "f"
mov AX True
jmp 37280
mov AX False
cmp AX 1
$jmp 37284 "!="
mov AX 1
jmp 37285
mov AX 0
cmp AX 1
$jmp 37311 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
push <parse_block_34592+9>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+51> <esp+1>
inc esp
jmp 37321        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
push AX
mov <parse_block_34592+51> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+26>
mov <esp+1>[1] <parse_block_34592+51>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+58>
push AX
mov <parse_block_34592+52> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+52>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
jmp 37630        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
mov <esp+1>[1] 0
push (13)
mov <esp+1>[0] "="
mov <esp+1>[1] "+="
mov <esp+1>[2] "-="
mov <esp+1>[3] "*="
mov <esp+1>[4] "/="
mov <esp+1>[5] "%="
mov <esp+1>[6] "//="
mov <esp+1>[7] "**="
mov <esp+1>[8] "<<="
mov <esp+1>[9] ">>="
mov <esp+1>[10] "&="
mov <esp+1>[11] "^="
mov <esp+1>[12] "|="
pop <esp+1>[2]
push [dict]
push "stop"
push [1]
mov <esp+1>[0] "lambda"
pop AX
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+53> <esp+1>
inc esp
push <parse_block_34592+6>
mov BX <parse_block_34592+53>
pop AX
push AX[BX]
mov <parse_block_34592+54> <esp+1>
inc esp
push [0]
mov <parse_block_34592+55> <esp+1>
inc esp
push 1
mov <parse_block_34592+56> <esp+1>
inc esp
mov DX <parse_block_34592+53>
cmp DX 0
$jmp 37406 "<="
mov AX True
jmp 37407
mov AX False
cmp AX 1
$jmp 37535 "!="
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] <parse_block_34592+56>
mov <esp+1>[1] <parse_block_34592+53>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+57> <esp+1>
inc esp
push (2)
mov <esp+1>[0] <&package_6+29>
mov <esp+1>[1] <&package_6+28>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 37478 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
ex_func AX "iter" <parse_block_34592+57>
push AX
fetch AX <esp+1>
$jmp 37476 "f"
mov <parse_block_34592+30> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37463 "f"
mov AX True
jmp 37464
mov AX False
cmp AX 1
$jmp 37475 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
jmp 37475        ;¸õ¦Ü©³³¡
jmp 37448
inc esp
jmp 37502        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37490 "f"
mov AX True
jmp 37491
mov AX False
cmp AX 1
$jmp 37502 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34592+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.add_info
jmp 37502        ;¸õ¦Ü©³³¡
push <parse_block_34592+53>
oper <esp+1> "+" 1
mov <parse_block_34592+56> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+55>.append
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+6>
push <parse_block_34592+53>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "="
push [dict]
push "stop"
push [1]
mov <esp+1>[0] "lambda"
pop AX
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34592+53> <esp+1>
inc esp
jmp 37401               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_block_34592+6>
push [3]
mov <esp+1>[0] <parse_block_34592+56>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34592+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34592+58> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34592+55>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 37568 "f"
mov AX True
jmp 37569
mov AX False
cmp AX 1
$jmp 37595 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+58>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
jmp 37630        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34592+55>
mov <esp+1>[1] <parse_block_34592+58>
mov <esp+1>[2] <parse_block_34592+54>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+52>
push AX
mov <parse_block_34592+59> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34592+59>
push (2)
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34592+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34592+3>.write
push 1
$mov <parse_block_34592+4> "+" <esp+1>
inc esp
jmp 34643               ;continue­«¨Ó
mov AX <parse_block_34592+3>
jmp 37636         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_block_34592" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59"
pop ip
Function <&package_6+12> 37642 None "From_Import^2" 1
name <&package_6+12> "<class '__main__.From_Import'>"
jmp 38041
tf $Inheritance "equ" None
$jmp 37647 "t"
mov <From_Import^2> $Inheritance
push 1
jmp 37649
mov <From_Import^2> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <From_Import^2> <&package_6+12>
Function BX 37657 <From_Import^2> "__init___37657" 6
mov <From_Import^2>.__init__ BX
jmp 37718           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 37665 "!="
tf <esp+2> "in" "module_name"
$jmp 37667 "t"
mov <esp+2>["module_name"] None
jmp 37667
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 37673 "!="
tf <esp+2> "in" "object_names"
$jmp 37675 "t"
mov <esp+2>["object_names"] None
jmp 37675
mov <esp+2>["object_names"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 37681 "!="
tf <esp+2> "in" "namespace"
$jmp 37683 "t"
mov <esp+2>["namespace"] None
jmp 37683
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 37689 "!="
tf <esp+2> "in" "now_info"
$jmp 37691 "t"
mov <esp+2>["now_info"] None
jmp 37691
mov <esp+2>["now_info"] <esp+1>[3]
dec CX
mov <__init___37657+2> <esp+2>["module_name"]
mov <__init___37657+3> <esp+2>["object_names"]
mov <__init___37657+4> <esp+2>["namespace"]
mov <__init___37657+5> <esp+2>["now_info"]


push <__init___37657+2>
mov <__init___37657+0>.module_name <esp+1>
inc esp
push <__init___37657+3>
mov <__init___37657+0>.object_names <esp+1>
inc esp
push <__init___37657+4>
mov <__init___37657+0>.namespace <esp+1>
inc esp
push <__init___37657+5>
mov <__init___37657+0>.now_info <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___37657+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___37657" "0,1,2,3,4,5"
pop ip
Function BX 37721 <From_Import^2> "__str___37721" 2
mov <From_Import^2>.__str__ BX
jmp 37737           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<From "
ex_func AX "str" <__str___37721+0>.module_name
oper <esp+1> "+" AX
oper <esp+1> "+" " import "
ex_func AX "str" <__str___37721+0>.object_names
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 37734         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___37721" "0,1"
pop ip
Function BX 37740 <From_Import^2> "write_37740" 14
mov <From_Import^2>.write BX
jmp 38027           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 37748 "!="
tf <esp+2> "in" "codes"
$jmp 37750 "t"
mov <esp+2>["codes"] None
jmp 37750
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_37740+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_37740+0>.module_name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.get_path
push AX
mov <write_37740+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_37740+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
push <write_37740+3>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 37779 "t"
mov AX True
jmp 37780
mov AX False
cmp AX 1
$jmp 37819 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "&tem_import_"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_37740+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_37740+4> <esp+1>
inc esp
push [dict]
mov BX <write_37740+0>.module_name
mov <esp+1>[BX] <write_37740+4>
mov <write_37740+5> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_37740+5>
mov <esp+1>[1] <write_37740+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+13>
push AX
mov <write_37740+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_37740+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+6>.write
jmp 37819        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "push $importer[\""
push <write_37740+3>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
mov DX <write_37740+0>.namespace
tf DX "equ" ""
$jmp 37838 "t"
mov AX True
jmp 37839
mov AX False
cmp AX 1
$jmp 37870 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_37740+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_37740+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_37740+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
push "<esp+1>."
mov <write_37740+7> <esp+1>
inc esp
push "<esp+2>"
mov <write_37740+8> <esp+1>
inc esp
jmp 37876        ;¸õ¦Ü©³³¡
push ""
mov <write_37740+7> <esp+1>
inc esp
push "<esp+1>"
mov <write_37740+8> <esp+1>
inc esp
ex_func AX "iter" <write_37740+0>.object_names
push AX
fetch AX <esp+1>
$jmp 37999 "f"
mov <write_37740+9> AX
push <write_37740+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 37889 "f"
mov AX True
jmp 37890
mov AX False
cmp AX 1
$jmp 37972 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <&package_6+16>.infos
push <write_37740+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <write_37740+10> <esp+1>
inc esp
mov DX <write_37740+10>
tf DX "equ" "built-in"
$jmp 37906 "f"
mov AX True
jmp 37907
mov AX False
cmp AX 1
$jmp 37919 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <&package_6+16>.module_dict
push <write_37740+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <write_37740+11> <esp+1>
inc esp
jmp 37922        ;¸õ¦Ü©³³¡
push <write_37740+10>.locals
mov <write_37740+11> <esp+1>
inc esp
ex_func AX "iter" <write_37740+11>
push AX
fetch AX <esp+1>
$jmp 37970 "f"
mov <write_37740+12> AX
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_37740+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_37740+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_37740+8>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_37740+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;import *"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_37740+12>
mov <esp+1>[1] <write_37740+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <write_37740+13> <esp+1>
inc esp
mov AX <write_37740+0>.now_info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <write_37740+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 37924
inc esp
jmp 37998        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_37740+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_37740+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_37740+8>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
push <write_37740+9>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
jmp 37878
inc esp
mov DX <write_37740+0>.namespace
tf DX "equ" ""
$jmp 38005 "t"
mov AX True
jmp 38006
mov AX False
cmp AX 1
$jmp 38016 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 2"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
jmp 38023        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_37740+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_37740" "0,1,2,3,4,5,6,7,8,9,10,11,12,13"
pop ip
mov AX <From_Import^2>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 38039 "=="
tf AX "Ctn" "__init__"
$jmp 38037 "t"
jmp 38039
call AX.__init__
mov AX <From_Import^2>
end "Function" "From_Import^2"
pop ip
Function <&package_6+13> 38044 None "Import^3" 1
name <&package_6+13> "<class '__main__.Import'>"
jmp 39271
tf $Inheritance "equ" None
$jmp 38049 "t"
mov <Import^3> $Inheritance
push 1
jmp 38051
mov <Import^3> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Import^3> <&package_6+13>
Function BX 38059 <Import^3> "__init___38059" 4
mov <Import^3>.__init__ BX
jmp 38096           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38067 "!="
tf <esp+2> "in" "package_dict"
$jmp 38069 "t"
mov <esp+2>["package_dict"] None
jmp 38069
mov <esp+2>["package_dict"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 38075 "!="
tf <esp+2> "in" "namespace"
$jmp 38077 "t"
mov <esp+2>["namespace"] None
jmp 38077
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <__init___38059+2> <esp+2>["package_dict"]
mov <__init___38059+3> <esp+2>["namespace"]


push <__init___38059+2>
mov <__init___38059+0>.package_dict <esp+1>
inc esp
push <__init___38059+3>
mov <__init___38059+0>.namespace <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___38059+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___38059" "0,1,2,3"
pop ip
Function BX 38099 <Import^3> "__str___38099" 2
mov <Import^3>.__str__ BX
jmp 38112           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Import: "
ex_func AX "str" <__str___38099+0>.package_dict
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 38109         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___38099" "0,1"
pop ip
Function BX 38115 <Import^3> "write_38115" 29
mov <Import^3>.write BX
jmp 39257           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38123 "!="
tf <esp+2> "in" "codes"
$jmp 38125 "t"
mov <esp+2>["codes"] None
jmp 38125
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_38115+2> <esp+2>["codes"]


mov DX <write_38115+0>.namespace
tf DX "equ" ""
$jmp 38133 "t"
mov AX True
jmp 38134
mov AX False
cmp AX 1
$jmp 38154 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_38115+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_38115+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38115+3> <esp+1>
inc esp
jmp 38157        ;¸õ¦Ü©³³¡
push ""
mov <write_38115+3> <esp+1>
inc esp
push <write_38115+3>
mov <write_38115+4> <esp+1>
inc esp
ex_func AX "iter" <write_38115+0>.package_dict
push AX
fetch AX <esp+1>
$jmp 39252 "f"
mov <write_38115+5> AX
push <write_38115+0>.package_dict
mov BX <write_38115+5>
pop AX
push AX[BX]
mov <write_38115+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+5>.split
push AX
mov <write_38115+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39247 "f"
mov <write_38115+8> AX
mov AX "."      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
push <write_38115+7>
push [3]
mov <esp+1>[0] None
push <write_38115+8>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38115+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.get_path
push AX
mov <write_38115+10> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_38115+11> <esp+1>
inc esp
push "&"
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "_"
ex_func AX "str" <write_38115+11>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_38115+12> <esp+1>
inc esp
push <write_38115+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 38265 "f"
mov AX True
jmp 38266
mov AX False
cmp AX 1
$jmp 38365 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " $importer[\""
push <write_38115+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
mov DX <write_38115+6>
tf DX "equ" None
$jmp 38290 "f"
mov AX True
jmp 38291
mov AX False
cmp AX 1
$jmp 38314 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38358        ;¸õ¦Ü©³³¡
push <write_38115+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38330 "f"
mov AX True
jmp 38331
mov AX False
cmp AX 1
$jmp 38351 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38115+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38358        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pass"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
push ""
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38115+3> <esp+1>
inc esp
jmp 39246        ;¸õ¦Ü©³³¡
push <write_38115+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 38373 "f"
mov AX True
jmp 38374
mov AX False
cmp AX 1
$jmp 38514 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&package_6+16>.loaded      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_38115+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "module "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_38115+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $importer[\""
push <write_38115+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
mov DX <write_38115+6>
tf DX "equ" None
$jmp 38428 "f"
mov AX True
jmp 38429
mov AX False
cmp AX 1
$jmp 38461 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;©w¸q"
ex_func AX "str" <write_38115+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38498        ;¸õ¦Ü©³³¡
push <write_38115+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38477 "f"
mov AX True
jmp 38478
mov AX False
cmp AX 1
$jmp 38498 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38115+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38498        ;¸õ¦Ü©³³¡
push "built-in"
push <&package_6+16>.infos
push <write_38115+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push ""
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38115+3> <esp+1>
inc esp
jmp 39246        ;¸õ¦Ü©³³¡
push <write_38115+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 38522 "f"
mov AX True
jmp 38523
mov AX False
cmp AX 1
$jmp 39246 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&package_6+16>.loaded      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_38115+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $importer[\""
push <write_38115+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
mov DX <write_38115+6>
tf DX "equ" None
$jmp 38567 "f"
mov AX True
jmp 38568
mov AX False
cmp AX 1
$jmp 38600 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;©w¸q"
ex_func AX "str" <write_38115+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38115+7>
mov BX <write_38115+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38644        ;¸õ¦Ü©³³¡
push <write_38115+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38616 "f"
mov AX True
jmp 38617
mov AX False
cmp AX 1
$jmp 38637 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38115+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38115+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
jmp 38644        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pass"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.append
push 1        ;Àx¦sCX
push [1]
push <write_38115+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.add_newtab
push 2        ;Àx¦sCX
push [2]
push <write_38115+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] <&package_6+16>.encoding
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38115+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov <write_38115+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <write_38115+15> <esp+1>
inc esp
ex_func AX "iter" <write_38115+15>.codelines
push AX
fetch AX <esp+1>
$jmp 38712 "f"
mov <write_38115+16> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+16>.write
jmp 38701
inc esp
push <write_38115+15>
push <&package_6+16>.infos
push <write_38115+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+2>.del_newtab
push [dict]
mov <write_38115+17> <esp+1>
inc esp
push [0]
mov <write_38115+18> <esp+1>
inc esp
push 0
mov <write_38115+19> <esp+1>
inc esp
ex_func AX "iter" <write_38115+15>.locals
push AX
fetch AX <esp+1>
$jmp 38771 "f"
mov <write_38115+20> AX
tf <write_38115+18> "in" <write_38115+20>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 38770 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+18>.append
push "<"
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
ex_func AX "str" <write_38115+19>
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
push <write_38115+17>
mov BX <write_38115+20>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_38115+19> "+" <esp+1>
inc esp
jmp 38770        ;¸õ¦Ü©³³¡
jmp 38739
inc esp
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38115+21> <esp+1>
inc esp
push "namespace "
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "\" \""
ex_func AX "str" <write_38115+21>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_38115+2>
mov BX <write_38115+11>
pop AX
mov AX[BX] <esp+1>
inc esp
Function <write_38115+22> 38802 None "get_name_38802" 5 "write_38115"
jmp 38884           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38810 "!="
tf <esp+2> "in" "string"
$jmp 38812 "t"
mov <esp+2>["string"] None
jmp 38812
mov <esp+2>["string"] <esp+1>[0]
dec CX
mov <get_name_38802+1> <esp+2>["string"]


push ".[ ;"
mov <get_name_38802+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_name_38802+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <get_name_38802+3> <esp+1>[0]
mov <get_name_38802+4> <esp+1>[1]
inc esp
mov DX <get_name_38802+3>
cmp DX <get_name_38802+4>
$jmp 38836 ">="
mov AX True
jmp 38837
mov AX False
cmp AX 1
$jmp 38876 "!="
push <get_name_38802+1>
mov BX <get_name_38802+3>
pop AX
tf <get_name_38802+2> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 38872 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push <get_name_38802+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <get_name_38802+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push <get_name_38802+1>
push [3]
mov <esp+1>[0] <get_name_38802+3>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[1] AX[BX]
pop AX
jmp 38881         ;returnÂI
jmp 38872        ;¸õ¦Ü©³³¡
push 1
$mov <get_name_38802+3> "+" <esp+1>
inc esp
jmp 38831               ;continue­«¨Ó
push (2)
mov <esp+1>[0] <get_name_38802+1>
mov <esp+1>[1] ""
pop AX
jmp 38881         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_name_38802" "0,1,2,3,4"
pop ip
Function <write_38115+23> 38886 None "parse_line_38886" 7 "write_38115"
jmp 39036           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38894 "!="
tf <esp+2> "in" "line"
$jmp 38896 "t"
mov <esp+2>["line"] None
jmp 38896
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <parse_line_38886+1> <esp+2>["line"]


push [0]
mov <parse_line_38886+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_line_38886+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_line_38886+3> <esp+1>[0]
mov <parse_line_38886+4> <esp+1>[1]
inc esp
mov DX <parse_line_38886+3>
cmp DX <parse_line_38886+4>
$jmp 38920 ">="
mov AX True
jmp 38921
mov AX False
cmp AX 1
$jmp 39031 "!="
push <parse_line_38886+3>
mov <parse_line_38886+5> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_line_38886+1>
mov BX <parse_line_38886+5>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 38982 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_line_38886+1>
mov BX <parse_line_38886+5>
pop AX
push AX[BX]
mov <parse_line_38886+6> <esp+1>
inc esp
push <parse_line_38886+5>
oper <esp+1> "+" 1
mov <parse_line_38886+3> <esp+1>
inc esp
push <parse_line_38886+1>
mov BX <parse_line_38886+3>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_line_38886+6>
$jmp 38956 "t"
mov AX True
jmp 38957
mov AX False
cmp AX 1
$jmp 38978 "!="
push <parse_line_38886+1>
mov BX <parse_line_38886+3>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 38967 "f"
mov AX True
jmp 38968
mov AX False
cmp AX 1
$jmp 38974 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_line_38886+3> "+" <esp+1>
inc esp
jmp 38974        ;¸õ¦Ü©³³¡
push 1
$mov <parse_line_38886+3> "+" <esp+1>
inc esp
jmp 38948               ;continue­«¨Ó
push 1
$mov <parse_line_38886+3> "+" <esp+1>
inc esp
jmp 38982        ;¸õ¦Ü©³³¡
mov DX <parse_line_38886+3>
cmp DX <parse_line_38886+4>
$jmp 38987 ">="
mov AX True
jmp 38988
mov AX False
cmp AX 1
$jmp 39003 "!="
push <parse_line_38886+1>
mov BX <parse_line_38886+3>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 38998 "t"
mov AX True
jmp 38999
mov AX False
cmp AX 1
$jmp 39003 "!="
mov AX 1
jmp 39004
mov AX 0
cmp AX 1
$jmp 39010 "!="
push 1
$mov <parse_line_38886+3> "+" <esp+1>
inc esp
jmp 38982               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push <parse_line_38886+1>
push [3]
mov <esp+1>[0] <parse_line_38886+5>
mov <esp+1>[1] <parse_line_38886+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_line_38886+2>.append
push 1
$mov <parse_line_38886+3> "+" <esp+1>
inc esp
jmp 38915               ;continue­«¨Ó
mov AX <parse_line_38886+2>
jmp 39033         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_line_38886" "0,1,2,3,4,5,6"
pop ip
push 3
$mov <write_38115+11> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_38115+11>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39238 "f"
mov <write_38115+24> AX
push <write_38115+2>
push <write_38115+11>
oper <esp+1> "+" <write_38115+24>
pop BX
pop AX
push AX[BX]
mov <write_38115+25> <esp+1>
inc esp
tf <write_38115+25> "in" "\""
mov AX TF
cmp AX 1
$jmp 39078 "=="
tf <write_38115+25> "in" "'"
mov AX TF
cmp AX 1
$jmp 39078 "=="
mov AX 0
jmp 39079
mov AX 1
cmp AX 1
$jmp 39092 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+25>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+23>
push AX
mov <write_38115+26> <esp+1>
inc esp
jmp 39110        ;¸õ¦Ü©³³¡
push <write_38115+2>
push <write_38115+11>
oper <esp+1> "+" <write_38115+24>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38115+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39218 "f"
mov <write_38115+27> AX
mov DX <write_38115+27>
tf DX "equ" 0
$jmp 39134 "f"
mov AX True
jmp 39135
mov AX False
cmp AX 1
$jmp 39150 "=="
push <write_38115+26>
mov BX <write_38115+27>
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 39145 "f"
mov AX True
jmp 39146
mov AX False
cmp AX 1
$jmp 39150 "=="
mov AX 0
jmp 39151
mov AX 1
cmp AX 1
$jmp 39155 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39126
jmp 39155        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_38115+26>
mov BX <write_38115+27>
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 39172 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39126
jmp 39172        ;¸õ¦Ü©³³¡
push <write_38115+26>
mov BX <write_38115+27>
pop AX
push AX[BX]
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ";"
$jmp 39183 "f"
mov AX True
jmp 39184
mov AX False
cmp AX 1
$jmp 39188 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39218          ;break¥X°j°é
jmp 39188        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <write_38115+26>
mov BX <write_38115+27>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38115+22>
push AX
mov <write_38115+20> <esp+1>[0]
mov <write_38115+28> <esp+1>[1]
inc esp
tf <write_38115+17> "in" <write_38115+20>
mov AX TF
cmp AX 1
$jmp 39217 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_38115+17>
mov BX <write_38115+20>
pop AX
push AX[BX]
oper <esp+1> "+" <write_38115+28>
push <write_38115+26>
mov BX <write_38115+27>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39217        ;¸õ¦Ü©³³¡
jmp 39126
inc esp
mov AX " "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38115+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <write_38115+2>
push <write_38115+11>
oper <esp+1> "+" <write_38115+24>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39057
inc esp
push ""
ex_func AX "str" <write_38115+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38115+3> <esp+1>
inc esp
jmp 39246        ;¸õ¦Ü©³³¡
jmp 38197
inc esp
push <write_38115+4>
mov <write_38115+3> <esp+1>
inc esp
jmp 38162
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_38115" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,24,25,26,27,28"
pop ip
mov AX <Import^3>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 39269 "=="
tf AX "Ctn" "__init__"
$jmp 39267 "t"
jmp 39269
call AX.__init__
mov AX <Import^3>
end "Function" "Import^3"
pop ip
Function <&package_6+14> 39273 None "Read_ex_func_39273" 9
jmp 39701           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


Function <Read_ex_func_39273+1> 39279 None "deal_line_39279" 8 "Read_ex_func_39273"
jmp 39513           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39287 "!="
tf <esp+2> "in" "line"
$jmp 39289 "t"
mov <esp+2>["line"] None
jmp 39289
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <deal_line_39279+1> <esp+2>["line"]


push [dict]
mov <deal_line_39279+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_line_39279+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <deal_line_39279+3> <esp+1>
inc esp
push 0
mov <deal_line_39279+4> <esp+1>
inc esp
mov DX <deal_line_39279+4>
cmp DX <deal_line_39279+3>
$jmp 39313 ">="
mov AX True
jmp 39314
mov AX False
cmp AX 1
$jmp 39508 "!="
mov DX <deal_line_39279+4>
cmp DX <deal_line_39279+3>
$jmp 39321 ">="
mov AX True
jmp 39322
mov AX False
cmp AX 1
$jmp 39333 "!="
push <deal_line_39279+1>
mov BX <deal_line_39279+4>
pop AX
tf ", " "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 39333 "!="
mov AX 1
jmp 39334
mov AX 0
cmp AX 1
$jmp 39340 "!="
push 1
$mov <deal_line_39279+4> "+" <esp+1>
inc esp
jmp 39316               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <deal_line_39279+1>
mov <esp+1>[1] <deal_line_39279+4>
mov <esp+1>[2] "( ,"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <deal_line_39279+5> <esp+1>
inc esp
push <deal_line_39279+1>
push [3]
mov <esp+1>[0] <deal_line_39279+4>
mov <esp+1>[1] <deal_line_39279+5>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <deal_line_39279+6> <esp+1>
inc esp
mov DX <deal_line_39279+5>
cmp DX <deal_line_39279+3>
$jmp 39373 ">="
mov AX True
jmp 39374
mov AX False
cmp AX 1
$jmp 39389 "!="
push <deal_line_39279+1>
mov BX <deal_line_39279+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 39384 "f"
mov AX True
jmp 39385
mov AX False
cmp AX 1
$jmp 39389 "!="
mov AX 1
jmp 39390
mov AX 0
cmp AX 1
$jmp 39396 "!="
push 1
$mov <deal_line_39279+5> "+" <esp+1>
inc esp
jmp 39368               ;continue­«¨Ó
mov DX <deal_line_39279+5>
cmp DX <deal_line_39279+3>
$jmp 39401 ">="
mov AX True
jmp 39402
mov AX False
cmp AX 1
$jmp 39417 "!="
push <deal_line_39279+1>
mov BX <deal_line_39279+5>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 39412 "f"
mov AX True
jmp 39413
mov AX False
cmp AX 1
$jmp 39417 "!="
mov AX 1
jmp 39418
mov AX 0
cmp AX 1
$jmp 39464 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <deal_line_39279+1>
push <deal_line_39279+5>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <deal_line_39279+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <deal_line_39279+1>
push [3]
push <deal_line_39279+5>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <deal_line_39279+7>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <Read_ex_func_39273+1>
push AX
push <deal_line_39279+2>
mov BX <deal_line_39279+6>
pop AX
mov AX[BX] <esp+1>
inc esp
push <deal_line_39279+7>
oper <esp+1> "+" 1
mov <deal_line_39279+4> <esp+1>
inc esp
jmp 39507        ;¸õ¦Ü©³³¡
mov DX <deal_line_39279+5>
cmp DX <deal_line_39279+3>
$jmp 39469 "<"
mov AX True
jmp 39470
mov AX False
cmp AX 1
$jmp 39485 "=="
push <deal_line_39279+1>
mov BX <deal_line_39279+5>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 39480 "f"
mov AX True
jmp 39481
mov AX False
cmp AX 1
$jmp 39485 "=="
mov AX 0
jmp 39486
mov AX 1
cmp AX 1
$jmp 39499 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
push <deal_line_39279+2>
mov BX <deal_line_39279+6>
pop AX
mov AX[BX] <esp+1>
inc esp
push <deal_line_39279+5>
oper <esp+1> "+" 1
mov <deal_line_39279+4> <esp+1>
inc esp
jmp 39507        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "unknow"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 39308               ;continue­«¨Ó
mov AX <deal_line_39279+2>
jmp 39510         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_line_39279" "0,1,2,3,4,5,6,7"
pop ip
push [dict]
mov <Read_ex_func_39273+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+1>
push AX
oper <esp+1> "+" "\\apython\\ex_func.py"
pop <esp+1>[0]
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] "utf-8"
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <Read_ex_func_39273+3> <esp+1>
inc esp
ex_func AX "iter" <Read_ex_func_39273+3>
push AX
fetch AX <esp+1>
$jmp 39695 "f"
mov <Read_ex_func_39273+4> AX
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39273+4>
mov <esp+1>[1] 0
mov <esp+1>[2] " #"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39273+5> <esp+1>
inc esp
push <Read_ex_func_39273+5>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <Read_ex_func_39273+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 39588 ">="
mov AX True
jmp 39589
mov AX False
cmp AX 1
$jmp 39604 "!="
push <Read_ex_func_39273+4>
mov BX <Read_ex_func_39273+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 39599 "f"
mov AX True
jmp 39600
mov AX False
cmp AX 1
$jmp 39604 "!="
mov AX 1
jmp 39605
mov AX 0
cmp AX 1
$jmp 39694 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39273+4>
push <Read_ex_func_39273+5>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] " #"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39273+6> <esp+1>
inc esp
push <Read_ex_func_39273+4>
push [3]
push <Read_ex_func_39273+5>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <Read_ex_func_39273+6>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <Read_ex_func_39273+7> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39273+4>
push <Read_ex_func_39273+6>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "#"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39273+8> <esp+1>
inc esp
mov DX <Read_ex_func_39273+8>
cmp DX <Read_ex_func_39273+6>
$jmp 39658 "<="
mov AX True
jmp 39659
mov AX False
cmp AX 1
$jmp 39687 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <Read_ex_func_39273+4>
push [3]
push <Read_ex_func_39273+8>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <Read_ex_func_39273+1>
push AX
push <Read_ex_func_39273+2>
mov BX <Read_ex_func_39273+7>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39693        ;¸õ¦Ü©³³¡
push [dict]
push <Read_ex_func_39273+2>
mov BX <Read_ex_func_39273+7>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39694        ;¸õ¦Ü©³³¡
jmp 39557
inc esp
mov AX <Read_ex_func_39273+2>
jmp 39698         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "Read_ex_func_39273" "0,2,3,4,5,6,7,8"
pop ip
Function <&package_6+15> 39704 None "Importer^4" 1
name <&package_6+15> "<class '__main__.Importer'>"
jmp 40235
tf $Inheritance "equ" None
$jmp 39709 "t"
mov <Importer^4> $Inheritance
push 1
jmp 39711
mov <Importer^4> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Importer^4> <&package_6+15>
Function BX 39719 <Importer^4> "__init___39719" 2
mov <Importer^4>.__init__ BX
jmp 39742           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+14>
push AX
mov <__init___39719+0>.module_dict <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___39719+0>.reset
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___39719" "0,1"
pop ip
Function BX 39745 <Importer^4> "__get_module_39745" 5
mov <Importer^4>.__get_module BX
jmp 40018           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39753 "!="
tf <esp+2> "in" "module_name"
$jmp 39755 "t"
mov <esp+2>["module_name"] None
jmp 39755
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <__get_module_39745+2> <esp+2>["module_name"]


Function <__get_module_39745+3> 39760 None "get_module_39760" 6 "__get_module_39745"
jmp 39996           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39768 "!="
tf <esp+2> "in" "nowfolder"
$jmp 39770 "t"
mov <esp+2>["nowfolder"] None
jmp 39770
mov <esp+2>["nowfolder"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 39776 "!="
tf <esp+2> "in" "k"
$jmp 39778 "t"
mov <esp+2>["k"] None
jmp 39778
mov <esp+2>["k"] <esp+1>[1]
dec CX
mov <get_module_39760+1> <esp+2>["nowfolder"]
mov <get_module_39760+2> <esp+2>["k"]


push <get_module_39760+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__get_module_39745+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 39798 "f"
mov AX True
jmp 39799
mov AX False
cmp AX 1
$jmp 39972 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push ""
mov <get_module_39760+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_39760+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+0>
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39968 "f"
mov <get_module_39760+4> AX
push ""
ex_func AX "str" <get_module_39760+1>
oper <esp+1> "+" AX
oper <esp+1> "+" "/"
ex_func AX "str" <get_module_39760+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
push AX.replace
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <get_module_39760+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_39760+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+4>
cmp AX 1
$jmp 39868 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_module_39760+4>.split
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "py"
$jmp 39863 "f"
mov AX True
jmp 39864
mov AX False
cmp AX 1
$jmp 39868 "!="
mov AX 1
jmp 39869
mov AX 0
cmp AX 1
$jmp 39881 "!="
mov DX <get_module_39760+3>
tf DX "equ" ""
$jmp 39876 "f"
mov AX True
jmp 39877
mov AX False
cmp AX 1
$jmp 39881 "!="
mov AX 1
jmp 39882
mov AX 0
cmp AX 1
$jmp 39910 "!="
push <get_module_39760+4>
push [3]
mov <esp+1>[0] None
mov AX 3
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <__get_module_39745+4>
mov BX <get_module_39760+2>
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 39905 "f"
mov AX True
jmp 39906
mov AX False
cmp AX 1
$jmp 39910 "!="
mov AX 1
jmp 39911
mov AX 0
cmp AX 1
$jmp 39917 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_module_39760+5>
mov <get_module_39760+3> <esp+1>
inc esp
jmp 39967        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_39760+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+3>
cmp AX 1
$jmp 39942 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_39760+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+0>
push AX
mov BX "__init__.py"
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 39942 "!="
mov AX 1
jmp 39943
mov AX 0
cmp AX 1
$jmp 39959 "!="
push <get_module_39760+4>
push <__get_module_39745+4>
mov BX <get_module_39760+2>
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 39954 "f"
mov AX True
jmp 39955
mov AX False
cmp AX 1
$jmp 39959 "!="
mov AX 1
jmp 39960
mov AX 0
cmp AX 1
$jmp 39967 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_module_39760+5>
oper <esp+1> "+" "/__init__.py"
mov <get_module_39760+3> <esp+1>
inc esp
jmp 39967        ;¸õ¦Ü©³³¡
jmp 39813
inc esp
mov AX <get_module_39760+3>
jmp 39993         ;returnÂI
jmp 39972        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push ""
ex_func AX "str" <get_module_39760+1>
oper <esp+1> "+" AX
oper <esp+1> "+" "\\"
push <__get_module_39745+4>
mov BX <get_module_39760+2>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
push <get_module_39760+2>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_39745+3>
jmp 39993         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_module_39760" "0,1,2,3,4,5"
pop ip
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_39745+2>.split
push AX
mov <__get_module_39745+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__get_module_39745+0>.work_folder
mov <esp+1>[1] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_39745+3>
jmp 40015         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__get_module_39745" "0,1,2"
pop ip
Function BX 40021 <Importer^4> "get_path_40021" 4
mov <Importer^4>.get_path BX
jmp 40108           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40029 "!="
tf <esp+2> "in" "module_name"
$jmp 40031 "t"
mov <esp+2>["module_name"] None
jmp 40031
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <get_path_40021+2> <esp+2>["module_name"]


tf <get_path_40021+0>.module_dict "in" <get_path_40021+2>
mov AX TF
cmp AX 1
$jmp 40062 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <get_path_40021+0>.loaded "in" <get_path_40021+2>
mov AX TF
cmp AX 1
$jmp 40052 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
push ""
ex_func AX "str" <get_path_40021+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 0
pop AX
jmp 40105         ;returnÂI
jmp 40052        ;¸õ¦Ü©³³¡
push [2]
push ""
ex_func AX "str" <get_path_40021+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 2
pop AX
jmp 40105         ;returnÂI
jmp 40105        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_path_40021+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_path_40021+0>.__get_module
push AX
mov <get_path_40021+3> <esp+1>
inc esp
tf <get_path_40021+0>.loaded "in" <get_path_40021+3>
mov AX TF
cmp AX 1
$jmp 40082 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
mov <esp+1>[0] <get_path_40021+3>
mov <esp+1>[1] 0
pop AX
jmp 40105         ;returnÂI
jmp 40082        ;¸õ¦Ü©³³¡
mov DX <get_path_40021+3>
tf DX "equ" ""
$jmp 40087 "f"
mov AX True
jmp 40088
mov AX False
cmp AX 1
$jmp 40100 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
push ""
ex_func AX "str" <get_path_40021+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 2
pop AX
jmp 40105         ;returnÂI
jmp 40100        ;¸õ¦Ü©³³¡
push [2]
mov <esp+1>[0] <get_path_40021+3>
mov <esp+1>[1] 1
pop AX
jmp 40105         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_path_40021" "0,1,2,3"
pop ip
Function BX 40111 <Importer^4> "reset_40111" 5
mov <Importer^4>.reset BX
jmp 40221           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40119 "!="
tf <esp+2> "in" "pyfile"
$jmp 40121 "t"
mov <esp+2>["pyfile"] ""
jmp 40121
mov <esp+2>["pyfile"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 40127 "!="
tf <esp+2> "in" "encoding"
$jmp 40129 "t"
mov <esp+2>["encoding"] "cp950"
jmp 40129
mov <esp+2>["encoding"] <esp+1>[1]
dec CX
mov <reset_40111+2> <esp+2>["pyfile"]
mov <reset_40111+3> <esp+2>["encoding"]


push 0
mov <reset_40111+0>.need_load <esp+1>
inc esp
push <reset_40111+3>
mov <reset_40111+0>.encoding <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <reset_40111+2>.replace
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <reset_40111+4> <esp+1>
inc esp
mov DX <reset_40111+2>
tf DX "equ" <reset_40111+4>
$jmp 40169 "f"
mov AX True
jmp 40170
mov AX False
cmp AX 1
$jmp 40182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+1>
push AX
mov <reset_40111+0>.work_folder <esp+1>
inc esp
jmp 40205        ;¸õ¦Ü©³³¡
push <reset_40111+2>
push [3]
mov <esp+1>[0] None
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <reset_40111+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
$oper AX "-"
push AX
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <reset_40111+0>.work_folder <esp+1>
inc esp
push <reset_40111+2>
mov <reset_40111+0>.nowpath <esp+1>
inc esp
push [0]
mov <reset_40111+0>.loaded <esp+1>
inc esp
push [dict]
mov <reset_40111+0>.infos <esp+1>
inc esp
push 0
mov <reset_40111+0>.class_n <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "reset_40111" "0,1,2,3,4"
pop ip
mov AX <Importer^4>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 40233 "=="
tf AX "Ctn" "__init__"
$jmp 40231 "t"
jmp 40233
call AX.__init__
mov AX <Importer^4>
end "Function" "Importer^4"
pop ip
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+15>
push AX
mov <&package_6+16> <esp+1>
inc esp
Function <&package_6+17> 40247 None "Packager^5" 1
name <&package_6+17> "<class '__main__.Packager'>"
jmp 40598
tf $Inheritance "equ" None
$jmp 40252 "t"
mov <Packager^5> $Inheritance
push 1
jmp 40254
mov <Packager^5> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Packager^5> <&package_6+17>
Function BX 40262 <Packager^5> "__init___40262" 3
mov <Packager^5>.__init__ BX
jmp 40291           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40270 "!="
tf <esp+2> "in" "encoding"
$jmp 40272 "t"
mov <esp+2>["encoding"] "cp950"
jmp 40272
mov <esp+2>["encoding"] <esp+1>[0]
dec CX
mov <__init___40262+2> <esp+2>["encoding"]


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+5>
push AX
mov <__init___40262+0>.code <esp+1>
inc esp
push <__init___40262+2>
mov <__init___40262+0>.encoding <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___40262" "0,1,2"
pop ip
Function BX 40294 <Packager^5> "load_40294" 9
mov <Packager^5>.load BX
jmp 40534           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40302 "!="
tf <esp+2> "in" "filepath"
$jmp 40304 "t"
mov <esp+2>["filepath"] None
jmp 40304
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <load_40294+2> <esp+2>["filepath"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40294+2>.split
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <load_40294+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40294+2>.replace
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <load_40294+4> <esp+1>
inc esp
push <load_40294+2>
push [3]
mov <esp+1>[0] None
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <load_40294+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 40380 "<="
mov AX True
jmp 40381
mov AX False
cmp AX 1
$jmp 40394 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+2>
push <load_40294+4>
mov <load_40294+2> <esp+1>
inc esp
jmp 40394        ;¸õ¦Ü©³³¡
mov DX "ec"
tf DX "equ" <load_40294+3>
$jmp 40399 "f"
mov AX True
jmp 40400
mov AX False
cmp AX 1
$jmp 40433 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40294+2>
mov <esp+1>[1] "r"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <load_40294+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40294+6>.split
push AX
mov AX <load_40294+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.code <esp+1>
inc esp
jmp 40530        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40294+2>
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] <load_40294+0>.encoding
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <load_40294+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov <load_40294+7> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40294+2>
mov <esp+1>[1] <load_40294+0>.encoding
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.reset
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <load_40294+0>.info <esp+1>
inc esp
cmp <&package_6+16>.need_load 1
$jmp 40496 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <load_40294+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $importer [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 40496        ;¸õ¦Ü©³³¡
mov AX <load_40294+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.add_newtab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <load_40294+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "iter" AX.codelines
push AX
fetch AX <esp+1>
$jmp 40520 "f"
mov <load_40294+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40294+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40294+8>.write
jmp 40509
inc esp
mov AX <load_40294+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.del_newtab
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "load_40294" "0,1,2,3,4,5,6,7,8"
pop ip
Function BX 40537 <Packager^5> "__load_easy_code_40537" 4
mov <Packager^5>.__load_easy_code BX
jmp 40584           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40545 "!="
tf <esp+2> "in" "ec_file"
$jmp 40547 "t"
mov <esp+2>["ec_file"] None
jmp 40547
mov <esp+2>["ec_file"] <esp+1>[0]
dec CX
mov <__load_easy_code_40537+2> <esp+2>["ec_file"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__load_easy_code_40537+2>
mov <esp+1>[1] "r"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__load_easy_code_40537+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__load_easy_code_40537+3>.split
push AX
mov AX <__load_easy_code_40537+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.code <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__load_easy_code_40537" "0,1,2,3"
pop ip
mov AX <Packager^5>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 40596 "=="
tf AX "Ctn" "__init__"
$jmp 40594 "t"
jmp 40596
call AX.__init__
mov AX <Packager^5>
end "Function" "Packager^5"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/package.py"]
mov <&apython_1+0> <esp+1>.Packager
inc esp
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"]
mov <&apython_1+1> <esp+1>.Executer
inc esp
Function <&apython_1+2> 40607 None "Apython^1" 1
name <&apython_1+2> "<class '__main__.Apython'>"
jmp 40819
tf $Inheritance "equ" None
$jmp 40612 "t"
mov <Apython^1> $Inheritance
push 1
jmp 40614
mov <Apython^1> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Apython^1> <&apython_1+2>
Function BX 40622 <Apython^1> "__init___40622" 3
mov <Apython^1>.__init__ BX
jmp 40663           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40630 "!="
tf <esp+2> "in" "encoding"
$jmp 40632 "t"
mov <esp+2>["encoding"] "utf-8"
jmp 40632
mov <esp+2>["encoding"] <esp+1>[0]
dec CX
mov <__init___40622+2> <esp+2>["encoding"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___40622+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&apython_1+0>
push AX
mov <__init___40622+0>.packager <esp+1>
inc esp
mov AX <__init___40622+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov <__init___40622+0>.code <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___40622+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&apython_1+1>
push AX
mov <__init___40622+0>.executer <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___40622" "0,1,2"
pop ip
Function BX 40666 <Apython^1> "parse_40666" 3
mov <Apython^1>.parse BX
jmp 40684           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX <parse_40666+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov <parse_40666+2> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_40666+2>.display
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_40666" "0,1,2"
pop ip
Function BX 40687 <Apython^1> "save_40687" 4
mov <Apython^1>.save BX
jmp 40735           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40695 "!="
tf <esp+2> "in" "filepath"
$jmp 40697 "t"
mov <esp+2>["filepath"] None
jmp 40697
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <save_40687+2> <esp+2>["filepath"]


mov AX "\n"      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov AX <save_40687+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <save_40687+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <save_40687+2>
mov <esp+1>[1] "w"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_40687+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "save_40687" "0,1,2,3"
pop ip
Function BX 40738 <Apython^1> "load_40738" 3
mov <Apython^1>.load BX
jmp 40765           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40746 "!="
tf <esp+2> "in" "filepath"
$jmp 40748 "t"
mov <esp+2>["filepath"] None
jmp 40748
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <load_40738+2> <esp+2>["filepath"]


mov AX <load_40738+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.load
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40738+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "load_40738" "0,1,2"
pop ip
Function BX 40768 <Apython^1> "run_40768" 4
mov <Apython^1>.run BX
jmp 40805           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40776 "!="
tf <esp+2> "in" "tf"
$jmp 40778 "t"
mov <esp+2>["tf"] 0
jmp 40778
mov <esp+2>["tf"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 40784 "!="
tf <esp+2> "in" "stack_size"
$jmp 40786 "t"
mov <esp+2>["stack_size"] 1024
jmp 40786
mov <esp+2>["stack_size"] <esp+1>[1]
dec CX
mov <run_40768+2> <esp+2>["tf"]
mov <run_40768+3> <esp+2>["stack_size"]


mov AX <run_40768+0>.executer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.run
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <run_40768+2>
mov <esp+1>[1] <run_40768+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "run_40768" "0,1,2,3"
pop ip
mov AX <Apython^1>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 40817 "=="
tf AX "Ctn" "__init__"
$jmp 40815 "t"
jmp 40817
call AX.__init__
mov AX <Apython^1>
end "Function" "Apython^1"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
mov Apython <esp+1>.Apython
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Apython
push AX
mov p <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "test.py"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call p.load
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call p.parse
push 0        ;Àx¦sCX
push [0]
push [dict]
mov BX "tf"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call p.run398085*07*backup3372846*07*apython14320*111*built_in.py#encoding='utf-8'
from apython.ex_func import *
class bcolors:
    OK = "[92m"  # GREEN
    WARNING = "[93m"  # YELLOW
    FAIL = "[91m"  # RED
    RESET = "[0m"  # RESET COLOR
def built_in_operator(obj,op):
    stype = str(type(obj))
    if stype=="<class 'str'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='format':return obj.format
        elif op=='encode':return obj.encode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='casefold':return obj.casefold
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='format_map':return obj.format_map
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdecimal':return obj.isdecimal
        elif op=='isdigit':return obj.isdigit
        elif op=='isidentifier':return obj.isidentifier
        elif op=='islower':return obj.islower
        elif op=='isnumeric':return obj.isnumeric
        elif op=='isprintable':return obj.isprintable
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'list'>":
        if op=='append':return obj.append
        elif op=='pop':return obj.pop
        elif op=='count':return obj.count
        elif op=='remove':return obj.remove
        elif op=='insert':return obj.insert
        elif op=='clear':return obj.clear
        elif op=='copy':return obj.copy
        elif op=='index':return obj.index
        elif op=='extend':return obj.extend
        elif op=='reverse':return obj.reverse
        elif op=='sort':return obj.sort
    elif stype=="<class 'tuple'>":
        if op=='index':return obj.index
        elif op=='count':return obj.count
    elif stype=="<class 'dict'>":
        if op=='pop':return obj.pop
        elif op=='get':return obj.get
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='keys':return obj.keys
        elif op=='fromkeys':return obj.fromkeys
        elif op=='items':return obj.items
        elif op=='popitem':return obj.popitem
        elif op=='setdefault':return obj.setdefault
        elif op=='values':return obj.values
    elif stype=="<class 'bytes'>":
        if op=='join':return obj.join
        elif op=='count':return obj.count
        elif op=='split':return obj.split
        elif op=='index':return obj.index
        elif op=='decode':return obj.decode
        elif op=='replace':return obj.replace
        elif op=='capitalize':return obj.capitalize
        elif op=='center':return obj.center
        elif op=='endswith':return obj.endswith
        elif op=='expandtabs':return obj.expandtabs
        elif op=='find':return obj.find
        elif op=='isalnum':return obj.isalnum
        elif op=='isalpha':return obj.isalpha
        elif op=='isascii':return obj.isascii
        elif op=='isdigit':return obj.isdigit
        elif op=='islower':return obj.islower
        elif op=='isspace':return obj.isspace
        elif op=='istitle':return obj.istitle
        elif op=='isupper':return obj.isupper
        elif op=='ljust':return obj.ljust
        elif op=='lower':return obj.lower
        elif op=='lstrip':return obj.lstrip
        elif op=='maketrans':return obj.maketrans
        elif op=='partition':return obj.partition
        elif op=='rfind':return obj.rfind
        elif op=='rindex':return obj.rindex
        elif op=='rjust':return obj.rjust
        elif op=='rpartition':return obj.rpartition
        elif op=='rsplit':return obj.rsplit
        elif op=='rstrip':return obj.rstrip
        elif op=='splitlines':return obj.splitlines
        elif op=='startswith':return obj.startswith
        elif op=='strip':return obj.strip
        elif op=='swapcase':return obj.swapcase
        elif op=='title':return obj.title
        elif op=='translate':return obj.translate
        elif op=='upper':return obj.upper
        elif op=='zfill':return obj.zfill
    elif stype=="<class 'set'>":
        if op=='pop':return obj.pop
        elif op=='add':return obj.add
        elif op=='remove':return obj.remove
        elif op=='copy':return obj.copy
        elif op=='clear':return obj.clear
        elif op=='update':return obj.update
        elif op=='difference':return obj.difference
        elif op=='difference_update':return obj.difference_update
        elif op=='discard':return obj.discard
        elif op=='intersection':return obj.intersection
        elif op=='intersection_update':return obj.intersection_update
        elif op=='isdisjoint':return obj.isdisjoint
        elif op=='issubset':return obj.issubset
        elif op=='issuperset':return obj.issuperset
        elif op=='symmetric_difference':return obj.symmetric_difference
        elif op=='symmetric_difference_update':return obj.symmetric_difference_update
        elif op=='union':return obj.union
    elif stype=="<class '_io.TextIOWrapper'>":
        if op=='write':return obj.write
        elif op=='tell':return obj.tell
        elif op=='read':return obj.read
        elif op=='close':return obj.close
        elif op=='seek':return obj.seek
        elif op=='fileno':return obj.fileno
        elif op=='flush':return obj.flush
        elif op=='isatty':return obj.isatty
        elif op=='readable':return obj.readable
        elif op=='readline':return obj.readline
        elif op=='readlines':return obj.readlines
        elif op=='seekable':return obj.seekable
        elif op=='truncate':return obj.truncate
        elif op=='writable':return obj.writable
        elif op=='writelines':return obj.writelines
        elif op=='__enter__':return obj.__enter__
        elif op=='__exit__':return obj.__exit__
    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>
        module_name=obj.module_name
        if module_name=="time":
            if op=='time':return time.time
            elif op=='sleep':return time.sleep
            elif op=='ctime':return time.ctime
            elif op=='localtime':return time.localtime
            elif op=='gmtime':return time.gmtime
            elif op=='mktime':return time.mktime
            elif op=='asctime':return time.asctime
            elif op=='strftime':return time.strftime
            elif op=='strptime':return time.strptime
        elif module_name=="math":
            if op=='pi':return math.pi
            elif op=='e':return math.e
            elif op=='ceil':return math.ceil
            elif op=='floor':return math.floor
            elif op=='copysign':return math.copysign
            elif op=='fabs':return math.fabs
            elif op=='fmod':return math.fmod
            elif op=='fsum':return math.fsum
            elif op=='gcd':return math.gcd
            elif op=='pow':return math.pow
            elif op=='sqrt':return math.sqrt
            elif op=='factorial':return math.factorial
            elif op=='degrees':return math.degrees
            elif op=='radians':return math.radians
            elif op=='sin':return math.sin
            elif op=='cos':return math.cos
            elif op=='tan':return math.tan
            elif op=='asin':return math.asin
            elif op=='acos':return math.acos
            elif op=='atan':return math.atan
            elif op=='exp':return math.exp
            elif op=='log':return math.log
            elif op=='log1p':return math.log1p
            elif op=='log2':return math.log2
            elif op=='log10':return math.log10
            elif op=='isclose':return math.isclose
            elif op=='isfinite':return math.isfinite
            elif op=='isinf':return math.isinf
            elif op=='isnan':return math.isnan
        elif module_name=="os":
            if op=='getcwd':return os.getcwd
            elif op=='listdir':return os.listdir
            elif op=='mkdir':return os.mkdir
            elif op=='chdir':return os.chdir
            elif op=='rmdir':return os.rmdir
            elif op=='open':return os.open
            elif op=='write':return os.write
            elif op=='rename':return os.rename
            elif op=='remove':return os.remove
            elif op=='stat':return os.stat
            elif op=='close':return os.close
            elif op=='path':return os.path
            elif op=='system':return os.system
            elif op=='walk':return os.walk
            elif op=='environ':return os.environ
            elif op=='_exit':return os._exit
        elif module_name=="os.path":
            if op=='isdir':return os.path.isdir
            elif op=='isfile':return os.path.isfile
            elif op=='abspath':return os.path.abspath
            elif op=='basename':return os.path.basename
            elif op=='dirname':return os.path.dirname
            elif op=='exists':return os.path.exists
            elif op=='getatime':return os.path.getatime
            elif op=='getmtime':return os.path.getmtime
            elif op=='getctime':return os.path.getctime
            elif op=='getsize':return os.path.getsize
            elif op=='isabs':return os.path.isabs
            elif op=='join':return os.path.join
            elif op=='realpath':return os.path.realpath
            elif op=='relpath':return os.path.relpath
            elif op=='samefile':return os.path.samefile
            elif op=='sameopenfile':return os.path.sameopenfile
            elif op=='samestat':return os.path.samestat
            elif op=='split':return os.path.split
            elif op=='splitext':return os.path.splitext
        elif module_name=="sys":
            if op=='argv':return sys.argv
            elif op=='platform':return sys.platform
            elif op=='version_info':return sys.version_info
            elif op=='path':return sys.path
            elif op=='stdin':return sys.stdin
            elif op=='stdout':return sys.stdout
            elif op=='stderr':return sys.stderr
            elif op=='displayhook':return sys.displayhook
            elif op=='exceptionhook':return sys.exceptionhook
            elif op=='setrecursionlimit':return sys.setrecursionlimit
            elif op=='setswitchinterval':return sys.setswitchinterval
            elif op=='settrace':return sys.settrace
            elif op=='setprofile':return sys.setprofile
        elif module_name=="random":
            if op=='seed':return random.seed
            elif op=='getstate':return random.getstate
            elif op=='setstate':return random.setstate
            elif op=='getrandbits':return random.getrandbits
            elif op=='randrange':return random.randrange
            elif op=='randint':return random.randint
            elif op=='choice':return random.choice
            elif op=='choices':return random.choices
            elif op=='shuffle':return random.shuffle
            elif op=='sample':return random.sample
            elif op=='random':return random.random
            elif op=='uniform':return random.uniform
            elif op=='triangular':return random.triangular
            elif op=='betavariate':return random.betavariate
            elif op=='expovariate':return random.expovariate
            elif op=='gammavariate':return random.gammavariate
            elif op=='gauss':return random.gauss
            elif op=='lognormvariate':return random.lognormvariate
            elif op=='normalvariate':return random.normalvariate
            elif op=='vonmisesvariate':return random.vonmisesvariate
            elif op=='paretovariate':return random.paretovariate
            elif op=='weibullvariate':return random.weibullvariate
        elif module_name=="socket":
            if op=='socket':return socket.socket
            elif op=='AF_INET':return socket.AF_INET
            elif op=='SOCK_STREAM':return socket.SOCK_STREAM
            elif op=='gethostname':return socket.gethostname
            elif op=='gethostbyname':return socket.gethostbyname
            elif op=='SOL_SOCKET':return socket.SOL_SOCKET
            elif op=='SO_REUSEADDR':return socket.SO_REUSEADDR
    obj_name=obj.__name__
    if op=="__name__":return obj_name
    if obj_name=="localtime":
        if op=='tm_year':return obj.tm_year
        elif op=='tm_mon':return obj.tm_mon
        elif op=='tm_mday':return obj.tm_mday
        elif op=='tm_hour':return obj.tm_hour
        elif op=='tm_min':return obj.tm_min
        elif op=='tm_sec':return obj.tm_sec
        elif op=='tm_wday':return obj.tm_wday
    elif obj_name=="socket":
        if op=='bind':return obj.bind
        elif op=='listen':return obj.listen
        elif op=='accept':return obj.accept
        elif op=='send':return obj.send
        elif op=='recv':return obj.recv
    print(f'{bcolors.FAIL}apython built_in error:\n    {obj} has no attribute {op} {bcolors.RESET}')
    raise Exception
15444*17*code.pyfrom apython.executer import Undefine
class Code:
    def __init__(self):
        self.tem=('AX','BX')
        self.clean()
    def clean(self):
        self.code=[]
        self.comments=[]
        self.simplify=0
        self.base_num=[]      #åŸºåº•æ•¸å€¼(ä¾æ“šæª”æ¡ˆ) #(namecode,[0,0,0])
        self.base_esp=-1
        self.file_ed=[]
        self.base=(0,0,0)
    def __apply_file(self,name):
        if name not in self.file_ed:
            self.file_ed.append(name)
        return self.file_ed.index(name)
    def add_newtab(self,name):
        namecode=self.__apply_file(name)
        self.base_num.append((namecode,[0]))
    def del_newtab(self):
        del self.base_num[-1]
    def add_tab(self):
        #print('add_tab')
        pass
       # self.base_num[self.base_esp][1].append(0)
    def del_tab(self):
        pass
        #print('del_tab')
      #  del self.base_num[self.base_esp][1][-1]
    def get_error_msg(self,row):    #ç²å–éŒ¯èª¤è¨Šæ¯
        if row<len(self.comments):
            cmt_n=self.comments[row][0][2]
            cmt=self.comments[cmt_n]
       #  print(self.comments[cmt_n-1],self.comments[cmt_n],self.comments[cmt_n+1])
            return {'file':self.file_ed[cmt[0][0]],'row':cmt[0][1],'code':cmt[1]}
        else:
            return {'file':'','row':row,'code':self.code[row]}
    def append(self,command,comment=None,simplify=0):
        if comment != None and comment[0]!='':
           # print(command,comment)
            cmt, row = comment
            self.base_num[self.base_esp][1][-1] = row
            real_row = sum(self.base_num[self.base_esp][1])  # å¯¦éš›åœ¨ç¨‹å¼ç¢¼ä¸­çš„è¡Œ
            namecode=self.base_num[self.base_esp][0]
            self.base = (namecode,real_row,len(self.comments))
            self.comments.append((self.base,cmt))     #(æª”æ¡ˆåç¨±ï¼Œç¬¬å¹¾è¡Œ)ï¼ŒåŸå§‹å‘½ä»¤
        if command=='':return
        if self.simplify==0 and simplify==0 and comment==None and len(self.code)>0 and type(command)==str and type(self.code[-1])==str:
            last=self.code[-1].split(' ')
            cmd=command.split(' ')
            if last[0]=='push' and cmd[0]=='pop':
                del self.code[-1]
                if last[1]!=cmd[1]:
                    self.code.append(f'mov {cmd[1]} {last[1]}')
            elif last[0] == 'pop' and cmd[0] == 'push' and last[1]==cmd[1]:
                del self.code[-1]
                if last[1] not in self.tem:
                    self.code.append(f'mov {last[1]} <esp+1>')
            elif last[0]=='mov' and cmd[0]=='push' and last[1]==cmd[1] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'push {last[2]}')
            elif last[0]=='pop' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:
                del self.code[-1]
                self.code.append(f'pop {cmd[1]}')
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[2]==cmd[1]:
                pass
            elif last[0]=='mov' and cmd[0]=='mov' and last[1]==cmd[2] and last[1] in self.tem:      #ä¸‹ä¸€è¡Œå¯èƒ½æ˜¯åˆ¥äººè·³çš„ï¼Œå› æ­¤ç„¡æ³•ç°¡åŒ–
                del self.code[-1]
                self.code.append(f'mov {cmd[1]} {last[2]}')
            elif cmd[0] in ('add','sub') and cmd[2]=='0':
                pass
            else:
                self.code.append(command)
        else:
            self.code.append(command)
        if self.simplify>0:self.simplify-=1
        self.simplify+=simplify
        if len(self.code) > len(self.comments):
            self.comments.append((self.base, ''))
    def display(self,now_ip=-1):
        print('--------------------------------')
        Row=len(self.code)
        if now_ip<Row and now_ip!=-1 and now_ip<len(self.comments):
            now_row=self.comments[now_ip][0][2]
        else:now_row=Row
        for i in range(Row):
            statement=(' â— ' if now_ip == i else '   ')+str(i)+ ' ' * (4 - len(str(i)))+'|'+self.code[i]
            #if now_ip==i:
             #   statement="[93m"+statement+"[0m"
            space=' '*70
            cmt = self.comments[i]
            if cmt[1]!='':   #è¦matchåˆ°æ‰æœƒprint
                orig_code=(' â— ' if i== now_row else '   ')+str(cmt[0][1])+ ' ' * (4 - len(str(i)))+'| '+cmt[1]
            else:orig_code=''
            print(space+orig_code[:40]+'\r'+statement)
            if i>100:
                print('row more than 100')
                break
        print('--------------------------------')
    def parse_code(self,start_row=0,reset=True):                    #è§£æç‚ºé©åˆåŸ·è¡Œçš„æ ¼å¼
        def deal_string(codeline,k):  # kç‚º',"çš„ä½ç½®
            c = codeline[k]
            k+=1
            p = k
            while True:
                if codeline[k] == '\\':
                    k += 1
                elif codeline[k] == c:
                    break
                k += 1
            return c+codeline[p:k]+c,k
        def login_item(item):
            if item not in self.data_dict:
                if len(self.data)-self.data_n<100:
                    self.data+=[Undefine()]*1024
                self.data_dict[item]=self.data_n
                if item[0] in ('"',"'"):
                    string=item[1:-1]
                    if item[0]=='"':
                        rbox = {'\\n':'\n','\\r':'\r','\\t':'\t','\\a':'\a','\\b':'\b','\\f':'\f','\\v':'\v','\\"':'"','\\\'':'\'','\\\\':'\\'}
                        k,n=0,len(string)
                        text_box=[]
                        while k<n:
                            if string[k]=='\\' and string[k:k+2] in rbox:
                                text_box.append(rbox[string[k:k+2]])
                                k+=1
                            else:text_box.append(string[k])
                            k+=1
                        string=''.join(text_box)
                    self.data[self.data_n]=string
                elif item[0] in '0123456789-':
                    if '.' in item:self.data[self.data_n]=float(item)
                    else:self.data[self.data_n]=int(item)
                self.data_n+=1
            return self.data_dict[item]
        cmd_dict={'mov':(0,2),
                  '$mov':(1,3),               #$mov AX op BX  #AX+=BX
                  'oper':(2,3),               #oper AX op BX  #AX=AX+BX             #'add','sub','mul','div','pow','quo','rem','address'
                  'cmp':(3,2),                #ZR=AX-BX
                  'jmp':(4,1),               #jmp ip
                  '$jmp':(5,2),              #$jmp ip ">"  #ZRå¤§æ–¼0å‰‡è·³
                  'call':(6,1),              #å‘¼å«å‡½æ•¸
                  'push':(7,1),'pop':(8,1),
                  'tf':(9,3),                 #tf AX "ctn" BX    #åˆ¤æ–·çœŸå‡      'ctn','equ','Ctn','is',
                  'inc':(10,1),'dec':(11,1),
                  '$oper':(12,2),              #$oper AX "op" BX                       #'neg','NEG','not'
                  'ex_func':(13,3),           #ex_fuunc AX "str" BX  #AX=str(BX)       #'iter'
                  'try':(14,1),'finally':(15,1),'raise':(16,1),'error':(17,1),
                  'Generator':(18,-1),'Yield':(19,0),'fetch':(20,2),
                  'stop':(21,0),'end':(22,-1),
                  'byte':(23,2),'del':(24,3),'Function':(25,-1),
                  'global':(26,0),'namespace':(28,3),'pass':(26,0),     #globalä¸äºˆç†æœƒ
                  '*args':(29,3),'**kwargs':(30,3),'module':(31,2),
                  'type':(32,2),'name':(33,2),'repl_print':(34,1)}
        #-----------------------------------------------------
        if reset:
            self.data_dict={'AX':0,'BX':1,'CX':2,'DX':3,'ip':4,'esp':5,'sp':6,'ZR':7,'TF':8,
                       '*args':9,'**kwargs':10,'$Exception':11,
                       'True':12,'False':13,'None':14,'$Inheritance':15}
            self.data_n = len(tuple(self.data_dict))
            self.data=[None]*self.data_n
            self.data+=[Undefine()]*1024
            self.data[12]=True
            self.data[13]=False
            self.data[14]=None
            self.data[15]=None
            self.parse_codes=[]
        else:
            self.data_n = len(tuple(self.data_dict))                              #dataé–‹å§‹ç™»è¨˜çš„ä½ç½®
        #print('data_n:',self.data_n)
        ROW=len(self.code)-1
        start_row-=1
        #print('code:',self.code)
        #print('start_row:',start_row)
        while start_row<ROW:
            start_row+=1
            line=self.code[start_row]
            if line=='':          #lineç‚ºç©º
                self.parse_codes.append([26])     #ä¸äºˆç†æœƒç©ºline
                continue
            op=line.split(' ')[0]
            cmd=cmd_dict[op]
            deal = [cmd[0]]
            k=len(op)+1
            fetch_k=0
            while fetch_k<cmd[1] or (cmd[1]==-1 and k<len(line)):
                if line[k] in ('"',"'"):                       #å¿…å®šç‚ºå­—ä¸²
                    string,k=deal_string(line,k)          #kç‚º"çš„ä½ç½®
                    if fetch_k==1:
                        if op in ('$mov','oper'):
                            op_num=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='tf':
                            op_num = ('in','equ','Ctn','is').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        elif op=='$oper':
                            op_num = ('not','-','~').index(string[1:-1])
                            deal.append((0, login_item(str(op_num))))
                        else:
                            deal.append((0, login_item(string)))
                    else:
                        deal.append((0,login_item(string)))
                    k+=2
                elif line[k] in '0123456789-':                  #å¿…å®šç‚ºæ•¸å€¼
                    k2=k
                    while k2<len(line) and line[k2] in '-0123456789.':k2+=1
                    number=line[k:k2]
                    deal.append((0,login_item(number)))
                    k=k2+1
                elif line[k]=='[':                    #æ­¤è™•ç‚º[value]é¡å‹ï¼Œé variable[value] é¡å‹ï¼Œå› æ­¤[]ä¸­åªèƒ½æ˜¯int,dict,class
                    k2=line.index(']',k)
                    value=line[k+1:k2]
                    if value=='dict':                   #11:dict
                        deal.append((11,-1))
                    elif value=='class':                #13:class
                        deal.append((13,-1))
                    elif value=='func':                 #16:func
                        deal.append((16,-1))
                    else:                                #10:list
                        deal.append((10,int(value)))
                    k=k2+2
                elif line[k]=='(':             #è¦æ±‚[number]        #12:tuple
                    k2=line.index(')',k)
                    deal.append((12,int(line[k+1:k2])))   #tupleå®£å‘Š
                    k=k2+2
                else:
                    typebox=''
                    if line[k]=='<':
                        k2=line.index('>',k)
                        name=line[k+1:k2]
                        if '+' in name:
                            c=name.split('+')
                            result=[c[0],int(c[1])]
                        else:result=[name,0]
                        k2+=1
                        if result[0]=='esp':
                            typebox+='1'                                   #<esp+k>:1
                            result[0] = login_item(result[0])
                        else:
                            #result[0] = login_item(result[0])            #æ­¤è™•ä¸é€²è¡Œç™»è¨˜ï¼Œå› ç‚ºfunc_nameè¦ä½œç‚ºkeyä½¿ç”¨
                            typebox='2'                                   #<func+k>:2
                    else:                                                  #name:0
                        k2=k
                        while k2<len(line) and line[k2] not in '[ .':k2+=1
                        result=[line[k:k2]]
                        typebox+='0'
                        result[0] = login_item(result[0])
                    k=k2+1
                    #----------------
                    #[],{},()æŒ‡ä»¤

                    if k2 < len(line) and line[k2] == '.':             # ä»£è¡¨æ˜¯å­å±¬æ€§ï¼Œ'.':0
                        k2+=1
                        while k2 < len(line) and line[k2] not in '[ .': k2 += 1
                        attr=line[k:k2]
                        result.append(attr)
                        typebox+='0'
                        k=k2+1
                    if k2<len(line) and line[k2]=='[':                        #ä»£è¡¨æ˜¯ç´¢å¼•ï¼Œ[key]:1
                        if line[k2+1] in ('"', "'"):           #å…§å®¹æ˜¯å­—ä¸²
                            value, k3 = deal_string(line,k2+ 1)
                            result.append(login_item(value))
                            k3+=1            #k3ç§»å‹•åˆ°]çš„ä½ç½®
                        else:
                            k3=line.index(']',k2)
                            value=line[k2+1:k3]
                            result.append(login_item(value))
                        typebox += '1'
                        k=k3+2
                    if typebox=='0':                    #ç´”åå­—                #name
                        deal.append((0,result[0]))
                    elif typebox=='00':                                       #name.attr
                        deal.append((1,result[0],result[1]))
                    elif typebox=='01':                                       #name[key]
                        deal.append((2, result[0], result[1]))  # name[key]
                    elif typebox=='1':                                       #<esp+k>
                        deal.append((3, result[0], result[1]))
                    elif typebox=='10':                                       #<esp+k>.attr
                        deal.append((4,result[0],result[1],result[2]))
                    elif typebox=='11':                                       #<esp+k>[key]
                        deal.append((5,result[0],result[1],result[2]))
                    elif typebox=='2':                                       #<func+k>
                        deal.append((6, result[0], result[1]))
                    elif typebox=='20':                                       #<func+1>.attr
                        deal.append((7,result[0],result[1],result[2]))
                    elif typebox=='21':                                       #<func+k>[key]
                        deal.append((8,result[0],result[1],result[2]))
                fetch_k+=1
            self.parse_codes.append(deal)
        return self.parse_codes,self.data,self.data_dict
    def __len__(self):
        return len(self.code)
    def __getitem__(self, item):
        return self.code[item]
    def __setitem__(self, key, value):
        self.code[key]=value
    #def __delitem__(self, key):        #æœ¬ç¨‹å¼è‡ªå‹•å„ªåŒ–ï¼Œå‹¿del
     #   del self.code[key]8435*112*ebuilt_in.pyfrom os import system
built_in=\
{
    "<class 'str'>":
        {
            'attr':'',
            'example':"'hello'",
            'function':'join,count,split,index,format,encode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'list'>":
        {
            'attr':'',
            'example':"[1,2,3]",
            'function':'append,pop,count,remove,insert,clear,copy,index,extend,reverse,sort'
        },
    "<class 'tuple'>":
        {
            'attr':'',
            'example':"(1,5,9)",
            'function':'index,count'
        },
    "<class 'dict'>":
        {
            'attr':'',
            'example':"{1:2,3:4}",
            'function':'pop,get,copy,clear,update,keys,fromkeys,items,popitem,setdefault,values'
        },
    "<class 'bytes'>":
        {
            'attr':'',
            'example':"b'hell'",
            'function':'join,count,split,index,format,decode,replace,capitalize,casefold,center,endswith,expandtabs,'
                       'find,format_map,isalnum,isalpha,isascii,isdecimal,isdigit,isidentifier,islower,isnumeric,'
                       'isprintable,isspace,istitle,isupper,ljust,lower,lstrip,maketrans,partition,removeprefix,'
                       'removesuffix,rfind,rindex,rjust,rpartition,rsplit,rstrip,splitlines,startswith,strip,swapcase,'
                       'title,translate,upper,zfill'
        },
    "<class 'set'>":
        {
            'attr':'',
            'example':"{1,2,3,4}",
            'function':'pop,add,remove,copy,clear,update,difference,difference_update,discard,intersection,intersection_update,'
                       'isdisjoint,issubset,issuperset,symmetric_difference,symmetric_difference_update,union'
        },
    "<class '_io.TextIOWrapper'>":
        {
            'attr':'name,encoding,mode,buffer,closed,errors,line_buffering,newlines',
            'example':"open('newtext.txt','w')",
            'function':'write,tell,read,close,seek,fileno,flush,isatty,readable,readline,readlines,seekable,truncate,writable,writelines,'
                       '__enter__,__exit__'
        },
    "<class 'builtin_function_or_method'>":
        {
            'attr':'__name__',
            'example':"print",
            'function':''
        }
}
build_template='''
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\\nfrom apython.ex_func import *\\n")
    g.write('class bcolors:\\n    OK = "\033[92m"  # GREEN\\n    WARNING = "\033[93m"  # YELLOW\\n    FAIL = "\033[91m"  # RED\\n    RESET = "\033[0m"  # RESET COLOR\\n')
    g.write("def built_in_operator(obj,op):\\n    stype = str(type(obj))\\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\\n')
            else:
                g.write(f'    elif stype=="{stype}":\\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\\'{item}\\':return obj.{item}\\n')
                else:
                    g.write(f'        elif op==\\'{item}\\':return obj.{item}\\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\\n        module_name=obj.module_name\\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            else:
                g.write(f'            elif op==\\'{sub_term}\\':return {module_name}.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\\n')
        k += 1
    g.write('    obj_name=obj.__name__\\n    if op=="__name__":return obj_name\\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            else:
                g.write(f'        elif op==\\'{sub_term}\\':return obj.{sub_term}\\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\\\n    {obj} has no attribute {op} {bcolors.RESET}')\\n    raise Exception\\n")
    g.close()
build()
'''
def test_and_build():
    f=open('test_error.txt','w',encoding='utf-8')
    f.write("#encoding='utf-8'\ndatas=[]")
    k=1
    for key in built_in:
        data=built_in[key]
        f.write(f'\ntype{k}="{key}"')
        f.write(f'\nexample{k}='+data['example'])
        f.write(f'\nabox{k}=[]')
        f.write(f'\nfbox{k}=[]')
        if data['attr'] != '':
            attrs = data['attr'].split(',')
            for item in attrs:
                f.write(f'\ntry:\n    abox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        if data['function']!='':
            functions = data['function'].split(',')
            for item in functions:
                f.write(f'\ntry:\n    fbox{k}.append(example{k}.{item}.__name__)\nexcept:\n    pass')
        f.write(f'\ndatas.append((type{k},abox{k},fbox{k}))')
        k+=1
    f.write(build_template)
    f.close()
test_and_build()
system('py test_error.txt')41704*111*executer.pyfrom apython.built_in import *
class Undefine:
    def __init__(self):
        self.Fail = "[91m"
        self.RESET = "[0m"
    def __str__(self):
        return f'{self.Fail}<undefined>{self.RESET}'
class class_obj:
    def __init__(self,ram):
        self.ram=ram
        self.atype=None
        self.vars={}
        self.print_lock=0        #0:é€²è¡Œé‹ç®—ï¼Œ1:ç›´æ¥å›å‚³<The class obj>
    def __str__(self):
        if self.print_lock==0 and '__str__' in self.vars:
            return self.ram.call_obj_function(self,[],'__str__')
        return '<class_obj>'
    def __add__(self, other):
        if self.print_lock==0 and '__add__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__add__')
    def __sub__(self, other):
        if self.print_lock==0 and '__sub__' in self.vars:
            return self.ram.call_obj_function(self,[other],'__sub__')
    def __len__(self):
        if self.print_lock==0 and '__len__' in self.vars:
            return self.ram.call_obj_function(self,[],'__len__')
    def __setitem__(self, key, value):
        if self.print_lock==0 and '__setitem__' in self.vars:
            return self.ram.call_obj_function(self,[key,value],'__setitem__')
    def __getitem__(self, item):
        if self.print_lock==0 and '__getitem__' in self.vars:
            return self.ram.call_obj_function(self,[item],'__getitem__')
    def __contains__(self, item):
        if self.print_lock == 0 and '__contains__' in self.vars:
            return self.ram.call_obj_function(self, [item], '__contains__')
    def __next__(self):
        if self.print_lock == 0 and '__next__' in self.vars:
            return self.ram.call_obj_function(self, [], '__next__')
        elif '__getitem__' in self.vars:
            self.error=False
            self.item_k += 1
            return self.__getitem__(self.item_k)
    def __iter__(self):
        self.item_k=-1
        if self.print_lock == 0 and '__iter__' in self.vars:
            return self.ram.call_obj_function(self, [], '__iter__')
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.print_lock == 0 and '__exit__' in self.vars:
            return self.ram.call_obj_function(self, [exc_type,exc_val,exc_tb], '__exit__')
    def __call__(self, *args, **kwargs):
        if self.print_lock == 0 and '__call__' in self.vars:
            return self.ram.call_obj_function(self, args, '__call__',kwargs)
    def __del__(self):
        if self.print_lock == 0 and '__del__' in self.vars:
            return self.ram.call_obj_function(self, [], '__del__')
    def __eq__(self, other):
        if self.print_lock == 0 and '__eq__' in self.vars:
            return self.ram.call_obj_function(self, [other], '__eq__')
class Func:
    def __init__(self,ram,ip,class_obj,func_var,stack_len,import_funcs):
        self.name='Function'
        self.atype='Function'
        self.ram=ram
        self.vars={'ip':ip,'class_obj':class_obj}
        self.stack_name=func_var
        self.stack_len=stack_len
        self.import_funcs=import_funcs
    def __str__(self):
        return str(self.name)
    def __call__(self, *args, **kwargs):                 #ç”±å…§éƒ¨æˆ–å¤–éƒ¨å‡½æ•¸(ex_function)å‘¼å«
        self.ram.data[self.ram.args_location] = args
        self.ram.data[self.ram.kwargs_location] = kwargs
        result=self.ram.func_run(self.vars['ip'],self.vars['class_obj'],self.stack_name,self.stack_len,self.import_funcs)    #ipå›ºå®šï¼Œclass_objå’Œex_boxéƒ½æ˜¯ä½å€å®šç¾©ï¼Œå› æ­¤ä¸ç”¨æ¥å—è¿”é‚„å€¼
        return result
class generator:
    def __init__(self,ram,start_ip,import_funcs):
        self.ram=ram
        self.next_ip=start_ip
        self.import_funcs = import_funcs
        #self.params=params
        #self.locals=locals
        self.ex_stack=[]                 #ç¨‹å¼ä¸­æ–·æ™‚å¯èƒ½æœ‰è¶…å‡ºçš„å †ç–Š
        #self.ex_box=ex_box                   #çˆ¶å‡½æ•¸å€‘çš„è³‡æ–™å…§å®¹ï¼Œ[(loc,stack),...]
        #self.orig_local_len=len(locals)
        #self.base_location=base_location
        self.enter=0                           #ç•¶enter=1æ™‚ï¼Œä»£è¡¨å·²ç¶“é­é‡äº†stopiteration
        self.next_lock=True                    #åœ¨sendå‰éœ€è¦å…ˆå•Ÿå‹•next
        self.send=False
        self.send_obj=None
        self.finally_box=[]                    #å¦‚æœç¨‹å¼åœ¨æœ‰finallyçš„tryä¸­è·³å‡ºï¼Œä¸¦ä¸”è‡ªå·±è¢«delï¼Œå‰‡ä¾åºåŸ·è¡Œfinallyboxä¸­çš„å…§å®¹
        def send(value):
            if not self.next_lock:
                self.send=True
                self.send_obj=value
                return self.__next()
            raise TypeError("can't send non-None value to a just-started generator")
        self.vars={'send':send}
    def __str__(self):
        return '<generator_obj>'
    def __getitem__(self, item):
        return self.__next()
    def __next__(self):
        self.next_lock=False
        if self.send:
            self.send_obj =None               #åœ¨å•Ÿç”¨sendä¹‹å¾Œï¼Œå¿…å®šè¦å‚³çµ¦AXå€¼
        return self.__next()
    def __next(self):
        if self.enter==1:    #ä»£è¡¨ä¹‹å‰é€²å…¥å»ä¹‹æ•—äº†
            raise StopIteration
        else:
            self.enter=1
            if not self.send:
                next_obj,self.ex_stack,yield_result,base_esp= self.ram.yield_run(self.next_ip,self.ex_stack, self.import_funcs)
            else:
                next_obj, self.ex_stack, yield_result, base_esp = self.ram.yield_run(self.next_ip, self.ex_stack,self.import_funcs,send_obj=self.send_obj)
             #print('å–å¾—çµæœ:',yield_result)
           # print('ex_stack',self.ex_stack)
            if next_obj!=None:
                self.next_ip,finally_box=next_obj
                for f_ip in finally_box:
                    if f_ip[0]>-1:
                        ex_stack_num=base_esp-f_ip[1]       #åŸºåº•å †ç–Šé‡èˆ‡é€²å…¥tryæ™‚å †ç–Šé‡çš„å·®
                        self.finally_box.append([f_ip[0],ex_stack_num])
                    else:
                        for fip in self.finally_box:          #åŒå€‹finallyå°±åˆªæ‰
                            if fip[0]==abs(f_ip[0]):
                                self.finally_box.remove(fip)
                                break
                self.enter=0
                return yield_result
            raise StopIteration
    def __del__(self):
       # print('del:',self.finally_box)
        for f_ip in self.finally_box:
           # print(f_ip)
            #å°‡å †ç–ŠåŒä½
            self.ram.data[self.ram.ip]= f_ip[0]+1
            # --------------------------------------------
            tem_stacks = {}
            for func_name in self.import_funcs:
                tem_stacks[func_name] = self.ram.func_stack[func_name]
                self.ram.func_stack[func_name] = self.import_funcs[func_name]
            for i in range(f_ip[1]):    #åŸå§‹localé‡+ex_stack
                self.ram.push(self.ex_stack[i])
            #self.ram.data[self.base_location] = self.ram.data[self.ram.esp]        #<stack_esp>
            self.ram.push(None)           #ç‚ºäº†ç¬¦åˆfinallyçš„å †ç–Šæ ¼å¼
            self.ram.push(1)
            # --------------------------------------------
            #self.ram.tf=1
            try:
                self.ram.one_run('finally yield run')
            except Exception as e:
                print(e)
            finally:
                for func_name in tem_stacks:
                    self.ram.func_stack[func_name] = tem_stacks[func_name]
         #   print('run finish')
def fetch_error(e):
    stype = str(type(e))
    k = stype.index("'")
    k2 = stype.index("'", k + 1)
    return stype[k + 1:k2]
def atype(obj):
    if type(obj)==class_obj:
        return obj.atype
    elif type(obj)==Func:
        return f"<class '__main__.{obj.name}'>"
    return type(obj)     #string,list,int,tuple,...
def aprint(*args,**kwargs):
    text_box=[]
    for obj in args:
        text_box.append(str(obj))
    text=' '.join(text_box)
    if 'end' in kwargs:
        total_output.append(text+kwargs['end'])
    else:
        total_output.append(text+'\n')
total_output=[]
built_in_functions=[abs,all,any,ascii,bin,bool,breakpoint,bytearray,bytes,callable,chr,classmethod,compile,complex,
                    delattr,dict,dir,divmod,enumerate,eval,exec,filter,float,format,frozenset,getattr,globals,hasattr,hash,hex,
                    id,input,int,isinstance,issubclass,iter,len,list,locals,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,
                    range,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,vars,zip]
Error_class=[NameError,IndexError,TypeError,SyntaxError,ValueError,KeyboardInterrupt,AssertionError,Exception,RecursionError,
             KeyError,ZeroDivisionError,AttributeError,IndentationError ,UnboundLocalError]
else_built_in=[StopIteration,StopAsyncIteration,SyntaxWarning,FileNotFoundError,ModuleNotFoundError]
bifs={
   # 'help':help,             #æ‰“åŒ…æˆexeæ™‚ï¼Œhelpæœƒç„¡æ•ˆ
    'IOError':IOError,
    'type':atype       #helpæ²’æœ‰name,IOErrorçš„nameç‚ºOSError
      }
for key in built_in_functions+Error_class+else_built_in:
    bifs[key.__name__]=key
class Executer:                                               #è¼‰å…¥ç¨‹å¼ç¢¼èˆ‡è¨˜æ†¶é«”
    def __init__(self,code):
        self.code=code
        self.ex_function=bifs.copy()
        self.run_layer=[]
        self.func_stack={}
    def set(self,var_name,value):
        location=self.data_dict[var_name]
        self.data[location]=value
    def push(self, value):
        self.esp_stack[self.data[self.esp]] = value
        self.data[self.esp]-= 1
    def pop(self):
        self.data[self.esp]+= 1
        return self.esp_stack[self.data[self.esp]]
    def login(self,var_name):
        if var_name in self.var_dict:
            return self.var_dict[var_name]
        self.var_dict[var_name]=self.used_size
        self.used_size+=1
        return self.used_size-1
    def get_var_location(self,var_name):
        return self.var_dict[var_name]
    def pushaw(self):
        for i in range(5):                                #å„²å­˜AX,BX,CX,DX,ipé€²å †ç–Š
            self.esp_stack[self.data[self.esp]]=self.data[i]
            self.data[self.esp]-=1
    def popaw(self):
        for i in range(5):                                #å›å¾©AX,BX,CX,DX,ipé€²å †ç–Š
            self.data[self.esp] += 1
            self.data[4-i]=self.esp_stack[self.data[self.esp]]
    def __setitem__(self,location, value):
     #   print(location,value)
        if location[0]==0:                                                       #name
            self.data[location[1]]=value
        elif location[0]==1:                                                        #name.attr
            self.data[location[1]].vars[location[2]]=value
        elif location[0]==2:                                                             #name[key]
            self.data[location[1]][self.data[location[2]]]=value
        #-----------------------------------------------------------------------------------------------
        elif location[0]==3:                                                             #<esp+k>
            self.esp_stack[self.data[location[1]]+location[2]]=value
        elif location[0]==4:                                                            #<esp+k>
            self.esp_stack[self.data[location[1]] + location[2]].vars[location[3]]=value
        elif location[0]==5:                                                              #<esp+k>[key]
            self.esp_stack[self.data[location[1]]+location[2]][self.data[location[3]]]=value
        # -----------------------------------------------------------------------------------------------
        elif location[0]==6:                                                             #<func+k>
            self.func_stack[location[1]][location[2]]=value
        elif location[0]==7:                                                            #<func+k>
            self.func_stack[location[1]][location[2]].vars[location[3]]=value
        elif location[0]==8:                                                              #<func+k>[key]
            self.func_stack[location[1]][location[2]][self.data[location[3]]]=value
    def call_obj_function(self,obj,args,funcname,kwargs=None):
        tem_esp=self.data[self.esp]
        if kwargs==None:kwargs={}
        self.pushaw()
        self.data[2] = len(args)                                           # CX=len(args)
        func=obj.vars[funcname]
        result=None
        try:
            result=func(*args,**kwargs)
        finally:
            self.popaw()
            self.data[self.esp]=tem_esp
        return result
    def yield_run(self,ip,ex_stack,import_funcs,send_obj=None):
        tem_ip=self.data[self.ip]
        self.data[self.ip]=ip
        #--------------------------------------------
        tem_stacks={}
        for func_name in import_funcs:
            tem_stacks[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        #--------------------------------------------
        tem_esp=self.data[self.esp]       #å„²å­˜ç›®å‰esp
        for ex_obj in ex_stack:
            self.push(ex_obj)
        #--------------------------------------------
        yield_result =None
        ok=False
        try:                                #æ­¤è™•runå¯èƒ½æœƒå™´StopIterationéŒ¯èª¤ï¼Œè‡³å°‘è¦å›æ”¶å †ç–Šã€é‚„åŸip
            self.data[0]=send_obj
            next_obj=self.__run('yield run')
            ok=True
        #--------------------------------------------
        finally:
            del self.run_layer[-1]          #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€é™¤å»yield run
            if ok:
                yield_result=self.data[0]            #ç²å–yieldçš„å€¼
            new_ex_stack=[]
            for i in range(tem_esp-self.data[self.esp]):
                new_ex_stack.insert(0,self.pop())
            # é‚„åŸçˆ¶å‡½æ•¸
            for func_name in tem_stacks:
                self.func_stack[func_name]=tem_stacks[func_name]
            #-------------------------------------------
            self.data[self.ip]=tem_ip
        return next_obj,new_ex_stack,yield_result,tem_esp
    def func_run(self,ip,class_obj,stack_name,stack_len,import_funcs):
        tem_ip = self.data[self.ip]  # ç•¶å‰ip
        tem_esp=self.data[self.esp]
        # --------------------------------------------
        tem_func_stack={}
        for func_name in import_funcs:
            tem_func_stack[func_name]=self.func_stack[func_name]
            self.func_stack[func_name]=import_funcs[func_name]
        if stack_name not in self.func_stack:            #è™•ç†å †ç–Šè³‡è¨Š
            self.func_stack[stack_name]=None
        tem_stack=self.func_stack[stack_name]
        # --------------------------------------------
       # self.push(len(self.code))  # æ¨å…¥æœ€å¾Œä¸€è¡Œï¼Œç¨‹å¼åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³æœ€å¾Œä¸€è¡Œ     #push ip
        #å»ºç«‹æ–°functionå †ç–Š
        func_stack=[0]*stack_len
        func_stack[0]=class_obj                 #ç¬¬0ä½ç½®ç‚ºclass_obj
        self.func_stack[stack_name]=func_stack
        #-------------------------------------------------------
        self.data[self.ip] = ip+ 1
        self.push(len(self.code))   #é€™æ¨£pop ipå°±æœƒç›´æ¥return
        result=None
        try:
            self.__run(f'Func<{ip}> run')
        #except Exception as e:
        #    print(e)
        #    raise e
        finally:
            result=self.data[0]
            del self.run_layer[-1]
            self.data[self.ip] = tem_ip
            # é‚„åŸçˆ¶å‡½æ•¸
            self.func_stack[stack_name]=tem_stack
            for func_name in import_funcs:
                self.func_stack[func_name] = tem_func_stack[func_name]
            self.data[self.esp]=tem_esp
        return result
    def __getitem__(self, location):
        #------------------------------------------------------------------------------------------------name
        if location[0] == 0:                                        # name
            return self.data[location[1]]
        elif location[0] == 1:                                       #name.attr
            obj = self.data[location[1]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[2] in obj.vars:
                    return obj.vars[location[2]]
                return self.undefined  # ç™¼ç”ŸéŒ¯èª¤
            elif type(obj)==Undefine:
                raise Exception(f'{self.inverse_data_dict[location[1]]} is undefined')
            elif type(obj)==Ex_module and location[2] in obj.vars:
                return obj.vars[location[2]]
            else:
                func=built_in_operator(obj, location[2])
                return func
        elif location[0] == 2:                                       # name[key]
            return self.data[location[1]][self.data[location[2]]]
        #------------------------------------------------------------------------------------------------<esp+k>
        elif location[0] == 3:                                       #<esp+k>
            return self.esp_stack[self.data[location[1]] + location[2]]
        elif location[0]==4:                                         #<esp+k>.attr
            obj = self.esp_stack[self.data[location[1]] + location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
                raise Exception(f'variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 5:                                         # <esp+k>[key]
            return self.esp_stack[self.data[location[1]] + location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------<func+k>
        elif location[0] == 6:                                       #<func+k>
            return self.func_stack[location[1]][location[2]]
        elif location[0]==7:                                         #<func+k>.attr
            obj =self.func_stack[location[1]][location[2]]
            if type(obj) in (class_obj, generator,Namespace_stack):
                if location[3] in obj.vars:
                    return obj.vars[location[3]]
                return self.undefined
            elif type(obj)==Undefine:
               # ip=self.data[self.ip]
               # print('ip:',ip)
               # start_ip=ip-20
               # error_lines=self.code.code[start_ip:ip+10]
               # for i in range(30):
               #     print(start_ip+i,error_lines[i])
               # print('location:',location)
                raise Exception(f'this variable is undefined')
            elif type(obj)==Ex_module and location[3] in obj.vars:
                return obj.vars[location[3]]
            else:
                func = built_in_operator(obj, location[3])
                return func
        elif location[0] == 8:                                         # <func+k>[key]
            return self.func_stack[location[1]][location[2]][self.data[location[3]]]
        #------------------------------------------------------------------------------------------------[object]
        elif location[0]==10:                                          #list
            return [0]*location[1]
        elif location[0]==11:                                          #dict
            return {}
        elif location[0]==12:                                          #tuple
            return [0]*location[1]
        elif location[0] == 13:                                        #<class obj>
            self.class_objs.append(class_obj(self))
            return self.class_objs[-1]
    def __error_print(self,msg):
        Fail="[91m"
        RESET = "[0m"
        print(f'{Fail}{msg}{RESET}')
    def __ok_print(self,msg):
        OK="[92m"
        RESET = "[0m"
        print(f'{OK}{msg}{RESET}')
    def one_run(self,comment):
        self.__run(comment)
    def run(self,tf=0,stack_size=1024,comment='normal'):
        self.codes, self.data, self.data_dict = self.code.parse_code(start_row=0,reset=True)
        self.inverse_data_dict = {}
        for key in self.data_dict:
            self.inverse_data_dict[self.data_dict[key]] = key
        self.stack_size=stack_size
        self.esp_stack= [0] * stack_size
        #-------------------------------------------------------------
        self.set('esp', -1)  # è¨­å®šå †ç–ŠæŒ‡æ¨™
        self.set('ip',0)
        self.esp = self.data_dict['esp']
        self.ip = self.data_dict['ip']
        self.ZR = self.data_dict['ZR']
        self.TF = self.data_dict['TF']
        self.ER=self.data_dict['$Exception']
        self.data[self.ER]=0
        self.error_line=0        #ç™¼ç”ŸéŒ¯èª¤çš„line
        self.args_location = self.data_dict['*args']
        self.kwargs_location = self.data_dict['**kwargs']
        self.class_objs=[]
        self.func_stack={}
        self.undefined=Undefine()
        #--------------------------åˆå§‹åŒ–å¤–éƒ¨å‡½æ•¸
        for name in self.data_dict:
            if name in self.ex_function:
                self.data[self.data_dict[name]]=self.ex_function[name]
        self.normal_run(0,tf,comment)
    def REPL_run(self, row):
        total_output.clear()
        if row==0:
            self.run(0,1024,comment='REPL')
        else:
            self.data[0]=None
            self.codes, self.data, self.data_dict = self.code.parse_code(start_row=row,reset=False)
            for name in self.data_dict:
                if name in self.ex_function:
                    self.data[self.data_dict[name]] = self.ex_function[name]
            for key in self.data_dict:
                self.inverse_data_dict[self.data_dict[key]] = key
            self.normal_run(row,0,'REPL')
        return ''.join(total_output)
    def normal_run(self,row,tf,comment='normal'):
        self.tf=tf
        self.set('esp',-1)
        self.set('ip',row)
        try:
            self.__run(comment)
            if self.data[self.esp] == -1:
                if tf > 0:
                    self.__ok_print('\nç¨‹å¼çµæŸ--------')
            else:
                self.__error_print(f'ç¨‹å¼è­¦å‘Š:å †ç–Šæœªé‚„åŸ---------->   {self.data[self.esp]}')
        except Exception as e:
            if self.data[self.ER] == 0:  # éŒ¯èª¤ä¸æ˜¯ä¾†è‡ªtryï¼ŒéŒ¯èª¤ä¾†è‡ªæ­£å¸¸è¡Œ
                error_ip = self.data[self.ip]
            else:  # éŒ¯èª¤ä¾†è‡ªtry
                error_ip = self.error_line
            if comment!='REPL':
                msg = self.code.get_error_msg(error_ip)
                self.__error_print(f'\nTrackback:\nFILE: ' + msg['file'] + ',  line:' + str(+msg['row']))
                self.__error_print('   ' + msg['code'])
            error = str(e)
            if len(error) > 0: error = ': ' + error
            self.__error_print(fetch_error(e) + error)
            # print('--------------')
            if tf > 0:
                raise e
    def __run(self,run_comment):
        self.run_layer.append(run_comment)
        def obj_lock(lock):
            for obj in self.class_objs: obj.print_lock = lock
        def cpu_state():
            print('data: ', end='')
            for key in self.data_dict:
                if key[0] not in '"0123456789-' + "'" and key not in  ('None','True','False') and key not in self.ex_function:
                    # if type(key) != int and '"' != key[0] and "'" != key[0]:  # å»é™¤æ•¸å€¼å’Œå­—ä¸²
                    print(f'{key}:{self.data[self.data_dict[key]]}', end='  ')
                if key in ('TF', '**kwargs'): print('\n      ', end='')
                if key=='$Exception':print('\n      ', end='')
                if key=='$Inheritance':
                    print('\nè‡ªç”±è®Šæ•¸:\n      ',end='')
            stack_text = '\n\nstack:['
            stack_n = 7
            for i in range(25):
                obj = self.esp_stack[-i - 1]
                get = str(obj) + ','
                if i + 1 < abs(self.data[esp]):
                    stack_n += len(get)
                stack_text += get
            print(stack_text[:-1] + ']')
            print(' ' * stack_n + '^')
            for func_name in self.func_stack:
                print(f'{func_name}: {self.func_stack[func_name]}')
        def get_status():
            obj_lock(1)
            now_ip=self.data[ip]
            self.code.display(now_ip)
            cpu_state()
            print(f'run_layer:{self.run_layer}')
            if now_ip < len(self.codes):
                print('\næº–å‚™åŸ·è¡Œ:', self.code.code[now_ip], '                  å°æ‡‰:', self.codes[now_ip])
                print('-------------------------------')
            else:
                print('ç¨‹åºå·²çµæŸ\n')
            obj_lock(0)
        ip=self.ip
        esp=self.esp
        ZR=self.ZR
        TF=self.TF
        ER=self.ER
        args_location=self.args_location
        kwargs_location=self.kwargs_location
        finally_box=[]
        n=len(self.codes)
        while self.data[ip]<n:
            cmd=self.codes[self.data[ip]]
           # print(f'{self.data[ip]}   {self.code.code[self.data[ip]]}                       {cmd}')
            if self.tf==1:
                get_status()
                a=input()
                if a!='':
                    #print(f'AX:"{self.data[0]}"')
                    if len(a)<3:
                        self.tf=0.5
                    elif a=='asd':
                        print('åµéŒ¯!!--------')
                        self.tf=0.1
                    else:
                        self.__ok_print('ç¨‹å¼é–‹å§‹--------')
                        self.tf=0
            if self.tf==0.1:
                now_ip=self.data[ip]
                msg=' '*60+self.code.comments[now_ip]+f'\r       {self.code.code[now_ip]}\r{now_ip}'
                print(msg)
                #cpu_state()
            #------------------------------------------
            if cmd[0] ==0:#mov
                self[cmd[1]] = self[cmd[2]]
            elif cmd[0]==1: #$mov
                op=self[cmd[2]]
                if op==0:  #add
                    self[cmd[1]] += self[cmd[3]]
                elif op==1: #sub
                    self[cmd[1]] -= self[cmd[3]]
                elif op==2: #mul
                    self[cmd[1]] *= self[cmd[3]]
                elif op==3: #div
                    self[cmd[1]]/=self[cmd[3]]
                elif op==4: #pow
                    self[cmd[1]] **= self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] %= self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] //= self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]<<=self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]>>=self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] &= self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] ^= self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] |=self[cmd[3]]
            elif cmd[0]==2:  #oper
                op = self[cmd[2]]
                if op == 0:  # add
                    self[cmd[1]] =self[cmd[1]]+self[cmd[3]]
                elif op == 1:  # sub
                    self[cmd[1]] =self[cmd[1]]-self[cmd[3]]
                elif op == 2:  # mul
                    self[cmd[1]] =self[cmd[1]]* self[cmd[3]]
                elif op == 3:  # div
                    self[cmd[1]] =self[cmd[1]]/self[cmd[3]]
                elif op == 4:  # pow
                    self[cmd[1]] =self[cmd[1]]**self[cmd[3]]
                elif op==5:  # quo
                    self[cmd[1]] =self[cmd[1]]%self[cmd[3]]
                elif op==6:  # rem
                    self[cmd[1]] =self[cmd[1]]//self[cmd[3]]
                elif op==7:  #shl
                    self[cmd[1]]=self[cmd[1]]<<self[cmd[3]]
                elif op == 8: #shr
                    self[cmd[1]]=self[cmd[1]]>>self[cmd[3]]
                elif op == 9:  #and
                    self[cmd[1]] =self[cmd[1]]&self[cmd[3]]
                elif op == 10: #xor
                    self[cmd[1]] =self[cmd[1]]^self[cmd[3]]
                elif op == 11: #or
                    self[cmd[1]] =self[cmd[1]] | self[cmd[3]]
            elif cmd[0] == 3:  # cmp ç›¸æ¸›
                self.data[ZR] = self[cmd[1]] - self[cmd[2]]
            elif cmd[0]==4: #jmp
                self.data[ip]=self[cmd[1]]
            elif cmd[0]==5: #$jmp
                op=self[cmd[2]]
                zr=self.data[ZR]
                tf=self.data[TF]
                if (op=='==' and  zr== 0) or (op=='!=' and zr != 0) or (op=='>=' and zr >= 0) or (
                        op=='<=' and zr <= 0) or (op=='>' and zr > 0) or (op=='<' and zr < 0):
                    self.data[ip] = self[cmd[1]]
                elif (op=='t' and tf) or (op=='f' and not tf):
                    self.data[ip] = self[cmd[1]]
            elif cmd[0]==6: #call
                jmp_ip=self[cmd[1]]
               # print('jmp:',jmp_ip)
                if jmp_ip==None:
                    jmp_ip=cmd[1][3]               #[mode,name,offset,key]ï¼Œå–å‡ºkey
                if type(jmp_ip)==Func:   #ä»£è¡¨è¦callå…§éƒ¨function
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    jmp_ip(*args,**kwargs)
                elif type(jmp_ip)==str:              #exfunction
                  #  print('exfunc')
                    args = self.data[args_location]
                    kwargs = self.data[kwargs_location]
                    tem_ip=self.data[ip]
                    self.data[0] = self.ex_function[jmp_ip](*args, **kwargs)  # å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                  #  print('get:',self.data[0])
                    self.data[ip]=tem_ip
                else:                                  #jmp_ipæ˜¯functionæœ¬èº«
                    args=self.data[args_location]
                    kwargs=self.data[kwargs_location]
                    tem_ip = self.data[self.ip]
                    #-------------------------------------------catch print
                    try:
                        call_func_name=jmp_ip.__name__
                    except:call_func_name=''
                    if call_func_name == 'print':
                        aprint(*args, **kwargs)
                    #-------------------------------------------
                    self.data[0]=jmp_ip(*args,**kwargs)            #å‘¼å«å¤–éƒ¨å‡½æ•¸ï¼Œç”±AXæ¥å—å›å‚³å€¼
                    self.data[self.ip] = tem_ip
            elif cmd[0] == 7:#push
                self.esp_stack[self.data[esp]]=self[cmd[1]]
                self.data[esp]-=1
            elif cmd[0] == 8:#pop
                self.data[esp] += 1
                self[cmd[1]]=self.esp_stack[self.data[esp]]
            elif cmd[0]==9:  #tfåˆ¤æ–·çœŸå‡
                event=self[cmd[2]]
                if event==0: #in
                    self.data[TF]=self[cmd[3]] in self[cmd[1]]
                elif event==1: #equ
                    self.data[TF]=self[cmd[3]]==self[cmd[1]]
                elif event ==2: # Ctn
                    self.data[TF] = self[cmd[3]] in self[cmd[1]].vars
                elif event ==3: # is
                    self.data[TF] = self[cmd[3]] is self[cmd[1]]
            elif cmd[0] == 10: #inc
                self[cmd[1]] += 1
            elif cmd[0] == 11:#dec
                self[cmd[1]] -= 1
            elif cmd[0]==12: #$oper
                op=self[cmd[2]]
                if op== 0:  # not
                    try:                                  #ç”¨tryæ˜¯æ€•ç‰©ä»¶ç„¡æ³•è½‰æ›:'NoneType' object cannot be interpreted as an integer
                        self[cmd[1]] = not self[cmd[1]]
                    except:
                        self[cmd[1]]=False
                elif op == 1:  #           è² æ•¸
                    self[cmd[1]] = -self[cmd[1]]
                elif op==2:  #          è£œæ•¸
                    self[cmd[1]] = ~self[cmd[1]]

            elif cmd[0]==13:                              #ex_func AX funcname BX
                tem_ip=self.data[ip]
                self[cmd[1]]=self.ex_function[self[cmd[2]]](self[cmd[3]])
                self.data[ip]=tem_ip
            elif cmd[0]==14: #--------------------------------------------------------------------------try
                error_ip=self[cmd[1]]
                if error_ip=='end':
                   # del self.run_layer[-1]                #tryæ­£å¸¸å¾Œæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return     #try end
                self.data[ip] += 1
                tem_esp=self.data[esp]           #å„²å­˜ç•¶å‰esp
                try:
                    self.__run(f'try {error_ip}')              #å¯èƒ½åœ¨å †ç–Šéç¨‹ä¸­æ–·
                                                               #å¯èƒ½å‡ºç¾yieldä¸­æ–·ï¼Œespè®Šå‹•
                except Exception as e:
                    self.error_line=self.data[ip]       #è¨»è¨˜ç™¼ç”ŸéŒ¯èª¤çš„ip
                    self.data[esp] = tem_esp  # é‚„åŸåŸæœ¬çš„esp
                    self.data[ER]=e
                    self.data[ip] = error_ip     #é‡åˆ°éŒ¯èª¤æ™‚ï¼Œè·³åˆ°åµéŒ¯ip
                del self.run_layer[-1]                   #å› ç‚ºå‰é¢æœ‰æ·»åŠ commentï¼Œæ­¤è™•éœ€del
            elif cmd[0]==15:  #finally
                f_ip=self[cmd[1]]
                finally_box.append((f_ip,self.data[self.esp]))
            elif cmd[0]==16: #raise
                raise self[cmd[1]]       #é€²å…¥exceptæœƒè‡ªå‹•delæ‰run_layer
            elif cmd[0]==17:  #error
                error=self[cmd[1]]
                if type(error)==list:
                    if Exception in error:
                        self.data[TF]=True
                    else:self.data[TF]=type(self.data[ER]) in error
                elif error==Exception:
                    self.data[TF]=True
                else:
                    self.data[TF] = type(self.data[ER])==error
            elif cmd[0]==18:  #Generator
                start_ip=self[cmd[2]]
                ex_k=3
                import_names={}   #(loc,stack)
                while ex_k<len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]
                    ex_k+=1
                self[cmd[1]]=generator(self,start_ip,import_names)
            elif cmd[0]==19:  #Yield
                if self.run_layer[-1]=='finally yield run':
                    raise Exception("Exception ignored in: <generator object>\nRuntimeError: generator ignored GeneratorExit")
               # del self.run_layer[-1]                    #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                return self.data[ip]+1,finally_box
            elif cmd[0] == 20:         #-------------------------------------------------------------- fetch
                tem_esp = self.data[esp]  # å„²å­˜ç•¶å‰esp
                tem_ip=self.data[ip]      #æš«å­˜ç•¶å‰ip
                try:
                    get=self[cmd[2]]
                    self[cmd[1]]=next(get)
                    self.data[TF]=True                 #æˆåŠŸ
                except StopIteration as e:                              #å› ç‚ºå‰é¢çš„tryæ²’æœ‰é™„åŠ run layerï¼Œæ­¤è™•exceptä¸æ¸…ç†ä»»ä½•run layer
                    self.data[TF]=False
                self.data[esp]=tem_esp
                self.data[ip]=tem_ip           #fetchçµæŸå¾Œç†è«–ä¸Šipä¸è®Š
            elif cmd[0]==21:  #stop
                print('ip---->',self.data[self.ip],'esp------>',self.data[self.esp])
              #  if self.tf!=1:
               #     get_status()
               # input()
               # self.tf=1
            elif cmd[0]==22:      #end
                command=self[cmd[1]]
                if command=='finally_yield' and self.run_layer[-1]=='finally yield run':
                   # del self.run_layer[-1]                                              #yield runçµæŸæœƒè‡ªå‹•delï¼Œæ­¤è™•ä¸éœ€è¦
                    return
                elif command=='Function':
                    func_name=self[cmd[2]]
                    if len(cmd)>3:
                        items_str = self[cmd[3]].split(',')
                        items = list(map(int, items_str))
                        for i in items:
                            self.func_stack[func_name][i]=None       #abort params
            elif cmd[0]==23:     #byte
                self[cmd[1]]=self[cmd[2]].encode()
               # del self[cmd[1]]
            elif cmd[0]==24:     #del
                op=self[cmd[1]]
                if op==0:    #åˆªé™¤å–®å…ƒç´ 
                    self[cmd[2]]=Undefine()
                elif op==1:  #åˆªé™¤AX[BX]
                    del self[cmd[2]][self[cmd[3]]]
                elif op==2:                         #åˆªé™¤  XXX.attr
                    del self[cmd[2]].vars[self[cmd[3]]]
            elif cmd[0]==25:     #Function
                func_ip=self[cmd[2]]
                func_class_obj=self[cmd[3]]
                func_stack_name=self[cmd[4]]
                func_stack_len=self[cmd[5]]
                ex_k = 6
                import_names= {}  #è¦åŒ¯å…¥çš„çˆ¶å‡½æ•¸åç¨±
                while ex_k < len(cmd):
                    func_name=self[cmd[ex_k]]
                    import_names[func_name]=self.func_stack[func_name]         #åœ¨å®£å‘Šæ™‚å°±å„²å­˜ç•¶å‰å †ç–Šè³‡è¨Š
                    ex_k += 1
                self[cmd[1]] = Func(self, func_ip,func_class_obj,func_stack_name,func_stack_len,import_names)
            elif cmd[0]==26: #pass
                pass
            elif cmd[0]==28:   #namespace
                var_box=self[cmd[3]].split(',')
                var_k=0
                var_dict={}
                for name in var_box:
                    var_dict[name]=var_k
                    var_k+=1
                stack=[Undefine()]*var_k
                namespace_name=self[cmd[2]]
                self.func_stack[namespace_name]=stack
                self[cmd[1]]=Namespace_stack(self,namespace_name,var_dict)
            elif cmd[0]==29:  #*args
                self[cmd[1]]=self[cmd[2]][self[cmd[3]]:]
            elif cmd[0]==30:  #kwargs
                key_dict=self[cmd[2]]
                not_need=self[cmd[3]].split(',')
                void_dict={}
                for key in key_dict:
                    if key not in not_need:
                        void_dict[key]=key_dict[key]
                self[cmd[1]]=void_dict
            elif cmd[0] == 31:  # module
                self[cmd[1]]=Ex_module(self[cmd[2]])
            elif cmd[0]==32:   #type
                self[cmd[1]].atype=self[cmd[2]]
            elif cmd[0]==33:   #name
                self[cmd[1]].name=self[cmd[2]]
            elif cmd[0] == 34:  #repl_print
                item=self[cmd[1]]
                if item!=None:
                    print(item)
                    total_output.append(str(item))
            self.data[ip]+=1
            if -self.data[esp]>self.stack_size:
                raise RecursionError('maxinum recursion depth exceeded')
        #del self.run_layer[-1]       #delè®“__runçš„è«‹æ±‚è€…delæ‰å°±å¥½ï¼Œè‡ªå·±ä¸ç”¨del
        if self.tf>0:
            get_status()
class Ex_module:    #å¼•å…¥å¤–éƒ¨å‡½æ•¸
    def __init__(self,module_name):
        self.module_name=module_name
        self.__name__='Ex_module'
        self.vars={}
    def __str__(self):
        return self.module_name
    def __call__(self, *args, **kwargs):
        raise TypeError("'module' object is not callable")
class Namespace_stack:
    def __init__(self,ram,stack_name,var_dict):
        self.stack_name=stack_name
        self.vars=namespace_stack_var(ram,stack_name,var_dict)
    def __str__(self):
        return f'module "{self.stack_name}"'
class namespace_stack_var:
    def __init__(self,ram,stack_name,var_dict):
        self.ram = ram
        self.name = stack_name
        self.var_dict = var_dict
    def __contains__(self, item):
        return item in self.var_dict
    def __setitem__(self, key, value):
        if key in self.var_dict:
            self.ram.func_stack[self.name][self.var_dict[key]]=value
        else:
            #ç™»è¨˜æ–°å±¬æ€§
            now_length=len(self.ram.func_stack[self.name])
            self.var_dict[key]=now_length
            self.ram.func_stack[self.name].append(value)            #åµŒå…¥æœ€å¾Œä¸€å€‹
    def __getitem__(self, item):
        return self.ram.func_stack[self.name][self.var_dict[item]]1197*110*ex_func.pyimport time     #time,sleep,ctime,localtime(tm_year,tm_mon,tm_mday,tm_hour,tm_min,tm_sec,tm_wday),gmtime,mktime,asctime,strftime,strptime
import math     #pi,e,ceil,floor,copysign,fabs,fmod,fsum,gcd,pow,sqrt,factorial,degrees,radians,sin,cos,tan,asin,acos,atan,exp,log,log1p,log2,log10,isclose,isfinite,isinf,isnan
import os       #getcwd,listdir,mkdir,chdir,rmdir,open,write,rename,remove,stat,close,path,system,walk,environ,_exit
import os.path  #isdir,isfile,abspath,basename,dirname,exists,getatime,getmtime,getctime,getsize,isabs,join,realpath,relpath,samefile,sameopenfile,samestat,split,splitext
import sys      #argv,platform,version_info,path,stdin,stdout,stderr,displayhook,exceptionhook,setrecursionlimit,setswitchinterval,settrace,setprofile
import random   #seed,getstate,setstate,getrandbits,randrange,randint,choice,choices,shuffle,sample,random,uniform,triangular,betavariate,expovariate,gammavariate,gauss,lognormvariate,normalvariate,vonmisesvariate,paretovariate,weibullvariate
#import requests #delete,get,head,patch,post,put,request
import socket   #socket(bind,listen,accept,send,recv),AF_INET,SOCK_STREAM,gethostname,gethostbyname,SOL_SOCKET,SO_REUSEADDR63564*19*module.py#åŸºæœ¬å‹æ…‹:
class Integer:                         #æ•´æ•¸
    def __init__(self,number):
        self.number=int(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class Float:                          #æµ®æ•´æ•¸
    def __init__(self,number):
        self.number=float(number)
    def __str__(self):
        return f'{self.number}'
    def write(self,codes):
        self.location=str(self.number)
class String:                          #å­—ä¸²
    def __init__(self,text,change=True):    #change:è‡ªå‹•æ”¹è®Š\',\nç¬¦è™Ÿ
        self.text=text
        self.change=change
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        if self.change:
            self.location=f'"{self.text}"'
        else:
            self.location=f"'{self.text}'"
class Byte:                          #å­—ä¸²
    def __init__(self,text):
        self.text=text
    def __str__(self):
        return f'"{self.text}"'
    def write(self,codes):
        codes.append(f'byte AX "{self.text}"')
        self.location=f'AX'
class Var_name:
    def __init__(self,name):           #è®Šæ•¸å
        self.name=name
    def __str__(self):
        return f'{self.name}'
#é€šç”¨è®Šæ•¸å‹æ…‹
class Namespace:
    def __init__(self,namespace=''):
        self.namespace=namespace
    def __str__(self):
        return f'{self.namespace}'
    def __eq__(self, other):
        return self.namespace==other
    def __contains__(self, item):
        return item in self.namespace
    def write(self,codes):
        if self.namespace!='':
            self.location=self.namespace
class Variable:
    def __init__(self,name,namespace):     #codelineæ˜¯æŸæ®µæŒ‡ç¨±è®Šæ•¸
        self.namespace=namespace
        self.name=name
    def __str__(self):
        return f'<var={self.name}>'
    def write(self,codes):
        if self.namespace!='':
            self.namespace.write(codes)
            self.location=f'{self.namespace.location}.{self.name}'
        else:self.location=self.name
class SubVariable:                          #å±¬æ€§æŒ‡ç¨±è®Šæ•¸
    def __init__(self,obj,attr):
        self.obj=obj                 #ä»»æ„ç‰©ä»¶
        self.attr=attr               #variable
    def __str__(self):
        return f'<obj={self.obj}  attr={self.attr}>'
    def write(self,codes):
        self.obj.write(codes)
        olocation=self.obj.location
        if '.' in olocation or '[' in olocation or olocation[0] in ('"',"'"):     #å¤ªé•·ï¼Œæˆ–æ˜¯å­—ä¸²
            codes.append(f'mov AX {self.obj.location}      ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²')
            self.location = f'AX.{self.attr.name}'
        else:self.location=f'{self.obj.location}.{self.attr.name}'
class Slice:
    def __init__(self,start_obj,end_obj,step_obj):
        self.start_obj=start_obj
        self.end_obj=end_obj
        self.step_obj=step_obj
    def __str__(self):
        return '<slice>'
    def write(self,codes):
        codes.append('push [3]')
        self.start_obj.write(codes)
        codes.append(f'mov <esp+1>[0] {self.start_obj.location}')
        self.end_obj.write(codes)
        codes.append(f'mov <esp+1>[1] {self.end_obj.location}')
        self.step_obj.write(codes)
        codes.append(f'mov <esp+1>[2] {self.step_obj.location}')
        codes.append('pop *args')
        codes.append('mov **kwargs [dict]')
        codes.append('call slice')
        self.location='AX'
class IndexVariable:
    def __init__(self,name,slice_obj):      #[a1:a2,a1:,a3...] => [(a1,a2),(a1,None),a3...]
        self.name=name
        self.slice_obj=slice_obj    #å–®å…ƒç´  or tuple
    def __str__(self):
        return f'<Index {self.name} slice={self.slice_obj}>'
    def write(self,codes):
        self.name.write(codes)
        codes.append(f'push {self.name.location}')
        self.slice_obj.write(codes)
        codes.append(f'mov BX {self.slice_obj.location}')
        codes.append('pop AX')
        self.location='AX[BX]'
#ä¸²åˆ—æ‰“åŒ…å‹æ…‹:
class List:
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        box=[]
        for obj in self.elements:
            box.append(str(obj))
        return '<List  '+','.join(box)+'>'
    def __getitem__(self, j):
        if j<len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append(f'mov AX [{len(self.elements)}]')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location='AX'
class Tuple:
    def __init__(self, elements):
        self.elements = elements
    def __str__(self):
        box = []
        for obj in self.elements:
            box.append(str(obj))
        return '<Tuple  ' + ','.join(box) + '>'
    def __getitem__(self, j):
        if j < len(self.elements):
            return self.elements[j]
        raise StopIteration
    def __len__(self):
        return len(self.elements)
    def write(self, codes):
        codes.append(f'mov AX ({len(self.elements)})')
        codes.append('push AX')
        for i in range(len(self.elements)):
            self.elements[i].write(codes)
            codes.append(f'mov <esp+1>[{i}] {self.elements[i].location}')
        codes.append('pop AX')
        self.location = 'AX'
class Dict:
    def __init__(self,elements):  #[(key,value),...]
        self.elements=elements
    def __str__(self):
        box=[]
        for key,value in self.elements:
            box.append(f'{key}:{value}')
        return '<Dict  '+','.join(box)+'>'
    def __len__(self):
        return len(self.elements)
    def write(self,codes):
        codes.append('push [dict]')
        for key,value in self.elements:
            key.write(codes)
            codes.append(f'push {key.location}')
            value.write(codes)
            codes.append(f'pop BX')
            codes.append(f'mov <esp+1>[BX] {value.location}')
        codes.append('pop AX')
        self.location = 'AX'
class Set:                           #é›†åˆ
    def __init__(self,elements):
        self.elements=elements
    def __str__(self):
        return '<set>'
    def write(self,codes):
        _tuple=Tuple(self.elements)
        _tuple.write(codes)
        codes.append(f'ex_func AX "set" {_tuple.location}')
        self.location='AX'
#é«˜éšæ‰“åŒ…å‹æ…‹:
def is_number(num):
    try:
        e=float(num)
        return True
    except:return False
class Lambda:
    def __init__(self,params,return_obj,namespace):
        self.params=params                   #{key:value,...}
        self.return_obj=return_obj
        self.namespace=namespace
    def __str__(self):
        return '<lambda>'
    def write(self,codes):
        tem_name = f'&lambda_{len(codes)}'
        _return=Backtrack(self.return_obj,'return')
        block_info=Info('')
        for key in self.params:
            block_info.add_info('var',Variable(key,''))
        block_info.codelines.append(_return)
        _def=Def(tem_name,self.params,block_info,self.namespace)
        _def.write(codes)
        if self.namespace == '':
            self.location=tem_name
        else:
            self.namespace.write(codes)
            loc=f'{self.namespace.location}.{tem_name}'
        #    codes.append(f'mov {loc} {tem_name}')
            self.location=loc
class Def:                                            #å‡½æ•¸å®šç¾©å‹æ…‹
    def __init__(self,fname,params,block_info,namespace):
        self.name=fname
        self.params=params        #{key:value,...}
      #  print('my params:',params)
        self.namespace = namespace
        self.codelines=block_info.codelines
        self.local_vars = block_info.locals
        self.in_class='^' in self.namespace
        self.orig_lines=('',0)
    def __str__(self):
        text=f'<Def {self.name}'
        vtext=[]
        for obj in self.codelines:
            vtext.append(str(obj))
        text+='{'+''.join(vtext)+'}'
        return text
    def write(self,codes):
        def get_name(string):
            sp='.[ ;'
            k,n=0,len(string)
            while k<n:
                if string[k] in sp:
                    return string[:k],string[k:]
                k+=1
            return string,''
        if self.namespace!='':                                 #å®£å‘Šè‡ªå·±çš„ç¨‹å¼é–‹å§‹ä½å€(<class>,ip)
            self.namespace.write(codes)
            declare_func=[len(codes),'BX',len(codes)+2,self.namespace.location,0]
            codes.append(0)
            codes.append(f'mov {self.namespace.location}.{self.name} BX')
        else:
            declare_func = [len(codes),self.name, len(codes) + 1,None, 0]
            codes.append(0)
        codes.add_tab()
        skip_ip=len(codes)                      #ä¸Šä¸€è¡Œçš„ç¨‹å¼éœ€è¦è·³éè‡ªå·±
        codes.append(0)             #é¡å¤–1
        #ç¨‹å¼é–‹å§‹å‰æº–å‚™------------------------------------------------------------
        self.func_var=f'{self.name}_{skip_ip}'       #è‡ªå·±çš„å †ç–Š
       # codes.append(f'push {self.func_var}')        #å°‡è‡ªå·±ä¸Šæ¬¡çš„espå­˜èµ·ä¾†
        codes.append('push **kwargs')
        codes.append('push *args')
        #é–‹è™•è™•ç†åƒæ•¸
        i=0      #ç´¯è¨ˆä½¿ç”¨åƒæ•¸æ•¸é‡
        keybox=[]   #ç´¯è¨ˆä½¿ç”¨åƒæ•¸å
      #  print('#############')
       # print(self.params)
        #print('namespace:',self.namespace)
        class_obj=None
        params=tuple(self.params)
        for key in params:
            if self.in_class and class_obj==None:                 #è‹¥æ˜¯classï¼Œæ“·å–ç¬¬ä¸€å€‹åƒæ•¸
                class_obj=key
                continue
            if key[:2]=='**':   #ä»£è¡¨æ˜¯kwargs
                key_text=','.join(keybox)
                codes.append(f'**kwargs <esp+2>["{key[2:]}"] <esp+2> "{key_text}"')
                self.params[key[2:]]=self.params[key]
                del self.params[key]
                keybox.append(key[2:])
            elif key[0]=='*':
                codes.append(f'*args <esp+2>["{key[1:]}"] <esp+1> {i}')
                self.params[key[1:]] = self.params[key]
                del self.params[key]
                keybox.append(key[1:])
            else:
                keybox.append(key)
                codes.append('cmp CX 0')
                skip_param=len(codes)
                codes.append(0)
                codes.append(f'tf <esp+2> "in" "{key}"')     #æŸ¥çœ‹keyæ˜¯å¦åœ¨å·²æœ‰åƒæ•¸ä¸­
                skip_param2=len(codes)
                codes.append(0)
                self.params[key].write(codes)
                codes.append(f'mov <esp+2>["{key}"] {self.params[key].location}')
                codes.append(f'jmp {len(codes)+2}')
                codes[skip_param]=f'$jmp {len(codes)-1} "!="'
                codes.append(f'mov <esp+2>["{key}"] <esp+1>[{i}]')
                codes.append('dec CX')
                codes[skip_param2]=f'$jmp {len(codes)-1} "t"'
                i+=1
        #è¨ˆç®—éparamçš„localæ•¸é‡
        local_num = 0
        local_dict = {}
        for key in self.params:
            local_num+=1
            local_dict[key]=local_num             #å°‡è‡ªå·±åƒæ•¸åŠ å…¥
        for var in self.local_vars:
            if var not in self.params and var not in local_dict:
                local_num+=1
                local_dict[var]=local_num
        declare_func[4]=local_num+1
        codes[declare_func[0]]=f'Function {declare_func[1]} {declare_func[2]} {declare_func[3]} "{self.func_var}" {declare_func[4]}'    #æ–°å»ºé™£åˆ—[0,1,2,3,...]
        #--------------------------------------------------------------------åœ°é»(åå­—)ï¼Œipï¼Œclass_obj,local_num+1,...
        return_ips=[]
        #çœŸæ­£çš„ç¨‹å¼é–‹å§‹----------------------------------------------------------------------------------åƒæ•¸ç§»å‹•
        codes.append(f'')
        for key in self.params:
            if key!=class_obj:
                #if key[:2]=='**':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[2:]}"]')
                #elif key[0]=='*':
                #    codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key[1:]}"]')
                #else:
                codes.append(f'mov <{self.func_var}+{local_dict[key]}> <esp+2>["{key}"]')
        yield_ip = len(codes)
        codes.append(0)  # é€™è£¡é€²è¡Œ2é¸ä¸€ï¼Œä»¥ç¨‹å¼ä¸­æ˜¯å¦æœ‰yieldä½œç‚ºåˆ¤æ–·
        codes.append(0)
        # çœŸæ­£çš„ç¨‹å¼é–‹å§‹--------------------------------------------------------------------------------------
        have_yield=False
        p = len(codes)
        for obj in self.codelines:
            obj.write(codes)             #æ¯ä¸€æ®µvoid_codeéƒ½æ˜¯ç¨ç«‹çš„
        def save_gen(num):
            if len(add_Function)>0 and num not in add_Function[-1][1]:
                add_Function[-1][1].append(num)
            if len(add_Generator)>0 and num not in add_Generator[-1][1]:
                add_Generator[-1][1].append(num)
    #------------------------------------------------------------------------------------ç¨‹å¼çµ„æ…‹è¨­å®š
        def in_global(word):
            for items in global_words:
                if word in items:
                    return True
            return False
        add_Generator=[]            #å…§å®¹:(len(codes),)
        add_Function=[]         #è‡ªå·±æœ‰å“ªäº›å­æ¶µæ•¸?è¦åœ¨é€™äº›å­æ¶µæ•¸çš„æ¨™æŠ•æ¬„æ·»åŠ è‡ªå·±åƒæ•¸çš„å †ç–Šåç¨±
        global_words=[[]]      #ç•¶è‡ªå·±æˆ–å­æ¶µæ•¸å®£å‘Šglobalæ™‚ï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal__words=[]     #è‡ªå·±æ‰€å®£å‘Šçš„nonlocal wordï¼Œä¸å¯åšåƒæ•¸æ›¿æ›
        nonlocal_ips=[]       #è‡ªèº«å®£å‘Šnonlocalæ™‚çš„ipï¼Œ
        not_abort=[]                         #ä¸å¯åœ¨ç¨‹å¼çµæŸå¾Œå¾å †ç–ŠéŠ·æ¯€çš„è®Šæ•¸ï¼ŒåŒ…å«add_Generator,add_Function
        def parse_line(line):
            box=[]
            k,n=0,len(line)
            while k<n:
                p=k
                if line[p] in ('"',"'"):
                    c=line[p]
                    k=p+1
                    while line[k]!=c:
                        if line[k]=='\\':k+=1
                        k+=1
                    k+=1
                while k<n and line[k]!=' ':k+=1
                box.append(line[p:k])
                k+=1
            return box
        for i in range(len(codes)-p):
            line=codes[p+i]
            if '"' in line or "'" in line:
                deal=parse_line(line)
            else:
                deal=line.split(' ')
            if deal[0]=='return':           #è™•ç†return
                return_ips.append(p+i)
                continue
            elif deal[0]=='global':
                global_words[-1].append(deal[1])           #è¨»è¨˜globalï¼Œé€²å…¥å…¶ä»–functionæ™‚ï¼Œä¸å¯é€²è¡Œåƒæ•¸æ›¿æ›
          #      print(p+i,deal[1])
            elif deal[0]=='nonlocal':          #è‡ªå·±æ¨™è¨˜çš„nonlocal
                nonlocal__words.append(deal[1])
                nonlocal_ips.append(p+i)
         #       print(p+i,deal[1])
            if deal[0] == 'yield':
                deal[0] ='Yield'     #å°‡yieldæ›æˆYieldè¡¨ç¤ºè¢«è™•ç†é
                have_yield=True
            elif deal[0]=='Function':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Function.append((p+i,[]))
                global_words.append([])
            elif deal[0]=='Generator':                                 #æœ‰å­æ¶µæ•¸æœƒç”¨åˆ°è‡ªå·±çš„è®Šæ•¸
                add_Generator.append((p+i,[]))
            elif deal[0]=='end':
                if deal[1]=='"Function"':          #å„²å­˜çµæœ
                    f_row,items=add_Function[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort+=items                    #å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        func_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[f_row]=codes[f_row]+func_add_text
                  #  print('------------------item:',items)
                    del add_Function[-1]
                   # print(f'{self.name} before del:',global_words)
                    del global_words[-1]
                elif deal[1]=='"Generator"':          #å„²å­˜çµæœ
                    g_row,items=add_Generator[-1]
                    if len(items)>0:                #æœ‰æ±è¥¿æ‰å„²å­˜
                        not_abort += items  # å› ç‚ºæœ‰å­æ¶µæ•¸ç”¨åˆ°è‡ªå·±çš„åƒæ•¸ï¼Œå› æ­¤åœ¨è‡ªå·±çµæŸå¾Œï¼Œé€™äº›åƒæ•¸ä¸åœ¨å †ç–Šä¸­é€²è¡ŒéŠ·æ¯€
                        gen_add_text=f' "{self.func_var}"'    #åŠ ä¸Š""ä»¥å…è¢«åˆ¤å®šç‚ºæ•¸å€¼
                        codes[g_row]=codes[g_row]+gen_add_text
                    del add_Generator[-1]
                continue
            for j in range(len(deal)):                      #å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                if j==0 or deal[j]=='':continue
                if deal[j][0] in ('"',"'"):   #ä»£è¡¨æ˜¯å­—ä¸²
                    continue
                if deal[j][0]==';':     #ä»£è¡¨æ˜¯è¨»è§£
                    break
                var,back=get_name(deal[j])
                if not in_global(var) and var not in nonlocal__words:
                    if var == '': break
                    elif var==class_obj:
                        deal[j]=f'<{self.func_var}+0>'+back
                       # deal.append(f'        ;æ­¤ç‚ºclass obj')
                        save_gen(local_num+4)
                    elif var in self.params:                     #è‡ªå·±çš„åƒæ•¸
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
                    elif var in self.local_vars:
                        deal[j]=f'<{self.func_var}+{local_dict[var]}>'+back
                      #  deal.append(f'        ;é€™å€‹åƒæ•¸ç‚º  {var}')
                        save_gen(local_dict[var])
            codes[p+i]=' '.join(deal)
        need_abort=[]
        for i in range(local_num+1):
            if i not in not_abort:
                need_abort.append(str(i))
        #---------------------------------------------------------------æ¸…é™¤nonlocalï¼Œä»¥å…è¢«å…¶ä»–function(çˆ¶å‡½æ•¸)è®€å–
        for non_ip in nonlocal_ips:
            codes[non_ip]=''
        #----------------------------------------------------------------------------------------------------------
        # returnå¾Œç›´é”ç¨‹å¼çµæŸ
        endip = len(codes)
        if len(return_ips)>0 and return_ips[-1]==endip-1:
            for rip in return_ips:
                codes[rip]=f'jmp {endip-1}         ;returné»'
        else:
            for rip in return_ips:
                codes[rip]=f'jmp {endip}'
            if have_yield:
                codes.append('mov AX ""')
            else:
                codes.append('mov AX None')            #return None
        #é‚„åŸå †ç–Šï¼Œreturn_ipè·³åˆ°æ­¤
        if have_yield:             #å¦‚æœæœ‰yieldï¼Œå‰‡return AXï¼Œä¸¦ä¸”ç™¼ç”ŸéŒ¯èª¤
            stopiteration=FuncCall(Variable('StopIteration',''),List([Variable('AX','')]),Dict({}))
            _raise=Backtrack(stopiteration,'raise')
            _raise.write(codes)
            codes.append('stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡Œ')
         #   codes.append(f'$mov esp "+" 1      ;ç¢ºä¿å¾raiseå¾Œå¯é›¢é–‹')
          #  codes.append('pop ip')
            codes[yield_ip] = f'Generator AX {yield_ip + 2} "{self.func_var}"'  # Generatoråœ°é»ï¼Œå§‹ipï¼Œè¦å„²å­˜çš„å †ç–Šåç¨±
            codes[yield_ip + 1] = f'jmp {len(codes) - 1}      ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ip'  # è·³åˆ°pop ip
            codes.append('end "Generator"')  # çµ„è­¯å™¨èªè¨€ï¼Œçµ¦è‡ªå·±çœ‹çš„
        else:
            codes[yield_ip] = ''  # f'$mov esp "-" {local_num}'                                        #æ­£å¸¸æƒ…æ³
            codes[yield_ip + 1] = ''  # f'mov {self.func_var} esp'
        #----------------------------------------------------------------å¦‚æœæœ‰yieldï¼Œå‰‡ç›´æ¥è·³åˆ°pop ip
        codes.append(f'$mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸')
        if have_yield:
            codes.append(f'end "Function" "{self.func_var}"')           #å› ç‚ºé‚„è¦é€²ä¾†ï¼Œå› æ­¤ä¸åˆªé™¤è‡ªèº«ä»»ä½•è®Šæ•¸
        else:
            codes.append(f'end "Function" "{self.func_var}" '+'"'+','.join(need_abort)+'"')        #åœ¨é€™è£¡ä¹‹å¾Œå°±ä¸ç”¨å†æ›¿æ›è®Šæ•¸äº†
        codes.append('pop ip')       #pop ipè·³åˆ°ç¨‹å¼æœ€å¾Œä¸€è¡Œreturn
        codes.del_tab()
        codes[skip_ip]=f'jmp {len(codes)-1}           ;è·³éæ­¤å‡½æ•¸'
class FuncCall:                                       #å‡½æ•¸å‘¼å«å‹æ…‹
    def __init__(self,name,args,kwargs,s_args=None,s_kwargs=()):  #name,args,kwargséƒ½æ˜¯objå‹æ…‹
        self.name=name
        self.args=args
        self.kwargs=kwargs
        self.s_args=s_args
        self.s_kwargs=s_kwargs
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Call {self.name} args={self.args} kwargs={self.kwargs}>'
    def __getitem__(self, item):
        return IndexVariable(Variable('AX',''),Integer(item))
    def write(self,codes):
        def deal_cx_args_kwargs(args,call_name):
            codes.append(f'push {len(args)}        ;å„²å­˜CX')  # ä¸åŒ…å«ï¼Œå°±å…¨æ¨
            args.write(codes)
            codes.append(f'push {args.location}  ;ç‚ºcall {call_name} åšæº–å‚™', simplify=self.in_class)
            if self.s_args != None:
                self.s_args.write(codes)
                codes.append(f'ex_func AX "list" {self.s_args.location}')    #AXè½‰ç‚ºé™£åˆ—
                codes.append(f'ex_func BX "len" AX')     #BXç‚ºé™£åˆ—é•·åº¦
                codes.append('$mov <esp+2> "+" BX')       #åŸCXå¢åŠ 
                codes.append('$mov <esp+1> "+" AX')       #AXå¢åŠ 
            self.kwargs.write(codes)
            if len(self.s_kwargs)>0:
                codes.append(f'push {self.kwargs.location}')
                for s_kwargs in self.s_kwargs:
                    s_kwargs.write(codes)
                    codes.append('mov *args [1]')
                    codes.append(f'mov *args[0] {s_kwargs.location}')
                    codes.append('mov **kwargs [dict]')
                    codes.append('call <esp+1>.update')
                codes.append('pop **kwargs')
            else:
                codes.append(f'mov **kwargs {self.kwargs.location}')
            codes.append('pop *args')
            codes.append(f'pop CX     ;å–å›CX')  # æ‰¹æ¬¡è®“Defè¼‰å…¥åƒæ•¸
            if need_push_name:
                codes.append('pop AX')
                codes.append('call AX')
            else:
                codes.append(f'call {call_name}')
        codes.append('',self.orig_lines)
        self.name.write(codes)
        self.in_class = '^' in self.name.location       #function callçš„namespaceåŒ…å«åœ¨nameä¸­
        need_push_name=self.name.location[:2]=='AX' or '&' in self.name.location
        if need_push_name:codes.append(f'push {self.name.location}')
        if self.in_class:
            space,name=self.name.location.split('.')
            codes.append(f'tf {space} "Ctn" "{name}"')    #æŸ¥çœ‹æ­¤å‡½æ•¸æ˜¯å¦åŒ…å«nameé€™å€‹function
            jmp_if_true=len(codes)          #åŒ…å«å°±è·³
            codes.append(0)
            #---------------------------------------------------å› ç‚ºä¸åŒ…å«ï¼Œæ‰€ä»¥å‘¼å«å¤–éƒ¨function
            deal_cx_args_kwargs(self.args,name)
            jmp_leave=len(codes)
            codes.append(0)
            #-----------------------------------------------------------------æœ‰åŒ…å«ï¼Œæ¨args[1:]ä¸¦å‘¼å«
            codes[jmp_if_true]=f'$jmp {len(codes)-1} "t"'
            args=List(self.args.elements[1:])     #è‹¥åŒ…å«ï¼Œå°±åªæ¨[1:]
            deal_cx_args_kwargs(args,self.name.location)
            #-------------------------------------------------------é›¢é–‹
            codes[jmp_leave]=f'jmp {len(codes)-1}'
        else:                                                     #-----------------------------ä¸åœ¨classè£¡çš„æ­£å¸¸æ¨¡å¼ä¸­
            deal_cx_args_kwargs(self.args,self.name.location)
        self.location='AX'
class Backtrack:           #å›å‚³
    def __init__(self,value,cmd):
        self.A=value
        self.cmd=cmd
        self.orig_lines=('',0)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location!='AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'{self.cmd} AX',self.orig_lines)
        self.location='AX'
class Var_declare:                      #è®Šæ•¸çš„å„ç¨®å®£å‘Š
    def __init__(self,value,cmd):      #del,global,nonlocal
        self.value=value
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.value}>'
    def write(self,codes):
        self.value.write(codes)
        if self.cmd=='del':
            if '.' in self.value.location:     #XXX.attr
                class_obj,key=self.value.location.split('.')
                codes.append(f'del 2 {class_obj} "{key}"')
            elif self.value.location[:3]=='AX[':    #AX[BX]
                codes.append('del 1 AX BX')
            else:
                codes.append(f'del 0 {self.value.location} None')
        else:
            codes.append(f'{self.cmd} {self.value.location}')
class Try_Except:
    def __init__(self,try_codelines,except_objects,else_codelines=(),finally_codelines=(),namespace=''):   #except_dict:{error_term:(as_name,codelines) }
        self.try_codelines=try_codelines
        self.except_objects=except_objects
        self.else_codelines=else_codelines
        self.finally_codelines=finally_codelines               #å³ä½¿exceptæ²’æŠ“åˆ°éŒ¯èª¤ï¼Œä¹Ÿå¿…å®šæœƒåŸ·è¡Œï¼Œç„¶å¾Œæ‰ç”¢ç”ŸéŒ¯èª¤
        self.namespace=namespace
        self.orig_lines = []
    def __str__(self):
        return f'<Try Except>'
    def write(self,codes):
        ol=0
        to_finally_ip=len(codes)               #å®£å‘Šå¿…å®šå¾—è¦åŸ·è¡Œçš„finallyä½ç½®
        codes.append(0,self.orig_lines[ol])   #finally ip
        to_except_ip=len(codes)                                     #try error_ip
        codes.append(0)   #try except_ip
        #----------------------------------------------**åƒæ•¸è’é›†ç®±
        SD = {'continue': [], 'break': [], 'return': []}        #å…¨åŸŸè’é›†
        yield_box=[]                                            #åªè™•ç†tryä¸­çš„
        #----------------------------------------é–‹å§‹å¯«try
        start_p=len(codes)                                 #é–‹å§‹æª¢æŸ¥çš„åŸºåº•p
        codes.add_tab()
        for obj in self.try_codelines:
            obj.write(codes)
        codes.del_tab()
        ol+=1
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†tryä¸­yield
            cmd = codes[start_p+i].split(' ')[0]
            if cmd=='yield':
                yield_box.append(start_p+i)
        #----------------------------------------
        codes.append('try "end"')           #åœæ­¢try
        try_leave = len(codes)                               # -----------------è·³åˆ°else
        codes.append(0)
        #-----------------------------------------é–‹å§‹å¯«except
        if self.namespace!='':
            self.namespace.write(codes)
            ispace=f'{self.namespace.location}.'
        else:ispace=''
        e=0
        try_except_ip = f'try {len(codes) - 1}'
        try_push_0= []
        jmp_push_0=[]
        jmp_push_1 = []  # æ”¶é›†å¾exceptçµæŸé€šå¾€finallyçš„ip
        for i in range(len(self.except_objects)+1):            #(obj,as_name,codelines)
            if e==0:
                codes[to_except_ip]=try_except_ip
                e=1
            else:
                codes[to_except_ip] = f'$jmp {len(codes) - 1} "f"'
            if i<len(self.except_objects):
                codes.append('', self.orig_lines[ol])
                ol += 1
                error_data = self.except_objects[i]
                error_data[0].write(codes)
                codes.append(f'error {error_data[0].location}')
                to_except_ip=len(codes)
                codes.append(0)
                if error_data[1]!=None:            #ä»£è¡¨æœ‰as
                    codes.append(f'mov {ispace}{error_data[1]} $Exception')
                codes.append('mov $Exception 0')               #æ¸…ç©ºException
                #---------------------------------exceptå…§å®¹é–‹å§‹
                try_push_0.append(len(codes))
                codes.append(0)
                codes.add_tab()
                for obj in error_data[2]:
                    obj.write(codes)
                codes.del_tab()
                codes.append('try "end"')
                jmp_push_1.append(len(codes))
                codes.append(0)
            else:                     #åŸ·è¡Œåˆ°æ­¤ä»£è¡¨éŒ¯èª¤éƒ½æ²’æœ‰è¢«æŠ“åˆ°
                jmp_push_0.append(len(codes))              #ç›´æ¥è·³åˆ°push 0
                codes.append(0)
                #_raise=Raise(Variable('$Exception',''))
                #_raise.write(codes)
        # -------------------------------è™•ç†tryä¸­çš„yield
        for yield_ip in yield_box:
            codes[yield_ip]=f'jmp {len(codes)-1} ;è™•ç†tryä¸­çš„yield'
            codes.append('try "end"')
            codes.append('yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡')
            codes.append(try_except_ip)
            codes.append(f'jmp {yield_ip}     ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œ')
        #--------------------------------------------------é–‹å§‹å¯«else
        jmp_to_finally=[]
        codes[try_leave]=f'jmp {len(codes)-1}    ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°else'
        if len(self.else_codelines) > 0:
            codes.append('',self.orig_lines[ol])
            ol+=1
            codes.add_tab()
            try_push_0.append(len(codes))
            codes.append(0)
            for obj in self.else_codelines:
                obj.write(codes)
            codes.append('try "end"')
            codes.del_tab()
        push_1=len(codes)-1
        for jp0 in jmp_push_1:
            codes[jp0]=f'jmp {push_1}  ;è·³åˆ°push 1'
        codes.append('push None  ;æ¨å…¥None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 1     ;ä»£è¡¨æ­£å¸¸')
        jmp_to_finally.append(len(codes))
        codes.append(0)
        #-------------------------#è™•ç†continue,break,return
        stype_SD={}
        for i in range(len(codes)-start_p):                    #---------------------------------è™•ç†try,except,elseä¸­çš„continue,break,return
            if type(codes[start_p+i])==str:
                cmd = codes[start_p+i].split(' ')[0]
                if cmd in SD:
                    SD[cmd].append(start_p+i)
        stype=2
        for key in SD:
            if len(SD[key])>0:
                jmp_ip = len(codes)-1
                for ip in SD[key]:
                    codes[ip]=f'jmp {jmp_ip}'
                if key=='return':
                    codes.append('push AX')
                else:
                    codes.append('push None')        #å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
                codes.append('try "end"')  # åœæ­¢try
                codes.append(f'push {stype}')
                jmp_to_finally.append(len(codes))
                codes.append(0)                       #jmp to_finally
                #é€²è¡Œè¨»å†Š
                stype_SD[stype]=key
                stype+=1
        #-------------------------æ”¶é›†æ‰€æœ‰éŒ¯èª¤é€²ä¾†è€…
        push_0= len(codes) - 1
        for tp0 in try_push_0:
            codes[tp0]=f'try {push_0}'
        for jp0 in jmp_push_0:
            codes[jp0]=f'jmp {push_0} ;push 0'
        codes.append('push None')  # å¹³è¡¡ä¸€ä¸‹returnï¼Œæ²’æ±è¥¿ä¹Ÿè¦push
        codes.append('push 0')
        #--------------------------------------------------------------------------é–‹å§‹å¯«finally
        finally_ip=len(codes)-1
        codes[to_finally_ip]=f'finally {finally_ip}'
        for jtf in jmp_to_finally:
            codes[jtf]=f'jmp {finally_ip}    ;è·³åˆ°finally'
        codes.append(f'finally -{finally_ip}')
        finally_p=len(codes)
        if len(self.finally_codelines)>0:
            codes.append('push $Exception')        #å„²å­˜éŒ¯èª¤è¨Šæ¯
            codes.append('mov $Exception 0')
            codes.append('', self.orig_lines[ol])
            ol += 1
            codes.add_tab()
            for obj in self.finally_codelines:
                obj.write(codes)
            codes.del_tab()
          #  codes.append('pop $Exception')        #å–å›éŒ¯èª¤è¨Šæ¯
        #-------------------------------æŠ“å–finallyä¸­çš„continue(å¯¦éš›ä¸å‡ºç¾)ï¼Œbreakï¼Œreturn
        finally_events={'continue':[],'break':[],'return':[]}
        for i in range(len(codes)-finally_p):                    #---------------------------------è™•ç†tryä¸­yieldï¼Œå¼·åˆ¶æ·¨åŒ–ä¹‹å‰çš„æ•ˆæœ
            if type(codes[finally_p+i])==str:
                cmd = codes[finally_p+i].split(' ')[0]
                if cmd in finally_events:
                    finally_events[cmd].append(finally_p+i)
        #-------------------------------------è™•ç†ä¹‹å‰pushçš„é—œéµè©ï¼Œæ­¤è™•ç‚ºä¸­é–“æ²’æœ‰breakæˆ–returnä¸­æ–·çš„å¾ŒçºŒ
        if len(self.finally_codelines)>0:
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
        codes.append('pop AX')
        leave_SD={}
        for stype in stype_SD:
            codes.append(f'cmp AX {stype}')
            leave_SD[len(codes)]=stype_SD[stype]
            codes.append(0)
        codes.append('cmp AX 1')
        jmp_to_leave=len(codes)
        codes.append(0)
        codes.append('pop AX')                             #å¾0èµ°è‡³æ­¤ï¼Œé‚„åŸå †ç–Š
        _raise=Backtrack(Variable('$Exception', ''),'raise')
        _raise.write(codes)
        #--------------------------------
        for key in finally_events:            #å¾finallyä¸­breakæˆ–returnçš„äº‹ä»¶
            if len(finally_events[key])>0:
                jmp_ip=len(codes)-1
                for ip in finally_events[key]:
                    codes[ip]=f'jmp {jmp_ip}       ;è·³è‡³finallyä¸­çš„äº‹ä»¶:{key}'
                codes.append('$mov esp "+" 3')    #å»é™¤é—œéµè©ï¼Œç„¡è«–å…ˆå‰æ˜¯ç”šéº¼éƒ½ä¸é‡è¦(å›å‚³å€¼None,åˆ¤æ–·å€¼0,éŒ¯èª¤error)
                codes.append(key)
        #---------------------------------
        for lip in leave_SD:                        #å¾try,except,elseä¸­çš„continue,break,returnäº‹ä»¶
            codes[lip]=f'$jmp {len(codes)-1} "=="'                   #å¾2,3,4é›¢é–‹è‡³æ­¤
            codes.append('pop $Exception')  # å–å›éŒ¯èª¤è¨Šæ¯
            codes.append('pop AX')                     #é‚„åŸAXå †ç–Š
            codes.append(leave_SD[lip])
        #--------------------------------
        codes[jmp_to_leave]=f'$jmp {len(codes)-1} "=="'            #å¾1é›¢é–‹è‡³æ­¤
        codes.append('pop AX')                          #é‚„åŸAXå †ç–Š
        codes.append('end "finally_yield"')
class With:
    def __init__(self,call_obj,orig_as_name,as_name,with_codelines,namespace):
        self.call_obj=call_obj
        self.orig_as_name=orig_as_name
        self.as_name=as_name
        self.with_codelines=with_codelines
        self.namespace=namespace
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<with>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        codes.add_tab()
        self.orig_as_name.write(codes)
        self.call_obj.write(codes)    #å®šç¾©å¥½åƒæ•¸argså’Œkwargsï¼Œpush ip,call (<class>,ip)
        codes.append(f'mov {self.orig_as_name.location} {self.call_obj.location}')
       # codes.append('stop')
        _enter_call=FuncCall(Variable(f'{self.orig_as_name.location}.__enter__',''),List([]),Dict({}))       #æœƒå…ˆpush ipå†callï¼Œæ•…é¡åˆ¥ä½ç½®ç‚º<esp+2>
        _enter_call.write(codes)
        if self.as_name!=None:                          #as_nameç²å–__enter__æ‰€å›å‚³çš„æ±è¥¿
            codes.append(f'push {_enter_call.location}')
            self.as_name.write(codes)
            codes.append(f'pop {self.as_name.location}')
        #--------------------------------------------------------------------
        try_codelines=self.with_codelines
        except_objects=[]
        else_codelines = []            #ç•¶å‰å †ç–Š:<class_obj>,(finallyçš„returnç‰©ä»¶),stype,æ­¤functionæ‰€pushçš„ipï¼Œæ•…è¦å‘¼å«ä½ç½®ç‚º<esp+4>
        _exit_call = FuncCall(Variable(f'{self.orig_as_name.location}.__exit__', ''), List([TFN(None), TFN(None), TFN(None)]), Dict({}))
        finally_codelines =[_exit_call]
        _try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines)
        _try_except.orig_lines=[('',0),('',0),('',0)]
        _try_except.write(codes)
        codes.del_tab()
        #codes.append('inc esp     ;é‚„åŸwithçš„<class_objç‰©ä»¶>')
class Stop:
    def __init__(self):
        pass
    def __str__(self):
        return '<$stop>'
    def write(self,codes):
        codes.append('stop')
class Command:
    def __init__(self,cmd_list):
        self.cmd_list=cmd_list
    def __str__(self):
        return f'<cmd_list>'
    def write(self,codes):
        for cmd in self.cmd_list:
            codes.append(cmd)
class sub_if_else:
    def __init__(self,event,true_item,false_item):           # A if B else C
        self.event=event
        self.true_item=true_item
        self.false_item=false_item
    def __str__(self):
        return f'<A if else B>'
    def write(self,codes):
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        jne_false=len(codes)
        codes.append(0)
        self.true_item.write(codes)
        if self.true_item.location!='AX':
            codes.append(f'mov AX {self.true_item.location}   ;true item')
        leave_ip=len(codes)
        codes.append(0)
        codes[jne_false]=f'$jmp {len(codes)-1} "!="   ;è·³åˆ°false'
#        print('false item:',self.false_item)
        self.false_item.write(codes)
 #       print('location:',self.false_item.location)
        if self.false_item.location!='AX':
            codes.append(f'mov AX {self.false_item.location}   ;false item',simplify=1)   #ä¸‹ä¸€è¡Œå¯èƒ½æœƒmov item AXï¼Œæœƒè¢«ç°¡åŒ–å°è‡´éŒ¯èª¤
        codes[leave_ip]=f'jmp {len(codes)-1}   ;é›¢é–‹sub_if_else'
        self.location='AX'
class If_else:                                        #if,elseå‹æ…‹
    def __init__(self,if_items,else_codelines):     #if_items=[[event_obj,codelines],...]
        self.if_items=if_items
        self.else_codelines=else_codelines
        self.orig_lines=[]
    def __str__(self):
        text=[f'if {self.if_items[0][0]}:']
        for obj in self.if_items[0][1]:text.append(str(obj))
        for i in self.if_items[1:]:
            text.append(f'elif {i[0]}:')
            for obj in i[1]:text.append(str(obj))
        if len(self.else_codelines)>0:
            text.append('else:')
            for obj in self.else_codelines:text.append(str(obj))
        return ''.join(text)
    def write(self,codes):
        need_set_end=[]
        ol=0
        for event,block in self.if_items:
            codes.append('',self.orig_lines[ol])
            ol+=1
            event.write(codes)          #é€²è¡Œæ¢ä»¶é‹ç®—
            codes.append(f'cmp {event.location} 1')
            codes.add_tab()
            jip=len(codes)
            codes.append(0)                         #jneæ¢ä»¶è¢«å¦å®šæ™‚è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·
            for obj in block:obj.write(codes)       #æ¢ä»¶æˆç«‹å‰‡ç¹¼çºŒåŸ·è¡Œ
            need_set_end.append(len(codes))         #åŸ·è¡ŒçµæŸç›´æ¥è·³è‡³åº•éƒ¨
            codes.append(0)
            codes[jip]=f'$jmp {len(codes)-1} "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·'          #ä¸‹ä¸€å¥åˆ¤æ–·çš„ä½ç½®
            codes.del_tab()
        if len(self.else_codelines)>0:
            codes.append('',self.orig_lines[ol])
            codes.add_tab()
            for obj in self.else_codelines:obj.write(codes)               #çµæŸåŸ·è¡Œ
            codes.del_tab()
        for ip in need_set_end:
            codes[ip]=f'jmp {len(codes)-1}        ;è·³è‡³åº•éƒ¨'           #è¨­å®šåº•éƒ¨
class While:                                          #whileå‹æ…‹
    def __init__(self,event,codelines,else_codelines):
        self.event=event
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return f'event:{self.event} do:{self.codelines}'
    def write(self,codes):
        again_ip=len(codes)
        codes.append('',self.orig_lines)
        self.event.write(codes)
        codes.append(f'cmp {self.event.location} 1')
        codes.add_tab()
        out_ip=len(codes)
        codes.append(0)          #ä¸æ˜¯Trueï¼Œè·³å‡ºè¿´åœˆ
        break_box=[]
        for obj in self.codelines:
            p=len(codes)
            obj.write(codes)
            for i in range(len(codes)-p):
                cmd=codes[p+i].split(' ')[0]
                if cmd=='continue':
                    codes[p+i]=f'jmp {again_ip-1}'     #continueè·³å›é–‹é ­
                elif cmd=='break':
                    break_box.append(p+i)
        codes.append(f'jmp {again_ip-1}               ;continueé‡ä¾†')     #é‡ä¾†
        #----------------------------------------
        to_else_ip=len(codes)-1
        codes[out_ip]=f'$jmp {to_else_ip} "!="'              #åœ¨whileåˆ¤å®šç‚ºFalseæ™‚ï¼Œè·³åˆ°else
        for obj in self.else_codelines:
            obj.write(codes)
        #----------------------------------------
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip]=f'jmp {break_ip}          ;breakå‡º'
        codes.del_tab()
class sub_for_loop:
    def __init__(self,express,vnames,base_obj,if_obj,is_list):
        self.express=express
        self.vnames=vnames
        self.base_obj=base_obj
        self.if_obj=if_obj
        self.is_list=is_list
    def __str__(self):
        return '<sub for loop>'
    def write(self,codes):
        _yield=Backtrack(self.express,'yield')        #expresséè³¦å€¼è®Šæ•¸ï¼Œä¸ç”¨è¨»å†Š
        if self.if_obj!=None:
            _if=If_else([[self.if_obj,[_yield]]],[])
            _if.orig_lines=[('',0),('',0),('',0)]
            _for_loop=For_loop(self.vnames,self.base_obj,[_if],[])
        else:
           # print(self.vnames)
          #  print(self.base_obj)
            _for_loop = For_loop(self.vnames, self.base_obj, [_yield],[])
        info = Info('')
        for var in self.vnames:
            info.add_info('var', var)
        info.write(_for_loop,('',0))
        id=len(codes)
        fDef=Def(f'&generator_{id}',{},info,'')      #functionæœ¬èº«ä¸æœƒè¢«å…¶ä»–ç‰©ä»¶å‘¼å«ï¼Œä¸éœ€è¦namespaceï¼Œ&ä»¥len(codes)ä½œç‚ºæ¨™èªŒï¼Œä¸æœƒæ‰¾éŒ¯
        fDef.write(codes)
        codes.append('push 0        ;å„²å­˜CX')
        codes.append('push [0]')
        codes.append('mov **kwargs [dict]')
        codes.append('pop *args')
        codes.append('pop CX     ;å–å›CX')
        codes.append(f'call &generator_{id}')
#        fcall=FuncCall(Variable(f'&generator_{id}',''),List([]),Dict({}))
 #       fcall.write(codes)
        if self.is_list:
            codes.append(f'ex_func AX "list" AX')
        self.location='AX'
class For_loop:                                       #for,loopå‹æ…‹
    def __init__(self,vnames,base_obj,codelines,else_codelines):                 #varuables=[name1,name2,...]
        self.vnames=vnames
        self.base_obj=base_obj
        self.codelines=codelines
        self.else_codelines=else_codelines
        self.orig_lines=('',0)
    def __str__(self):
        return '<For loop>'
    def write(self,codes):
        self.base_obj.write(codes)
        #base_obj_name=f'&base_obj_{len(codes)}'
        codes.append(f'ex_func AX "iter" {self.base_obj.location}',self.orig_lines)                        #å°‡base_objè½‰ç‚ºiterå­˜èµ·ä¾†
        codes.add_tab()
        codes.append('push AX')
       # codes.append('stop')
        #-------------------------------
        again_ip=len(codes)                           #æ¯ä¸€åœˆçš„èµ·å§‹é»
        codes.append(f'fetch AX <esp+1>')                                           #å¾base_objå–å‡ºä¸€å€‹å€¼åˆ°AXï¼Œå–å‡ºæˆåŠŸæ™‚TF=1ï¼Œå¦å‰‡TF=0
        leave_ip=len(codes)                             #æ¯”è¼ƒç™¼ç¾ç„¡æ³•å–å‡ºæ±è¥¿è·³å‡º
        codes.append(0)
        if len(self.vnames)==1:                                  #é–‹å§‹åˆ†é…åƒæ•¸
            self.vnames[0].write(codes)
            codes.append(f'mov {self.vnames[0].location} AX')
        else:
            #codes.append('mov AX <esp+3>[CX]')
            for i in range(len(self.vnames)):
                self.vnames[i].write(codes)
                codes.append(f'mov {self.vnames[i].location} AX[{i}]')
        #---------------------------------------------------------å‡½æ•¸é–‹å§‹
        break_box = []
        return_box=[]
        for obj in self.codelines:
            p = len(codes)
            obj.write(codes)
            for i in range(len(codes) - p):
                cmd = codes[p + i].split(' ')[0]
                if cmd == 'continue':
                    codes[p + i] = f'jmp {again_ip - 1}'  # continueè·³å›é–‹é ­
                elif cmd == 'break':
                    break_box.append(p + i)
                elif cmd=='return':                   #æ­¤æ™‚è¦returnçš„ç‰©ä»¶å·²ç¶“å­˜åœ¨AX
                    return_box.append(p+i)
        codes.append(f'jmp {again_ip-1}')
        #-------------------------------------è¿´åœˆçµæŸ
        if len(return_box)>0:
            return_leave_ip=len(codes)                      #æ‰€æœ‰returnéƒ½è·³åˆ°é€™è£¡
            for r_ip in return_box:
                codes[r_ip]=f'jmp {return_leave_ip-1}'
            codes.append('inc esp')                       #é‚„åŸå †ç–Š
            codes.append('return AX')                       #è£œè¶³return
        #-------------------------------------breakæˆ–æ­£å¸¸é›¢é–‹åˆ°æ­¤
        out_ip=len(codes)-1
        codes[leave_ip] = f'$jmp {out_ip} "f"'                  # ç„¡æ³•å–å‡ºæ±è¥¿æ™‚ï¼Œtf=0ï¼Œè·³è‡³else
        for obj in self.else_codelines:
            obj.write(codes)
        #--------------------------------                   #ä¸­é€”breakçš„ç›´æ¥è·³å‡º
        break_ip=len(codes)-1
        for b_ip in break_box:
            codes[b_ip] = f'jmp {break_ip}          ;breakå‡ºè¿´åœˆ'
        codes.append('inc esp')                                     #é‚„åŸå †ç–Š
        codes.del_tab()
class Mark:                    #æ¨™èªŒ
    def __init__(self,mark):
        self.mark=mark
    def __str__(self):
        return f'<mark {self.mark}>'
    def write(self,codes):
        codes.append(self.mark)
class Pass:
    def __init__(self):
        pass
    def __str__(self):
        return '<pass>'
    def write(self,codes):
        pass
class TFN:                 #True,False,None
    def __init__(self,value):
        self.value=value
    def __str__(self):
        return f'<{self.value}>'
    def write(self,codes):
        self.location=self.value
class Class:
    def __init__(self,name,info,namespace,class_esp,father=None):
        self.name=name
        self.functions=info.funcs
        #for func_key in self.functions:
         #   self.functions[func_key].in_class=True
        self.codelines=info.codelines
        self.namespace=namespace
        self.class_esp=class_esp
        self.father=father
        self.orig_lines=('',0)
    def __str__(self):
        return f'<class {self.name}>'
    def write(self,codes):
        #codes.append('mov BX [func]',self.orig_lines)
       # set_ip=len(codes)
       # codes.append(0)
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'Function BX {len(codes) + 3} {self.namespace.location} "{self.class_esp}" 1', self.orig_lines)
            class_param=f'{self.namespace.location}.{self.name}'
            codes.append(f'mov {class_param} BX')
        else:
            class_param=self.name
            codes.append(f'Function {class_param} {len(codes) + 2} None "{self.class_esp}" 1', self.orig_lines)  # åœ°é»(åå­—)ï¼Œipï¼Œclass_obj
        codes.append(f'name {class_param} "<class \'__main__.{self.name}\'>"')     #è¨»å†Šé¡åˆ¥åç¨±
        codes.add_tab()
        skip_class_ip=len(codes)
        codes.append(0)                                           #è·³éè‡ªå·±
        #------------------------------------------------------
        codes.append('tf $Inheritance "equ" None')          #åˆ¤æ–·å‘¼å«è‡ªå·±çš„äººæ˜¯å¦è¦ç¹¼æ‰¿è‡ªå·±ï¼Œç”¨equå› ç‚ºæ€•inheritanceç‚ºundefined
        codes.append(f'$jmp {len(codes)+3} "t"')        #jt ip 'f'
        codes.append(f'mov <{self.class_esp}> $Inheritance')
        codes.append('push 1')              #è¦ç¹¼æ‰¿
        codes.append(f'jmp {len(codes)+2}')
        codes.append(f'mov <{self.class_esp}> [class]')
        codes.append('push 0')
        codes.append('mov $Inheritance None')      #æ¸…ç©ºç¹¼æ‰¿
        # ------------------------------------------------------å„²å­˜CX,args,kwargs
        codes.append('push CX')
        codes.append('push *args')
        codes.append('push **kwargs')  # å…ˆå°‡å®£å‘Šç”¨çš„argså’Œkwargså„²å­˜èµ·ä¾†
        #--------------------------------------------------------
        if self.father!=None:
            if type(self.father)==Tuple:
                deal=self.father.elements
            else:deal=[self.father]
           # print(deal)
            for father in deal:
                #-----------------------------åœ¨çˆ¶å‡½æ•¸writeå‰è¦å…ˆpush cx,args,kwargs
                father.write(codes)
                #------------------------------åœ¨callçˆ¶å‡½æ•¸å‰å…ˆå–å›åƒæ•¸
                codes.append('mov **kwargs <esp+1>')
                codes.append('mov *args <esp+2>')
                codes.append('mov CX <esp+3>')
                #------------------------------
                codes.append(f'mov $Inheritance <{self.class_esp}>')
                codes.append(f'call {father.location}')
        #------------------------------------------------------
        codes.append(f'type <{self.class_esp}> {class_param}')     #è¨»å†Šè‡ªå·±çš„é¡åˆ¥
        #é€²è¡Œå€åŸŸç‰©ä»¶å®£å‘Š
        for obj in self.codelines:
            obj.write(codes)
        #-------------------------------------------------------
        #åœ¨æ‰€æœ‰å‡½æ•¸å®£å‘ŠçµæŸå¾Œï¼Œå¦‚æœè‡ªå·±æœ‰å»ºç«‹__init__ï¼Œå°±é€²å…¥
        codes.append(f'mov AX <{self.class_esp}>')  # å–å›è‡ªå·±class
        codes.append('pop **kwargs')
        codes.append('pop *args')
        codes.append('pop CX')
        #----------------------------------------
        codes.append('pop BX')           #å–å›ç¹¼æ‰¿åˆ¤æ–·
        codes.append('cmp BX 1')         #åˆ¤æ–·æ˜¯å¦ç¹¼æ‰¿
        leave_init_ip=len(codes)
        codes.append(0)           #å¦‚æœè¦ç¹¼æ‰¿ï¼Œå°±è·³éinitã€‚$jmp ip "t"
        #----------------------------------------
        codes.append('tf AX "Ctn" "__init__"')             #æ˜¯å¦åŒ…å«__init__é€™å€‹å®£å‘Š?
        codes.append(f'$jmp {len(codes)+1} "t"')                 #å¦‚æœåŒ…å«initå°±call
        skip_init_ip=len(codes)
        codes.append(0)
        codes.append('call AX.__init__')
        codes.append(f'mov AX <{self.class_esp}>')                   #å–å›è‡ªå·±
        #------------------------------------------------------
        end=len(codes)-1
        codes[leave_init_ip]=f'$jmp {end} "=="'
        codes[skip_init_ip]=f'jmp {end}'
        codes.append(f'end "Function" "{self.class_esp}"')
        codes.append('pop ip')      #å›å»ç¨‹å¼çš„å®£å‘Šè™•
        #----------------------------------------------------------
        codes[skip_class_ip] = f'jmp {len(codes) - 1}'
        self.location='AX'
        codes.del_tab()
#è³‡æ–™ç§»è½‰å‹æ…‹
def two_object_write(A,B,codes):
    A.write(codes)
    if A.location[:3] == 'AX.' or A.location=='AX':  # Aç‚ºsubvariable
        codes.append('push AX')
        B.write(codes)
        codes.append(f'mov BX {B.location}')
        codes.append('pop AX')
        blocation = 'BX'
    elif A.location[:3] == 'AX[':  # Aç‚ºindexvariableï¼Œlocationå¿…ç‚ºAX[BX]
        codes.append('push AX')
        codes.append('push BX')
        B.write(codes)
        codes.append(f'mov DX {B.location}')
        codes.append('pop BX')
        codes.append('pop AX')
        blocation = 'DX'
    else:  # æ­£å¸¸æƒ…æ³
        B.write(codes)
        blocation = B.location
    return blocation
#class Mov:
#    def __init__(self,A,B,op='='):
#        self.A=A
#        self.B=B
##        cmd={'+=':'add','-=':'sub','*=':'mul','/=':'div','%=':'quo','//=':'rem','**=':'pow',
# #            '<<=':'shl','>>=':'shr','&=':'and','^=':'xor','|=':'or'}
#        if op=='=':
#            self.ctype=0
#            self.cmd='mov'
#        else:
#            self.ctype=1
#            self.cmd=op[:-1]     #å°‡ç­‰è™Ÿå»é™¤
#        self.orig_lines = ('', 0)
#    def __str__(self):
#        return f'<{self.cmd} {self.A} {self.B}>'
#    def write(self,codes):
#        codes.append('',self.orig_lines)
#        blocation=two_object_write(self.A,self.B,codes)
#        if self.ctype == 0:
#            codes.append(f'mov {self.A.location} {blocation}')
#        elif self.ctype == 1:
#            codes.append(f'$mov {self.A.location} "{self.cmd}" {blocation}')
class Multiple_Mov:
    def __init__(self,obj_list,target,op):
        self.obj_list=obj_list
        self.target=target
        if op == '=':
            self.ctype = 0
            self.cmd = 'mov'
        else:
            self.ctype = 1
            self.cmd = op[:-1]  # å°‡ç­‰è™Ÿå»é™¤
        self.orig_lines = ('', 0)
    def __str__(self):
        return '<Multiple mov>'
    def write(self,codes):
        codes.append('', self.orig_lines)
        self.target.write(codes)
        codes.append(f'push {self.target.location}')
        for obj in self.obj_list:
            if type(obj) in (Tuple,List):
                for i in range(len(obj)):
                    obj[i].write(codes)
                    if self.ctype == 0:
                        codes.append(f'mov {obj[i].location} <esp+1>[{i}]')
                    elif self.ctype == 1:
                        codes.append(f'$mov {obj[i].location} "{self.cmd}" <esp+1>[{i}]')
            else:
                obj.write(codes)
                if self.ctype == 0:
                    codes.append(f'mov {obj.location} <esp+1>')
                elif self.ctype == 1:
                    codes.append(f'$mov {obj.location} "{self.cmd}" <esp+1>')
        codes.append('inc esp')          #é‚„åŸå †ç–Š
#é‹ç®—å‹æ…‹
class Oper:
    def __init__(self,A,B,symbol):
        self.A=A
        self.B=B
        self.symbol=symbol#{'+':'add','-':'sub','*':'mul','/':'div','**':'pow','%':'quo','//':'rem','<<':'shl','>>':'shr','&':'and','^':'xor','|':'or'}[symbol]
       # self.oper=('+','-','*','/','**','%','//','<<','>>','&','^','|').index(symbol)
    def __str__(self):
        return f'<{self.A} {self.symbol} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'push {self.A.location}')
        self.B.write(codes)
        codes.append(f'oper <esp+1> "{self.symbol}" {self.B.location}')
        codes.append('pop AX')
        self.location = 'AX'
#é‚è¼¯é‹ç®—ç¬¦
class Tf:   #çœŸå‡åˆ¤æ–·å¼
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
       # self.oper=('in','equ','Ctn','is').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
       # print('tf:  ',self.A,self.B,self.cmd)
        blocation=two_object_write(self.A,self.B,codes)
        codes.append(f'tf {self.A.location} "{self.cmd}" {blocation}')    #Bæ˜¯å¦cmdåœ¨A
        codes.append('mov AX TF')
        self.location='AX'
class AndOr:
    def __init__(self,A,B,cmd):
        self.A=A
        self.B=B
        self.cmd=cmd
    def __str__(self):
        return f'<{self.cmd} {self.A} {self.B}>'
    def write(self,codes):
        self.A.write(codes)
        codes.append(f'cmp {self.A.location} 1')          #ç›¸åŒå°±ç¹¼çºŒï¼Œå¦å‰‡è·³è‡³mov AX 0
        jip=len(codes)
        codes.append(0)
        self.B.write(codes)
        codes.append(f'cmp {self.B.location} 1')           #å¤±æ•—å°±è·³è‡³mov AX 0
        lip = len(codes)
        codes.append(0)
        if self.cmd=='and':       #å…©é‚Šéƒ½è¦Trueï¼Œjip,lipç‚ºFalseæ™‚è·³åˆ°0
            codes.append('mov AX 1')
            codes.append(f'jmp {len(codes)+1}')          #æˆåŠŸå°±è·³émov AX 0
            to_false=len(codes)-1
            codes.append('mov AX 0', simplify=1)
            codes[jip]=f'$jmp {to_false} "!="'
            codes[lip]=f'$jmp {to_false} "!="'
        elif self.cmd=='or':       #å…©é‚Šéƒ½è¦Falseï¼Œjip,lipç‚ºTrueæ™‚è·³åˆ°1
            codes.append('mov AX 0')
            codes.append(f'jmp {len(codes) + 1}')  # å¤±æ•—å°±è·³émov AX 1
            to_true = len(codes) - 1
            codes.append('mov AX 1', simplify=1)
            codes[jip] = f'$jmp {to_true} "=="'
            codes[lip] = f'$jmp {to_true} "=="'
        self.location='AX'
class Deny:       #å¦å®šoperator
    def __init__(self,A,cmd):
        self.A=A
        self.cmd=cmd
        #self.oper=('not','-','~').index(cmd)
    def __str__(self):
        return f'<{self.cmd} {self.A}>'
    def write(self,codes):
        self.A.write(codes)
        if self.A.location != 'AX':
            codes.append(f'mov AX {self.A.location}')
        codes.append(f'$oper AX "{self.cmd}"')
        self.location = 'AX'
#çœŸå‡åˆ¤æ–·ç¬¦
class Bool:
    def __init__(self,enequalbox):     #enebox=[var,==,var,!=,var...]
        self.enebox=enequalbox
    def __str__(self):
        text=''
        for i in self.enebox:
            text+=str(i)
        return text
    def write(self,codes):
        k=0
        self.enebox[0].write(codes)           #è¨ˆç®—ç¬¬ä¸€å€‹
        codes.append(f'push {self.enebox[0].location}')        #å°‡çµæœå­˜èµ·ä¾†
        need_set_end=[]
        need_set_tf=[]
        cmp_dict={'==':'f','!=':'t','>':'<=','<':'>=','>=':'<','<=':'>'}            #å¦å®šæ™‚è·³é›¢ç¬¦
        while k<len(self.enebox)-1:
            self.enebox[k+2].write(codes)             #è¨ˆç®—ç¬¬äºŒå€‹
            codes.append('pop DX')           #å°‡ç¬¬ä¸€å€‹çš„çµæœæ”¾åœ¨DX  (ä¸Šä¸€å€‹çš„çµæœå¯èƒ½åœ¨AX,AX[BX],xxx.attr)
            if self.enebox[k+1] in ('==','!='):
                codes.append(f'tf DX "equ" {self.enebox[k + 2].location}')
                need_set_tf.append((len(codes),cmp_dict[self.enebox[k+1]]))
            else:
                codes.append(f'cmp DX {self.enebox[k+2].location}')       #å°‡ç¬¬äºŒå€‹çš„å€¼èˆ‡ç¬¬ä¸€å€‹
                need_set_end.append((len(codes),cmp_dict[self.enebox[k+1]]))              #Trueå°±ç¹¼çºŒæ¯”è¼ƒä¸‹å»ï¼ŒFalseå‰‡è·³è‡³mov AX 0
            codes.append(0)                            #è‹¥æ¯”è¼ƒçµæœç‚ºFalseå‰‡è·³é›¢
            if k+3<len(self.enebox):
                codes.append(f'push {self.enebox[k+2].location}')        #å°‡ç¬¬äºŒå€‹çµæœçš„å€¼å­˜èµ·ä¾†
            k+=2
        codes.append('mov AX True')                         #ç•¶æ¢ä»¶æˆåŠŸåˆ°æœ€å¾Œï¼Œè¨­ç½®AXç‚º1
        codes.append(f'jmp {len(codes)+1}')                                     #è·³émov AX 0æŒ‡ä»¤
        end = len(codes)-1  # æ‰€æœ‰ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤è¡Œ
        codes.append('mov AX False',simplify=1)                #ä¸­é–“å¤±æ•—çš„éƒ½è·³åˆ°æ­¤ï¼Œè¨­ç‚ºFalse
        for i in need_set_end:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
        for i in need_set_tf:
            codes[i[0]]=f'$jmp {end} "{i[1]}"'
       # codes.append('dec esp')                       #å †ç–ŠæŒ‡æ¨™å›å»ä¸€å€‹
        self.location='AX'
#ç‰¹æ®ŠåŠŸèƒ½å‡½æ•¸
class Assert:
    def __init__(self,event,msg):
        self.event=event
        self.msg=msg
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<assert {self.event}, {self.msg}>'
    def write(self,codes):
        codes.append('',self.orig_lines)
        not_event=Deny(self.event,'not')
        assertionerror = FuncCall(Variable('AssertionError', ''), List([self.msg]), Dict({}))
        _raise = Backtrack(assertionerror, 'raise')
        if_obj=If_else([[not_event,[_raise]]],[])
        if_obj.orig_lines=[('',0)]
        if_obj.write(codes)
class STR:
    def __init__(self,obj):
        self.obj=obj
    def __str__(self):
        return f'<STR: {self.obj}>'
    def write(self,codes):
        self.obj.write(codes)
        codes.append(f'ex_func AX "str" {self.obj.location}')
        self.location='AX'
#------------------------------------------------------------------ç¨‹å¼è³‡è¨Š
class Info:                             #ç”¨ä¾†è¨˜éŒ„parse_blockè³‡è¨Š
    def __init__(self,namespace):
        self.locals=[]
        self.vars={}
        self.funcs={}       #fname:fDef
        self.classes={}
        self.codelines=[]
        self.namespace=namespace
    def add_info(self,type,obj):
        if type=='var':
            self.vars[obj.name]=obj
        elif type=='func':
            self.funcs[obj.name]=obj
        elif type=='class':
            self.classes[obj.name]=obj
        if obj.name not in self.locals:
            self.locals.append(obj.name)
    def update(self,info):
        self.locals+=info.locals
        self.vars.update(info.vars)
        self.funcs.update(info.funcs)
        self.classes.update(info.classes)
    def write(self,codeline,orig_codelines):
        def deal_orig(orig_codeline):
            box = []
            for obj in orig_codeline:
                if type(obj)==int:
                    box.append(' '*obj)
                else:box.append(str(obj)+' ')
            return ''.join(box)
        self.codelines.append(codeline)
        #if type(orig_codelines)==list:
        #    nbox=[]
        #    for line in orig_codelines:
        #        nbox.append((deal_orig(line[0]),line[1]))
        #else:nbox=(deal_orig(orig_codelines[0]),orig_codelines[1])
        codeline.orig_lines=orig_codelines14*111*newtext.txt59891*110*package.py#æ‰“åŒ…ç¨‹å¼ç¢¼
from os import listdir,getcwd,chdir
from os.path import isdir,isfile
from apython.code import Code
from apython.module import *

def parse_code(code):  # æ‰“åŒ…ç¨‹å¼ç¢¼ç‚º[codeline_1,codeline_2,...]
    def hex_to_int(hex):
        string='0123456789abcdef'
        total,base=0,1
        for i in range(len(hex)):
            total+=string.index(hex[-i-i])*base
            base*=16
        return str(total)
    def deal_string(k,change=True):  # kç‚º',"çš„ä½ç½®
        c = code[k]
        k += 1
        p = k
        while True:
            c2=code[k]
            if c2=='\n':
                cline[0]+=1   #é¡å¤–åŠ ä¸€è¡Œ
            if c2 == '\\':
                k += 1
            elif c2 == c:
                break
            k += 1
        get_text=code[p:k]
       # print('c:',c,change)
        if (c=="'" and not change) or (c=='"' and change):      #ä»£è¡¨å…§å®¹æ‹¬è™Ÿç‚º"ï¼Œèˆ‡stringä¸€æ¨£
            return String(get_text,change=change),k
        elif c == "'" and change:
            text = []
            ck, n = 0, len(get_text)
            while ck < n:
                if get_text[ck]=='"':
                    text.append('\\')
                if get_text[ck]=='\\':
                    text.append(get_text[ck])
                    ck += 1
                text.append(get_text[ck])
                ck += 1
            return String(''.join(text),change=change), k
        elif c=='"' and not change:      #è£¡é¢å¯èƒ½æœ‰"
            text=[]
            ck,n=0,len(get_text)
            while ck<n:
                if get_text[ck]=='"':
                    text.append('\\')
                text.append(get_text[ck])
                if get_text[ck]=='\\':
                    text.append('\\')
                ck+=1
            return String(''.join(text)),k
    key_word=['def','while','for','in','if','elif','else','class','break','continue','return',':','and','not','or',
              'True','False','None','from','import','as','is','with','raise','try','except','finally','yield',
              'lambda','del','global','nonlocal','assert','$stop']        #ç„¡æ³•è¢«ç•¶æˆè®Šæ•¸çš„å…ƒç´ ï¼Œ$stopæ˜¯apythonèªè¨€
    data_dict = {'AX': 0, 'BX': 1, 'CX': 2, 'DX': 3, 'ip': 4, 'esp': 5, 'sp': 6, 'ZR': 7, 'TF': 8}      #codeä¸­çš„ç¦ç”¨é—œéµå­—åç¨±
    k, n = 0, len(code)
    codelines = []
    in_brackets=0
    in_lambda=0
    orig_code=code.split('\n')
    cline=[1]         #æ­¤ç‚ºçœŸå¯¦è¡Œ
    codeline = [(0,cline[0],orig_code[cline[0]-1])]                   #0ä»£è¡¨å‰ç½®ç©ºæ ¼æ•¸é‡,lineç‚ºç¬¬å¹¾è¡Œ,å¾Œæ–¹ç‚ºåŸå§‹ç¨‹å¼
    while k < n:
      #  print('codeline:',codeline)
      #  input()
        c = code[k]
        if c in '0123456789':  # ä»£è¡¨æ­¤ç‚ºæ•¸å€¼
            p = k
            numbers = '0123456789.xabcdefXABCDEF'
            while k < n:
                if code[k] in numbers:
                    k += 1
                else:
                    break
            number=code[p:k].lower()
            if number[:2]=='0x':
                number=hex_to_int(number[2:])
            if '.' in number:codeline.append(Float(number))
            else:codeline.append(Integer(number))
            k -= 1
        elif c in '+-*/,()[]{}!=%:><.&^|~':  # é‹ç®—å–®å…ƒç´ 
            if k+2<n:
                c3=code[k:k+3]
                if c3 in ('**=','//=','>>=','<<='):
                    codeline.append(c3)
                    k += 3
                    continue
            if k+1<n:
                c2=code[k:k+2]
                if c2 in ('+=','-=','*=','/=','==','!=','**','>','<','>=','<=','%=','//','>>','<<','&=','^=','|='):
                    codeline.append(c2)
                    k += 2
                    continue
            codeline.append(c)
            if c in ('(','[','{'):in_brackets+=1
            elif c in (')',']','}'):in_brackets-=1
            if c==':' and in_brackets==0: #-----------------------------------------------------------è™•ç†å†’è™Ÿ
                if in_lambda>0:
                    in_lambda-=1
                else:
                    try:
                        q=code.index('\n',k)        #å¦‚æœæ‰¾ä¸åˆ°\nä»£è¡¨æ˜¯æœ€å¾Œä¸€è¡Œäº†
                    except:q=len(code)
                    if q-k>1:
                        codelines.append(codeline)
                        #cline+=1                    #åœ¨åŒä¸€è¡Œï¼Œclineä¸åŠ ä¸€
                       # print('codeline:',codeline)
                        codeline = [(codeline[0][0]+4,cline[0],orig_code[cline[0]-1])]   #[(ç©ºæ ¼æ•¸,ç¬¬å¹¾è¡Œ,åŸå§‹ç¨‹å¼),...]
                        k+=1
                        while code[k]==' ':k+=1
                        k-=1
        elif c == '#':  # ç•¥éè¨»è§£
            while k < n and code[k] != '\n':
                k += 1
            k -= 1
        elif c in ('"', "'"):  # å­—ä¸²
            string,k=deal_string(k)
            if len(codeline)>0 and type(codeline[-1])==String:    #é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == '\n':    #å¦‚æœin_bracketsï¼Œå‰‡å¿½ç•¥\n
            cline[0]+=1
            if in_brackets==0:
                if len(codeline)>1:
                    codelines.append(codeline)
                codeline = []
                # -----------------------------è¨ˆç®—ä¸‹ä¸€è¡Œçš„ç©ºæ ¼ï¼Œå³ä¾¿æ²’æœ‰ç©ºæ ¼ä¹Ÿéœ€è¦
                k += 1
                if k < n:
                    space_num=0             #ç©ºæ ¼æ•¸é‡
                    while k < n and code[k] == ' ':
                        k += 1
                        space_num+=1
                    codeline.append((space_num,cline[0],orig_code[cline[0]-1]))       #æ¯å€‹[]çš„ç¬¬ä¸€å€‹ç‚ºç©ºæ ¼æ•¸é‡
                k -= 1
        elif c == 'r' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k += 1
            string, k = deal_string(k,change=False)
            if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(string)
        elif c == 'b' and k + 1 < n and code[k + 1] in ('"', "'"):    #byteé¡å‹
            k+=1
            string,k=deal_string(k)
            if len(codeline) > 0 and type(codeline[-1]) == Byte:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                codeline.append('+')
            codeline.append(Byte(string.text))
        elif c=='f' and k+1<n and code[k+1] in ('"',"'"):          #ä»£è¡¨æ˜¯f'aaa{bbb}aaa'é¡å‹
           # print('é€™è£¡2')
            codeline.append('(')
            symbol=code[k+1]
            q=k+2
            while code[q] != symbol or code[q-1]=='\\':
                q += 1
            get=code[k+2:q]
           # print('getç‚º:',get)
            sn=len(get)
            sk=0
            textbox = []
            while sk<sn:
                if get[sk]=='\n':
                    cline[0]+=1
                if get[sk]=='{':
                    if get[sk+1]=='{':
                        textbox.append('{')
                        sk+=1
                    else:                                   #å…§åµŒè®Šæ•¸
                        #å…ˆå„²å­˜å…ˆå‰çš„
                        if len(codeline) > 0 and type(codeline[-1]) == String:  # é€£çºŒå…©å€‹stringè‡ªå‹•ç›¸åŠ 
                            codeline.append('+')
                        codeline.append(String(''.join(textbox)))
                        textbox=[]
                        sk+=1
                        p=sk
                        #ç´¢å¼•è‡³ä¸‹ä¸€å€‹"}"
                        slock=0            #å­—ä¸²é–
                        c=1                #{é–
                        while c>0:
                            sc = get[sk]
                            if slock==0:
                                if sc=='{':
                                    c+=1
                                elif sc=='}':
                                    c-=1
                                elif sc in ("'",'"'):      #å•Ÿå‹•å­—ä¸²é–ï¼Œé–‹å§‹å¿½ç•¥{}
                                    slock=sc
                            else:
                                if sc==slock and get[sk-1]!='\\':    #è§£é™¤å­—ä¸²é–
                                    slock=0
                            sk+=1
                        sk-=1                 #ç‚ºäº†è®“get[sk]å®šä½åœ¨"}"
                        vartext=get[p:sk]        #ç›®å‰get[sk]=="}"
                        sub_codeline=parse_code(vartext)[0][1:]        #ç†è«–ä¸Šåªæœ‰ä¸€è¡Œï¼Œå»é™¤æœ€å‰æ–¹çš„0
                        codeline+=['+',Var_name('$str'),'(']+sub_codeline+[')','+']
                elif get[sk]=='}' and get[sk:sk+2]=='}}':
                    textbox.append(get[sk])
                    sk+=1
                elif get[sk]=='\\':
                    textbox.append(get[sk])
                    sk+=1
                    textbox.append(get[sk])
                elif get[sk] in ('"',"'"):
                    textbox.append('\\')
                    textbox.append(get[sk])
                else:
                    textbox.append(get[sk])
                sk+=1
            codeline.append(String(''.join(textbox)))
            codeline.append(')')
            k=q
        elif c!=' ':                         # ä»£è¡¨æ­¤ç‚ºè‡ªå®šç¾©è®Šæ•¸
        #    print('c:',c)
          #  print('end')
            v_name = []
            ban_word = '+-*/,()[]{}!=%:><.&^|~\\# \n:'   #åœ¨è®Šæ•¸ä¸­ç¦æ­¢å‡ºç¾çš„å…ƒç´ 
            while k < n:
                if code[k] not in ban_word:
                    v_name.append(code[k])
                    k += 1
                else:
                    break
            element_name=''.join(v_name)
            if element_name in key_word:
                if element_name=='True':codeline.append(TFN(True))
                elif element_name=='False':codeline.append(TFN(False))
                elif element_name == 'None':codeline.append(TFN(None))
                elif element_name == '$stop':codeline.append(Stop())
                else:codeline.append(element_name)
                if element_name=='lambda':in_lambda+=1
            else:
                #if len(codeline)>=2 and codeline[-1] in ('*','**') and codeline[-2] in ('(',','): #ä»£è¡¨æ˜¯key word argument
                #    codeline[-1]=Var_name(codeline[-1]+element_name)
                #else:                                                 #ä¸€èˆ¬é—œéµå­—
                if element_name in data_dict:
                    element_name='$$'+element_name
                codeline.append(Var_name(element_name))
            k -= 1
      #  else:
       #     print('nononono')
        k += 1
       # print(code[k:])
    if len(codeline)>1:
        codelines.append(codeline)
    #print('ç²å–codelines:\n[')
    #for line in codelines:
    #    if len(line)>0:
    #        print('[',end='')
    #        for i in range(len(line)-1):
    #            print(line[i],',',end='')
    #        print(line[-1],'],')
    #    else:print('[],')
    #print(']\n')
    return codelines
#---------------------------å·¥å…·å‡½æ•¸
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
          #  print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def get_var(codeline,k,namespace):                        #å¾ké–‹å§‹å–å¾—ä¸€å€‹è®Šæ•¸
    n=len(codeline)
    if k==n:
        return None,-1
    p=k                     #ç›®å‰pçš„ä½ç‚ºobj
    k+=1
    leftb=('[','(')
    rightb=(']',')')
    while k<n and (codeline[k] in leftb or codeline[k]=='.'):    #functionæˆ–index
        if codeline[k] in leftb:
            c=1
            k+=1
            while k<n and c>0:
                if codeline[k] in leftb:c+=1
                elif codeline[k] in rightb:c-=1
                k+=1
        elif codeline[k]=='.':
            k+=2
    get=codeline[p:k]
    if len(get)==1:      #ä»£è¡¨æ˜¯æŸç‰©ä»¶
        if type(get[0])==Var_name:
            return Variable(get[0].name,namespace),k                            #å›å‚³ è®Šæ•¸,ç´¢å¼•çµæŸé»ï¼Œ')'å¾Œä¸€æ ¼
        else:return get[0],k
    elif type(get[0])==Var_name and get[0].name=='$str':                        #æ“·å–apythonè‡ªèº«å‡½æ•¸
        obj=parse_codeline(get[2:-1],namespace)            #å–å¾—()ä¸­çš„æ±è¥¿
        return STR(obj),k
    elif get[1] in '([.':                                      #ä»£è¡¨æ˜¯functionæˆ–index
       # print('é€²ä¾†äº†,getç‚º',get)
        q=k
        k=1
        if type(get[0])==Var_name:
            get[0]=Variable(get[0].name,namespace)
       # print('get:',get)
        from time import time
        st=time()+1
        while len(get)>1:
            if get[k]=='(':                         #ä»£è¡¨æ˜¯function call
               # print('èµ°é€™æ¢')
                args=[]
                kwargs=[]
                s_args=None
                s_kwargs=[]
                if get[k+1]!=')':
                    while k<len(get):              #é–‹å§‹è’é›†åƒæ•¸
                        if get[k+2]=='=':                      #ä»£è¡¨æ˜¯æŒ‡å®šåƒæ•¸
                            p=k+3
                            k = next_element(get, p, ',)')
                            value = parse_codeline(get[p:k],namespace)
                            kwargs.append((String(get[p-2].name),value))
                        elif get[k+1]=='*':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            value=parse_codeline(get[p:k], namespace)
                            if s_args==None:
                                s_args =value
                            else:
                                s_args=Oper(s_args,value,'+')  #ç›¸åŠ 
                        elif get[k+1]=='**':
                            p = k + 2
                            k = next_element(get, p, ',)')
                            s_kwargs.append(parse_codeline(get[p:k], namespace))
                        else:
                            p=k+1
                            k=next_element(get,p,',)')
                            value = parse_codeline(get[p:k],namespace)
                            args.append(value)
                        if get[k]==')':break
                    #print('args:',args)
                    #print('kwargs:',kwargs)
                else:k+=1
                #æ­¤æ™‚kç‚º ")"
                get=[FuncCall(get[0],List(args),Dict(kwargs),s_args,s_kwargs)]+get[k+1:]
            elif get[k]=='[':
                p=k+1
                collect=[]
                while True:
                    k=next_element(get,p,':]')
                    if get[k]==':':                                           #sliceç´¢å¼•
                        if k==p:
                            value=TFN(None)                                 #ä»£è¡¨ç¬¬ä¸€æ¬„ä½ç‚ºç©º
                        else:
                            value = parse_codeline(get[p:k],namespace)
                        p=k+1
                        collect.append(value)
                    else:                                                        #å–®ç´¢å¼•
                        if len(collect)==0:
                            collect=parse_codeline(get[p:k],namespace)
                        elif k==p:
                            collect.append(TFN(None))
                        else:
                            collect.append(parse_codeline(get[p:k],namespace))
                        break
                #kç‚º "]"
                if type(collect)==list:
                    if len(collect)<3:
                        collect+=[TFN(None)]*(3-len(collect))
                    collect=Slice(collect[0],collect[1],collect[2])
                get=[IndexVariable(get[0],collect)]+get[k+1:]
            elif get[k]=='.':                                        #attribute
                subattr=SubVariable(get[0],get[2])
                get=[subattr]+get[3:]
                k-=1
            if time()>st:
              #  print('getç‚º:',get)
                raise Exception('335 get error')
            k=1
       # print('å–å¾—:',get[0])
       # a=input()
        return get[0],q
def next_codeline(codelines,row):
    space_n=codelines[row][0][0]
    s_n=space_n+1
    Row=len(codelines)
    while s_n>space_n:
        row += 1
        if row==Row:break
        s_n = codelines[row][0][0]
    return row
#è§£æä¸€è¡Œ:
def parse_codeline(codeline,namespace,is_list=False):     #å›å‚³è§£ç­”é™£åˆ—[A,B,C,...]
    # è™•ç†lambda(å› ç‚ºæ€•namespaceè¢«è¦†è“‹)
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c == 'lambda':
            # print('æ‰¾åˆ°äº†')
            p2 = k
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k += 1  # kå¾æ­¤é–‹å§‹æ˜¯è®Šæ•¸
            n = len(codeline)
            while k < n:
                c = codeline[k]
                if type(c) == Var_name:  # å–å¾—param
                    paramsbox[c.name]= TFN(None)
                    if k + 1 < n and codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',:')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[c.name] = parse_codeline(codeline[p:k], namespace)  # functionåƒæ•¸éœ€è¦namespace
                        if codeline[k] == ':': break
                if c == ':': break
                k += 1
            #  print('ç²å–åƒæ•¸:',paramsbox)
            # æ­¤æ™‚kæœƒæŒ‡è‘—å†’è™Ÿ
            # print('ç›®å‰kæŒ‡è‘—:',codeline[k])
            q = next_element(codeline, k, (',',')'), end=True)  # ç¢°åˆ°",",")"åœæ­¢
           # print('getå¾·:',codeline[k + 1:q])
            return_obj = parse_codeline(codeline[k + 1:q], '')  # functionå…§çš„å…§å®¹(namespace)è¦æ¸…ç©º
            #  print('return_obj:',return_obj)
            lambda_obj = Lambda(paramsbox, return_obj, namespace)
            codeline = codeline[:p2] + [lambda_obj] + codeline[q:]
            # print('æ–°codeline:',codeline)
            k = 0
        k += 1
    # è™•ç†æ‹¬å¼§
    k = 0
    while k < len(codeline):
        if k==0 or (type(codeline[k-1])==str and codeline[k-1] not in (')',']','}')):                 #å‰é¢ç‚º',','='
            objecct = codeline[k]
            if objecct == '(' :  # ä»£è¡¨æ­¤è™•æœ‰tupleï¼Œ
                q = next_element(codeline, k + 1, ')')
                get = parse_codeline(codeline[k + 1:q], namespace)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k-=1
            elif objecct == '[':  # ä»£è¡¨æ˜¯list
                q = next_element(codeline, k + 1, ']')
                get = parse_codeline(codeline[k + 1:q], namespace, is_list=True)  # è®Šæˆä¸€å€‹tuple
                codeline = codeline[:k] + [get] + codeline[q + 1:]
                # k -= 1
            elif objecct == '{':  # ä»£è¡¨æ˜¯é›†åˆæˆ–dict
                #print(codeline)
                q=next_element(codeline,k+1,['}'])      #å…ˆå°‡å­—å…¸åº•éƒ¨æ‰¾åˆ°
               # print('q:',q)
                content=parse_codeline(codeline[k+1:q],namespace,is_list=True)       #æ­¤æ™‚contentçš„å½¢å¼ç‚º <obj>:<obj><obj>:<obj>ï¼Œé€—è™Ÿæœƒæ¶ˆå¤±ï¼Œå¦‚æœæ²’å†’è™Ÿï¼Œå°±æ˜¯é›†åˆ
                #codeline=codeline[:k]+content.elements+codeline[q+1:]
                deal_line=content.elements
                #print('deal_line:',deal_line)
                if ':' in deal_line or len(deal_line)==0:     #deal_lineç‚ºç©ºï¼Œé»˜èªç‚ºdict
                    elementbox = []      #[(key,value),...]
                    p =0
                    n=len(deal_line)
                    while p<n:
                        key=deal_line[p]
                        p+=2
                        value=deal_line[p]
                        p+=1
                        elementbox.append((key, value))
                    get = Dict(elementbox)
                else:
                    get=Set(deal_line)        #é›†åˆå…ƒç´ 
                codeline = codeline[:k] + [get] + codeline[q + 1:]
        k += 1
    k=0
    while k<len(codeline):
        c=codeline[k]
        if type(c)==str and c in ('break','continue'):      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Mark(c)
        elif type(c)==str and c=='pass':      #æ­¤è¡Œåªæœ‰æ­¤å…ƒç´ 
            return Pass()
        else:
            l=len(codeline)
            var, q = get_var(codeline, k, namespace)
            codeline = codeline[:k] + [var] + codeline[q:]
            if len(codeline)<l:                              #æœ‰è®ŠåŒ–æ‰è™•ç†
                k -= 1
        k+=1
    def deal_single_operator(codeline,op_box,operator):
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box and type(codeline[k + 1]) != str:
                if c in ('+','-'):
                    if k==0 or type(codeline[k-1])==str:   #ä»£è¡¨æ²’æœ‰åŠ æ¸›é‹ç®—
                        if c=='-':
                            get = operator(codeline[k + 1],c)
                            codeline = codeline[:k] + [get] + codeline[k + 2:]
                            k=-1
                        else:
                            codeline=codeline[:k]+codeline[k+1:]            #åˆªé™¤"+"
                else:
                    get = operator(codeline[k + 1],c)
                    codeline = codeline[:k] + [get] + codeline[k + 2:]
                    k = -1
            k += 1
        return codeline
    def deal_single_operator_all(codeline,op_box,operator):     #å°‡opå¾Œçš„åƒæ•¸å…¨éƒ¨æ‰“åŒ…
        k = 0
        while k < len(codeline):
            c = codeline[k]
            if c in op_box:
                value=parse_codeline(codeline[k+1:],namespace)
                get = operator(value,c)
                codeline = codeline[:k] + [get]
                k = -1
            k += 1
        return codeline
    def deal_operator(codeline,op_box,operator):
        k=0
        while k<len(codeline):
            c=codeline[k]
            if c in op_box:
                if k>0:
                    get=operator(codeline[k-1],codeline[k+1],c)
                    codeline=codeline[:k-1]+[get]+codeline[k+2:]
                    k-=1
            k+=1
        return codeline
    # è™•ç†**
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='**':
            k+=1
            p=k
            while type(codeline[k])==str:k+=1    #å¯èƒ½å–åˆ°è² è™Ÿæˆ–è£œæ•¸ã€æ­£è™Ÿ
            obj=parse_codeline(codeline[p:k+1],namespace)
            get=Oper(codeline[p-2],obj,'**')
            codeline = codeline[:p-2] + [get] + codeline[k+1:]
            k=p-2
        k += 1
    #è™•ç† ~,-
    codeline = deal_single_operator(codeline, ['~','-','+'],Deny)
    # è™•ç†*/
    codeline=deal_operator(codeline,('*','/','%','//'),Oper)
    #è™•ç†+-
    codeline=deal_operator(codeline,('+','-'),Oper)
    # è™•ç†<<>>
    codeline = deal_operator(codeline,('<<','>>'),Oper)
    # è™•ç†&
    codeline = deal_operator(codeline, ['&'],Oper)
    # è™•ç†^
    codeline = deal_operator(codeline, ['^'],Oper)
    # è™•ç†|
    codeline = deal_operator(codeline,['|'],Oper)
    #è™•ç†==,!=
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c in ('==','!=','>','<','>=','<='):
            enebox=[codeline[k-1]]
            p=k
            while c in ('==','!=','>','<','>=','<='):
                enebox+=[c,codeline[k+1]]
                k+=2
                if k<len(codeline):
                    c=codeline[k]
                else:break
            get=Bool(enebox)
            codeline=codeline[:p-1]+[get]+codeline[k:]
            k=p-1
        k += 1
    # è™•ç†in,isï¼Œinå‰é¢ä¸èƒ½æœ‰for
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='for':
            k=next_element(codeline,k,['in'],end=True)    #è¦ç•¥éforå¾Œé¢çš„in
        elif c=='in':                # è™•ç†in
            if k > 0:
                if codeline[k-1]=='not':
                    get=Deny(Tf(codeline[k+1], codeline[k-2], c),'not')
                    codeline = codeline[:k - 2] + [get] + codeline[k + 2:]
                    k -= 2
                else:
                    get = Tf(codeline[k+1], codeline[k-1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                    k -= 1
        elif c=='is':              # è™•ç†is
            if k > 0:
                if codeline[k+1]=='not':
                    get=Deny(Tf(codeline[k+2], codeline[k-1], c),'not')
                    codeline = codeline[:k -1] + [get] + codeline[k + 3:]
                else:
                    get = Tf(codeline[k+1], codeline[k - 1], c)
                    codeline = codeline[:k - 1] + [get] + codeline[k + 2:]
                k -= 1
        k += 1
    #è™•ç†not
    codeline=deal_single_operator(codeline,['not'],Deny)
    #è™•ç†and,or
    codeline = deal_operator(codeline,('and','or'),AndOr)
    #è™•ç† A if B else C
    k = 0
    while k < len(codeline):
        c = codeline[k]
        if c=='if':                                                             #è™•ç† A if B else C
            else_k=next_element(codeline,k,['else'])
            true_item=codeline[k-1]
            event_obj=parse_codeline(codeline[k+1:else_k],namespace)
            end_k=next_element(codeline,else_k,',',end=True)
            false_item=parse_codeline(codeline[else_k+1:end_k],namespace)
            get = sub_if_else(event_obj,true_item,false_item)
            codeline = codeline[:k-1] + [get] + codeline[end_k:]
            k = 0
        elif c=='for':              #è™•ç†for
           # print(codeline)
            #print('k:',k)
            express=codeline[k-1]
            in_k=next_element(codeline,k,['in'])
            vnames=parse_codeline(codeline[k+1:in_k],namespace,is_list=True)
            base_obj=codeline[in_k+1]
            if_k=next_element(codeline,in_k,['if'])
           # print('in_k:',in_k)
            if if_k==-1:      #æ²’æœ‰if
                if_obj=None
            else:if_obj=codeline[if_k+1]
           # print('å–å¾—:')
            #print(express,vnames,base_obj,if_obj)
            get=sub_for_loop(express,vnames,base_obj,if_obj,is_list)
            return get                                                #å…¶ä»–éƒ½åˆ¥ç®¡äº†ï¼Œç›´æ¥return
        k += 1
    #è™•ç†return
    codeline=deal_single_operator(codeline,['yield'],Backtrack)
    codeline = deal_single_operator_all(codeline, ('return', 'raise'), Backtrack)
    codeline = deal_single_operator(codeline, ('del','global','nonlocal'),Var_declare)
    #åˆªé™¤å…§éƒ¨é€—è™Ÿ
    k=0
    while k<len(codeline)-1:                       #å¯èƒ½æ˜¯(a,)çš„tuple
        if codeline[k]==',':del codeline[k]
        else:k+=1
        if k==len(codeline)-1 and not is_list:break
    if len(codeline)>0 and codeline[-1]==',':         #codelineå¯èƒ½ç‚º[],()é€²ä¾†ï¼Œé•·åº¦ç‚º0
        if is_list:del codeline[-1]
        else:
            return Tuple(codeline)
    if is_list:
        return List(codeline)
    if len(codeline)==1:return codeline[0]
    return Tuple(codeline)
#è§£æç¨‹å¼å€å¡Š:
def parse_block(codelines,namespace=Namespace()):         #å›å‚³[[A,B,C,...],[A,B,C,...],...]
    info=Info(namespace)       #localç‚ºæ‰€æœ‰è®Šæ•¸ï¼Œcodelinesç‚ºè™•ç†å¥½çš„codelines
    #é–‹å§‹è™•ç†
    row=0
    Row = len(codelines)  # ç¸½è¡Œæ•¸
    while row<Row:
        codeline=codelines[row]                 #å–å¾—ä¸€è¡Œ
        if codeline[1]=='def':
            func_name = codeline[2].name  # Variable
            # 3æ˜¯(ï¼Œ4é–‹å§‹æ˜¯è®Šæ•¸
            paramsbox = {}  # {param1:å€¼,param2:å€¼,...}
            k = 4
            n = len(codeline)
            pre=''        #å‰ç¶´ï¼Œå¯èƒ½ç‚º*æˆ–**
            while k < n:
                c = codeline[k]
                if c in ('*','**') and codeline[k-1] in ('(',','): #ç¢ºä¿é€™ä¸æ˜¯é‹ç®—ç¬¦
                    pre=c
                elif type(c) == Var_name:  # å–å¾—param
                    param_name=pre+c.name
                    paramsbox[param_name] = TFN(None)
                    if codeline[k + 1] == '=':  # æ­¤åƒæ•¸å­˜åœ¨é»˜èªå€¼
                        p = k + 2
                        k = next_element(codeline, p, ',)')  # ç¢°åˆ°,æˆ–)èª¿æŒ‡ç´¢å¼•é»˜èªå€¼
                        paramsbox[param_name] =parse_codeline(codeline[p:k],namespace)
                    pre=''             #æ¸…ç©ºå‰ç¶´
                k += 1
            q = next_codeline(codelines, row)
            pinfo =parse_block(codelines[row + 1:q],namespace=Namespace())   #Defå…§éš”çµ•å¤–éƒ¨namespace
            fDef = Def(func_name, paramsbox,pinfo,namespace)
            fDef.local_vars=pinfo.locals
            #é€²è¡Œç™»è¨˜
            info.add_info('func',fDef)
            info.write(fDef,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='class':
            classname=codeline[2].name
            if codeline[3]=='(':      #ä»£è¡¨æœ‰ç¹¼æ‰¿
                q=next_element(codeline,4,[')'])
                father=parse_codeline(codeline[4:q],namespace)
            else:
                father=None
            q=next_codeline(codelines,row)
            importer.class_n+=1
            class_esp=f'{classname}^{importer.class_n}'
            pinfo=parse_block(codelines[row+1:q],namespace=Namespace(f'<{class_esp}>'))           #åœ¨namespaceç‹€æ…‹ä¸‹ï¼Œvarè½‰ç‚ºnamespace.var, funcè½‰ç‚º namespace.func
            get=Class(classname,pinfo,namespace,class_esp,father)
            #é€²è¡Œç™»è¨˜
            info.add_info('class',get)
            info.write(get,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='if':                                            #if,elif,elseå‹æ…‹
            eventbox=[]
            else_codelines=[]
            orig_codelines=[]
            if_k=0
            while row<Row:
                codeline=codelines[row]
                if (codeline[1]=='if' and if_k==0) or codeline[1]=='elif':
                    if_k+=1
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    event=parse_codeline(codeline[2:-1],namespace)         #äº‹ä»¶çœŸå‡å€¼
                    if type(event)==Tuple:event=Integer(1)
                    q=next_codeline(codelines,row)
                    block=codelines[row+1:q]
                    pinfo=parse_block(block,namespace)
                    #é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    eventbox.append((event,pinfo.codelines))
                    row=q
                elif codeline[1]=='else':
                    orig_codelines.append((codeline[0][2],codeline[0][1]))
                    q = next_codeline(codelines, row)
                    block = codelines[row + 1:q]
                    pinfo=parse_block(block,namespace)
                    else_codelines=pinfo.codelines
                    # é€²è¡Œç™»è¨˜
                    info.update(pinfo)
                    row=q
                    break
                else:break
            row-=1
            info.write(If_else(eventbox,else_codelines),orig_codelines)
        elif codeline[1]=='while':                                         #whileå‹æ…‹
            event=parse_codeline(codeline[2:-1],namespace)
            if type(event) == Tuple: event = Integer(1)
            q = next_codeline(codelines, row)
            block = codelines[row + 1:q]
            pinfo= parse_block(block,namespace)
            while_codelines=pinfo.codelines
            # é€²è¡Œç™»è¨˜
            info.update(pinfo)
            #--------------------------------------
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            info.write(While(event,while_codelines,else_codelines),(codeline[0][2],codeline[0][1]))
            row = q-1
        elif codeline[1]=='for':                                           #for,loopå‹æ…‹
            vnames=[]
            k=2            #é–‹å§‹æ¸…é»åƒæ•¸
            while type(codeline[k])==Var_name or codeline[k]==',':
                if type(codeline[k])==Var_name:
                    var=Variable(codeline[k].name,namespace)
                    info.add_info('var',var)
                    vnames.append(var)
                k+=1
            #æ¥ä¸‹ä¾†kæœƒæŒ‡åˆ° in
            base_obj=parse_codeline(codeline[k+1:-1],namespace)
            q=next_codeline(codelines,row)
            block = codelines[row + 1:q]
            pinfo = parse_block(block, namespace)
            fp_codelines=pinfo.codelines
            info.update(pinfo)
            if q<Row and codelines[q][1]=='else':
                row=q
                q = next_codeline(codelines,row)
                block = codelines[row + 1:q]
                pinfo = parse_block(block, namespace)
                else_codelines=pinfo.codelines
                # é€²è¡Œç™»è¨˜
                info.update(pinfo)
            else:
                else_codelines=[]
            for_loop=For_loop(vnames,base_obj,fp_codelines,else_codelines)
            # é€²è¡Œç™»è¨˜
            info.write(for_loop,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='import':
            importer.need_load=1
            package_dict={}
            k,n=2,len(codeline)
            while k<n:
                if type(codeline[k])==Var_name:
                    module_name=codeline[k].name
                    while k+1<n and codeline[k+1]=='.':
                        module_name+=f'.{codeline[k+2].name}'
                        k+=2
                    as_name=None
                    if k+1<n and codeline[k+1]=='as':
                        as_name=codeline[k+2].name
                        var = Variable(as_name, namespace)
                        k+=2
                    else:
                        var=Variable(module_name.split('.')[0],namespace)
                    package_dict[module_name]=as_name   #(filepath,1/0)
                    #ç™»è¨˜
                    info.add_info('var',var)
                k+=1
            import_obj=Import(package_dict,namespace)                  #{'abc.def.ghi':as_name,...} , namespace
            info.write(import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1] == 'from':
            importer.need_load = 1
            object_names=[]
            module_name=codeline[2].name
            k = 2
            n = len(codeline)
            while k + 1 < n and codeline[k + 1] == '.':
                module_name += f'.{codeline[k + 2].name}'
                k += 2
            #-----------------------------------------
            k+=2                              #è·³éimport
            while k<n:
                if type(codeline[k])==Var_name:
                    object_name=codeline[k].name
                    if k+1<n and codeline[k+1]=='as':
                        deal=(object_name,codeline[k+2].name)
                        k+=2
                    else:deal=(object_name,object_name)
                    object_names.append(deal)
                    var=Variable(deal[1],namespace)
                    #ç™»è¨˜
                    info.add_info('var',var)
                elif codeline[k]=='*':
                    object_names.append(('*','*'))
                k+=1
            from_import_obj = From_Import(module_name,object_names,namespace,info)
            info.write(from_import_obj,(codeline[0][2],codeline[0][1]))
        elif codeline[1]=='try':
            orig_codelines=[(codeline[0][2],codeline[0][1])]
            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            try_codelines=pinfo.codelines
            info.update(pinfo)
            except_objects=[]
            row=q
            while q<Row and codelines[q][1]=='except':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                k=next_element(codeline,1,(':','as'))
                if codeline[k]==':':
                    if k-1>1:                #ä»£è¡¨ä¸­é–“æœ‰åŒ…æ±è¥¿
                        error_obj=parse_codeline(codeline[2:k],namespace)
                    else:                    #ä¸­é–“æ²’æœ‰åŒ…æ±è¥¿
                        error_obj=Variable('Exception',namespace)
                    as_name=None
                else:                              #ä»£è¡¨æ˜¯as
                    error_obj = parse_codeline(codeline[2:k], namespace)
                    as_name=codeline[k+1].name
                #é–‹å§‹æ”¶é›†codelines
                q=next_codeline(codelines,q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                except_objects.append((error_obj,as_name,pinfo.codelines))
                info.update(pinfo)
                row=q
            if q<Row and codelines[q][1]=='else':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                else_codelines=pinfo.codelines
                info.update(pinfo)
            else:else_codelines=[]
            row=q
            if q<Row and codelines[q][1]=='finally':
                codeline=codelines[q]
                orig_codelines.append((codeline[0][2],codeline[0][1]))
                q = next_codeline(codelines, q)
                pinfo=parse_block(codelines[row+1:q],namespace)
                finally_codelines=pinfo.codelines
                info.update(pinfo)
            else:finally_codelines=[]
            #if len(except_objects)==0 and len(finally_codelines)==0:
             #   raise SyntaxError('invalid syntax')
            try_except=Try_Except(try_codelines,except_objects,else_codelines,finally_codelines,namespace)
            info.write(try_except,orig_codelines)
            row=q-1
        elif codeline[1]=='with':
            k=2
            q=next_element(codeline,k,['as',':'])
            call_obj=parse_codeline(codeline[k:q],namespace)
            importer.class_n += 1
            orig_as_name=Variable(f'%with_obj_{importer.class_n}',namespace)
            info.add_info('var', orig_as_name)
            if codeline[q]=='as':
                q2=next_element(codeline,q,[':'])
                as_name=parse_codeline(codeline[q+1:q2],namespace)
                if type(as_name)==Variable:
                    info.add_info('var', as_name)
            else:as_name=None

            q=next_codeline(codelines,row)
            pinfo=parse_block(codelines[row+1:q],namespace)
            info.update(pinfo)
            with_obj=With(call_obj,orig_as_name,as_name,pinfo.codelines,namespace)
            info.write(with_obj,(codeline[0][2],codeline[0][1]))
            row=q-1
        elif codeline[1]=='assert':
            k=next_element(codeline,1,[','],end=True)
            event=parse_codeline(codeline[2:k],namespace)
            if k<len(codeline) and codeline[k]==',':
                msg=parse_codeline(codeline[k+1:],namespace)
            else:msg=String('')
            assert_obj=Assert(event,msg)
            info.write(assert_obj, (codeline[0][2], codeline[0][1]))
        else:
            equal=next_element(codeline,0,('=','+=','-=','*=','/=','%=','//=','**=','<<=','>>=','&=','^=','|='),stop=['lambda'])                             #è™•ç†=
            op=codeline[equal]      #operator
            variablebox=[]                          #æ”¶é›†[(var1,var2,...),(var1,var2,...),...]
            s=1
            while equal>0:
                vars=parse_codeline(codeline[s:equal],namespace)
                if type(vars) in (Tuple,List):
                    for var in vars:
                        if type(var)==Variable:
                            info.add_info('var', var)
                elif type(vars)==Variable:
                    info.add_info('var', vars)
                s=equal+1
                #vars=[]
                #d=1
                #while d<equal:
                #    if codeline[d]==',':d+=1    #è·³éé€—è™Ÿ
                #    var,d=get_var(codeline,d,namespace)
                #    if type(var)==Variable:
                #        var.namespace=namespace
                #        info.add_info('var',var)
                #    vars.append(var)
                #    s=d+1
                variablebox.append(vars)
                equal=next_element(codeline,equal+1,'=',stop=['lambda'])
            target=parse_codeline(codeline[s:],namespace)                      #æœ€å°¾ç«¯çš„ç‰©ä»¶
           # variablebox.append(results)
           # print('variablebox:',variablebox)
          #  print('\n\ncodeline:',codeline,'\n\n')
           # print('variablebox:',variablebox)
            if len(variablebox)==0:                                   #æ²’æœ‰ç­‰æ–¼
                info.write(target,(codeline[0][2],codeline[0][1]))
            #elif len(variablebox)==1 and type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
            #        object = Mov(variablebox[0], target, op)
            #        info.write(object, (codeline[0][2], codeline[0][1]))
            else:
                mov_obj=Multiple_Mov(variablebox,target,op)
                info.write(mov_obj, (codeline[0][2], codeline[0][1]))
                #if type(variablebox[0]) not in (Tuple, List):  # ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #    object = Mov(variablebox[0], target, op)
                #    info.write(object, (codeline[0][2], codeline[0][1]))
                #target = variablebox[-1]
                #if
                #for i in range(len(variablebox)-1):
                #    vars=variablebox[i]
                #
                #    if type(vars) not in (Tuple,List):   #ä»£è¡¨æ˜¯å–®ä½å…ƒç´ 
                #        object = Mov(vars,target,op)
                #        info.write(object,(codeline[0][2],codeline[0][1]))
                #        if type(vars[0])==Variable:
                #            info.add_info('var',vars[0])
                #    else:
                #        if type(target)==FuncCall:
                #            info.write(target,('',0))
                #        for j in range(len(vars)):
                #            object=Mov(vars[j],target[j])
                #            info.write(object,(codeline[0][2],codeline[0][1]))
                #            if type(vars[j])==Variable:
                #                info.add_info('var',vars[j])
        row+=1
    return info
#å¤–éƒ¨åŒ¯å…¥å‡½æ•¸
class From_Import:
    def __init__(self,module_name,object_names,namespace,now_info):   #dict:name:(filepath,1/0,name2)ï¼Œ[(name,name2),(name,name2),...],
        self.module_name=module_name
        self.object_names=object_names
        self.namespace=namespace
        self.now_info=now_info
        self.orig_lines = ('', 0)
    def __str__(self):
        return f'<From {self.module_name} import {self.object_names}>'
    def write(self,codes):
        module_data = importer.get_path(self.module_name)
        codes.append('',self.orig_lines)
        if module_data[1]!=0:       #éœ€è¦è¢«è¼‰å…¥
            tem_module_name=f'&tem_import_{len(codes)}'
            package_dict={self.module_name:tem_module_name}
            _import = Import(package_dict,self.namespace)
            _import.write(codes)  # å¯ä½¿å€åŸŸè®Šæ•¸åå¤±æ•ˆ
        codes.append(f'push $importer["{module_data[0]}"]')
        if self.namespace!='':
            self.namespace.write(codes)
            codes.append(f'push {self.namespace.location}')
            module_space='<esp+1>.'
            ispace='<esp+2>'
        else:
            module_space=''
            ispace='<esp+1>'
        for var in self.object_names:
            if var[0]=='*':             #import å…§éƒ¨æ‰€æœ‰ç‰©ä»¶
                info=importer.infos[module_data[0]]
                if info=='built-in':
                    locals=importer.module_dict[module_data[0]]
                else:
                    locals=info.locals
                for local_var in locals:
                    codes.append(f'mov {module_space}{local_var} {ispace}.{local_var}    ;import *')
                    variable=Variable(local_var,self.namespace)
                    self.now_info.add_info('var',variable)
            else:
                codes.append(f'mov {module_space}{var[1]} {ispace}.{var[0]}')
        if self.namespace!='':
            codes.append('$mov esp "+" 2')               #é‚„åŸå †ç–Š
        else:codes.append('inc esp')
class Import:
    def __init__(self,package_dict,namespace):   #package_dict:{'name':name2/None}    #åç¨±:æª”æ¡ˆè·¯å¾‘ï¼Œæ˜¯å¦è®€å–ï¼Œæ˜¯å¦è½‰ç‚ºå…¶ä»–åç¨±(as)
        self.package_dict=package_dict
        self.namespace=namespace
        self.orig_lines=('',0)
    def __str__(self):
        return f'<Import: {self.package_dict}>'
    def write(self,codes):         #å¦‚æœcheckç‚ºTrueï¼Œå‰‡åœ¨å·²importç‹€æ…‹ä¸é€²è¡Œimport
        if self.namespace != '':
            self.namespace.write(codes)
            last_layer = f'{self.namespace.location}.'
        else:last_layer=''
        tem_layer=last_layer
        for module_name in self.package_dict:
            as_name = self.package_dict[module_name]
            mbox=module_name.split('.')
            for m in range(len(mbox)):
                dealname='.'.join(mbox[:m+1])
                deal_data=importer.get_path(dealname)    #,[filepath,0:å·²è™•ç†/1:æœªè™•ç†]
                p = len(codes)
                namespace_stack_name = f'&{mbox[m]}_{p}'  # æ­¤åç‚ºå”¯ä¸€ï¼Œæ›¿æ›åƒæ•¸å †ç–Šå
                if deal_data[1] == 0:  # å·²ç¶“è¢«è™•ç†
                    codes.append(f'mov {namespace_stack_name} $importer["{deal_data[0]}"]')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==2:       #ä»£è¡¨æ˜¯å¤–éƒ¨å‡½æ•¸
                    importer.loaded.append(deal_data[0])
                    codes.append(f'module {namespace_stack_name} "{deal_data[0]}"')
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    importer.infos[deal_data[0]] ='built-in'
                    last_layer = f'{namespace_stack_name}.'
                elif deal_data[1]==1:       #æœªè™•ç†
                    importer.loaded.append(deal_data[0])    #-----------------------------ç™»è¨˜å·²è¼‰å…¥
                    codes.append(0)
                    codes.append(f'mov $importer["{deal_data[0]}"] {namespace_stack_name}')
                    if as_name == None:                                                   # ä»£è¡¨ç›´æ¥å¼•å…¥åç¨±
                        codes.append(f'mov {last_layer}{mbox[m]} {namespace_stack_name}  ;å®šç¾©{last_layer}{mbox[m]}')
                    elif m == len(mbox) - 1:                                              #å¼•å…¥as_name
                        codes.append(f'mov {tem_layer}{as_name} {namespace_stack_name}')
                    else:
                        codes.append('pass')
                    #--------------------------------------------------------------------é–‹å§‹ç·¨è­¯
                    codes.add_newtab(deal_data[0])
                    code = open(deal_data[0], 'r', encoding=importer.encoding).read()
                    codelines = parse_code(code)
                    info = parse_block(codelines)    #ç•¶ä½œç¨ç«‹ç¨‹å¼ç¢¼é€²è¡Œè§£æ
                    for obj in info.codelines:
                        obj.write(codes)
                    importer.infos[deal_data[0]] = info   #ç™»è¨˜infoè³‡è¨Š
                    codes.del_newtab()
                    #--------------------------------------------------------------------ç·¨è­¯çµæŸ
                    #-------------------------ç·¨å¯«åƒæ•¸æ›¿æ›å­—å…¸
                    params_dict={}
                    box=[]
                    var_k=0
                   # print('info locals:',info.locals)
                    for var in info.locals:
                        if var not in box:
                            box.append(var)
                            params_dict[var]=f'<{namespace_stack_name}+{var_k}>'          #name:order
                            var_k+=1
                    var_text=','.join(box)
                    codes[p] = f'namespace {namespace_stack_name} "{namespace_stack_name}" "{var_text}"'
                    #--------------------------
                    #-------------------------------------------------------------é€²è¡Œåƒæ•¸æ›¿æ›
                    def get_name(string):
                        sp = '.[ ;'
                        k, n = 0, len(string)
                        while k < n:
                            if string[k] in sp:
                                return string[:k], string[k:]
                            k += 1
                        return string, ''
                    def parse_line(line):
                        box = []
                        k, n = 0, len(line)
                        while k < n:
                            p = k
                            if line[p] in ('"', "'"):
                                c = line[p]
                                k = p + 1
                                while line[k] != c:
                                    if line[k] == '\\': k += 1
                                    k += 1
                                k += 1
                            while k < n and line[k] != ' ': k += 1
                            box.append(line[p:k])
                            k += 1
                        return box
                    p+=3           #è·³éè‡ªå·±å®£å‘Šçš„åç¨±ï¼Œ(å°å¿ƒè‡ªå·±çš„åƒæ•¸ä¸è¦è¢«æ›¿æ›)
                    for i in range(len(codes) - p):
                        line=codes[p+i]
                        if '"' in line or "'" in line:
                            deal=parse_line(line)
                        else:
                            deal = codes[p + i].split(' ')
                        for j in range(len(deal)):  # å°‡è‡ªå·±çš„è®Šæ•¸åšæ›¿æ›
                            if j == 0 or deal[j] == '': continue       #é™¤äº†å‘½ä»¤å’Œç©ºï¼Œå…¶é¤˜æª¢æŸ¥
                            if deal[j][0] in ('"', "'"):
                                continue
                            if deal[j][0] == ';':  # ä»£è¡¨æ˜¯è¨»è§£
                                break
                            var, back = get_name(deal[j])
                            if var in params_dict:
                                deal[j]=params_dict[var]+back
                        codes[p + i] = ' '.join(deal)
                    #----------------------------------------------------------------------åƒæ•¸æ›¿æ›çµæŸ
                    last_layer=f'{namespace_stack_name}.'
            last_layer=tem_layer
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open(getcwd() + '/apython/ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict
class Importer:          #æ¨¡çµ„åŒ¯å…¥ç®¡ç†å™¨
    def __init__(self):
        self.module_dict=Read_ex_func()
        self.reset()
    def __get_module(self,module_name):        #ç²å–è©²è³‡æ–™å¤¾å…§æ‰€æœ‰å¯importæ¨¡çµ„
        def get_module(nowfolder,k):      #ç›®å‰å·¥ä½œè³‡æ–™å¤¾ï¼Œfboxçš„index
            if k==len(fbox)-1:
                filepath=''
                for file in listdir(nowfolder):
                    road = f'{nowfolder}/{file}'.replace('\\', '/')
                    if isfile(road) and file.split('.')[-1] == 'py' and filepath=='' and file[:-3]==fbox[k]:
                        filepath = road
                    elif isdir(road) and '__init__.py' in listdir(road) and file==fbox[k]:  # å¦‚æœæœ‰è³‡æ–™å¤¾å’Œpyæª”åŒé¡ï¼Œå–è³‡æ–™å¤¾
                        filepath= road + '/__init__.py'
                return filepath
            return get_module(f'{nowfolder}/{fbox[k]}',k+1)
        fbox=module_name.split('.')
        return get_module(self.work_folder,0)
    def get_path(self,module_name):          #importå¾ŒåŠ [åŒç›®éŒ„æª”æ¡ˆå]ï¼Œåªèƒ½æ˜¯[.py]æˆ–[å…§éƒ¨æœ‰__init__çš„è³‡æ–™å¤¾]
        if module_name in self.module_dict:
            if module_name in self.loaded:
                return [f'{module_name}',0]
            return [f'{module_name}',2]      #2ä»£è¡¨built-in
        else:
            filepath=self.__get_module(module_name)
            if filepath in self.loaded:   #å·²ç¶“è¼‰å…¥é
                return [filepath,0]
            if filepath=='':    #ä»£è¡¨æ‰¾ä¸åˆ°
                return [f'{module_name}', 2]  # 2ä»£è¡¨built-inï¼Œå‰µå»ºä¸€å€‹ç©ºçš„Ex_module
            #print('filepath:',filepath,module_name)
            return [filepath,1]
    def reset(self,pyfile='',encoding='cp950'):
        self.need_load=0
        self.encoding=encoding
        py_file_name=pyfile.replace('\\','/').split('/')[-1]
        if pyfile==py_file_name:
            self.work_folder = getcwd()
        else:
            self.work_folder=pyfile[:-len(py_file_name)-1]
        self.nowpath = pyfile
        self.loaded=[]
        self.infos={}                     #path:info
        self.class_n = 0  # é¡åˆ¥ç®¡ç†
importer=Importer()
#æ‰“åŒ…è€…
class Packager:
    def __init__(self,encoding='cp950'):
        self.code=Code()
        self.encoding=encoding
        self.REPL_box=[True,[]]
        importer.reset('module', self.encoding)
        self.add_need_load = 0
    def load(self,filepath):
        ftype = filepath.split('.')[-1]
        filename = filepath.replace('\\', '/').split('/')[-1]
        work_folder = filepath[:-len(filename)]
        if len(work_folder) > 0:
            chdir(work_folder)
            filepath = filename
        if 'ec' == ftype:
            code = open(filepath, 'r').read()
            self.code.code = code.split('\n')
        else:
            code = open(filepath, 'r',encoding=self.encoding).read()
            self.code.add_newtab(filepath)
            importer.reset(filepath,self.encoding)
            self.add_need_load=0
            #--------------------------------------------------
            self.load_code(code)
            #--------------------------------------------------
            self.code.del_newtab()
    def REPL(self,cmd,one_line=True):               #å–®è¡Œç¨‹å¼ç¢¼
        self.code.add_newtab('REPL')
        if cmd=='':
            if len(self.REPL_box[1])>0:
                code='\n'.join(self.REPL_box[1])
              #  print('code:',code)
                self.load_code(code)
            self.REPL_box=[True,[]]
        else:
            codelines = parse_code(cmd)
            if one_line:
                codeline=codelines[0]
                if codeline[1] in ('def','class','if','while','for','try','with'):
                    self.REPL_box[0]=False     #False ä»£è¡¨ä¸åŸ·è¡Œ
                    self.REPL_box[-1].append(cmd)
                elif not self.REPL_box[0]:
                    self.REPL_box[-1].append(cmd)
                else:
                    self.load_code(cmd,repl=True)
            else:
                self.load_code(cmd, repl=True)
        self.code.del_newtab()
        return self.REPL_box[0]    #æ˜¯å¦åŸ·è¡Œ
    def load_code(self,code,repl=False):     #ç›´æ¥è¼¸å…¥ä»£ç¢¼
        codelines = parse_code(code)
        self.info = parse_block(codelines)
        if importer.need_load and self.add_need_load == 0:
            self.code.append('mov $importer [dict]')
            self.add_need_load = 1
        if len(self.info.codelines)>0:
            for obj in self.info.codelines:
                obj.write(self.code)
            if repl and type(self.info.codelines[-1]) in (Integer,Float,String,Byte,Variable,SubVariable,IndexVariable,List,Tuple,Dict,Set,FuncCall,Oper,Tf,AndOr,Deny,Bool):
                if type(self.info.codelines[-1])!=FuncCall or self.info.codelines[-1].name!='print':
                    self.code.append(f'repl_print {self.info.codelines[-1].location}')
    def __load_easy_code(self,ec_file):
        code = open(ec_file, 'r').read()
        self.code.code=code.split('\n')
16723*113*test_error.pydatas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='cp950')
    g.write('from apython.ex_func import *\n')
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
16851*114*test_error.txt#encoding='utf-8'
datas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w',encoding='utf-8')
    g.write("#encoding='utf-8'\nfrom apython.ex_func import *\n")
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n    if op=="__name__":return obj_name\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
16776*114*test_error2.py#encoding='utf-8'
datas=[]
type1="<class 'str'>"
example1='hello'
abox1=[]
fbox1=[]
try:
    fbox1.append(example1.join.__name__)
except:
    pass
try:
    fbox1.append(example1.count.__name__)
except:
    pass
try:
    fbox1.append(example1.split.__name__)
except:
    pass
try:
    fbox1.append(example1.index.__name__)
except:
    pass
try:
    fbox1.append(example1.format.__name__)
except:
    pass
try:
    fbox1.append(example1.encode.__name__)
except:
    pass
try:
    fbox1.append(example1.replace.__name__)
except:
    pass
try:
    fbox1.append(example1.capitalize.__name__)
except:
    pass
try:
    fbox1.append(example1.casefold.__name__)
except:
    pass
try:
    fbox1.append(example1.center.__name__)
except:
    pass
try:
    fbox1.append(example1.endswith.__name__)
except:
    pass
try:
    fbox1.append(example1.expandtabs.__name__)
except:
    pass
try:
    fbox1.append(example1.find.__name__)
except:
    pass
try:
    fbox1.append(example1.format_map.__name__)
except:
    pass
try:
    fbox1.append(example1.isalnum.__name__)
except:
    pass
try:
    fbox1.append(example1.isalpha.__name__)
except:
    pass
try:
    fbox1.append(example1.isascii.__name__)
except:
    pass
try:
    fbox1.append(example1.isdecimal.__name__)
except:
    pass
try:
    fbox1.append(example1.isdigit.__name__)
except:
    pass
try:
    fbox1.append(example1.isidentifier.__name__)
except:
    pass
try:
    fbox1.append(example1.islower.__name__)
except:
    pass
try:
    fbox1.append(example1.isnumeric.__name__)
except:
    pass
try:
    fbox1.append(example1.isprintable.__name__)
except:
    pass
try:
    fbox1.append(example1.isspace.__name__)
except:
    pass
try:
    fbox1.append(example1.istitle.__name__)
except:
    pass
try:
    fbox1.append(example1.isupper.__name__)
except:
    pass
try:
    fbox1.append(example1.ljust.__name__)
except:
    pass
try:
    fbox1.append(example1.lower.__name__)
except:
    pass
try:
    fbox1.append(example1.lstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.maketrans.__name__)
except:
    pass
try:
    fbox1.append(example1.partition.__name__)
except:
    pass
try:
    fbox1.append(example1.removeprefix.__name__)
except:
    pass
try:
    fbox1.append(example1.removesuffix.__name__)
except:
    pass
try:
    fbox1.append(example1.rfind.__name__)
except:
    pass
try:
    fbox1.append(example1.rindex.__name__)
except:
    pass
try:
    fbox1.append(example1.rjust.__name__)
except:
    pass
try:
    fbox1.append(example1.rpartition.__name__)
except:
    pass
try:
    fbox1.append(example1.rsplit.__name__)
except:
    pass
try:
    fbox1.append(example1.rstrip.__name__)
except:
    pass
try:
    fbox1.append(example1.splitlines.__name__)
except:
    pass
try:
    fbox1.append(example1.startswith.__name__)
except:
    pass
try:
    fbox1.append(example1.strip.__name__)
except:
    pass
try:
    fbox1.append(example1.swapcase.__name__)
except:
    pass
try:
    fbox1.append(example1.title.__name__)
except:
    pass
try:
    fbox1.append(example1.translate.__name__)
except:
    pass
try:
    fbox1.append(example1.upper.__name__)
except:
    pass
try:
    fbox1.append(example1.zfill.__name__)
except:
    pass
datas.append((type1,abox1,fbox1))
type2="<class 'list'>"
example2=[1,2,3]
abox2=[]
fbox2=[]
try:
    fbox2.append(example2.append.__name__)
except:
    pass
try:
    fbox2.append(example2.pop.__name__)
except:
    pass
try:
    fbox2.append(example2.count.__name__)
except:
    pass
try:
    fbox2.append(example2.remove.__name__)
except:
    pass
try:
    fbox2.append(example2.insert.__name__)
except:
    pass
try:
    fbox2.append(example2.clear.__name__)
except:
    pass
try:
    fbox2.append(example2.copy.__name__)
except:
    pass
try:
    fbox2.append(example2.index.__name__)
except:
    pass
try:
    fbox2.append(example2.extend.__name__)
except:
    pass
try:
    fbox2.append(example2.reverse.__name__)
except:
    pass
try:
    fbox2.append(example2.sort.__name__)
except:
    pass
datas.append((type2,abox2,fbox2))
type3="<class 'tuple'>"
example3=(1,5,9)
abox3=[]
fbox3=[]
try:
    fbox3.append(example3.index.__name__)
except:
    pass
try:
    fbox3.append(example3.count.__name__)
except:
    pass
datas.append((type3,abox3,fbox3))
type4="<class 'dict'>"
example4={1:2,3:4}
abox4=[]
fbox4=[]
try:
    fbox4.append(example4.pop.__name__)
except:
    pass
try:
    fbox4.append(example4.get.__name__)
except:
    pass
try:
    fbox4.append(example4.copy.__name__)
except:
    pass
try:
    fbox4.append(example4.clear.__name__)
except:
    pass
try:
    fbox4.append(example4.update.__name__)
except:
    pass
try:
    fbox4.append(example4.keys.__name__)
except:
    pass
try:
    fbox4.append(example4.fromkeys.__name__)
except:
    pass
try:
    fbox4.append(example4.items.__name__)
except:
    pass
try:
    fbox4.append(example4.popitem.__name__)
except:
    pass
try:
    fbox4.append(example4.setdefault.__name__)
except:
    pass
try:
    fbox4.append(example4.values.__name__)
except:
    pass
datas.append((type4,abox4,fbox4))
type5="<class 'bytes'>"
example5=b'hell'
abox5=[]
fbox5=[]
try:
    fbox5.append(example5.join.__name__)
except:
    pass
try:
    fbox5.append(example5.count.__name__)
except:
    pass
try:
    fbox5.append(example5.split.__name__)
except:
    pass
try:
    fbox5.append(example5.index.__name__)
except:
    pass
try:
    fbox5.append(example5.format.__name__)
except:
    pass
try:
    fbox5.append(example5.decode.__name__)
except:
    pass
try:
    fbox5.append(example5.replace.__name__)
except:
    pass
try:
    fbox5.append(example5.capitalize.__name__)
except:
    pass
try:
    fbox5.append(example5.casefold.__name__)
except:
    pass
try:
    fbox5.append(example5.center.__name__)
except:
    pass
try:
    fbox5.append(example5.endswith.__name__)
except:
    pass
try:
    fbox5.append(example5.expandtabs.__name__)
except:
    pass
try:
    fbox5.append(example5.find.__name__)
except:
    pass
try:
    fbox5.append(example5.format_map.__name__)
except:
    pass
try:
    fbox5.append(example5.isalnum.__name__)
except:
    pass
try:
    fbox5.append(example5.isalpha.__name__)
except:
    pass
try:
    fbox5.append(example5.isascii.__name__)
except:
    pass
try:
    fbox5.append(example5.isdecimal.__name__)
except:
    pass
try:
    fbox5.append(example5.isdigit.__name__)
except:
    pass
try:
    fbox5.append(example5.isidentifier.__name__)
except:
    pass
try:
    fbox5.append(example5.islower.__name__)
except:
    pass
try:
    fbox5.append(example5.isnumeric.__name__)
except:
    pass
try:
    fbox5.append(example5.isprintable.__name__)
except:
    pass
try:
    fbox5.append(example5.isspace.__name__)
except:
    pass
try:
    fbox5.append(example5.istitle.__name__)
except:
    pass
try:
    fbox5.append(example5.isupper.__name__)
except:
    pass
try:
    fbox5.append(example5.ljust.__name__)
except:
    pass
try:
    fbox5.append(example5.lower.__name__)
except:
    pass
try:
    fbox5.append(example5.lstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.maketrans.__name__)
except:
    pass
try:
    fbox5.append(example5.partition.__name__)
except:
    pass
try:
    fbox5.append(example5.removeprefix.__name__)
except:
    pass
try:
    fbox5.append(example5.removesuffix.__name__)
except:
    pass
try:
    fbox5.append(example5.rfind.__name__)
except:
    pass
try:
    fbox5.append(example5.rindex.__name__)
except:
    pass
try:
    fbox5.append(example5.rjust.__name__)
except:
    pass
try:
    fbox5.append(example5.rpartition.__name__)
except:
    pass
try:
    fbox5.append(example5.rsplit.__name__)
except:
    pass
try:
    fbox5.append(example5.rstrip.__name__)
except:
    pass
try:
    fbox5.append(example5.splitlines.__name__)
except:
    pass
try:
    fbox5.append(example5.startswith.__name__)
except:
    pass
try:
    fbox5.append(example5.strip.__name__)
except:
    pass
try:
    fbox5.append(example5.swapcase.__name__)
except:
    pass
try:
    fbox5.append(example5.title.__name__)
except:
    pass
try:
    fbox5.append(example5.translate.__name__)
except:
    pass
try:
    fbox5.append(example5.upper.__name__)
except:
    pass
try:
    fbox5.append(example5.zfill.__name__)
except:
    pass
datas.append((type5,abox5,fbox5))
type6="<class 'set'>"
example6={1,2,3,4}
abox6=[]
fbox6=[]
try:
    fbox6.append(example6.pop.__name__)
except:
    pass
try:
    fbox6.append(example6.add.__name__)
except:
    pass
try:
    fbox6.append(example6.remove.__name__)
except:
    pass
try:
    fbox6.append(example6.copy.__name__)
except:
    pass
try:
    fbox6.append(example6.clear.__name__)
except:
    pass
try:
    fbox6.append(example6.update.__name__)
except:
    pass
try:
    fbox6.append(example6.difference.__name__)
except:
    pass
try:
    fbox6.append(example6.difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.discard.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection.__name__)
except:
    pass
try:
    fbox6.append(example6.intersection_update.__name__)
except:
    pass
try:
    fbox6.append(example6.isdisjoint.__name__)
except:
    pass
try:
    fbox6.append(example6.issubset.__name__)
except:
    pass
try:
    fbox6.append(example6.issuperset.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference.__name__)
except:
    pass
try:
    fbox6.append(example6.symmetric_difference_update.__name__)
except:
    pass
try:
    fbox6.append(example6.union.__name__)
except:
    pass
datas.append((type6,abox6,fbox6))
type7="<class '_io.TextIOWrapper'>"
example7=open('newtext.txt','w')
abox7=[]
fbox7=[]
try:
    abox7.append(example7.name.__name__)
except:
    pass
try:
    abox7.append(example7.encoding.__name__)
except:
    pass
try:
    abox7.append(example7.mode.__name__)
except:
    pass
try:
    abox7.append(example7.buffer.__name__)
except:
    pass
try:
    abox7.append(example7.closed.__name__)
except:
    pass
try:
    abox7.append(example7.errors.__name__)
except:
    pass
try:
    abox7.append(example7.line_buffering.__name__)
except:
    pass
try:
    abox7.append(example7.newlines.__name__)
except:
    pass
try:
    fbox7.append(example7.write.__name__)
except:
    pass
try:
    fbox7.append(example7.tell.__name__)
except:
    pass
try:
    fbox7.append(example7.read.__name__)
except:
    pass
try:
    fbox7.append(example7.close.__name__)
except:
    pass
try:
    fbox7.append(example7.seek.__name__)
except:
    pass
try:
    fbox7.append(example7.fileno.__name__)
except:
    pass
try:
    fbox7.append(example7.flush.__name__)
except:
    pass
try:
    fbox7.append(example7.isatty.__name__)
except:
    pass
try:
    fbox7.append(example7.readable.__name__)
except:
    pass
try:
    fbox7.append(example7.readline.__name__)
except:
    pass
try:
    fbox7.append(example7.readlines.__name__)
except:
    pass
try:
    fbox7.append(example7.seekable.__name__)
except:
    pass
try:
    fbox7.append(example7.truncate.__name__)
except:
    pass
try:
    fbox7.append(example7.writable.__name__)
except:
    pass
try:
    fbox7.append(example7.writelines.__name__)
except:
    pass
try:
    fbox7.append(example7.__enter__.__name__)
except:
    pass
try:
    fbox7.append(example7.__exit__.__name__)
except:
    pass
datas.append((type7,abox7,fbox7))
type8="<class 'builtin_function_or_method'>"
example8=print
abox8=[]
fbox8=[]
try:
    abox8.append(example8.__name__.__name__)
except:
    pass
datas.append((type8,abox8,fbox8))
def next_element(codeline,k,elements,end=False,stop=()):           #å¾codelineçš„ç¬¬kè™•é–‹å§‹å°‹æ‰¾elementsï¼Œæ²’æœ‰å‰‡è¿”å›-1
    c=0      #æ‹¬è™Ÿ
    n=len(codeline)
    elements=list(elements)
    while k<n:
        element=codeline[k]
        if c==0:
            if element in elements:
                return k
            elif element in stop:
                if end:return k
                return -1
        if c<0:
            print('å¼·åˆ¶è¿”å›')
            return k
        if element in ('(','[','{'):c+=1
        elif element in (')',']','}'):c-=1
        k+=1
    if end:return n
    return -1
def Read_ex_func():
    def deal_line(line):
        line_dict={}
        n=len(line)
        k=0
        while k<n:
            while k<n and line[k] in ', ':k+=1
            q=next_element(line,k,'( ,',end=True)
            element=line[k:q]
            while q<n and line[q]==' ':q+=1
            if q<n and line[q]=='(':    #ä»£è¡¨é‚„æœ‰å­é¡åˆ¥
                q2=next_element(line,q+1,')')
                line_dict[element]=deal_line(line[q+1:q2])
                k=q2+1
                sub_dict[element]=list(line_dict[element])
            elif q>=n or line[q]==',':
                line_dict[element]={}     #è©²å…ƒç´ æ²’æœ‰å­é¡åˆ¥
                k=q+1
            else:raise Exception('unknow')
        return line_dict
    sub_dict={}   #name:[sub,...]
    module_dict = {}  # module_name:[å­é¡åˆ¥åç¨±,...]
    ex_func_content = open('ex_func.py', 'r', encoding='utf-8').read().split('\n')
    for line in ex_func_content:
        p = next_element(line, 0, ' #', end=True)
        if p < len(line) and line[p] == ' ':
            k = next_element(line, p + 1, ' #', end=True)
            module_name = line[p + 1:k]
            if k<len(line) and line[k]=='#':k-=1
            q = next_element(line, k + 1, '#')
            if q > k:                             #å­é¡åˆ¥å­˜åœ¨
                module_dict[module_name]=deal_line(line[q + 1:])
            else:module_dict[module_name]={}
    return module_dict,sub_dict
def build():
    g = open('built_in.py', 'w')
    g.write('from apython.ex_func import *\n')
    g.write('class bcolors:\n    OK = "[92m"  # GREEN\n    WARNING = "[93m"  # YELLOW\n    FAIL = "[91m"  # RED\n    RESET = "[0m"  # RESET COLOR\n')
    g.write("def built_in_operator(obj,op):\n    stype = str(type(obj))\n")
    k=0
    for stype,abox,fbox in datas:
        if len(fbox)>0:
            if k==0:
                g.write(f'    if stype=="{stype}":\n')
            else:
                g.write(f'    elif stype=="{stype}":\n')
            s=0
            for item in fbox:
                if s==0:
                    g.write(f'        if op==\'{item}\':return obj.{item}\n')
                else:
                    g.write(f'        elif op==\'{item}\':return obj.{item}\n')
                s+=1
            k+=1
    module_dict,sub_dict=Read_ex_func()
    g.write("    elif 'Ex_module' in stype:   #ä»£è¡¨æ˜¯Ex_moduleï¼Œ<class '__main__.Ex_module'>\n        module_name=obj.module_name\n")
    k = 0
    for module_name in module_dict:
        if k == 0:
            g.write(f'        if module_name=="{module_name}":\n')
        else:
            g.write(f'        elif module_name=="{module_name}":\n')
        s = 0
        for sub_term in module_dict[module_name]:
            if s == 0:
                g.write(f'            if op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            else:
                g.write(f'            elif op==\'{sub_term}\':return {module_name}.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'            pass\n')
        k += 1
    g.write('    obj_name=obj.__name__\n')
    k = 0
    for sub_element in sub_dict:
        if k == 0:
            g.write(f'    if obj_name=="{sub_element}":\n')
        else:
            g.write(f'    elif obj_name=="{sub_element}":\n')
        s = 0
        for sub_term in sub_dict[sub_element]:
            if s == 0:
                g.write(f'        if op==\'{sub_term}\':return obj.{sub_term}\n')
            else:
                g.write(f'        elif op==\'{sub_term}\':return obj.{sub_term}\n')
            s += 1
        if s==0:   #ä»£è¡¨æ²’æœ‰sub_term
            g.write(f'        pass\n')
        k += 1
    g.write("    print(f'{bcolors.FAIL}apython built_in error:\\n    {obj} has no attribute {op} {bcolors.RESET}')\n    raise Exception\n")
    g.close()
build()
2118*111*__init__.pyfrom apython.package import Packager
from apython.executer import Executer
class Apython:
    def __init__(self,encoding='utf-8'):
        self.packager = Packager(encoding)
        self.code = self.packager.code
        self.executer = Executer(self.code)
    def parse(self):  # å°å‡ºeasy_code
        code = self.packager.code
        code.display()
    def save(self, filepath):
        code = '\n'.join(self.code.code)
        open(filepath, 'w').write(code)
        print(f'[92mApython:save {filepath}[0m')
    def load(self, filepath):
        self.packager.load(filepath)
    def REPL(self,one_line_cmd=None):                   #äº’å‹•å¼ä»‹é¢ï¼Œä»¥å–®è¡Œæ•¸codeç‚ºè¼¸å…¥
        hint='>>>'
        process = len(self.code.code)
        print_result=''
        while True:
            try:
               if one_line_cmd==None:
                   cmd=input(hint)
               else:
                   cmd=one_line_cmd
            except KeyboardInterrupt:
                print('\nKeyboardInterrupt')
                continue
            except EOFError:
                break
            try:
                need_execute=self.packager.REPL(cmd)        #ç•¶cmdæœ‰def,with,class,...æ™‚ï¼Œæš«åœåŸ·è¡Œ
            except:
                print_result='Compile Error'
                if one_line_cmd!=None:break
                continue
            if need_execute:
                print_result=self.executer.REPL_run(process)      #print_resultç”¨ä¸åˆ°ï¼Œå› ç‚ºå¯¦å‡½æ•¸å°±printéäº†
                process = len(self.code.code)          #æ›´æ–°åŸ·è¡Œé€²åº¦
                hint='>>>'
            else:
                hint='...'
            if one_line_cmd!=None:break
        return print_result
    def interaactive(self,code_block):     #äº’å‹•å¼ï¼Œä»¥ä»»æ„è¡Œæ•¸codeç‚ºè¼¸å…¥
        process=len(self.code.code)
        self.packager.REPL(code_block,one_line=False)
        print_result=self.executer.REPL_run(process)
        return print_result
    def run(self, tf=0, stack_size=1024):
        self.executer.run(tf, stack_size)115341*011*__pycache__5586*123*built_in.cpython-37.pycB
    OÒQe•  ã               @   s"   d dl T G dd„ dƒZdd„ ZdS )é    )Ú*c               @   s   e Zd ZdZdZdZdZdS )Úbcolorsz[92mz[93mz[91mz[0mN)Ú__name__Ú
__module__Ú__qualname__ÚOKZWARNINGÚFAILÚRESET© r
   r
   ú0C:\Users\allen\Desktop\py\py\apython\built_in.pyr      s   r   c             C   sV
  t t| ƒƒ}|dkrÒ|dkr$| jS |dkr2| jS |dkr@| jS |dkrN| jS |dkr\| jS |dkrj| jS |dkrx| jS |d	kr†| j	S |d
kr”| j
S |dkr¢| jS |dkr°| jS |dkr¾| jS |dk rÎ| jS |dk rŞ| jS |dk rî| jS |dk rş| jS |dkr| jS |dkr| jS |dkr.| jS |dkr>| jS |dkrN| jS |dkr^| jS |dkrn| jS |dkr~| jS |dkr| jS |dkr| jS |dkr®| jS |dkr¾| jS |dkrÎ| jS |dkrŞ| jS |d krî| j S |d!krş| j!S |d"kr| j"S |d#kr| j#S |d$kr.| j$S |d%kr>| j%S |d&krN| j&S |d'kr^| j'S |d(krn| j(S |d)kr~| j)S |d*kr| j*S |d+kr| j+S |d,kr®| j,S |d-kr¾| j-S |d.k
r| j.S nF|d/kr|d0krì| j/S |d1krü| j0S |dkr| jS |d2kr| j1S |d3kr,| j2S |d4kr<| j3S |d5krL| j4S |dkr\| jS |d6krl| j5S |d7kr|| j6S |d8k
r| j7S nˆ|d9kr¾|dkrª| jS |dk
r| jS nZ|d:kr||d1krØ| j0S |d;krè| j8S |d5krø| j4S |d4kr| j3S |d<kr| j9S |d=kr(| j:S |d>kr8| j;S |d?krH| j<S |d@krX| j=S |dAkrh| j>S |dBk
r| j?S nœ|dCkrê|dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dDkrÖ| j@S |dkræ| jS |d	krö| j	S |dkr| jS |dkr| jS |dkr&| jS |dkr6| jS |dkrF| jS |dkrV| jS |dkrf| jS |dkrv| jS |dkr†| jS |dkr–| jS |dkr¦| jS |dkr¶| jS |dkrÆ| jS |dkrÖ| jS |dkræ| jS |dkrö| jS |d kr| j S |d!kr| j!S |d"kr&| j"S |d#kr6| j#S |d$krF| j$S |d%krV| j%S |d&krf| j&S |d'krv| j'S |d(kr†| j(S |d)kr–| j)S |d*kr¦| j*S |d+kr¶| j+S |d,krÆ| j,S |d-krÖ| j-S |d.k
r| j.S n.|dEkr|d1kr| j0S |dFkr| jAS |d2kr$| j1S |d5kr4| j4S |d4krD| j3S |d<krT| j9S |dGkrd| jBS |dHkrt| jCS |dIkr„| jDS |dJkr”| jES |dKkr¤| jFS |dLkr´| jGS |dMkrÄ| jHS |dNkrÔ| jIS |dOkrä| jJS |dPkrô| jKS |dQk
r| jLS n|dRk	r&|dSkr"| jMS |dTkr2| jNS |dUkrB| jOS |dVkrR| jPS |dWkrb| jQS |dXkrr| jRS |dYkr‚| jSS |dZkr’| jTS |d[kr¢| jUS |d\kr²| jVS |d]krÂ| jWS |d^krÒ| jXS |d_krâ| jYS |d`krò| jZS |dak	r| j[S |dbk	r| j\S |dck
r| j]S  nòdd|k
r| j^}|dek	rb|dek	rPt_j_S |dfk
rt_j`S n¶|dgk	r|dhk	r|tajbS |dik	rŒtajcS |djk
rtajdS nz|dkk	rê|dlk	r¸tejfS |dmk	rÈtejgS |dnk	rØtejhS |dok
rtejiS n.|dpk
r|dqk
rtejjjkS |drk
rtejjjlS | jm}|dsk
r,|S tntojp› dt| › du|› dvtojq› ƒ tr‚d S )wNz<class 'str'>ÚjoinÚcountÚsplitÚindexÚformatÚencodeÚreplaceÚ
capitalizeÚcasefoldÚcenterÚendswithÚ
expandtabsÚfindÚ
format_mapÚisalnumÚisalphaÚisasciiÚ	isdecimalÚisdigitÚisidentifierÚislowerÚ	isnumericÚisprintableÚisspaceÚistitleÚisupperÚljustÚlowerÚlstripÚ	maketransÚ	partitionÚrfindÚrindexÚrjustÚ
rpartitionÚrsplitÚrstripÚ
splitlinesÚ
startswithÚstripÚswapcaseÚtitleÚ	translateÚupperÚzfillz<class 'list'>ÚappendÚpopÚremoveÚinsertÚclearÚcopyÚextendÚreverseÚsortz<class 'tuple'>z<class 'dict'>ÚgetÚupdateÚkeysÚfromkeysÚitemsÚpopitemÚ
setdefaultÚvaluesz<class 'bytes'>Údecodez<class 'set'>ÚaddÚ
differenceÚdifference_updateÚdiscardÚintersectionÚintersection_updateÚ
isdisjointÚissubsetÚ
issupersetÚsymmetric_differenceÚsymmetric_difference_updateÚunionz<class '_io.TextIOWrapper'>ÚwriteÚtellÚreadÚcloseÚseekÚfilenoÚflushÚisattyÚreadableÚreadlineÚ	readlinesÚseekableÚtruncateÚwritableÚ
writelinesÚ	__enter__Ú__exit__Ú	Ex_moduleÚtimeÚsleepÚmathÚsinÚcosÚtanÚosÚgetcwdÚlistdirÚmkdirÚchdirzos.pathÚisdirÚisfiler   zapython built_in error:
    z has no attribute ú )sÚstrÚtyper   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r    r!   r"   r#   r$   r%   r&   r'   r(   r)   r*   r+   r,   r-   r.   r/   r0   r1   r2   r3   r4   r5   r6   r7   r8   r9   r:   r;   r<   r=   r>   r?   r@   rA   rB   rC   rD   rE   rF   rG   rH   rI   rJ   rK   rL   rM   rN   rO   rP   rQ   rR   rS   rT   rU   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   ra   rb   rc   rd   re   rf   rg   Úmodule_nameri   rj   rk   rl   rm   rn   ro   rp   rq   rr   rs   Úpathrt   ru   r   Úprintr   r   r	   Ú	Exception)ÚobjÚopÚstypery   Zobj_namer
   r
   r   Úbuilt_in_operator   s†   
            
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 

 
 
 

 
 
 
 

 
 
 "r€   N)Zapython.ex_funcr   r€   r
   r
   r
   r   Ú<module>   s   8696*119*code.cpython-37.pycB
    ÈTTej:  ã               @   s   d dl mZ G dd„ dƒZdS )é    )ÚUndefinec               @   s€   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
d dd„Zd!dd„Zdd„ Zdd„ Zdd„ Zdd„ ZdS )"ÚCodec             C   s   d| _ |  ¡  d S )N)ÚAXÚBX)ÚtemÚclean)Úself© r	   ú,C:\Users\allen\Desktop\py\py\apython\code.pyÚ__init__   s    zCode.__init__c             C   s.   g | _ g | _d| _g | _d| _g | _d| _d S )Nr   éÿÿÿÿ)r   r   r   )ÚcodeÚcommentsÚsimplifyÚbase_numÚbase_espÚfile_edÚbase)r   r	   r	   r
   r      s    z
Code.cleanc             C   s"   || j kr| j  |¡ | j  |¡S )N)r   ÚappendÚindex)r   Únamer	   r	   r
   Z__apply_file   s    
zCode.__apply_filec             C   s    |   |¡}| j |dgf¡ d S )Nr   )Ú_Code__apply_filer   r   )r   r   Únamecoder	   r	   r
   Ú
add_newtab   s    
zCode.add_newtabc             C   s   | j d= d S )Nr   )r   )r   r	   r	   r
   Ú
del_newtab   s    zCode.del_newtabc             C   s   d S )Nr	   )r   r	   r	   r
   Úadd_tab   s    zCode.add_tabc             C   s   d S )Nr	   )r   r	   r	   r
   Údel_tab   s    zCode.del_tabc             C   sf   |t | jƒk rP| j| d d }| j| }| j|d d  |d d |d dœS d|| j| dœS d S )Nr   é   é   )ÚfileÚrowr   Ú )Úlenr   r   r   )r   r    Zcmt_nÚcmtr	   r	   r
   Úget_error_msg   s
    
&zCode.get_error_msgNr   c       
      C   s   |d krx|d dkrx|\}}|| j | j d d< t| j | j d ƒ}| j | j d }||t| jƒf| _| j | j|f¡ |dkr„d S | jdkr@|dkr@|d kr@t| jƒdkr@t	|ƒt
kr@t	| jd ƒt
kr@| jd  d¡}| d¡}	|d dkrJ|	d dkrJ| jd= |d |	d kr>| j d|	d › d|d › ¡ qL|d dkr¬|	d dkr¬|d |	d kr¬| jd= |d | jkr>| j d|d › d	¡ qL|d d
kr|	d dkr|d |	d kr|d | jkr| jd= | j d|d › ¡ qL|d dkrj|	d d
krj|d |	d krj|d | jkrj| jd= | j d|	d › ¡ nÔ|d d
kr¬|	d d
kr¬|d |	d kr¬|d |	d kr¬n’|d d
kr|	d d
kr|d |	d kr|d | jkr| jd= | j d|	d › d|d › ¡ n*|	d dkr2|	d dkr2n| j |¡ n| j |¡ | jdkrf|  jd8  _|  j|7  _t| jƒt| jƒkrœ| j | jdf¡ d S )Nr   r!   r   r   ú ÚpushÚpopzmov z <esp+1>Úmovzpush r   zpop )ÚaddÚsubÚ0)r   r   Úsumr"   r   r   r   r   r   ÚtypeÚstrÚsplitr   )
r   ZcommandZcommentr   r#   r    Zreal_rowr   ZlastÚcmdr	   r	   r
   r   '   sP     R
$.>>@>" zCode.appendr   c       	      C   s.  t dƒ t| jƒ}||k rD|dkrD|t| jƒk rD| j| d d }n|}xØt|ƒD ]Ì}||krbdndt|ƒ ddtt|ƒƒ   d	 | j|  }d
}| j| }|d dkrì||kr¶dndt|d d ƒ ddtt|ƒƒ   d |d  }nd}t ||d d…  d | ƒ |dkrRt dƒ P qRW t dƒ d S )Nz --------------------------------r   r   r   u    â— z   r%   é   ú|zF                                                                      r   r!   z| é(   úéd   zrow more than 100)Úprintr"   r   r   Úranger.   )	r   Znow_ipÚRowZnow_rowÚiZ	statementZspacer#   Ú	orig_coder	   r	   r
   ÚdisplayQ   s"    
:
BzCode.displayc          #      s  dd„ }‡ ‡fdd„}ddddd	d
dddddddddddddddddddddd dd!d"d#d$d%d&œ"}d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7œ‰ t tˆ ƒƒˆ_d'gˆj ˆ_ˆ jtƒ gd8 7  _d9ˆjd3< d:ˆjd4< d ˆjd5< d ˆjd6< g }xˆjD ]}|d;kr| d<g¡ qî| d=¡d' }|| }|d' g}t |ƒd( }	d'}
x¶|
|d( k sj|d( d>krô|	t |ƒk rô||	 d?kr^|||	ƒ\}}	|
d(kr@|d@krÄdA |d(d>… ¡}| d'|t	|ƒƒf¡ nz|dBkrødC |d(d>… ¡}| d'|t	|ƒƒf¡ nF|dDkr,dE |d(d>… ¡}| d'|t	|ƒƒf¡ n| d'||ƒf¡ n| d'||ƒf¡ |	d)7 }	nŠ||	 dFkrÆ|	}x*|t |ƒk rš|| dGkrš|d(7 }qrW ||	|… }| d'||ƒf¡ |d( }	n"||	 dHkrP| dI|	¡}||	d( |… }|dJkr| dK¡ n>|dLkr| dM¡ n(|dNkr2| dO¡ n| d1t
|ƒf¡ |d) }	n˜||	 dPkr”| dQ|	¡}| d3t
||	d( |… ƒf¡ |d) }	nTd;}||	 dRkr*| dS|	¡}||	d( |… }dT|krì| dT¡}|d' t
|d( ƒg}n|d'g}|d(7 }|d' dUkr$|dV7 }||d' ƒ|d'< ndW}nV|	}x*|t |ƒk rX|| dXkrX|d(7 }q0W ||	|… g}|dY7 }||d' ƒ|d'< |d( }	|t |ƒk rş|| dZkrş|d(7 }x*|t |ƒk rÖ|| dXkrÖ|d(7 }q®W ||	|… }| |¡ |dY7 }|d( }	|t |ƒk r|| dHkr||d(  d?krV|||d( ƒ\}}| ||ƒ¡ |d(7 }n*| dI|¡}||d( |… }| ||ƒ¡ |dV7 }|d) }	|dYkr°| d'|d' f¡ n8|d[krÖ| d(|d' |d( f¡ n|d\krú| d)|d' |d( f¡ nî|dVkr| d*|d' |d( f¡ nÊ|d]krH| d+|d' |d( |d) f¡ n |d^krr| d,|d' |d( |d) f¡ nv|dWkr–| d-|d' |d( f¡ nR|d_krÀ| d.|d' |d( |d) f¡ n(|d`krè| d/|d' |d( |d) f¡ |
d(7 }
q@W | |¡ qîW |ˆjˆ fS )aNc             S   s^   | | }|d7 }|}x0| | dkr,|d7 }n| | |kr:P |d7 }qW || ||…  | |fS )Nr   ú\r	   )ÚcodelineÚkÚcÚpr	   r	   r
   Údeal_stringf   s    
z$Code.parse_code.<locals>.deal_stringc                sb  | ˆ krZt ˆjƒˆj dk r4ˆ jtƒ gd 7  _ˆjˆ | < | d dkr| dd… }| d dkrdd	d
ddddddddœ
}dt |ƒ }}g }xf||k rø|| dkrà|||d … |krà| ||||d …  ¡ |d7 }n| || ¡ |d7 }q”W d |¡}|ˆjˆj< n:| d dkrLd| kr<t| ƒˆjˆj< nt| ƒˆjˆj< ˆ jd7  _ˆ |  S )Nr5   i   r   )ú"ú'r   r   rB   Ú
r4   ú	úúúúrC   r<   )
z\nz\rz\tz\az\bz\fz\vz\"z\'z\\r   r!   z0123456789-Ú.)r"   ÚdataÚdata_nr   r   ÚjoinÚfloatÚint)ÚitemÚstringZrboxr>   ÚnZtext_box)Ú	data_dictr   r	   r
   Ú
login_itemq   s0    


 


 z#Code.parse_code.<locals>.login_item)r   r   )r   é   )r   rU   )rU   r   )r1   r   )é   r   )é   r   )é   r   )é   r   )é	   rU   )é
   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   r   )é   rU   )é   r   )é   r   )é   rU   )é   rU   )é   rU   )é   r   )é    r   )é!   r   )"r(   z$movÚoperZcmpZjmpz$jmpZcallr&   r'   ÚtfZincZdecz$operZex_funcÚtryÚfinallyÚraiseÚerrorÚ	GeneratorZYieldZfetchÚstopÚendZbyteÚdelZFunctionÚglobalÚ	namespaceÚpassz*argsz**kwargsÚmoduler-   r   r   r   r   rU   r1   rV   rW   rX   rY   rZ   r[   r\   r]   r^   r_   r`   )r   r   ÚCXÚDXÚipÚespÚspÚZRÚTFz*argsz**kwargsz
$ExceptionÚTrueÚFalseÚNonez$Inheritancei   TFr!   rk   r%   r   )rB   rC   )z$movrr   )ú+ú-Ú*ú/z**ú%z//z<<z>>ú&ú^r2   rs   )ÚinZequZCtnÚisz$oper)Únotr‹   ú~z0123456789-z-0123456789.ú[ú]Údict)r\   r   Úclass)r^   r   Úfunc)ra   r   ú(ú)ú<ú>rŠ   rƒ   Ú1Ú2z[ .r+   rJ   Z00Z01Z10Z11Z20Z21)r"   ÚtuplerL   rK   r   r   r   r/   r   r.   rO   )r   rA   rT   Zcmd_dictÚcodesÚlineÚopr0   Údealr>   Zfetch_krQ   Zop_numZk2ÚnumberÚvalueZtypeboxr   r?   ÚresultÚattrZk3r	   )rS   r   r
   Ú
parse_codee   s   






.



 




  






 
 

 
zCode.parse_codec             C   s
   t | jƒS )N)r"   r   )r   r	   r	   r
   Ú__len__  s    zCode.__len__c             C   s
   | j | S )N)r   )r   rP   r	   r	   r
   Ú__getitem__  s    zCode.__getitem__c             C   s   || j |< d S )N)r   )r   Úkeyr¦   r	   r	   r
   Ú__setitem__  s    zCode.__setitem__)Nr   )r   )Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r$   r   r;   r©   rª   r«   r­   r	   r	   r	   r
   r      s   
*
 6r   N)Úapython.executerr   r   r	   r	   r	   r
   Ú<module>   s   24095*123*executer.cpython-37.pycB
    °ˆTe ›  ã            B   @   sf  d dl T G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZd
d„ Zeeee	e
eeeeeeeeeeeeeeeeeeeeee e!e"e#e$e%e&e'e(e)e*e+e,e-e.e/e0e1e2e3e4e5e6e7e8e9e:e;e<e=e>e?e@eAeBeCeDeEeFeGgBZHeIeJeKeLeMeNeOePeQeReSeTeUgZVeWeXeYeZe[gZ\e]e^edœZ_x eHeV e\ D ]Z`e`e_e`ja< qW G dd„ dƒZbG dd„ dƒZcG dd„ dƒZdG dd„ dƒZedS )é    )Ú*c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚUndefinec             C   s   d| _ d| _d S )Nz[91mz[0m)ÚFailÚRESET)Úself© r   ú0C:\Users\allen\Desktop\py\py\apython\executer.pyÚ__init__   s    zUndefine.__init__c             C   s   | j › d| j› S )Nz<undefined>)r   r   )r   r   r   r   Ú__str__   s    zUndefine.__str__N)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r      s   r   c               @   s|   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zdd„ Zdd„ Zdd„ Zdd„ Zdd„ ZdS )Ú	class_objc             C   s   || _ d | _i | _d| _d S )Nr   )ÚramÚatypeÚvarsÚ
print_lock)r   r   r   r   r   r	   	   s    zclass_obj.__init__c             C   s(   | j dkr$d| jkr$| j | g d¡S dS )Nr   r
   z<class_obj>)r   r   r   Úcall_obj_function)r   r   r   r   r
      s    zclass_obj.__str__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__add__)r   r   r   r   )r   Úotherr   r   r   r      s    zclass_obj.__add__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__sub__)r   r   r   r   )r   r   r   r   r   r      s    zclass_obj.__sub__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__len__)r   r   r   r   )r   r   r   r   r      s    zclass_obj.__len__c             C   s,   | j dkr(d| jkr(| j | ||gd¡S d S )Nr   Ú__setitem__)r   r   r   r   )r   ÚkeyÚvaluer   r   r   r      s    zclass_obj.__setitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__getitem__)r   r   r   r   )r   Úitemr   r   r   r      s    zclass_obj.__getitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__contains__)r   r   r   r   )r   r   r   r   r   r   !   s    zclass_obj.__contains__c             C   sR   | j dkr$d| jkr$| j | g d¡S d| jkrNd| _|  jd7  _|  | j¡S d S )Nr   Ú__next__r   Fé   )r   r   r   r   ÚerrorÚitem_kr   )r   r   r   r   r   $   s    
zclass_obj.__next__c             C   s.   d| _ | jdkr*d| jkr*| j | g d¡S | S )Néÿÿÿÿr   Ú__iter__)r!   r   r   r   r   )r   r   r   r   r#   +   s    zclass_obj.__iter__c             C   s.   | j dkr*d| jkr*| j | |||gd¡S d S )Nr   Ú__exit__)r   r   r   r   )r   Úexc_typeZexc_valZexc_tbr   r   r   r$   0   s    zclass_obj.__exit__c             O   s*   | j dkr&d| jkr&| j | |d|¡S d S )Nr   Ú__call__)r   r   r   r   )r   ÚargsÚkwargsr   r   r   r&   3   s    zclass_obj.__call__c             C   s(   | j dkr$d| jkr$| j | g d¡S d S )Nr   Ú__del__)r   r   r   r   )r   r   r   r   r)   6   s    zclass_obj.__del__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__eq__)r   r   r   r   )r   r   r   r   r   r*   9   s    zclass_obj.__eq__N)r   r   r   r	   r
   r   r   r   r   r   r   r   r#   r$   r&   r)   r*   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFuncc             C   s4   d| _ d| _|| _||dœ| _|| _|| _|| _d S )NÚFunction)Úipr   )Únamer   r   r   Ú
stack_nameÚ	stack_lenÚimport_funcs)r   r   r-   r   Zfunc_varr0   r1   r   r   r   r	   =   s    zFunc.__init__c             C   s
   t | jƒS )N)Ústrr.   )r   r   r   r   r
   E   s    zFunc.__str__c             O   sJ   || j j| j j< || j j| j j< | j  | jd | jd | j| j| j¡}|S )Nr-   r   )	r   ÚdataÚargs_locationÚkwargs_locationÚfunc_runr   r/   r0   r1   )r   r'   r(   Úresultr   r   r   r&   G   s    &zFunc.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r+   <   s   r+   c               @   s<   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ ZdS )Ú	generatorc                sP   |ˆ _ |ˆ _|ˆ _g ˆ _dˆ _dˆ _dˆ _d ˆ _g ˆ _‡ fdd„}d|iˆ _	d S )Nr   TFc                s&   ˆ j sdˆ _| ˆ _ˆ  ¡ S tdƒ‚d S )NTz5can't send non-None value to a just-started generator)Ú	next_lockÚsendÚsend_objÚ_generator__nextÚ	TypeError)r   )r   r   r   r:   \   s
    z generator.__init__.<locals>.sendr:   )
r   Únext_ipr1   Úex_stackÚenterr9   r:   r;   Úfinally_boxr   )r   r   Ústart_ipr1   r:   r   )r   r   r	   M   s    zgenerator.__init__c             C   s   dS )Nz<generator_obj>r   )r   r   r   r   r
   c   s    zgenerator.__str__c             C   s   |   ¡ S )N)r<   )r   r   r   r   r   r   e   s    zgenerator.__getitem__c             C   s   d| _ | jrd | _|  ¡ S )NF)r9   r:   r;   r<   )r   r   r   r   r   g   s    zgenerator.__next__c             C   sö   | j dkrt‚nâd| _ | js>| j | j| j| j¡\}| _}}n&| jj| j| j| j| jd\}| _}}|d krî|\| _}xl|D ]d}|d dkr®||d  }| j	 
|d |g¡ q|x0| j	D ]&}|d t|d ƒkr¶| j	 |¡ P q¶W q|W d| _ |S t‚d S )Nr   )r;   r   r"   )r@   ÚStopIterationr:   r   Ú	yield_runr>   r?   r1   r;   rA   ÚappendÚabsÚremove)r   Únext_objÚyield_resultÚbase_esprA   Úf_ipZex_stack_numZfipr   r   r   Z__nextl   s&    
"&


zgenerator.__nextc             C   s  xş| j D ]ô}|d d | jj| jj< i }x0| jD ]&}| jj| ||< | j| | jj|< q0W x&t|d ƒD ]}| j | j| ¡ qhW | j d ¡ | j d¡ z@y| j 	d¡ W n* t
k
rÖ } zt|ƒ W d d }~X Y nX W d x|D ]}|| | jj|< qâW X qW d S )Nr   r   zfinally yield run)rA   r   r3   r-   r1   Ú
func_stackÚrangeÚpushr?   Úone_runÚ	ExceptionÚprint)r   rK   Ú
tem_stacksÚ	func_nameÚiÚer   r   r   r)   …   s     
zgenerator.__del__N)	r   r   r   r	   r
   r   r   r<   r)   r   r   r   r   r8   L   s   r8   c             C   s4   t | ƒtkr| jS t | ƒtkr,d| j› dS t | ƒS )Nz<class '__main__.z'>)Útyper   r   r+   r.   )Úobjr   r   r   r   Ÿ   s
    r   )ÚhelpÚIOErrorrV   c               @   s¢   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dd„ Z
dd„ Zd(dd„Zd)dd„Zdd„ Zdd„ Zdd„ Zdd„ Zd d!„ Zd*d$d%„Zd&d'„ ZdS )+ÚExecuterc             C   s    || _ t ¡ | _g | _i | _d S )N)ÚcodeÚbifsÚcopyÚex_functionÚ	run_layerrL   )r   r[   r   r   r   r	   °   s    
zExecuter.__init__c             C   s   | j | }|| j|< d S )N)Ú	data_dictr3   )r   Úvar_namer   Úlocationr   r   r   Úsetµ   s    
zExecuter.setc             C   s&   || j | j d < | j d  d8  < d S )Né   r   )r3   )r   r   r   r   r   rN   ¸   s    zExecuter.pushc             C   s"   | j d  d7  < | j | j d  S )Nrd   r   )r3   )r   r   r   r   Úpop»   s    zExecuter.popc             C   s8   || j kr| j | S | j| j |< |  jd7  _| jd S )Nr   )Úvar_dictZ	used_size)r   ra   r   r   r   Úlogin¾   s
    

zExecuter.loginc             C   s
   | j | S )N)rf   )r   ra   r   r   r   Úget_var_locationÄ   s    zExecuter.get_var_locationc             C   sB   x<t dƒD ]0}| j| | j| j| j < | j| j  d8  < q
W d S )Nrd   r   )rM   r3   Úesp)r   rT   r   r   r   ÚpushawÆ   s    zExecuter.pushawc             C   sF   x@t dƒD ]4}| j| j  d7  < | j| j| j  | jd| < q
W d S )Nrd   r   é   )rM   r3   ri   )r   rT   r   r   r   ÚpopawÊ   s    zExecuter.popawc             C   s–  |d dkr|| j |d < nt|d dkrF|| j |d  j|d < nL|d dkrr|| j |d  | j |d  < n |d dkrœ|| j | j |d  |d  < nö|d dkrĞ|| j | j |d  |d   j|d < nÂ|d dkr
|| j | j |d  |d   | j |d  < nˆ|d dkr0|| j|d  |d < nb|d dkr`|| j|d  |d  j|d < n2|d d	kr’|| j|d  |d  | j |d  < d S )
Nr   r   é   é   rk   rd   é   é   é   )r3   r   rL   )r   rb   r   r   r   r   r   Î   s$     (,"zExecuter.__setitem__Nc          	   C   sf   | j | j }|d kri }|  ¡  t|ƒ| j d< |j| }d }z|||}W d |  ¡  || j | j< X |S )Nrm   )r3   ri   rj   Úlenr   rl   )r   rW   r'   Úfuncnamer(   Útem_espÚfuncr7   r   r   r   r   ä   s     
zExecuter.call_obj_functionc             C   s  | j | j }|| j | j< i }x(|D ] }| j| ||< || | j|< q"W | j | j }x|D ]}	|  |	¡ qXW d }
d}z|| j d< |  d¡}d}W d | jd= |r¦| j d }
g }x,t|| j | j  ƒD ]}| d|  	¡ ¡ qÀW x|D ]}|| | j|< qŞW || j | j< X |||
|fS )NFr   z	yield runTr"   )
r3   r-   rL   ri   rN   Ú_Executer__runr_   rM   Úinsertre   )r   r-   r?   r1   r;   Útem_iprR   rS   rt   Zex_objrI   ZokrH   Znew_ex_stackrT   r   r   r   rD   ñ   s2    





zExecuter.yield_runc          
   C   s  | j | j }| j | j }i }x(|D ] }	| j|	 ||	< ||	 | j|	< q"W || jkrZd | j|< | j| }
dg| }||d< || j|< |d | j | j< |  t| jƒ¡ d }z|  d|› d¡ W d | j d }| jd= || j | j< |
| j|< x|D ]}	||	 | j|	< qêW || j | j< X |S )Nr   r   zFunc<z> runr"   )	r3   r-   ri   rL   rN   rr   r[   rv   r_   )r   r-   r   r/   r0   r1   rx   rt   Ztem_func_stackrS   Z	tem_stackrL   r7   r   r   r   r6     s2    








zExecuter.func_runc             C   s¤  |d dkr| j |d  S |d dkrÌ| j |d  }t|ƒtttfkrh|d |jkrb|j|d  S | jS t|ƒtkrt| j	|d  › dƒ‚n:t|ƒt
kr¶|d |jkr¶|j|d  S t||d ƒ}|S nÔ|d dk rö| j |d  | j |d   S |d dkr | j | j |d  |d   S |d dkrì| j | j |d  |d   }t|ƒtttfkr‚|d |jkr||j|d  S | jS t|ƒtkrªt| j	|d  › dƒ‚n>t|ƒt
krÖ|d |jkrÖ|j|d  S t||d ƒ}|S n´|d dkr$| j | j |d  |d   | j |d   S |d dkrH| j|d  |d  S |d d	krü| j|d  |d  }t|ƒtttfkr¤|d |jkr|j|d  S | jS t|ƒtkr¼td
ƒ‚n>t|ƒt
krè|d |jkrè|j|d  S t||d ƒ}|S n¤|d dkr.| j|d  |d  | j |d   S |d dkrJdg|d  S |d dkr\i S |d dkrxdg|d  S |d dkr | j t| ƒ¡ | jd S d S )Nr   r   rm   z is undefinedrn   rk   rd   ro   rp   zthis variable is undefinedrq   é
   é   é   é   r"   )r3   rV   r   r8   ÚNamespace_stackr   Ú	undefinedr   rP   Úinverse_data_dictÚ	Ex_moduleZbuilt_in_operatorrL   Ú
class_objsrE   )r   rb   rW   ru   r   r   r   r   6  sr    *
$zExecuter.__getitem__c             C   s    d}d}t |› |› |› ƒ d S )Nz[91mz[0m)rQ   )r   Úmsgr   r   r   r   r   Z__error_print~  s    zExecuter.__error_printc             C   s    d}d}t |› |› |› ƒ d S )Nz[92mz[0m)rQ   )r   r‚   ZOKr   r   r   r   Z
__ok_print‚  s    zExecuter.__ok_printc             C   s   |   |¡ d S )N)rv   )r   Úcommentr   r   r   rO   †  s    zExecuter.one_runr   é (  c       
   
   C   s*  | j  ¡ \| _| _| _i | _x| jD ]}|| j| j| < q$W |  jdg| 7  _|  dd¡ |  dd¡ | jd | _| jd | _| jd | _	| jd | _
| jd | _d| j| j< d| _| jd | _| jd	 | _|| _g | _i | _tƒ | _x.| jD ]$}|| jkrğ| j| | j| j| < qğW yD|  d
¡ | j| j dkrB|  d¡ n|  d| j| j › ¡ W nÈ tk
r$ } z¨dd„ }| j| j dkr˜| j| j }n| j}| j  |¡}|  d|d  d t|d 
 ƒ ¡ |  d|d  ¡ t|ƒ}	t|	ƒdkrşd|	 }	|  ||ƒ|	 ¡ |‚W d d }~X Y nX d S )Nr   ri   r"   r-   ÚZRÚTFz
$Exceptionz*argsz**kwargsZnormalu   
ç¨‹å¼æ­£å¸¸çµæŸ--------u   å †ç–Šæœªé‚„åŸ---------->   c             S   s6   t t| ƒƒ}| d¡}| d|d ¡}||d |… S )Nú'r   )r2   rV   Úindex)rU   ZstypeÚkÚk2r   r   r   Úfetch_error©  s    
z!Executer.run.<locals>.fetch_errorz
Trackback:
FILE: Úfilez,  line:Úrowz   r[   z: )r[   Ú
parse_codeÚcodesr3   r`   r   rc   ri   r-   r…   r†   ÚERÚ
error_liner4   r5   Útfr   rL   r   r~   r^   rv   Ú_Executer__ok_printÚ_Executer__error_printrP   Úget_error_msgr2   rr   )
r   r’   Ú
stack_sizer   r.   rU   r‹   Úerror_ipr‚   r    r   r   r   Úrunˆ  sR    

$ zExecuter.runc       2   
      sæ  ˆj  |¡ ‡fdd„‰‡‡fdd„‰ ‡ ‡‡‡fdd„}ˆj‰ˆj‰ˆj}ˆj}ˆj}ˆj}ˆj}g }t	ˆj
ƒ}	x\ˆjˆ |	k rÎˆj
ˆjˆ  }
ˆjdkrî|ƒ  tƒ }|dkrît	|ƒd	k rÆd
ˆ_n(|dkrŞtdƒ dˆ_nˆ d¡ dˆ_ˆjdkr4ˆjˆ }dˆjj|  dˆjj| › d|›  }t|ƒ |
d dkrZˆ|
d  ˆ|
d < n`|
d dkr`ˆ|
d  }|dkrˆ|
d   ˆ|
d	  7  < qº|dkrÈˆ|
d   ˆ|
d	  8  < qº|dkròˆ|
d   ˆ|
d	  9  < qº|d	krˆ|
d   ˆ|
d	    < qº|dkrFˆ|
d   ˆ|
d	  C  < qº|dkrnˆ|
d   ˆ|
d	  ;  < nî|dkr–ˆ|
d   ˆ|
d	    < nÆ|dkr¾ˆ|
d   ˆ|
d	  K  < n|dkræˆ|
d   ˆ|
d	  L  < nv|dkrˆ|
d   ˆ|
d	  M  < nN|dkr6ˆ|
d   ˆ|
d	  N  < n&|dkrºˆ|
d   ˆ|
d	  O  < nZ|
d dkr˜ˆ|
d  }|dkr¨ˆ|
d  ˆ|
d	   ˆ|
d < qº|dkrÖˆ|
d  ˆ|
d	   ˆ|
d < qº|dkrˆ|
d  ˆ|
d	   ˆ|
d < qº|d	kr2ˆ|
d  ˆ|
d	   ˆ|
d < qº|dkr`ˆ|
d  ˆ|
d	   ˆ|
d < qº|dkrˆ|
d  ˆ|
d	   ˆ|
d < qº|dkrºˆ|
d  ˆ|
d	   ˆ|
d < nÚ|dkræˆ|
d  ˆ|
d	  > ˆ|
d < n®|dkrˆ|
d  ˆ|
d	  ? ˆ|
d < n‚|dkr>ˆ|
d  ˆ|
d	  @ ˆ|
d < nV|dkrjˆ|
d  ˆ|
d	  A ˆ|
d < n*|dkrºˆ|
d  ˆ|
d	  B ˆ|
d < n"|
d d	krÈˆ|
d  ˆ|
d   ˆj|< 
nò|
d dkrìˆ|
d  ˆjˆ< 
nÎ|
d dkrÜˆ|
d  }ˆj| }ˆj| }|dkr.|dks’|dkrB|dks’|dkrV|dks’|dkrj|dks’|d kr~|dks’|d!kr¦|dk r¦ˆ|
d  ˆjˆ< n2|d"kr¶|sÆ|d#krº|sºˆ|
d  ˆjˆ< 	nŞ|
d dkrÈˆ|
d  }|d kr|
d d	 }t|ƒtkr:ˆj| }ˆj| }||| nŠt|ƒtkrˆˆj| }ˆj| }ˆjˆ }ˆj| ||ˆjd< |ˆjˆ< n<ˆj| }ˆj| }ˆjˆj }|||ˆjd< |ˆjˆj< nò|
d dkrˆ|
d  ˆjˆjˆ < ˆjˆ  d8  < n¶|
d dkr@ˆjˆ  d7  < ˆjˆjˆ  ˆ|
d < nz|
d dk	rˆ|
d  }|dkr„ˆ|
d	  ˆ|
d  kˆj|< n~|dkr®ˆ|
d	  ˆ|
d  kˆj|< nT|dkrÚˆ|
d	  ˆ|
d  jkˆj|< n(|d	krºˆ|
d	  ˆ|
d  kˆj|< n´|
d dk	r,ˆ|
d   d7  < n|
d dk	rRˆ|
d   d8  < nh|
d d$k	ròˆ|
d  }|dk	r¬yˆ|
d   ˆ|
d < W n   d%ˆ|
d < Y nX nB|dk	rÎˆ|
d   ˆ|
d < n |dkrºˆ|
d   ˆ|
d < nÈ|
d d&k
r>ˆjˆ }ˆjˆ|
d   ˆ|
d	  ƒˆ|
d < |ˆjˆ< n||
d d'k
ròˆ|
d  }|d(k
rfd S ˆjˆ  d7  < ˆjˆ }yˆ d)|› ¡ W nN tk

rä } z.ˆjˆ ˆ_|ˆjˆ< |ˆj|< |ˆjˆ< W d d }~X Y nX ˆj d*= nÈ|
d d+kr&ˆ|
d  }| |ˆjˆj f¡ n”|
d d,krDˆ|
d  ‚nv|
d d-krÎˆ|
d  }t|ƒtkrœt|kr‚d.ˆj|< ntˆj| ƒ|kˆj|< n.|tkr²d.ˆj|< ntˆj| ƒ|kˆj|< nì|
d d/kr@ˆ|
d  }d	}i }x6|t	|
ƒk r&ˆ|
|  }ˆj| ||< |d7 }qòW tˆ||ƒˆ|
d < nz|
d d0krxˆj d* d1krftd2ƒ‚ˆjˆ d |fS |
d d3krˆjˆ }ˆjˆ }y*ˆ|
d  }t|ƒˆ|
d < d.ˆj|< W n. tk
rò } zd%ˆj|< W d d }~X Y nX |ˆjˆ< |ˆjˆ< n®|
d d4kr<td5ˆjˆj d6ˆjˆj ƒ n~|
d d7krÚˆ|
d  } | d8krtˆj d* d1krtd S | d9krºˆ|
d  }t	|
ƒd	krºˆ|
d	   d:¡}!tt t!|!ƒƒ}"x|"D ]}#d ˆj| |#< q¾W nà|
d d;krˆ|
d   "¡ ˆ|
d < n¶|
d d<kr€ˆ|
d  }|dkr8t#ƒ ˆ|
d < nD|dkrZˆ|
d  ˆ|
d	  = n"|dkrºˆ|
d  jˆ|
d	  = n:|
d d=krˆ|
d  }$ˆ|
d	  }%ˆ|
d  }&ˆ|
d  }'d}i }x6|t	|
ƒk rüˆ|
|  }ˆj| ||< |d7 }qÈW tˆ|$|%|&|'|ƒˆ|
d < n|
d d>kr.nŒ|
d d?kr°ˆ|
d	   d:¡}(d})i }*x|(D ]}+|)|*|+< |)d7 })q\W t#ƒ g|) },ˆ|
d  }-|,ˆj|-< t$ˆ|-|*ƒˆ|
d < n
|
d d@kräˆ|
d  ˆ|
d	  d … ˆ|
d < nÖ|
d dAkrHˆ|
d  }.ˆ|
d	   d:¡}/i }0x$|.D ]}1|1|/kr|.|1 |0|1< qW |0ˆ|
d < nr|
d dBkrpt%ˆ|
d  ƒˆ|
d < nJ|
d dCkr–ˆ|
d  ˆ|
d  _&n$|
d dDkrºˆ|
d  ˆ|
d  _'ˆjˆ  d7  < qtW ˆjdkrâ|ƒ  d S )ENc                s   xˆ j D ]
}| |_qW d S )N)r   r   )ÚlockrW   )r   r   r   Úobj_lock½  s     z Executer.__run.<locals>.obj_lockc                 sJ  t ddd xŠˆjD ]€} | d dkrX| dkrX| ˆjkrXt | › dˆjˆj|   › dd | d	krlt d
dd | dkr€t d
dd | dkrt ddd qW d}d}xVtdƒD ]J}ˆj| d  }t|ƒd }|d tˆjˆ  ƒk rì|t|ƒ7 }||7 }qªW t |d d… d ƒ t d| d ƒ x(ˆjD ]}t |› dˆj| › ƒ q$W d S )Nzdata: Ú )Úendr   z"0123456789-')ÚNoneÚTrueÚFalseú:z  )r†   z**kwargsz
      z
$Exceptionz$Inheritanceu   
è‡ªç”±è®Šæ•¸:
      z	

stack:[rp   é   r   ú,r"   ú]ú ú^z: )	rQ   r`   r^   r3   rM   r2   rF   rr   rL   )r   Z
stack_textZstack_nrT   rW   ÚgetrS   )ri   r   r   r   Ú	cpu_state¿  s,    "  z!Executer.__run.<locals>.cpu_statec                 s|   ˆdƒ ˆj ˆ } ˆj | ¡ ˆ ƒ  tdˆj› ƒ | tˆjƒk rhtdˆjj|  dˆj|  ƒ tdƒ ntdƒ ˆdƒ d S )Nr   z
run_layer:u   
æº–å‚™åŸ·è¡Œ:u                     å°æ‡‰:z-------------------------------u   ç¨‹åºå·²çµæŸ
r   )r3   r[   ÚdisplayrQ   r_   rr   r   )Únow_ip)r§   r-   rš   r   r   r   Ú
get_statusÕ  s    

z"Executer.__run.<locals>.get_statusr   r›   rn   g      à?Zasdu   åµéŒ¯!!--------gš™™™™™¹?u   ç¨‹å¼é–‹å§‹--------r   z<                                                            z       úrm   rk   rd   ro   rp   rq   é	   ry   rz   z==z!=z>=z<=ú>ú<ÚtÚfr{   Fr|   é   rœ   ztry r"   é   é   é   Té   é   zfinally yield runzVException ignored in: <generator object>
RuntimeError: generator ignored GeneratorExité   é   zip---->z
esp------>é   Zfinally_yieldr,   r¢   é   é   r¡   é   é   é   é   é   é    é!   )(r_   rE   r-   ri   r…   r†   r   r4   r5   rr   r   r3   r’   ÚinputrQ   r“   r[   ÚcommentsrV   r+   r2   r^   r   rv   rP   r‘   ÚlistrL   r8   ÚnextrC   ÚsplitÚmapÚintÚencoder   r}   r€   r   r.   )2r   Zrun_commentrª   r…   r†   r   r4   r5   rA   ÚnÚcmdÚar©   r‚   ÚopZzrr’   Zjmp_ipr'   r(   rx   Úeventr—   rt   rU   rK   r    rB   Zex_kZimport_namesrS   r¦   ÚcommandZ	items_strÚitemsrT   Zfunc_ipZfunc_class_objZfunc_stack_nameZfunc_stack_lenZvar_boxÚvar_krf   r.   ZstackZnamespace_nameZkey_dictZnot_needZ	void_dictr   r   )r§   ri   r-   rš   r   r   Z__run»  s   



(
 
 
 
 
 






 
$
$
$
$
$
$
"
"
"
"
"
$"

<< 








 
 
"
"



&








"






&

zExecuter.__run)N)N)r   r„   )r   r   r   r	   rc   rN   re   rg   rh   rj   rl   r   r   rD   r6   r   r”   r“   rO   r˜   rv   r   r   r   r   rZ   ¯   s$   

!$H
3rZ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r€   c             C   s   || _ d| _i | _d S )Nr€   )Úmodule_namer   r   )r   rÓ   r   r   r   r	     s    zEx_module.__init__c             C   s   | j S )N)rÓ   )r   r   r   r   r
     s    zEx_module.__str__c             O   s   t dƒ‚d S )Nz'module' object is not callable)r=   )r   r'   r(   r   r   r   r&     s    zEx_module.__call__N)r   r   r   r	   r
   r&   r   r   r   r   r€      s   r€   c               @   s   e Zd Zdd„ Zdd„ ZdS )r}   c             C   s   || _ t|||ƒ| _d S )N)r/   Únamespace_stack_varr   )r   r   r/   rf   r   r   r   r	   
  s    zNamespace_stack.__init__c             C   s   d| j › dS )Nzmodule "ú")r/   )r   r   r   r   r
     s    zNamespace_stack.__str__N)r   r   r   r	   r
   r   r   r   r   r}   	  s   r}   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rÔ   c             C   s   || _ || _|| _d S )N)r   r.   rf   )r   r   r/   rf   r   r   r   r	     s    znamespace_stack_var.__init__c             C   s
   || j kS )N)rf   )r   r   r   r   r   r     s    z namespace_stack_var.__contains__c             C   sX   || j kr$|| jj| j | j | < n0t| jj| j ƒ}|| j |< | jj| j  |¡ d S )N)rf   r   rL   r.   rr   rE   )r   r   r   Z
now_lengthr   r   r   r     s
    

znamespace_stack_var.__setitem__c             C   s   | j j| j | j|  S )N)r   rL   r.   rf   )r   r   r   r   r   r     s    znamespace_stack_var.__getitem__N)r   r   r   r	   r   r   r   r   r   r   r   rÔ     s   rÔ   N)fZapython.built_inr   r   r+   r8   r   rF   ÚallÚanyÚasciiÚbinÚboolÚ
breakpointÚ	bytearrayÚbytesÚcallableÚchrÚclassmethodÚcompileÚcomplexÚdelattrÚdictÚdirÚdivmodÚ	enumerateÚevalÚexecÚfilterÚfloatÚformatÚ	frozensetÚgetattrÚglobalsÚhasattrÚhashÚhexÚidrÃ   rÉ   Ú
isinstanceÚ
issubclassÚiterrr   rÅ   ÚlocalsrÈ   ÚmaxÚ
memoryviewÚminrÆ   ÚobjectÚoctÚopenÚordÚpowrQ   ÚpropertyrM   ÚreprÚreversedÚroundrc   ÚsetattrÚsliceÚsortedÚstaticmethodr2   ÚsumÚsuperÚtupler   ÚzipZbuilt_in_functionsÚ	NameErrorÚ
IndexErrorr=   ÚSyntaxErrorÚ
ValueErrorÚKeyboardInterruptÚAssertionErrorrP   ÚKeyErrorÚZeroDivisionErrorÚAttributeErrorÚIndentationErrorÚUnboundLocalErrorZError_classrC   ÚStopAsyncIterationÚSyntaxWarningÚFileNotFoundErrorÚModuleNotFoundErrorZelse_built_inrX   rY   r\   r   r   rZ   r€   r}   rÔ   r   r   r   r   Ú<module>   s.   4S *"    U	3787*122*exe_obj.cpython-37.pycB
    Y9;e§  ã               @   s(   G d d„ dƒZ G dd„ dƒZdd„ ZdS )c               @   sD   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ Zdd„ Zdd„ Z	dS )Ú	class_objc             C   s   || _ i | _d| _d S )Né    )ÚramÚvarsÚ
print_lock)Úselfr   © r   ú/C:\Users\allen\Desktop\py\py\apython\exe_obj.pyÚ__init__   s    zclass_obj.__init__c             C   s4   | j dkr0d| jkr0| j | g d¡ | jjd S dS )Nr   Ú__str__z<class_obj>)r   r   r   Úcall_obj_functionÚdata)r   r   r   r   r
      s    zclass_obj.__str__c             C   s,   | j dkr(d| jkr(| j | ||gd¡ d S )Nr   Ú__setitem__)r   r   r   r   )r   ÚkeyÚvaluer   r   r   r      s    zclass_obj.__setitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__getitem__)r   r   r   r   )r   Úitemr   r   r   r      s    zclass_obj.__getitem__c             C   s*   | j dkr&d| jkr&| j | |gd¡S d S )Nr   Ú__contains__)r   r   r   r   )r   r   r   r   r   r      s    zclass_obj.__contains__c             C   sR   | j dkr$d| jkr$| j | g d¡S d| jkrNd| _|  jd7  _|  | j¡S d S )Nr   Ú__next__r   Fé   )r   r   r   r   ÚerrorÚitem_kr   )r   r   r   r   r      s    
zclass_obj.__next__c             C   s.   d| _ | jdkr*d| jkr*| j | g d¡S | S )Néÿÿÿÿr   Ú__iter__)r   r   r   r   r   )r   r   r   r   r      s    zclass_obj.__iter__N)
Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )Ú	generatorc                sJ   |ˆ _ |ˆ _|ˆ _|ˆ _|ˆ _dˆ _dˆ _dˆ _‡ fdd„}d|iˆ _d S )Nr   TFc                s,   ˆ j s dˆ _| ˆ jjd< ˆ  ¡ S tdƒ‚d S )NTr   z5can't send non-None value to a just-started generator)Ú	next_lockÚsendr   r   Ú_generator__nextÚ	TypeError)r   )r   r   r   r   *   s
    z generator.__init__.<locals>.sendr   )	r   Únext_ipÚparamsÚlocalsÚbase_locationÚenterr   r   r   )r   r   Zstart_ipr"   r#   r$   r   r   )r   r   r	   !   s    zgenerator.__init__c             C   s   dS )Nz<generator_obj>r   )r   r   r   r   r
   1   s    zgenerator.__str__c             C   s   |   ¡ S )N)r   )r   r   r   r   r   r   3   s    zgenerator.__getitem__c             C   s    d| _ | jrd | jjd< |  ¡ S )NFr   )r   r   r   r   r   )r   r   r   r   r   5   s    zgenerator.__next__c             C   sL   | j dkrt‚n8d| _ | j | j| j| j| j¡\| _| _| _}d| _ |S d S )Nr   r   )r%   ÚStopIterationr   Ú	yield_runr!   r"   r#   r$   )r   Úyield_resultr   r   r   Z__next:   s    
(zgenerator.__nextN)r   r   r   r	   r
   r   r   r   r   r   r   r   r       s
   r   c             C   s  t | ƒtkrœ|dkr|  ¡ S |dkr.| j| S |dkr@| j| S |dkrR| j| S |dkrd| j| S |dkrv| j| S |dkrˆ| j| S |dkrš| j	| S nXt | ƒt
k rô|d	kr¼| j| S |d
krÎ| j| S |dkrà| j| S |dk rô| j| S tdƒ t| ||ƒ t‚d S )NÚencodeÚsplitÚreplaceÚformatÚjoinÚindexÚlowerÚupperÚappendÚinsertÚremovez

error!)ÚtypeÚstrr)   r*   r+   r,   r-   r.   r/   r0   Úlistr1   r2   r3   ÚprintÚ	Exception)ÚobjÚopÚargsr   r   r   Úbuilt_in_opB   s:      
 
 
 
 
 
  
 
 

 
r<   N)r   r   r<   r   r   r   r   Ú<module>   s   "224*122*ex_func.cpython-37.pycB
    7ãPe…   ã               @   s$   d dl Z d dlZd dlZd dlZdS )é    N)ÚtimeÚmathÚosÚos.path© r   r   ú/C:\Users\allen\Desktop\py\py\apython\ex_func.pyÚ<module>   s   45313*121*module.cpython-37.pycB
    ÀoTeAø  ã               @   sR  G d d„ dƒZ G dd„ dƒZG dd„ dƒZG dd„ dƒZG dd	„ d	ƒZG d
d„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZG dd„ dƒZ	G dd„ dƒZ
G dd„ dƒZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZG d d!„ d!ƒZG d"d#„ d#ƒZG d$d%„ d%ƒZG d&d'„ d'ƒZG d(d)„ d)ƒZG d*d+„ d+ƒZG d,d-„ d-ƒZG d.d/„ d/ƒZG d0d1„ d1ƒZG d2d3„ d3ƒZG d4d5„ d5ƒZG d6d7„ d7ƒZG d8d9„ d9ƒZG d:d;„ d;ƒZG d<d=„ d=ƒZG d>d?„ d?ƒZG d@dA„ dAƒZ dBdC„ Z!G dDdE„ dEƒZ"G dFdG„ dGƒZ#G dHdI„ dIƒZ$G dJdK„ dKƒZ%G dLdM„ dMƒZ&G dNdO„ dOƒZ'G dPdQ„ dQƒZ(G dRdS„ dSƒZ)G dTdU„ dUƒZ*dVS )Wc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIntegerc             C   s   t |ƒ| _d S )N)ÚintÚnumber)Úselfr   © r   ú.C:\Users\allen\Desktop\py\py\apython\module.pyÚ__init__   s    zInteger.__init__c             C   s   | j › S )N)r   )r   r   r   r   Ú__str__   s    zInteger.__str__c             C   s   t | jƒ| _d S )N)Ústrr   Úlocation)r   Úcodesr   r   r   Úwrite   s    zInteger.writeN)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚFloatc             C   s   t |ƒ| _d S )N)Úfloatr   )r   r   r   r   r   r   
   s    zFloat.__init__c             C   s   | j › S )N)r   )r   r   r   r   r      s    zFloat.__str__c             C   s   t | jƒ| _d S )N)r	   r   r
   )r   r   r   r   r   r      s    zFloat.writeN)r   r   r   r   r   r   r   r   r   r   r   	   s   r   c               @   s&   e Zd Zd	dd„Zdd„ Zdd„ ZdS )
ÚStringTc             C   s   || _ || _d S )N)ÚtextÚchange)r   r   r   r   r   r   r      s    zString.__init__c             C   s   d| j › dS )Nú")r   )r   r   r   r   r      s    zString.__str__c             C   s,   | j rd| j› d| _nd| j› d| _d S )Nr   ú')r   r   r
   )r   r   r   r   r   r      s    zString.writeN)T)r   r   r   r   r   r   r   r   r   r   r      s   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBytec             C   s
   || _ d S )N)r   )r   r   r   r   r   r      s    zByte.__init__c             C   s   d| j › dS )Nr   )r   )r   r   r   r   r      s    zByte.__str__c             C   s   |  d| j› d¡ d| _d S )Nz	byte AX "r   ÚAX)Úappendr   r
   )r   r   r   r   r   r       s    z
Byte.writeN)r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ Zdd„ ZdS )ÚVar_namec             C   s
   || _ d S )N)Úname)r   r   r   r   r   r   $   s    zVar_name.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   &   s    zVar_name.__str__N)r   r   r   r   r   r   r   r   r   r   #   s   r   c               @   s6   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zd
d„ ZdS )Ú	NamespaceÚ c             C   s
   || _ d S )N)Ú	namespace)r   r   r   r   r   r   *   s    zNamespace.__init__c             C   s   | j › S )N)r   )r   r   r   r   r   ,   s    zNamespace.__str__c             C   s
   | j |kS )N)r   )r   Úotherr   r   r   Ú__eq__.   s    zNamespace.__eq__c             C   s
   || j kS )N)r   )r   Úitemr   r   r   Ú__contains__0   s    zNamespace.__contains__c             C   s   | j dkr| j | _d S )Nr   )r   r
   )r   r   r   r   r   r   2   s    
zNamespace.writeN)r   )r   r   r   r   r   r    r"   r   r   r   r   r   r   )   s
   
r   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVariablec             C   s   || _ || _d S )N)r   r   )r   r   r   r   r   r   r   6   s    zVariable.__init__c             C   s   d| j › dS )Nz<var=ú>)r   )r   r   r   r   r   9   s    zVariable.__str__c             C   s:   | j dkr.| j  |¡ | j j› d| j› | _n| j| _d S )Nr   Ú.)r   r   r
   r   )r   r   r   r   r   r   ;   s    
zVariable.writeN)r   r   r   r   r   r   r   r   r   r   r#   5   s   r#   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSubVariablec             C   s   || _ || _d S )N)ÚobjÚattr)r   r'   r(   r   r   r   r   A   s    zSubVariable.__init__c             C   s   d| j › d| j› dS )Nz<obj=z  attr=r$   )r'   r(   )r   r   r   r   r   D   s    zSubVariable.__str__c             C   st   | j  |¡ | j j}d|ks0d|ks0|d dkrX| d| j j› d¡ d| jj› | _n| j j› d| jj› | _d S )Nr%   ú[é    )r   r   zmov AX u         ;æ­¤é …éé•·æˆ–æ˜¯å­—ä¸²zAX.)r'   r   r
   r   r(   r   )r   r   Z	olocationr   r   r   r   F   s    zSubVariable.writeN)r   r   r   r   r   r   r   r   r   r   r&   @   s   r&   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSlicec             C   s   || _ || _|| _d S )N)Ú	start_objÚend_objÚstep_obj)r   r,   r-   r.   r   r   r   r   N   s    zSlice.__init__c             C   s   dS )Nz<slice>r   )r   r   r   r   r   R   s    zSlice.__str__c             C   s’   |  d¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ | j |¡ |  d| jj› ¡ |  d¡ |  d¡ |  d¡ d| _d S )	Nzpush [3]zmov <esp+1>[0] zmov <esp+1>[1] zmov <esp+1>[2] z	pop *argszmov **kwargs [dict]z
call slicer   )r   r,   r   r
   r-   r.   )r   r   r   r   r   r   T   s    



zSlice.writeN)r   r   r   r   r   r   r   r   r   r   r+   M   s   r+   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIndexVariablec             C   s   || _ || _d S )N)r   Ú	slice_obj)r   r   r0   r   r   r   r   a   s    zIndexVariable.__init__c             C   s   d| j › d| j› dS )Nz<Index z slice=r$   )r   r0   )r   r   r   r   r   d   s    zIndexVariable.__str__c             C   sT   | j  |¡ | d| j j› ¡ | j |¡ | d| jj› ¡ | d¡ d| _d S )Nzpush zmov BX zpop AXzAX[BX])r   r   r   r
   r0   )r   r   r   r   r   r   f   s    
zIndexVariable.writeN)r   r   r   r   r   r   r   r   r   r   r/   `   s   r/   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚListc             C   s
   || _ d S )N)Úelements)r   r2   r   r   r   r   o   s    zList.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<List  ú,r$   )r2   r   r	   Újoin)r   Úboxr'   r   r   r   r   q   s    zList.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)Úlenr2   ÚStopIteration)r   Újr   r   r   Ú__getitem__v   s    
zList.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   Ú__len__z   s    zList.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX [ú]zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   Úranger   r
   )r   r   Úir   r   r   r   |   s    
"
z
List.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r1   n   s
   r1   c               @   s4   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	d
„ ZdS )ÚTuplec             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   …   s    zTuple.__init__c             C   s4   g }x| j D ]}| t|ƒ¡ qW dd |¡ d S )Nz<Tuple  r3   r$   )r2   r   r	   r4   )r   r5   r'   r   r   r   r   ‡   s    zTuple.__str__c             C   s    |t | jƒk r| j| S t‚d S )N)r6   r2   r7   )r   r8   r   r   r   r9   Œ   s    
zTuple.__getitem__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:      s    zTuple.__len__c             C   s|   |  dt| jƒ› d¡ |  d¡ xDtt| jƒƒD ]2}| j|  |¡ |  d|› d| j| j› ¡ q2W |  d¡ d| _d S )Nzmov AX (ú)zpush AXzmov <esp+1>[z] zpop AXr   )r   r6   r2   r<   r   r
   )r   r   r=   r   r   r   r   ’   s    
"
zTuple.writeN)r   r   r   r   r   r9   r:   r   r   r   r   r   r>   „   s
   r>   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
ÚDictc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ›   s    zDict.__init__c             C   s>   g }x&| j D ]\}}| |› d|› ¡ qW dd |¡ d S )Nú:z<Dict  r3   r$   )r2   r   r4   )r   r5   ÚkeyÚvaluer   r   r   r      s    zDict.__str__c             C   s
   t | jƒS )N)r6   r2   )r   r   r   r   r:   ¢   s    zDict.__len__c             C   st   |  d¡ xT| jD ]J\}}| |¡ |  d|j› ¡ | |¡ |  d¡ |  d|j› ¡ qW |  d¡ d| _d S )Nzpush [dict]zpush zpop BXzmov <esp+1>[BX] zpop AXr   )r   r2   r   r
   )r   r   rB   rC   r   r   r   r   ¤   s    




z
Dict.writeN)r   r   r   r   r   r:   r   r   r   r   r   r@   š   s   r@   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSetc             C   s
   || _ d S )N)r2   )r   r2   r   r   r   r   ¯   s    zSet.__init__c             C   s   dS )Nz<set>r   )r   r   r   r   r   ±   s    zSet.__str__c             C   s0   t | jƒ}| |¡ | d|j› ¡ d| _d S )Nzex_func AX "set" r   )r>   r2   r   r   r
   )r   r   Z_tupler   r   r   r   ³   s    

z	Set.writeN)r   r   r   r   r   r   r   r   r   r   rD   ®   s   rD   c             C   s   yt | ƒ}dS    dS d S )NTF)r   )ÚnumÚer   r   r   Ú	is_number¹   s
     rG   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚLambdac             C   s   || _ || _|| _d S )N)ÚparamsÚ
return_objr   )r   rI   rJ   r   r   r   r   r   ¿   s    zLambda.__init__c             C   s   dS )Nz<lambda>r   )r   r   r   r   r   Ã   s    zLambda.__str__c             C   s¦   dt |ƒ› }t| jdƒ}tdƒ}x | jD ]}| dt|dƒ¡ q*W |j |¡ t	|| j|| j
ƒ}| |¡ | j
dkr~|| _n$| j
 |¡ | j
j› d|› }|| _d S )Nz&lambda_Úreturnr   Úvarr%   )r6   Ú	BacktrackrJ   ÚInforI   Úadd_infor#   Ú	codelinesr   ÚDefr   r   r
   )r   r   Ztem_nameZ_returnÚ
block_inforB   Z_defZlocr   r   r   r   Å   s    

zLambda.writeN)r   r   r   r   r   r   r   r   r   r   rH   ¾   s   rH   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rQ   c             C   s8   || _ || _|| _|j| _|j| _d| jk| _d| _d S )Nú^)r   r*   )r   rI   r   rP   ÚlocalsÚ
local_varsÚin_classÚ
orig_lines)r   ZfnamerI   rR   r   r   r   r   r   Ö   s    zDef.__init__c             C   sH   d| j › }g }x| jD ]}| t|ƒ¡ qW |dd |¡ d 7 }|S )Nz<Def ú{r   ú})r   rP   r   r	   r4   )r   r   Zvtextr'   r   r   r   r   ß   s    zDef.__str__c       *         s`	  dd„ }| j dkrf| j  |¡ t|ƒdt|ƒd | j jdg}| d¡ | d| j j› d| j› d	¡ n&t|ƒ| jt|ƒd
 d dg}| d¡ | ¡  t|ƒ}| d¡ | j› d|› | _| d¡ | d¡ d}g }d }t| j	ƒ}xà|D ]Ö}	| j
r|d kr|	}qê|	d d… dkrxd |¡}
| d|	dd … › d|
› d¡ | j	|	 | j	|	dd … < | j	|	= | |	dd … ¡ qê|	d dkrØ| d|	d
d … › d|› ¡ | j	|	 | j	|	d
d … < | j	|	= | |	d
d … ¡ qê| |	¡ | d¡ t|ƒ}| d¡ | d|	› d¡ t|ƒ}| d¡ | j	|	  |¡ | d|	› d| j	|	 j› ¡ | dt|ƒd › ¡ dt|ƒd
 › d||< | d|	› d|› d¡ | d¡ dt|ƒd
 › d ||< |d
7 }qêW d}i }x | j	D ]}	|d
7 }|||	< qÖW x6| jD ],}|| j	krø||krø|d
7 }|||< qøW |d
 |d!< d"|d
 › d#|d › d#|d$ › d%| j› d&|d! › 
||d < g }|  ¡ x>| j	D ]4}	|	|kr†| d'| j› d(||	 › d)|	› d*¡ q†W t|ƒ}| d¡ | d¡ d+}t|ƒ}x| jD ]}| |¡ qîW ‡ ‡fd,d-„}‡fd.d/„}g ‰g ‰ g g‰g }g }g }d0d1„ }x2tt|ƒ| ƒD ]}|||  }d|ksxd2|kr‚||ƒ}n
| d#¡}|d d3kr®| || ¡ qRnL|d d4krĞˆd5  |d
 ¡ n*|d d6krú| |d
 ¡ | || ¡ |d d7krd8|d< d9}n|d d:krDˆ  || g f¡ ˆ g ¡ nä|d d;krfˆ || g f¡ nÂ|d d<kr(|d
 d=krĞˆ d5 \}}t|ƒdkrÂ||7 }d%| j› d}|| | ||< ˆ d5= ˆd5= nT|d
 d>krRˆd5 \} }t|ƒdkr||7 }d%| j› d}!||  |! || < ˆd5= qRx0tt|ƒƒD ]}"|"dks8||" dkrZq8||" d d?krpq8||" d d@kr„P |||" ƒ\}}#||ƒs8||kr8|dkr¶P n ||krädA| j› dB|# ||"< ||d! ƒ nr|| j	krdA| j› d(|| › dC|# ||"< ||| ƒ n8|| jkr8dA| j› d(|| › dC|# ||"< ||| ƒ q8W d# |¡||| < qRW g }$x.t|d
 ƒD ]}||kr†|$ t|ƒ¡ q†W x|D ]}%d||%< q®W t|ƒ}&t|ƒdkr|d5 |&d
 krx^|D ]}'d|&d
 › dD||'< qîW n:x|D ]}'d|&› ||'< qW |r>| dE¡ n
| dF¡ |rÒttdGdƒttdHdƒgƒti ƒƒ}(t|(dIƒ})|) |¡ | dJ¡ dK|d › d%| j› d||< dt|ƒd
 › dL||d
 < | dM¡ nd||< d||d
 < | dN¡ |	r| dO| j› d¡ n&| dO| j› d&d d |$¡ d ¡ | dP¡ | ¡  dt|ƒd
 › dQ||< d S )RNc             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r*   é   r   )r6   )ÚstringÚspÚkÚnr   r   r   Úget_nameç   s    
zDef.write.<locals>.get_namer   ÚBXé   r*   zmov r%   z BXrZ   Ú_zpush **kwargsz
push *argsz**r3   z**kwargs <esp+2>["z"] <esp+2> "r   Ú*z*args <esp+2>["z"] <esp+1> zcmp CX 0ztf <esp+2> "in" "zmov <esp+2>["z"] zjmp z$jmp z "!="z"] <esp+1>[r;   zdec CXz "t"é   z	Function ú é   z "z" zmov <ú+z> <esp+2>["z"]Fc                s`   t ˆ ƒdkr.| ˆ d d kr.ˆ d d  | ¡ t ˆƒdkr\| ˆd d kr\ˆd d  | ¡ d S )Nr*   éÿÿÿÿrZ   )r6   r   )rE   )Úadd_FunctionÚadd_Generatorr   r   Úsave_genF  s    zDef.write.<locals>.save_genc                s   xˆ D ]}| |krdS qW dS )NTFr   )ZwordÚitems)Úglobal_wordsr   r   Ú	in_globalL  s    
zDef.write.<locals>.in_globalc             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr*   )r   r   rZ   ú\re   )r6   r   )Úliner5   r]   r^   ÚpÚcr   r   r   Ú
parse_lineW  s"    
  zDef.write.<locals>.parse_liner   rK   Úglobalrh   ÚnonlocalÚyieldÚYieldTÚFunctionÚ	GeneratorÚendz
"Function"z"Generator")r   r   ú;ú<z+0>r$   u            ;returné»z	mov AX ""zmov AX Noner7   r   Úraiseu+   stop     ;ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°é€™ä¸€è¡ŒzGenerator AX u*         ;å› ç‚ºæ˜¯yieldï¼Œç›´æ¥è·³åˆ°pop ipzend "Generator"u,   $mov esp "+" 2           ;æº–å‚™é›¢é–‹å‡½æ•¸zend "Function" "zpop ipu              ;è·³éæ­¤å‡½æ•¸)r   r   r6   r
   r   r   Úadd_tabÚfunc_varÚtuplerI   rV   r4   rU   rP   r<   Úsplitr	   ÚFuncCallr#   r1   r@   rM   Údel_tab)*r   r   r_   Zdeclare_funcZskip_ipr=   ZkeyboxÚ	class_objrI   rB   Zkey_textZ
skip_paramZskip_param2Z	local_numZ
local_dictrL   Z
return_ipsÚyield_ipZ
have_yieldrq   r'   rk   rn   Znonlocal__wordsZnonlocal_ipsZ	not_abortrs   rp   ÚdealZf_rowrl   Zfunc_add_textZg_rowZgen_add_textr8   ÚbackZ
need_abortZnon_ipZendipZripZstopiterationÚ_raiser   )ri   rj   rm   r   r   æ   sV   

 





 




<

*



 
 
  

 


"



&
z	Def.writeN)r   r   r   r   r   r   r   r   r   r   rQ   Õ   s   	rQ   c               @   s.   e Zd Zddd„Zdd„ Zdd„ Zd	d
„ ZdS )r‚   Nr   c             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )r   ÚargsÚkwargsÚs_argsÚs_kwargsrW   )r   r   r‰   rŠ   r‹   rŒ   r   r   r   r   Ô  s    zFuncCall.__init__c             C   s   d| j › d| j› d| j› dS )Nz<Call z args=z kwargs=r$   )r   r‰   rŠ   )r   r   r   r   r   Û  s    zFuncCall.__str__c             C   s   t tddƒt|ƒƒS )Nr   r   )r/   r#   r   )r   r!   r   r   r   r9   İ  s    zFuncCall.__getitem__c                s>  ‡ ‡‡fdd„}ˆ   dˆj¡ ˆj ˆ ¡ dˆjjkˆ_ˆjjd d… dkpVdˆjjk‰ˆrpˆ   dˆjj› ¡ ˆjr$ˆjj d	¡\}}ˆ   d
|› d|› d¡ tˆ ƒ}ˆ   d¡ |ˆj|ƒ tˆ ƒ}ˆ   d¡ dtˆ ƒd › dˆ |< t	ˆjj
dd … ƒ}||ˆjjƒ dtˆ ƒd › ˆ |< n|ˆjˆjjƒ dˆ_d S )Nc                sf  ˆ   dt| ƒ› d¡ |  ˆ ¡ ˆ j d| j› d|› dˆjd ˆjd krˆˆj ˆ ¡ ˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆ   d	¡ ˆj ˆ ¡ tˆjƒd
krˆ   dˆjj› ¡ xHˆjD ]>}| ˆ ¡ ˆ   d¡ ˆ   d|j› ¡ ˆ   d¡ ˆ   d¡ qÀW ˆ   d¡ nˆ   dˆjj› ¡ ˆ   d¡ ˆ   d¡ ˆrRˆ   d¡ ˆ   d¡ nˆ   d|› ¡ d S )Nzpush u           ;å„²å­˜CXu     ;ç‚ºcall u
    åšæº–å‚™)Úsimplifyzex_func AX "list" zex_func BX "len" AXz$mov <esp+2> "+" BXz$mov <esp+1> "+" AXr*   zmov *args [1]zmov *args[0] zmov **kwargs [dict]zcall <esp+1>.updatezpop **kwargszmov **kwargs z	pop *argsu   pop CX     ;å–å›CXzpop AXzcall AXzcall )r   r6   r   r
   rV   r‹   rŠ   rŒ   )r‰   Z	call_namerŒ   )r   Úneed_push_namer   r   r   Údeal_cx_args_kwargsà  s4    
 









z+FuncCall.write.<locals>.deal_cx_args_kwargsr   rS   ra   r   ú&zpush r%   ztf z "Ctn" "r   r*   z$jmp rZ   z "t"zjmp )r   rW   r   r   r
   rV   r   r6   r‰   r1   r2   )r   r   r   Úspacer   Zjmp_if_trueZ	jmp_leaver‰   r   )r   r   r   r   r   ß  s*      

zFuncCall.write)Nr   )r   r   r   r   r   r9   r   r   r   r   r   r‚   Ó  s   
r‚   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rM   c             C   s   || _ || _d| _d S )N)r   r*   )ÚAÚcmdrW   )r   rC   r“   r   r   r   r     s    zBacktrack.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r     s    zBacktrack.__str__c             C   sL   | j  |¡ | j jdkr,| d| j j› ¡ | | j› d| j¡ d| _d S )Nr   zmov AX z AX)r’   r   r
   r   r“   rW   )r   r   r   r   r   r     s
    zBacktrack.writeN)r   r   r   r   r   r   r   r   r   r   rM     s   rM   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚVar_declarec             C   s   || _ || _d S )N)rC   r“   )r   rC   r“   r   r   r   r   "  s    zVar_declare.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   rC   )r   r   r   r   r   %  s    zVar_declare.__str__c             C   s¤   | j  |¡ | jdkr†d| j jkrN| j j d¡\}}| d|› d|› d¡ q | j jd d… dkrn| d¡ q | d	| j j› d
¡ n| | j› d| j j› ¡ d S )NÚdelr%   zdel 2 z "r   rf   zAX[zdel 1 AX BXzdel 0 z Nonere   )rC   r   r“   r
   r   r   )r   r   r„   rB   r   r   r   r   '  s    
zVar_declare.writeN)r   r   r   r   r   r   r   r   r   r   r”   !  s   r”   c               @   s&   e Zd Zd
dd„Zdd„ Zdd„ Zd	S )Ú
Try_Exceptr   r   c             C   s(   || _ || _|| _|| _|| _g | _d S )N)Útry_codelinesÚexcept_objectsÚelse_codelinesÚfinally_codelinesr   rW   )r   r—   r˜   r™   rš   r   r   r   r   r   4  s    zTry_Except.__init__c             C   s   dS )Nz<Try Except>r   )r   r   r   r   r   ;  s    zTry_Except.__str__c       &      C   s  d}t |ƒ}| d| j| ¡ t |ƒ}| d¡ g g g dœ}g }t |ƒ}| ¡  x| jD ]}| |¡ qXW | ¡  |d7 }xDtt |ƒ| ƒD ]0}	|||	   d¡d }
|
dkrŒ| ||	 ¡ qŒW | d¡ t |ƒ}| d¡ | j	dkr| j	 |¡ | j	j
› d}nd}d}d	t |ƒd › }g }g }g }xltt | jƒd ƒD ]T}	|dkr^|||< d}nd
t |ƒd › d||< |	t | jƒk r|| d| j| ¡ |d7 }| j|	 }|d  |¡ | d|d j
› ¡ t |ƒ}| d¡ |d d kr| d|› |d › d¡ | d¡ | t |ƒ¡ | d¡ | ¡  x|d D ]}| |¡ q<W | ¡  | d¡ | t |ƒ¡ | d¡ n| t |ƒ¡ | d¡ q@W xV|D ]N}dt |ƒd › d||< | d¡ | d¡ | |¡ | d|› d¡ q W g }dt |ƒd › d||< t | jƒdkr†| d| j| ¡ |d7 }| ¡  | t |ƒ¡ | d¡ x| jD ]}| |¡ q`W | d¡ | ¡  t |ƒd }x|D ]}d|› d||< q˜W | d¡ | d¡ | t |ƒ¡ | d¡ i }xbtt |ƒ| ƒD ]N}	t|||	  ƒtkrô|||	   d¡d }
|
|krô||
  ||	 ¡ qôW d}x°|D ]¨}t || ƒdkrPt |ƒd }x || D ]}d|› ||< q|W |dkrª| d¡ n
| d¡ | d¡ | d|› ¡ | t |ƒ¡ | d¡ |||< |d7 }qPW t |ƒd }x|D ]}d	|› ||< qW x|D ]}d|› d||< q,W | d¡ | d¡ t |ƒd }d|› ||< x|D ]}d|› d ||< qzW | d!|› ¡ t |ƒ} t | jƒdkr| d"¡ | d¡ | d| j| ¡ |d7 }| ¡  x| jD ]}| |¡ qúW | ¡  g g g dœ}!xbtt |ƒ|  ƒD ]N}	t|| |	  ƒtkr4|| |	   d¡d }
|
|!kr4|!|
  | |	 ¡ q4W t | jƒdkr | d#¡ | d$¡ i }"x8|D ]0}| d%|› ¡ || |"t |ƒ< | d¡ q´W | d&¡ t |ƒ}#| d¡ | d$¡ ttd'dƒd(ƒ}$|$ |¡ xh|!D ]`}t |!| ƒdkr.t |ƒd }x&|!| D ]}d|› d)|› ||< qZW | d*¡ | |¡ q.W xH|"D ]@}%d
t |ƒd › d+||%< | d#¡ | d$¡ | |"|% ¡ q˜W d
t |ƒd › d+||#< | d$¡ | d,¡ d S )-Nr*   )ÚcontinueÚbreakrK   rZ   re   rv   z	try "end"r   r%   ztry z$jmp z "f"zerror zmov z $Exceptionzmov $Exception 0ra   zjmp u    ;è™•ç†tryä¸­çš„yieldu-   yield AX          ;tryä¸­çš„yieldæ”¹åˆ°é€™è£¡u#        ;è¿”å›tryä¸­çš„yieldä¸‹ä¸€è¡Œu!       ;tryæ­£å¸¸çµæŸï¼Œè·³åˆ°elseu     ;è·³åˆ°push 1u   push None  ;æ¨å…¥Noneu   push 1     ;ä»£è¡¨æ­£å¸¸rK   zpush AXz	push Nonezpush z ;push 0zpush 0zfinally u       ;è·³åˆ°finallyz	finally -zpush $Exceptionzpop $Exceptionzpop AXzcmp AX zcmp AX 1z
$Exceptionr}   u"          ;è·³è‡³finallyä¸­çš„äº‹ä»¶:z$mov esp "+" 3z "=="zend "finally_yield")r6   r   rW   r~   r—   r   rƒ   r<   r   r   r
   r˜   r™   Útyper	   rš   rM   r#   )&r   r   ÚolZto_finally_ipZto_except_ipZSDZ	yield_boxZstart_pr'   r=   r“   Z	try_leaveÚispacerF   Ztry_except_ipZ
try_push_0Z
jmp_push_0Z
jmp_push_1Z
error_datar…   Zjmp_to_finallyZpush_1Zjp0Zstype_SDÚstyperB   Újmp_ipÚipZpush_0Ztp0Z
finally_ipZjtfZ	finally_pZfinally_eventsZleave_SDZjmp_to_leaverˆ   Úlipr   r   r   r   =  s>   













































zTry_Except.writeN)r   r   r   )r   r   r   r   r   r   r   r   r   r   r–   3  s   
r–   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWithc             C   s(   || _ || _|| _|| _|| _d| _d S )N)r   r*   )Úcall_objÚorig_as_nameÚas_nameÚwith_codelinesr   rW   )r   r¥   r¦   r§   r¨   r   r   r   r   r   ô  s    zWith.__init__c             C   s   dS )Nz<with>r   )r   r   r   r   r   û  s    zWith.__str__c       	      C   s0  |  d| j¡ | ¡  | j |¡ | j |¡ |  d| jj› d| jj› ¡ tt| jj› ddƒt	g ƒt
i ƒƒ}| |¡ | jd kr¶|  d|j› ¡ | j |¡ |  d| jj› ¡ | j}g }g }tt| jj› ddƒt	td ƒtd ƒtd ƒgƒt
i ƒƒ}|g}t||||ƒ}dddg|_| |¡ | ¡  d S )	Nr   zmov re   z
.__enter__zpush zpop z	.__exit__)r   r*   )r   rW   r~   r¦   r   r¥   r
   r‚   r#   r1   r@   r§   r¨   ÚTFNr–   rƒ   )	r   r   Z_enter_callr—   r˜   r™   Z
_exit_callrš   Z_try_exceptr   r   r   r   ı  s(    $

6
z
With.writeN)r   r   r   r   r   r   r   r   r   r   r¤   ó  s   r¤   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚStopc             C   s   d S )Nr   )r   r   r   r   r     s    zStop.__init__c             C   s   dS )Nz<$stop>r   )r   r   r   r   r     s    zStop.__str__c             C   s   |  d¡ d S )NÚstop)r   )r   r   r   r   r   r     s    z
Stop.writeN)r   r   r   r   r   r   r   r   r   r   rª     s   rª   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚCommandc             C   s
   || _ d S )N)Úcmd_list)r   r­   r   r   r   r     s    zCommand.__init__c             C   s   dS )Nz
<cmd_list>r   )r   r   r   r   r     s    zCommand.__str__c             C   s   x| j D ]}| |¡ qW d S )N)r­   r   )r   r   r“   r   r   r   r   !  s    zCommand.writeN)r   r   r   r   r   r   r   r   r   r   r¬     s   r¬   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_if_elsec             C   s   || _ || _|| _d S )N)ÚeventÚ	true_itemÚ
false_item)r   r¯   r°   r±   r   r   r   r   %  s    zsub_if_else.__init__c             C   s   dS )Nz<A if else B>r   )r   r   r   r   r   )  s    zsub_if_else.__str__c             C   sà   | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | jjdkrb| d| jj› d¡ t|ƒ}| d¡ dt|ƒd › d	||< | j |¡ | jjdkr¾|jd| jj› d
dd dt|ƒd › d||< d| _d S )Nzcmp z 1r*   r   zmov AX z   ;true itemz$jmp rZ   u    "!="   ;è·³åˆ°falsez   ;false item)r   zjmp u      ;é›¢é–‹sub_if_else)r¯   r   r   r
   r6   r°   r±   )r   r   Z	jne_falseÚleave_ipr   r   r   r   +  s    

zsub_if_else.writeN)r   r   r   r   r   r   r   r   r   r   r®   $  s   r®   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚIf_elsec             C   s   || _ || _g | _d S )N)Úif_itemsr™   rW   )r   r´   r™   r   r   r   r   >  s    zIf_else.__init__c             C   sÌ   d| j d d › dg}x$| j d d D ]}| t|ƒ¡ q(W xL| j dd … D ]:}| d|d › d¡ x|d D ]}| t|ƒ¡ qrW qNW t| jƒdkrÂ| d¡ x| jD ]}| t|ƒ¡ q¬W d |¡S )Nzif r*   rA   rZ   zelif zelse:r   )r´   r   r	   r6   r™   r4   )r   r   r'   r=   r   r   r   r   B  s      
 zIf_else.__str__c       	      C   s6  g }d}x´| j D ]ª\}}| d| j| ¡ |d7 }| |¡ | d|j› d¡ | ¡  t|ƒ}| d¡ x|D ]}| |¡ qpW | t|ƒ¡ | d¡ dt|ƒd › d||< | ¡  qW t| jƒdkr
| d| j| ¡ | ¡  x| jD ]}| |¡ qğW | ¡  x&|D ]}dt|ƒd › d	||< qW d S )
Nr*   r   rZ   zcmp z 1z$jmp u#    "!="        ;è·³åˆ°ä¸‹ä¸€å¥åˆ¤æ–·zjmp u           ;è·³è‡³åº•éƒ¨)	r´   r   rW   r   r
   r~   r6   rƒ   r™   )	r   r   Úneed_set_endr   r¯   ÚblockÚjipr'   r¢   r   r   r   r   L  s0    


 
 
zIf_else.writeN)r   r   r   r   r   r   r   r   r   r   r³   =  s   
r³   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚWhilec             C   s   || _ || _|| _d| _d S )N)r   r*   )r¯   rP   r™   rW   )r   r¯   rP   r™   r   r   r   r   d  s    zWhile.__init__c             C   s   d| j › d| j› S )Nzevent:z do:)r¯   rP   )r   r   r   r   r   i  s    zWhile.__str__c             C   sd  t |ƒ}| d| j¡ | j |¡ | d| jj› d¡ | ¡  t |ƒ}| d¡ g }x†| jD ]|}t |ƒ}| |¡ xdtt |ƒ| ƒD ]P}|||   	d¡d }|dkrÀd|d › ||| < q†|d	kr†| || ¡ q†W q^W | d|d › d
¡ t |ƒd }	d|	› d||< x| j
D ]}| |¡ qW t |ƒd }
x|D ]}d|
› d||< q>W | ¡  d S )Nr   zcmp z 1r*   re   r›   zjmp rZ   rœ   u                  ;continueé‡ä¾†z$jmp z "!="u             ;breakå‡º)r6   r   rW   r¯   r   r
   r~   rP   r<   r   r™   rƒ   )r   r   Úagain_ipÚout_ipÚ	break_boxr'   rq   r=   r“   Z
to_else_ipÚbreak_ipÚb_ipr   r   r   r   k  s4    


zWhile.writeN)r   r   r   r   r   r   r   r   r   r   r¸   c  s   r¸   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )Úsub_for_loopc             C   s"   || _ || _|| _|| _|| _d S )N)ÚexpressÚvnamesÚbase_objÚif_objÚis_list)r   r¿   rÀ   rÁ   rÂ   rÃ   r   r   r   r   ‰  s
    zsub_for_loop.__init__c             C   s   dS )Nz<sub for loop>r   )r   r   r   r   r     s    zsub_for_loop.__str__c       	      C   s  t | jdƒ}| jd krLt| j|gggg ƒ}dddg|_t| j| j|gg ƒ}nt| j| j|gg ƒ}tdƒ}x| jD ]}| 	d|¡ qpW | 
|d¡ t|ƒ}td|› i |dƒ}| 
|¡ | d¡ | d¡ | d¡ | d	¡ | d
¡ | d|› ¡ | jr
| d¡ d| _d S )Nrv   )r   r*   r   rL   z&generator_u   push 0        ;å„²å­˜CXzpush [0]zmov **kwargs [dict]z	pop *argsu   pop CX     ;å–å›CXzcall &generator_zex_func AX "list" AXr   )rM   r¿   rÂ   r³   rW   ÚFor_looprÀ   rÁ   rN   rO   r   r6   rQ   r   rÃ   r
   )	r   r   Z_yieldZ_ifZ	_for_loopÚinforL   ÚidÚfDefr   r   r   r   ‘  s,    







zsub_for_loop.writeN)r   r   r   r   r   r   r   r   r   r   r¾   ˆ  s   r¾   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )rÄ   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r*   )rÀ   rÁ   rP   r™   rW   )r   rÀ   rÁ   rP   r™   r   r   r   r   ®  s
    zFor_loop.__init__c             C   s   dS )Nz
<For loop>r   )r   r   r   r   r   ´  s    zFor_loop.__str__c             C   sf  | j  |¡ | d| j j› | j¡ | ¡  | d¡ t|ƒ}| d¡ t|ƒ}| d¡ t| jƒdkr”| jd  |¡ | d| jd j› d¡ nHxFtt| jƒƒD ]4}| j|  |¡ | d| j| j› d|› d	¡ q¤W g }g }x¦| j	D ]œ}t|ƒ}| |¡ x„tt|ƒ| ƒD ]p}|||   
d
¡d }	|	dkrPd|d › ||| < n2|	dkrj| || ¡ n|	dkr| || ¡ qW qìW | d|d › ¡ t|ƒdkrìt|ƒ}
x |D ]}d|
d › ||< q¼W | d¡ | d¡ t|ƒd }d|› d||< x| jD ]}| |¡ qW t|ƒd }x|D ]}d|› d||< q6W | d¡ | ¡  d S )Nzex_func AX "iter" zpush AXzfetch AX <esp+1>r*   rZ   zmov z AXz AX[r;   re   r›   zjmp rœ   rK   zinc espz	return AXz$jmp z "f"u             ;breakå‡ºè¿´åœˆ)rÁ   r   r   r
   rW   r~   r6   rÀ   r<   rP   r   r™   rƒ   )r   r   r¹   r²   r=   r»   Z
return_boxr'   rq   r“   Zreturn_leave_ipZr_iprº   r¼   r½   r   r   r   r   ¶  sV    


$








zFor_loop.writeN)r   r   r   r   r   r   r   r   r   r   rÄ   ­  s   rÄ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMarkc             C   s
   || _ d S )N)Úmark)r   rÉ   r   r   r   r   ì  s    zMark.__init__c             C   s   d| j › dS )Nz<mark r$   )rÉ   )r   r   r   r   r   î  s    zMark.__str__c             C   s   |  | j¡ d S )N)r   rÉ   )r   r   r   r   r   r   ğ  s    z
Mark.writeN)r   r   r   r   r   r   r   r   r   r   rÈ   ë  s   rÈ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚPassc             C   s   d S )Nr   )r   r   r   r   r   ó  s    zPass.__init__c             C   s   dS )Nz<pass>r   )r   r   r   r   r   õ  s    zPass.__str__c             C   s   d S )Nr   )r   r   r   r   r   r   ÷  s    z
Pass.writeN)r   r   r   r   r   r   r   r   r   r   rÊ   ò  s   rÊ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r©   c             C   s
   || _ d S )N)rC   )r   rC   r   r   r   r   ú  s    zTFN.__init__c             C   s   d| j › dS )Nr|   r$   )rC   )r   r   r   r   r   ü  s    zTFN.__str__c             C   s   | j | _d S )N)rC   r
   )r   r   r   r   r   r   ş  s    z	TFN.writeN)r   r   r   r   r   r   r   r   r   r   r©   ù  s   r©   c               @   s&   e Zd Zddd„Zdd„ Zdd„ ZdS )	ÚClassNc             C   s2   || _ |j| _|j| _|| _|| _|| _d| _d S )N)r   r*   )r   ÚfuncsZ	functionsrP   r   Ú	class_espÚfatherrW   )r   r   rÅ   r   rÍ   rÎ   r   r   r   r     s    zClass.__init__c             C   s   d| j › dS )Nz<class r$   )r   )r   r   r   r   r     s    zClass.__str__c       
   	   C   sP  | j dkrn| j  |¡ | dt|ƒd › d| j j› d| j› d| j¡ | j j› d| j› }| d|› d	¡ n2| j}| d
|› dt|ƒd › d| j› d| j¡ | d|› d| j› d¡ | ¡  t|ƒ}| d¡ | d¡ | dt|ƒd › d¡ | d| j› d¡ | d¡ | dt|ƒd › ¡ | d| j› d¡ | d¡ | d¡ | d¡ | d¡ | d¡ | j	d kr t
| j	ƒtkrš| j	j}n| j	g}x\|D ]T}| |¡ | d¡ | d¡ | d ¡ | d!| j› d"¡ | d#|j› ¡ q¨W | d$| j› d%|› ¡ x| jD ]}| |¡ q W | d&| j› d"¡ | d'¡ | d(¡ | d)¡ | d*¡ | d+¡ t|ƒ}| d¡ | d,¡ | dt|ƒd- › d¡ t|ƒ}| d¡ | d.¡ | d&| j› d"¡ t|ƒd- }	d|	› d/||< d|	› ||< | d0| j› d1¡ | d2¡ dt|ƒd- › ||< d3| _| ¡  d S )4Nr   zFunction BX rf   re   z "z" 1r%   zmov z BXz	Function ra   z None "zname z "<class '__main__.z'>"r*   ztf $Inheritance "equ" Nonez$jmp z "t"zmov <z> $Inheritancezpush 1zjmp z	> [class]zpush 0zmov $Inheritance Nonezpush CXz
push *argszpush **kwargszmov **kwargs <esp+1>zmov *args <esp+2>zmov CX <esp+3>zmov $Inheritance <r$   zcall ztype <z> zmov AX <zpop **kwargsz	pop *argszpop CXzpop BXzcmp BX 1ztf AX "Ctn" "__init__"rZ   zcall AX.__init__z "=="zend "Function" "r   zpop ipr   )r   r   r   r6   r
   rÍ   rW   r   r~   rÎ   r   r>   r2   rP   rƒ   )
r   r   Zclass_paramZskip_class_ipr†   rÎ   r'   Zleave_init_ipZskip_init_iprz   r   r   r   r     st    
0,























zClass.write)N)r   r   r   r   r   r   r   r   r   r   rË      s   

rË   c             C   sÌ   |   |¡ | jd d… dks&| jdkr\| d¡ |  |¡ | d|j› ¡ | d¡ d}nl| jd d… dkr¸| d¡ | d	¡ |  |¡ | d
|j› ¡ | d¡ | d¡ d}n|  |¡ |j}|S )Nrf   zAX.r   zpush AXzmov BX zpop AXr`   zAX[zpush BXzmov DX zpop BXÚDX)r   r
   r   )r’   ÚBr   Ú	blocationr   r   r   Útwo_object_write\  s$    









rÒ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚMultiple_Movc             C   s@   || _ || _|dkr"d| _d| _nd| _|d d… | _d| _d S )Nú=r*   ÚmovrZ   rh   )r   r*   )Úobj_listÚtargetÚctyper“   rW   )r   rÖ   r×   Úopr   r   r   r   ‡  s    zMultiple_Mov.__init__c             C   s   dS )Nz<Multiple mov>r   )r   r   r   r   r   ‘  s    zMultiple_Mov.__str__c             C   s,  |  d| j¡ | j |¡ |  d| jj› ¡ xî| jD ]ä}t|ƒttfkrÊxÎt	t
|ƒƒD ]l}||  |¡ | jdkr”|  d|| j› d|› d¡ qX| jdkrX|  d|| j› d	| j› d
|› d¡ qXW q6| |¡ | jdkrô|  d|j› d¡ q6| jdkr6|  d|j› d	| j› d¡ q6W |  d¡ d S )Nr   zpush r*   zmov z	 <esp+1>[r;   rZ   z$mov z "z
" <esp+1>[z <esp+1>z	" <esp+1>zinc esp)r   rW   r×   r   r
   rÖ   r   r>   r1   r<   r6   rØ   r“   )r   r   r'   r=   r   r   r   r   “  s"    
 
,


 zMultiple_Mov.writeN)r   r   r   r   r   r   r   r   r   r   rÓ   †  s   
rÓ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOperc             C   s   || _ || _|| _d S )N)r’   rĞ   Úsymbol)r   r’   rĞ   rÛ   r   r   r   r   ¨  s    zOper.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r’   rÛ   rĞ   )r   r   r   r   r   ­  s    zOper.__str__c             C   s\   | j  |¡ | d| j j› ¡ | j |¡ | d| j› d| jj› ¡ | d¡ d| _d S )Nzpush zoper <esp+1> "z" zpop AXr   )r’   r   r   r
   rĞ   rÛ   )r   r   r   r   r   r   ¯  s    
z
Oper.writeN)r   r   r   r   r   r   r   r   r   r   rÚ   §  s   rÚ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚTfc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   ¸  s    zTf.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   ½  s    z
Tf.__str__c             C   sF   t | j| j|ƒ}| d| jj› d| j› d|› ¡ | d¡ d| _d S )Nztf z "z" z	mov AX TFr   )rÒ   r’   rĞ   r   r
   r“   )r   r   rÑ   r   r   r   r   ¿  s    "
zTf.writeN)r   r   r   r   r   r   r   r   r   r   rÜ   ·  s   rÜ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAndOrc             C   s   || _ || _|| _d S )N)r’   rĞ   r“   )r   r’   rĞ   r“   r   r   r   r   Æ  s    zAndOr.__init__c             C   s   d| j › d| j› d| j› dS )Nr|   re   r$   )r“   r’   rĞ   )r   r   r   r   r   Ê  s    zAndOr.__str__c             C   sB  | j  |¡ | d| j j› d¡ t|ƒ}| d¡ | j |¡ | d| jj› d¡ t|ƒ}| d¡ | jdkrĞ| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< nh| jdkr8| d¡ | dt|ƒd › ¡ t|ƒd }|jddd	 d
|› d||< d
|› d||< d| _d S )Nzcmp z 1r*   Úandzmov AX 1zjmp rZ   zmov AX 0)r   z$jmp z "!="Úorz "=="r   )r’   r   r   r
   r6   rĞ   r“   )r   r   r·   r£   Zto_falseZto_truer   r   r   r   Ì  s.    




zAndOr.writeN)r   r   r   r   r   r   r   r   r   r   rİ   Å  s   rİ   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚDenyc             C   s   || _ || _d S )N)r’   r“   )r   r’   r“   r   r   r   r   å  s    zDeny.__init__c             C   s   d| j › d| j› dS )Nr|   re   r$   )r“   r’   )r   r   r   r   r   é  s    zDeny.__str__c             C   sJ   | j  |¡ | j jdkr,| d| j j› ¡ | d| j› d¡ d| _d S )Nr   zmov AX z
$oper AX "r   )r’   r   r
   r   r“   )r   r   r   r   r   r   ë  s
    z
Deny.writeN)r   r   r   r   r   r   r   r   r   r   rà   ä  s   rà   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚBoolc             C   s
   || _ d S )N)Úenebox)r   Z
enequalboxr   r   r   r   ó  s    zBool.__init__c             C   s$   d}x| j D ]}|t|ƒ7 }qW |S )Nr   )râ   r	   )r   r   r=   r   r   r   r   õ  s    zBool.__str__c             C   sğ  d}| j d  |¡ | d| j d j› ¡ g }g }ddddddd	œ}x|t| j ƒd
 k rL| j |d   |¡ | d¡ | j |d
  dkrÌ| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ n<| d| j |d  j› ¡ | t|ƒ|| j |d
   f¡ | d¡ |d t| j ƒk rB| d| j |d  j› ¡ |d7 }qJW | d¡ | dt|ƒd
 › ¡ t|ƒd
 }|jdd
d x,|D ]$}d|› d|d
 › d||d < qW x,|D ]$}d|› d|d
 › d||d < q¾W d| _d S )Nr*   zpush ÚfÚtz<=z>=r|   r$   )z==z!=r$   r|   z>=z<=rZ   ra   zpop DX)z==z!=ztf DX "equ" zcmp DX rf   zmov AX Truezjmp zmov AX False)r   z$jmp z "r   r   )râ   r   r   r
   r6   )r   r   r]   rµ   Zneed_set_tfZcmp_dictrz   r=   r   r   r   r   ú  s6    
" 


$
$z
Bool.writeN)r   r   r   r   r   r   r   r   r   r   rá   ò  s   rá   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚAssertc             C   s   || _ || _d| _d S )N)r   r*   )r¯   ÚmsgrW   )r   r¯   ræ   r   r   r   r     s    zAssert.__init__c             C   s   d| j › d| j› dS )Nz<assert z, r$   )r¯   ræ   )r   r   r   r   r     s    zAssert.__str__c             C   sj   |  d| j¡ t| jdƒ}ttddƒt| jgƒti ƒƒ}t	|dƒ}t
||gggg ƒ}dg|_| |¡ d S )Nr   ÚnotÚAssertionErrorr}   )r   r*   )r   rW   rà   r¯   r‚   r#   r1   ræ   r@   rM   r³   r   )r   r   Z	not_eventZassertionerrorrˆ   rÂ   r   r   r   r      s    
zAssert.writeN)r   r   r   r   r   r   r   r   r   r   rå     s   rå   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚSTRc             C   s
   || _ d S )N)r'   )r   r'   r   r   r   r   )  s    zSTR.__init__c             C   s   d| j › dS )Nz<STR: r$   )r'   )r   r   r   r   r   +  s    zSTR.__str__c             C   s*   | j  |¡ | d| j j› ¡ d| _d S )Nzex_func AX "str" r   )r'   r   r   r
   )r   r   r   r   r   r   -  s    z	STR.writeN)r   r   r   r   r   r   r   r   r   r   ré   (  s   ré   c               @   s,   e Zd Zdd„ Zdd„ Zdd„ Zdd„ Zd	S )
rN   c             C   s(   g | _ i | _i | _i | _g | _|| _d S )N)rT   ÚvarsrÌ   ÚclassesrP   r   )r   r   r   r   r   r   3  s    zInfo.__init__c             C   s^   |dkr|| j |j< n*|dkr,|| j|j< n|dkr@|| j|j< |j| jkrZ| j |j¡ d S )NrL   ÚfuncÚclass)rê   r   rÌ   rë   rT   r   )r   r   r'   r   r   r   rO   :  s    zInfo.add_infoc             C   s>   |  j |j 7  _ | j |j¡ | j |j¡ | j |j¡ d S )N)rT   rê   ÚupdaterÌ   rë   )r   rÅ   r   r   r   rî   C  s    zInfo.updatec             C   s   dd„ }| j  |¡ ||_d S )Nc             S   sJ   g }x:| D ]2}t |ƒtkr*| d| ¡ q
| t|ƒd ¡ q
W d |¡S )Nre   r   )r   r   r   r	   r4   )Zorig_codeliner5   r'   r   r   r   Ú	deal_origI  s    
zInfo.write.<locals>.deal_orig)rP   r   rW   )r   ÚcodelineÚorig_codelinesrï   r   r   r   r   H  s    z
Info.writeN)r   r   r   r   rO   rî   r   r   r   r   r   rN   2  s   	rN   N)+r   r   r   r   r   r   r#   r&   r+   r/   r1   r>   r@   rD   rG   rH   rQ   r‚   rM   r”   r–   r¤   rª   r¬   r®   r³   r¸   r¾   rÄ   rÈ   rÊ   r©   rË   rÒ   rÓ   rÚ   rÜ   rİ   rà   rá   rå   ré   rN   r   r   r   r   Ú<module>   sZ      A A"&%%>\*!'
25632*122*package.cpython-37.pycB
    TTeèß  ã               @   s¼   d Z ddlmZmZ ddlmZmZ ddlmZ ddl	T dd„ Z
dd
d„Zdd„ Zdd„ Zd dd„Zeƒ fdd„ZG dd„ dƒZG dd„ dƒZdd„ ZG dd„ dƒZeƒ ZG dd„ dƒZdS )!u   
æ‰“åŒ…ç¨‹å¼ç¢¼
é    )ÚlistdirÚgetcwd)ÚisdirÚisfile)ÚCode)Ú*c           "      s	  dN‡ ‡fdd„	}dddddd	d
dddddddddddddddddddddd d!d"d#d$d%g"}d&d'd(d)d*d+d,d-d.d/œ	}d&t ˆƒ }}g }d&}d&}ˆ d0¡}	d'g‰ d&ˆ d& |	ˆ d& d'  fg}
xB||k rúˆ| }|d1krH|}d2}x(||k rˆ| |kr|d'7 }qàP qàW ˆ||… }d3|kr.|
 t|ƒ¡ n|
 t|ƒ¡ |d'8 }n¨|d4krº|d( |k rˆ||d) … }|d5kr|
 |¡ |d)7 }qº|d' |k rÊˆ||d( … }|d6krÊ|
 |¡ |d(7 }qº|
 |¡ |d7krè|d'7 }n|d8krú|d'8 }|dkrğ|d&krğ|d&kr"|d'8 }n”yˆ d0|¡}W n   t ˆƒ}Y nX || d'krğ| |
¡ |
d& d& d* ˆ d& |	ˆ d& d'  fg}
|d'7 }xˆ| d9kr¬|d'7 }q’W |d'8 }n6|d:krøx&||k rêˆ| d0krê|d'7 }qÆW |d'8 }nø|d;krF||ƒ\}}t |
ƒd&kr8t|
d< ƒtkr8|
 d=¡ |
 |¡ nª|d0krøˆ d&  d'7  < |d&krğt |
ƒd'kr‚| |
¡ g }
|d'7 }||k rìd&}x.||k rÊˆ| d9krÊ|d'7 }|d'7 }qW |
 |ˆ d& |	ˆ d& d'  f¡ |d'8 }nø|d>krr|d' |k rrˆ|d'  d;krr|d'7 }||d?d@\}}t |
ƒd&krdt|
d< ƒtkrd|
 d=¡ |
 |¡ n~|dAkrî|d' |k rîˆ|d'  d;krî|d'7 }||ƒ\}}t |
ƒd&krÚt|
d< ƒtkrÚ|
 d=¡ |
 t|j	ƒ¡ n|dBkrä|d' |k räˆ|d'  d;krä|
 dC¡ ˆ|d'  }|d( }x.ˆ| |ksXˆ|d'  dDkrd|d'7 }q8W ˆ|d( |… }t |ƒ}d&}g }x4||k r¼|| d0kr²ˆ d&  d'7  < || dEkr
||d'  dEkrè| dE¡ |d'7 }q°t |
ƒd&krt|
d< ƒtkr|
 d=¡ |
 tdF 
|¡ƒ¡ g }|d'7 }|}d&}d'}x‚|d&krÀ|| }|d&kr”|dEkrp|d'7 }n"|dGkr„|d'8 }n|dHkr´|}n ||kr´||d'  dDkr´d&}|d'7 }q@W |d'8 }|||… }t|ƒd& d'd … }|
d=tdIƒdCg| dJd=g 7 }
n¦|| dGkrF|||d( … dKkrF| || ¡ |d'7 }nj|| dDkrz| || ¡ |d'7 }| || ¡ n6|| d;kr¢| dD¡ | || ¡ n| || ¡ |d'7 }qŠW |
 tdF 
|¡ƒ¡ |
 dJ¡ |}n|d9krğg }dL}x8||k r.ˆ| |kr(| ˆ| ¡ |d'7 }nP qøW dF 
|¡}||krÈ|dkr^|
 tdƒ¡ nV|dkrx|
 td?ƒ¡ n<|dkr’|
 td ƒ¡ n"|d%krª|
 tƒ ¡ n
|
 |¡ |d krè|d'7 }n ||krÚdM| }|
 t|ƒ¡ |d'8 }|d'7 }qºW t |
ƒd'k	r| |
¡ |S )ONTc       	         s¸  ˆ|  }| d7 } | }xHˆ|  }|dkr6ˆ d  d7  < |dkrH| d7 } n
||krRP | d7 } qW ˆ|| … }|dkrv|r‚|dkr’|r’t ||d| fS |dkr(|r(g }dt|ƒ }}x\||k r|| dkrÖ| d¡ || dkrø| || ¡ |d7 }| || ¡ |d7 }q¶W t d |¡|d| fS |dkr´|s´g }dt|ƒ }}xV||k r || dkrn| d¡ | || ¡ || dkr”| d¡ |d7 }qLW t d |¡ƒ| fS d S )	Né   Ú
r   ú\ú'ú")ÚchangeÚ )ÚStringÚlenÚappendÚjoin)	Úkr   ÚcÚpÚc2Zget_textÚtextZckÚn)ÚclineÚcode© ú/C:\Users\allen\Desktop\py\py\apython\package.pyÚdeal_string
   sL    



zparse_code.<locals>.deal_stringÚdefÚwhileÚforÚinÚifÚelifÚelseÚclassÚbreakÚcontinueÚreturnú:ÚandÚnotÚorÚTrueÚFalseÚNoneÚfromÚimportÚasÚisÚwithÚraiseÚtryÚexceptÚfinallyÚyieldÚlambdaÚdelÚglobalÚnonlocalÚassertz$stopr   r   é   é   é   é   é   é   é   )	ZAXZBXZCXZDXZipZespÚspZZRZTFr	   Z
0123456789z0123456789.Ú.z+-*/,()[]{}!=%:><.&^|~)z**=z//=z>>=z<<=)z+=z-=z*=z/=z==z!=z**ú>ú<z>=z<=z%=z//z>>z<<z&=z^=z|=)ú(ú[ú{)ú)ú]ú}ú ú#)r   r   éÿÿÿÿú+ÚrF)r   ÚbÚfrJ   r
   rL   r   rO   )r   r   z$strrM   z}}z+-*/,()[]{}!=%:><.&^|~\# 
:z$$)T)r   Úsplitr   ZFloatÚIntegerÚindexÚtyper   ZByter   r   Ú
parse_codeÚVar_nameÚTFNZStop) r   r   Zkey_wordZ	data_dictr   r   Ú	codelinesZin_bracketsZ	in_lambdaZ	orig_codeÚcodeliner   r   ZnumbersZnumberZc3r   ÚqÚstringZ	space_numZsymbolÚgetZsnZskZtextboxZslockZscZvartextZsub_codelineZv_nameZban_wordZelement_namer   )r   r   r   r[   	   sd   (



 






 

 

 
( 

 




 * 
* 
*
"
 






 $







 
 
 
 

 



r[   Fr   c             C   s”   d}t | ƒ}t|ƒ}xr||k r†| | }|dkrN||kr:|S ||krN|rJ|S dS |dk rZ|S |dkrl|d7 }n|dkr||d8 }|d7 }qW |r|S dS )Nr   rR   )rJ   rK   rL   r   )rM   rN   rO   )r   Úlist)r_   r   ÚelementsÚendÚstopr   r   Úelementr   r   r   Únext_elementû   s,    
  
  rh   c             C   s  t | ƒ}||krdS |}|d7 }d}d}xš||k rÂ| | |ksJ| | dkrÂ| | |kr¬d}|d7 }x\||k r¨|dkr¨| | |krŠ|d7 }n| | |kr|d8 }|d7 }qdW q*| | dkr*|d7 }q*W | ||… }t |ƒdkrt|d ƒtkrt|d j|ƒ|fS |d |fS nôt|d ƒtkrT|d jdkrTt|dd	… |ƒ}	t|	ƒ|fS |d d
kr|}
d}t|d ƒtkrt|d j|ƒ|d< ddlm} |ƒ d }xRt |ƒdkrú|| dkrhg }g }d }g }||d  dkr.xJ|t |ƒk r*||d  dkrP|d }t||dƒ}t|||… |ƒ}| 	t
||d  jƒ|f¡ nÆ||d  dkr¦|d }t||dƒ}t|||… |ƒ}|d kr˜|}nt||dƒ}np||d  dkræ|d }t||dƒ}| 	t|||… |ƒ¡ n0|d }t||dƒ}t|||… |ƒ}| 	|¡ || dkrìP qìW n|d7 }t|d t|ƒt|ƒ||ƒg||d d …  }nv|| dkr¤|d }g }x°t||dƒ}|| dkrØ||kr²td ƒ}nt|||… |ƒ}|d }| 	|¡ nVt |ƒdkrút|||… |ƒ}n2||kr| 	td ƒ¡ n| 	t|||… |ƒ¡ P q„W t|ƒtkr‚t |ƒdk rj|td ƒgdt |ƒ  7 }t|d |d |d ƒ}t|d |ƒg||d d …  }n:|| dkrŞt|d |d ƒ}|g|dd …  }|d8 }|ƒ |kròtdƒ‚d}qªW |d |
fS d S )N)NrR   r   )rK   rJ   )rN   rM   rG   r   r?   z$strrR   z([.)ÚtimerJ   rM   ú=r@   z,)r   rS   z**rK   z:]r)   z335 get error)r   rZ   r\   ÚVariableÚnameÚparse_codelineZSTRri   rh   r   r   ÚOperZFuncCallÚListÚDictr]   rc   ZSliceZIndexVariableZSubVariableÚ	Exception)r_   r   Ú	namespacer   r   ZleftbZrightbr   rb   Úobjr`   ri   ÚstÚargsÚkwargsZs_argsZs_kwargsÚvalueZcollectZsubattrr   r   r   Úget_var  sÀ    " 
 "


 
2


"
rx   c             C   sT   | | d d }|d }t | ƒ}x.||krN|d7 }||kr<P | | d d }q"W |S )Nr   r   )r   )r^   ÚrowZspace_nZs_nÚRowr   r   r   Únext_codeline|  s    
 r{   c       %         sÌ	  d}x0|t | ƒk r6| | }|dkr,|}i }|d7 }t | ƒ}x–||k rÖ| | }t|ƒtkrÂtd ƒ||j< |d |k rÂ| |d  dkrÂ|d }t| |dƒ}t| ||… ˆ ƒ||j< | | dkrÂP |dkrÌP |d7 }qBW t| |dd	d
}	t| |d |	… dƒ}
t||
ˆ ƒ}| d |… |g | |	d …  } d}|d7 }qW d}xÜ|t | ƒk r|dks€t| |d  ƒtkr| |d  dkr| | }|dkrŞt| |d dƒ}	t| |d |	… ˆ ƒ}| d |… |g | |	d d …  } n0|dkr6t| |d dƒ}	t| |d |	… ˆ d	d}| d |… |g | |	d d …  } nØ|dkrt| |d dgƒ}	t| |d |	… ˆ d	d}|j	}d|ksŠt |ƒdkräg }d}t |ƒ}x>||k rØ|| }|d7 }|| }|d7 }| 
||f¡ qœW t|ƒ}nt|ƒ}| d |… |g | |	d d …  } |d7 }q@W d}x®|t | ƒk rÎ| | }t|ƒtkrX|dkrXt|ƒS t|ƒtkrv|dkrvtƒ S t | ƒ}t| |ˆ ƒ\}}	| d |… |g | |	d …  } t | ƒ|k rÂ|d8 }|d7 }q"W dd„ }‡ fdd„}dd„ }d}x´|t | ƒk r¤| | }|dkr˜|d7 }|}x t| | ƒtkr>|d7 }q W t| ||d … ˆ ƒ}t| |d  |dƒ}| d |d … |g | |d d …  } |d }|d7 }qòW || dddgtƒ} || d tƒ} || d!tƒ} || d"tƒ} || d#gtƒ} || d$gtƒ} || d%gtƒ} d}xº|t | ƒk rÄ| | }|d&kr¸| |d  g}|}xF|d&kr„||| |d  g7 }|d7 }|t | ƒk r~| | }nP q@W t|ƒ}| d |d … |g | |d …  } |d }|d7 }qW d}xÂ|t | ƒk r| | }|d'krt| |d(gd	d
}n~|d(krÈ|dkr‚| |d  d)kr|tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d d …  } |d8 }nJt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }nº|d*kr‚|dkr‚| |d  d)kr8tt| |d  | |d  |ƒd)ƒ}| d |d … |g | |d+ d …  } nBt| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qÎW || d)gtƒ} || d,tƒ} d}x@|t | ƒk rğ| | }|d-kr\t| |d.gƒ}| |d  }t| |d |… ˆ ƒ}t| |d/d	d
}t| |d |… ˆ ƒ}t|||ƒ}| d |d … |g | |d …  } d}nˆ|d'krä| |d  }t| |d(gƒ} t| |d | … ˆ d	d}!| | d  }"t| | d-gƒ}#|#d0krÄd }$n| |#d  }$t||!|"|$|ƒ}|S |d7 }q²W || d1gtƒ} || d2tƒ} || d3tƒ} d}xP|t | ƒd k 	rl| | d/k	rF| |= n|d7 }|t | ƒd k	r|	sP 	qW t | ƒdk	r | d0 d/k	r |	r˜| d0= nt| ƒS |	r®t| ƒS t | ƒdk	rÄ| d S t| ƒS )4Nr   r:   r   rj   r?   z,:r)   )ú,rM   T)re   r   )rM   rN   rO   rJ   rM   rK   rN   )Úis_listrL   rO   )r&   r'   Úpassc             S   s  d}xø|t | ƒk rü| | }||kròt| |d  ƒtkrò|dkrº|dksZt| |d  ƒtkrò|dkrœ|| |d  |ƒ}| d |… |g | |d d …  } d}qò| d |… | |d d …  } n8|| |d  |ƒ}| d |… |g | |d d …  } d}|d7 }qW | S )Nr   r   )rS   ú-r   r?   rR   )r   rZ   Ústr)r_   Úop_boxÚoperatorr   r   rb   r   r   r   Údeal_single_operatorÜ  s     ""z,parse_codeline.<locals>.deal_single_operatorc                sh   d}x^|t | ƒk rb| | }||krXt| |d d … ˆ ƒ}|||ƒ}| d |… |g } d}|d7 }qW | S )Nr   r   rR   )r   rm   )r_   r   r‚   r   r   rw   rb   )rr   r   r   Údeal_single_operator_allï  s    
z0parse_codeline.<locals>.deal_single_operator_allc             S   s„   d}xz|t | ƒk r~| | }||krt|dkrt|| |d  | |d  |ƒ}| d |d … |g | |d d …  } |d8 }|d7 }qW | S )Nr   r   r?   )r   )r_   r   r‚   r   r   rb   r   r   r   Údeal_operatorú  s    &z%parse_codeline.<locals>.deal_operatorz**ú~r   rS   )r   ú/ú%z//)rS   r   )z<<z>>ú&ú^ú|)z==z!=rH   rI   z>=z<=r    r!   r+   r3   r@   )r*   r,   r"   r$   r|   rR   r9   )r(   r5   )r;   r<   r=   )r   rZ   r\   r]   rl   rh   rm   ZLambdar€   rd   r   rp   ÚSetZMarkZPassrx   rn   ZDenyZBoolZTfZAndOrZsub_if_elseZsub_for_loopZ	BacktrackZVar_declareÚTuplero   )%r_   rr   r}   r   r   Zp2Ú	paramsboxr   r   r`   Z
return_objZ
lambda_objZobjecctrb   ZcontentÚ	deal_lineZ
elementboxÚkeyrw   ÚlÚvarrƒ   r„   r…   rs   ZeneboxZelse_kZ	true_itemZ	event_objZend_kZ
false_itemZexpressZin_kÚvnamesÚbase_objÚif_kZif_objr   )rr   r   rm   †  sb   

  2
&
$

"
 &

"


"&
&


"(&
"

    rm   c       ;      C   s&  t |ƒ}d}t| ƒ}x
||k r | | }|d dkrd|d j}i }d}t|ƒ}	d}
xš||	k rğ|| }|dkr†||d  dkr†|}
n`t|ƒtkræ|
|j }td ƒ||< ||d  d	krâ|d }t||d
ƒ}t|||… |ƒ||< d}
|d7 }qXW t| |ƒ}t	| |d |… t
ƒ d}t||||ƒ}|j|_| d|¡ | ||d d |d d f¡ |d }n²|d dkrD|d j}|d dkr¬t|ddgƒ}t|d|… |ƒ}nd }t| |ƒ}t jd7  _|› dtj› }t	| |d |… t
d|› dƒd}t|||||ƒ}| d|¡ | ||d d |d d f¡ |d }nÒ|d dkr¾g }g }g }d}x:||k r| | }|d dkr|dks|d dkr0|d7 }| |d d |d d f¡ t|dd… |ƒ}t|ƒtkrìtdƒ}t| |ƒ}| |d |… }t	||ƒ}| |¡ | ||jf¡ |}nj|d dkr˜| |d d |d d f¡ t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ |}P nP qfW |d8 }| t||ƒ|¡ 
nX|d dkr¶t|dd… |ƒ}t|ƒtkrôtdƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k r~| | d dkr~|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }| t|||ƒ|d d |d d f¡ |d }	n`|d dkrg }d}xft|| ƒtksî|| dkr2t|| ƒtkr&t|| j|ƒ}| d|¡ | |¡ |d7 }qÎW t||d d… |ƒ}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ||k rÔ| | d dkrÔ|}t| |ƒ}| |d |… }t	||ƒ}|j}| |¡ ng }t||||ƒ} | | |d d |d d f¡ |d }n|d dkrRdt_i }!dt|ƒ }}	xê||	k r"t|| ƒtkr|| j}"xF|d |	k r¦||d  dkr¦|"d||d  j› 7 }"|d7 }qbW d }#|d |	k rî||d  dkrî||d  j}#t|#|ƒ}|d7 }nt|" d¡d |ƒ}|#|!|"< | d|¡ |d7 }q:W t|!|ƒ}$| |$|d d |d d f¡ nÄ|d dkrºdt_g }%|d j}"d}t|ƒ}	xF|d |	k rÆ||d  dkrÆ|"d||d  j› 7 }"|d7 }q‚W |d7 }x¶||	k r†t|| ƒtkrb|| j}&|d |	k r4||d  dkr4|&||d  jf}'|d7 }n|&|&f}'|% |'¡ t|'d |ƒ}| d|¡ n|| d krz|% d!¡ |d7 }qÒW t|"|%||ƒ}(| |(|d d |d d f¡ n\|d d"kr,|d d |d d fg}t| |ƒ}t	| |d |… |ƒ}|j})| |¡ g }*|}xô||k 
r| | d d#k
r| | }| |d d |d d f¡ t|dd$ƒ}|| d%k	rª|d dk	ršt|d|… |ƒ}+n
td&|ƒ}+d }#n t|d|… |ƒ}+||d  j}#t| |ƒ}t	| |d |… |ƒ}|* |+|#|jf¡ | |¡ |}	qW ||k 
r„| | d dk
r„| | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j}| |¡ ng }|}||k r | | d d'kr | | }| |d d |d d f¡ t| |ƒ}t	| |d |… |ƒ}|j},| |¡ ng },t |)|*||,|ƒ}-| |-|¡ |d }nê|d d(krFd}t||dd%gƒ}t|||… |ƒ}.t jd7  _td)tj› |ƒ}/| d|/¡ || dkrÚt||d%gƒ}0t||d |0… |ƒ}#t|#ƒtkrŞ| d|#¡ nd }#t| |ƒ}t	| |d |… |ƒ}| |¡ t!|.|/|#|j|ƒ}1| |1|d d |d d f¡ |d }nĞ|d d*krât|ddgd+d,}t|d|… |ƒ}|t|ƒk r¬|| dkr¬t||d d … |ƒ}2nt"dƒ}2t#||2ƒ}3| |3|d d |d d f¡ n4t|dd-d.gd/}4||4 }5g }6d}7x¢|4dkr¦t||7|4… |ƒ}8t|8ƒtt$fkr`xD|8D ] }t|ƒtkr:| d|¡ q:W nt|8ƒtkrz| d|8¡ |4d }7|6 |8¡ t||4d d	d.gd/}4qW t||7d … |ƒ}9t|6ƒdkrê| |9|d d |d d f¡ n,t%|6|9|5ƒ}:| |:|d d |d d f¡ |d7 }qW |S )0Nr   r   r   r?   rA   r   )r   z**)rJ   r|   rj   z,))rr   Úfuncr%   r@   rJ   rM   rŠ   rI   rH   r"   r#   rR   r$   r   r    r|   r’   r1   rG   r2   r0   r   )r   r   r6   r7   )r)   r2   r)   rq   r8   r4   z
%with_obj_r>   T)re   )rj   z+=z-=z*=z/=z%=z//=z**=z<<=z>>=z&=z^=z|=r:   )rf   )&ZInfor   rl   rZ   r\   r]   rh   rm   r{   Úparse_blockÚ	NamespaceZDefÚlocalsZ
local_varsÚadd_infoÚwriteÚimporterÚclass_nZClassr   r   rX   Úupdater^   ZIf_elseZWhilerk   ZFor_loopÚ	need_loadrW   ÚImportÚFrom_ImportZ
Try_ExceptZWithr   ZAssertro   ZMultiple_Mov);r^   rr   Úinfory   rz   r_   Z	func_namer   r   r   Zprer   Z
param_namer   r`   ZpinfoZfDefZ	classnameZfatherZ	class_esprb   ZeventboxZelse_codelinesZorig_codelinesr•   ZeventZblockZwhile_codelinesr“   r’   r”   Zfp_codelinesZfor_loopÚpackage_dictÚmodule_nameÚas_nameZ
import_objÚobject_namesZobject_nameÚdealZfrom_import_objZtry_codelinesZexcept_objectsZ	error_objZfinally_codelinesZ
try_exceptZcall_objZorig_as_nameÚq2Zwith_objÚmsgZ
assert_objZequalÚopZvariableboxÚsÚvarsÚtargetZmov_objr   r   r   r—   €  s   



 

$ & 





 




("





 
" 


$
"
 


$









 
$

" r—   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r¡   c             C   s"   || _ || _|| _|| _d| _d S )N)r   r   )r¤   r¦   rr   Únow_infoÚ
orig_lines)Úselfr¤   r¦   rr   r®   r   r   r   Ú__init__Æ  s
    zFrom_Import.__init__c             C   s   d| j › d| j› dS )Nz<From z import rH   )r¤   r¦   )r°   r   r   r   Ú__str__Ì  s    zFrom_Import.__str__c             C   sŠ  t  | j¡}| d| j¡ |d dkrTdt|ƒ› }| j|i}t|| jƒ}| |¡ | d|d › d¡ | jdkr| j |¡ | d| jj	› ¡ d}d	}nd}d
}x¼| j
D ]²}|d dkr8t j|d  }	|	dkræt j|d  }
n|	j}
xr|
D ]@}| d|› |› d|› d|› d¡ t|| jƒ}| j d|¡ qòW q®| d|› |d › d|› d|d › ¡ q®W | jdkr|| d¡ n
| d¡ d S )Nr   r   r   z&tem_import_zpush $importer["z"]zpush z<esp+1>.z<esp+2>z<esp+1>r   zbuilt-inzmov rP   rG   z    ;import *r’   z$mov esp "+" 2zinc esp)rœ   Úget_pathr¤   r   r¯   r   r    rr   r›   Úlocationr¦   ÚinfosÚmodule_dictr™   rk   r®   rš   )r°   ÚcodesZmodule_dataZtem_module_namer£   Z_importZmodule_spaceZispacer’   r¢   r™   Z	local_varZvariabler   r   r   r›   Î  s:    



",zFrom_Import.writeN)Ú__name__Ú
__module__Ú__qualname__r±   r²   r›   r   r   r   r   r¡   Å  s   r¡   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )r    c             C   s   || _ || _d| _d S )N)r   r   )r£   rr   r¯   )r°   r£   rr   r   r   r   r±   ğ  s    zImport.__init__c             C   s   d| j › dS )Nz	<Import: rH   )r£   )r°   r   r   r   r²   ô  s    zImport.__str__c             C   s¾  | j dkr&| j  |¡ | j j› d}nd}|}xˆ| jD ]|}| j| }| d¡}x\tt|ƒƒD ]J}d |d |d … ¡}t 	|¡}	t|ƒ}
d|| › d|
› }|	d dkr:| 
d|› d|	d › d	¡ |d krö| 
d|› || › d
|› ¡ n8|t|ƒd kr$| 
d|› |› d
|› ¡ n
| 
d¡ |› d}qb|	d dkrtj 
|	d ¡ | 
d|› d|	d › d¡ | 
d|	d › d|› ¡ |d krÆ| 
d|› || › d
|› d|› || › ¡ n,|t|ƒd krò| 
d|› |› d
|› ¡ dtj|	d < |› d}qb|	d dkrbtj 
|	d ¡ | 
d¡ | 
d|	d › d|› ¡ |d kr„| 
d|› || › d
|› d|› || › ¡ n8|t|ƒd kr²| 
d|› |› d
|› ¡ n
| 
d¡ | |	d ¡ t|	d dtjd ¡ }t|ƒ}t|ƒ}x|jD ]}| |¡ qúW |tj|	d < | ¡  i }g }d}xB|jD ]8}||kr8| 
|¡ d|› d|› d||< |d7 }q8W d |¡}d|› d|› d|› d||
< dd„ }dd„ }|
d 7 }
xğtt|ƒ|
 ƒD ]Ü}||
|  }d|ksèd!|krò||ƒ}n||
|   d
¡}x†tt|ƒƒD ]v}|dks|| dkr2q|| d d"krHq|| d d#kr\P ||| ƒ\}}||kr|| | ||< qW d
 |¡||
| < qÄW |› d}qbW |}q8W d S )$Nr   rG   r   r‰   Ú_r   zmov z $importer["z"]rP   r~   r?   zmodule z "r   zmov $importer["z"] u	     ;å®šç¾©zbuilt-inrT   )ÚencodingrI   rS   rH   r|   z
namespace z" "c             S   sT   d}dt | ƒ }}x8||k rJ| | |kr@| d |… | |d … fS |d7 }qW | dfS )Nz.[ ;r   r   r   )r   )ra   rF   r   r   r   r   r   Úget_name9  s    
zImport.write.<locals>.get_namec             S   s¶   g }dt | ƒ }}x||k r°|}| | dkrr| | }|d }x,| | |krh| | dkr^|d7 }|d7 }q>W |d7 }x ||k r’| | dkr’|d7 }qtW | | ||… ¡ |d7 }qW |S )Nr   )r   r   r   r
   rP   )r   r   )ÚlineÚboxr   r   r   r   r   r   r   Ú
parse_lineA  s"    
  z Import.write.<locals>.parse_liner@   r   )r   r   ú;)rr   r›   r´   r£   rW   Úranger   r   rœ   r³   r   Úloadedrµ   Ú
add_newtabÚopenr¼   Úreadr[   r—   r^   Ú
del_newtabr™   )r°   r·   Z
last_layerZ	tem_layerr¤   r¥   ZmboxÚmZdealnameZ	deal_datar   Znamespace_stack_namer   r^   r¢   rs   Zparams_dictr¿   Zvar_kr’   Zvar_textr½   rÀ   Úir¾   r§   ÚjZbackr   r   r   r›   ö  s    



 

.

.




 
zImport.writeN)r¸   r¹   rº   r±   r²   r›   r   r   r   r   r    ï  s   r    c                 sÆ   ‡ fdd„‰ i } t tƒ d ddd ¡  d¡}x’|D ]Š}t|dd	d
d}|t|ƒk r4|| dkr4t||d d	d
d}||d |… }t||d dƒ}||kr¶ˆ ||d d … ƒ| |< q4i | |< q4W | S )Nc                sö   i }t | ƒ}d}xà||k rğx ||k r:| | dkr:|d7 }qW t| |ddd}| ||… }x ||k rx| | dkrx|d7 }qZW ||k rÀ| | dkrÀt| |d d	ƒ}ˆ | |d |… ƒ||< |d }q||ksÔ| | d
kræi ||< |d }qtdƒ‚qW |S )Nr   z, r   z( ,T)re   rP   rJ   rM   r|   Zunknow)r   rh   rq   )r¾   Z	line_dictr   r   r`   rg   r¨   )r   r   r   r   f  s&    
  

zRead_ex_func.<locals>.deal_linez\apython\ex_func.pyrT   zutf-8)r¼   r	   r   z #T)re   rP   r   rQ   )rÅ   r   rÆ   rW   rh   r   )r¶   Zex_func_contentr¾   r   r   r¤   r`   r   )r   r   ÚRead_ex_funce  s    
rË   c               @   s.   e Zd Zdd„ Zdd„ Zdd„ Zdd	d
„ZdS )ÚImporterc             C   s   t ƒ | _|  ¡  d S )N)rË   r¶   Úreset)r°   r   r   r   r±   …  s    zImporter.__init__c                s$   ‡ ‡fdd„‰|  d¡‰ ˆ| jdƒS )Nc                sÀ   |t ˆ ƒd kr¤d}xŠt| ƒD ]~}| › d|›  dd¡}t|ƒrt| d¡d dkrt|dkrt|d d… ˆ | krt|}qt|ƒrd	t|ƒkr|ˆ | kr|d
 }qW |S ˆ| › dˆ | › |d ƒS )Nr   r   r‡   r
   rG   rR   Úpyéıÿÿÿz__init__.pyz/__init__.py)r   r   Úreplacer   rW   r   )Z	nowfolderr   ÚfilepathÚfileZroad)ÚfboxÚ
get_moduler   r   rÔ   ‰  s    6 z)Importer.__get_module.<locals>.get_modulerG   r   )rW   Úwork_folder)r°   r¤   r   )rÓ   rÔ   r   Z__get_moduleˆ  s    
zImporter.__get_modulec             C   sb   || j kr(|| jkr|› dgS |› dgS |  |¡}|| jkrD|dgS |dkrV|› dgS |dgS d S )Nr   r?   r   r   )r¶   rÃ   Ú_Importer__get_module)r°   r¤   rÑ   r   r   r   r³   –  s    






zImporter.get_pathr   Úcp950c             C   sh   d| _ || _| dd¡ d¡d }||kr4tƒ | _n|d t|ƒ d … | _|| _g | _i | _	d| _
d S )Nr   r
   r‡   rR   r   )rŸ   r¼   rĞ   rW   r   rÕ   r   ZnowpathrÃ   rµ   r   )r°   Zpyfiler¼   Zpy_file_namer   r   r   rÍ   £  s    
zImporter.resetN)r   r×   )r¸   r¹   rº   r±   rÖ   r³   rÍ   r   r   r   r   rÌ   „  s   rÌ   c               @   s&   e Zd Zd	dd„Zdd„ Zdd„ ZdS )
ÚPackagerr×   c             C   s   t ƒ | _|| _d S )N)r   r   r¼   )r°   r¼   r   r   r   r±   ²  s    zPackager.__init__c             C   s~   t |d| jd ¡ }t|ƒ}t || j¡ t|ƒ| _tjrF| j	 
d¡ | j	 |¡ x| jjD ]}| | j	¡ q\W | j	 ¡  d S )NrT   )r¼   zmov $importer [dict])rÅ   r¼   rÆ   r[   rœ   rÍ   r—   r¢   rŸ   r   r   rÄ   r^   r›   rÇ   )r°   Úpy_filer   r^   rs   r   r   r   Úloadµ  s    
zPackager.loadc             C   s    t |dƒ ¡ }| d¡| j_d S )NrT   r	   )rÅ   rÆ   rW   r   )r°   Zec_filer   r   r   r   Úload_easy_codeÀ  s    zPackager.load_easy_codeN)r×   )r¸   r¹   rº   r±   rÚ   rÛ   r   r   r   r   rØ   ±  s   
rØ   N)Fr   )F)Ú__doc__Úosr   r   Zos.pathr   r   Zapython.coder   Zapython.moduler[   rh   rx   r{   rm   r˜   r—   r¡   r    rË   rÌ   rœ   rØ   r   r   r   r   Ú<module>   s(    s
m

 {  G*v+1944*123*__init__.cpython-37.pycB
    ¸åPeG  ã               @   sD   d dl mZ d dlmZ d dlmZ G dd„ dƒZG dd„ dƒZdS )	é    )ÚPackager)ÚExecuter)Úchdirc               @   s   e Zd Zddd„Zdd„ ZdS )ÚApythonúutf-8c             C   s$   t |ƒ| _| jj| _t| jƒ| _d S )N)r   ÚpackagerÚcoder   Úexecuter)ÚselfÚencoding© r   ú0C:\Users\allen\Desktop\py\py\apython\__init__.pyÚ__init__   s    

zApython.__init__c             C   s   | j  |¡ | j ¡  d S )N)r   Úloadr	   Úrun)r
   Zpy_filer   r   r   r   	   s    zApython.runN)r   )Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r      s   
r   c               @   s8   e Zd Zddd„Zdd„ Zdd„ Zdd	„ Zddd„ZdS )ÚParserúutf-8c             C   s$   t |ƒ| _| jj| _t| jƒ| _d S )N)r   r   r   r   r	   )r
   r   r   r   r   r      s    

zParser.__init__c             C   s   | j j}| ¡  d S )N)r   r   Zdisplay)r
   r   r   r   r   Úparse   s    zParser.parsec             C   s"   d  | jj¡}t|dƒ |¡ d S )NÚ
Úw)Újoinr   ÚopenÚwrite)r
   Úfilepathr   r   r   r   Úsave   s    zParser.savec             C   st   |  d¡d }| dd¡  d¡d }|d t|ƒ … }t|ƒdkrNt|ƒ |}d|krd| j |¡ n| j |¡ d S )NÚ.éÿÿÿÿú\ú/r   Zec)ÚsplitÚreplaceÚlenr   r   Zload_easy_coder   )r
   r   ZftypeÚfilenameZwork_folderr   r   r   r      s    zParser.loadr   é   c             C   s   | j  ||¡ d S )N)r	   r   )r
   ÚtfÚ
stack_sizer   r   r   r   #   s    z
Parser.runN)r   )r   r&   )r   r   r   r   r   r   r   r   r   r   r   r   r      s
   
r   N)Zapython.packager   Zapython.executerr   Úosr   r   r   r   r   r   r   Ú<module>   s   	368*122*è®Šæ•¸å‘½åè¦å‰‡.txt$name            ç³»çµ±è®Šæ•¸ï¼Œéç³»çµ±åƒæ•¸ä¸å¯ä½¿ç”¨
&name_len(code)  æš«æ™‚è®Šæ•¸ï¼Œç†è«–ä¸Šå› ç‚ºipä¸é‡è¤‡ï¼Œæ‰€ä»¥ä¸é‡è¤‡ï¼Œä¸å¯ç”¨æ–¼å †ç–Šè®Šæ•¸ï¼Œåªèƒ½ç”¨æ–¼å®£å‘ŠæŸç‰©ä»¶æ™‚
%name_id         ä¸å…·ååƒæ•¸ï¼Œidç‚ºimporterçš„è®Šå‹•id
name^id          classåƒæ•¸ï¼Œç•¶namepaceç‚ºæ­¤æ™‚ï¼Œä»£è¡¨æ­¤ç‰©ä»¶åœ¨classä¹‹ä¸­560*14*m.pyfrom apython import Apython,Parser
p=Parser()
p.load('test.py')
#p.load('test_data/string.py')
#p.load('backup2/m.py')
#p.load('test_data/import.py')
#p.load('test_data/oper.py')
#p.load('test_data/function.py')
#p.load('test_data/loop.py')
#p.load('test_data/try.py')
#p.load('test_data/mix.py')
#p.load('test_data/del.py')
#p.load('test_data/keyword.py')
#p.load('C:\\Users\\allen\\Desktop\\pyå¤§ç¦®åŒ…\\æœŸæœ«\\æ°´.py')
#p.save('new.ec')
p.parse()
p.run(tf=1)
#p.load('new.ec')
#p.parse()
#p.run()
#ap=Apython()
#ap.run('test.py')33*17*test.pyprint('I am in backup3')24613*09*test_data569*16*del.pyb=[4]
a=[[1],[2],[3],b]
print(a)
del a[-1]
print(a)
#print(b)
def abc():
    x=1
    y=2
    def rew():
        print(x+y)
    return rew
a=abc()
a()
class ABC:
    def __init__(self):
        self.a=5
        self.k=0
    def k(self):
        print('100')
abc=ABC()
print(abc.k)
print(abc.a)
del abc.k
print(abc.k)
a=list(range(10))
print(a[3:])
print(a[3::])
print(a[:5:])
print(a[:8:-1])
del a[2:5]
print(a[::-1])
a+=['hello','world!']+a[::-2]
for i in range(3):
    del a[-1]
print(a)
b='hello'
print(b)
del b
print(b)557*111*function.pydef func1(a,b,c):
    w=a+b
    z=a+c
    d=a*b-c
    return w*z*d
def func2(q,w,e):
    s=q-w**e
    return s
print(func1(3,6,7))
print(func1(func2(2,3,4),6,7))
class ABC:
    def __init__(self):
        print('init')
        self.k=0
    def func(self,a,b):
        print('func')
        return 100*a*b
    def __str__(self):
        return 'this is abc'
    def __add__(self, other):
        self.k+=other
        print(f'now self.k is {self.k}')
        return self
abc=ABC()
c=abc.func(2,3)+50
print(c,str(abc+5))1408*19*glocal.pya=None
def test():
    a=100
    def test2():
        nonlocal a
        a=200
        print('test2:a=', a)
       # $stop
       # $stop
        def test3():
            nonlocal a
            a=300
            def test5():
                nonlocal a
                a+=30
                print('test5:a=',a)
            test5()
            print('test3:a=',a)
            return test5
        def test4():
           # $stop
            global a
            global he_plus
            #$stop
           # $stop
            class ABC:
                def __init__(self,orig,nnn):
                    self.k=orig**nnn
                def __add__(self, other):
                    new=ABC(2,3)
                    new.k=self.k+other.k
                    return new
                def __str__(self):
                    return f'{self.k}'
            he_plus=ABC(4,5)
            a=400
          #  $stop
            return ABC(6,7)
        print('test2:a=', a)
        ss=test3()
        print('test2:a=', a)
        nonlocal he2
        print('test2:a=', a)
        he2=test4()
      #  $stop
#        $stop
      #  $stop
        print('test2:a=',a)
        ss()
        ss()
    #$stop
    he2=0
    test2()
    #$stop
    print('test:a=',a)
    global fff
   # $stop
    fff=he2+he_plus
test()
#$stop
print('å…¨åŸŸa=',a)
print(fff)399*19*import.pyfrom import2 import Apple,b,test_function,q
#import test2
a=Apple()
print(a.func1(20))
d=b.func1(5)
c=b
print(c.k*d)
#print(test_function(q))
import okg.pk2.sss
print(okg)
print(okg.pk2)
print(okg.pk2.sss)
print(b)
print(c)
d=not b
#print(not b)
#assert 1==2 or 1==3 or c is not b,'123'+'456'
asd=okg.ABC()
print(okg.pk2.sss.repeat_func(asd.asd))
print(asd.func('he+'))436*110*import2.pyimport import3
from import3 import *
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(a.k)
#223*110*import3.pyimport import2
q='this is test'
from mix import *
def test_function(string):
    for i in string:
        print(i)
    print(string)
    print(test2.test3.q)
print('answer:--------------------',s,a,b,y)910*114*inheritance.py#from random import random
class AAA:
    print('sound good')
    def __init__(self):
        self.k=10
        print('my k is ',self.k)
    def func(self):
        self.k+=100
        return self.k
    print('he+')
    ccc=3000
class BBB(AAA):
    print('my first')
    def __init__(self):
        self.k=200
        print('my k is ',self.k)
    def func(self):
        self.k+=2000
        return self.k
    print('zzz')
b=BBB()
print(b.func())
print(b.ccc)
class A2:
    print('A2')
    def func(self):
        return 2
class A1:
    print('A1')
    def func(self):
        return 1
class A3:
    print('A3')
    def func(self):
        return 3
box=[A1,A2,A3]
class BB(A3,A2,A1):
    def __init__(self):
        print('start')
for i in range(10):
    a=BB()
    print(a.func())
def p1():
    print('p1')
def p2():
    print('p2')
a=[p2(),p1()]637*110*keyword.pyimport keyword2
from keyword3 import *
def abc(x,y,*args,**kwargs):
    print(x)
    print(y)
    for i in args:
        print(i,end=' ')
    print(kwargs['ed'])
dfg={'ed':200,'su':400}
abc(1,2,3,2,3,4,5,6,r=100,**dfg)
def allen_func(function,*args, **kwargs):
    a=function(*args,**kwargs)
    print(a)
for i in range(3):
    allen_func(print,'hello',' he+ ',123456,'',end=' \n\n')
alen=allen_func(len,[1,2,3,4,5])
print(alen)
qq=allen_func('hey he+'.replace,'h','H')
allen_func(print,allen_func('this is easy '.split,' '),qq,end='\nthis is end')
keyword2.sleep(1)
allen_func(keyword2.keyword3.listdir)570*111*keyword2.pyfrom time import *
import keyword3
import os.path
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(f'now time is {round(time(),2)} and a.k=',a.k)
#
print(f'new.txt is '+('file' if os.path.isfile('new.txt') else 'not file'))123*111*keyword3.pyfrom os import listdir
def test_function(string):
    for i in string:
        print(i)
    print(string)696*17*loop.pybox=[]
for i in range(10):
    box.append(i**2-i)
    for j in range(10):
        box.append(i*j)
s=sum(box)%30
k=[]
hintbox=[]
while s>0:
    k.append((s,s**2))
    s-=1
    if s>10:
        hintbox+=['>10']
    elif s==10:
        hintbox+=['==10']
    else:
        hintbox+=['<10']
sss=[i+j for i,j in k]
print(sss)
c=(i for i in range(10))
for i in range(10):
    print(next(c))
print(hintbox)
def func_loop(a,b):
    def sub_func(a,b,x):
        for i in range(10):
            yield i**a+b/(abs(x)+12)
    xbox=sub_func(a+b,a*b*1234,a-b)
    for i in range(10):
        yield next(xbox)
func=func_loop(2,5)
for i in range(10):
    print(next(func))2552*16*mix.pyb=lambda x,y:x**2+y*3-5
s=b(5,7)
print(s)
c=lambda x:[i for i in range(x) if i%2==0]
d=lambda x,y:((yield x+y+i) for i in range(10) if i%3==1)
g=d(2,3)
#a=c(10)
try:
    for i in c(100):
        print(next(g),end=' ')
except:
    print(c(10))
    def abc(x,y):
        def p():
            for i in range(10):
                yield (x+y+i)
        return p()
    class YYY:
        a=(lambda self,x,y,z:x+y**z)(0,3,5,7)
        b=lambda self,w,e:(lambda q,w,e:q*w+e-7)(w,e,10)
        def __init__(self,x,y):
            self.value=self.b(x,y)
        def __str__(self):
            return str(self.value)
        def func(self,func):
            func()
    #with c(10) as ce:
     #   print('happy')
finally:
    def this_is_mix_try():
        class test:
            def __init__(self):
                print('__init__')
            def __enter__(self):
                print('__enter__')
                return YYY(10,20)
            def __exit__(self, exc_type, exc_val, exc_tb):
                print('__exit__')
        with test() as T:
            k=0
            while k<2:
                with test():
                    print('inside test')
                    def lock():
                        for i in range(10):
                            yield k**3+T.value
                    lo=lock()
                    print('yield:',next(lo))
                k+=1
                if T.value>10:
                    print(f'T is bigger:{T.value}')
                elif s<30:
                    print('s is small')
                print(T.value,s)
            else:
                print('this is else leave')
    sss=this_is_mix_try
    for i in range(20):
        try:
            a=abc(2,3)
            for i in range(10):
                print(next(a)*i,end=' ')
            y=YYY(3,6)
            y.func(sss)
            print(y,end=' ')
            if i>3:
                i+=5
                break
        except:
            print('a except occur')
        finally:
            print(i,end=' ')
            if i>8:
                break

a=[1,2,3]
b=list(map(str,a))
print(b)
a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
class YYY:
    a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
    b = lambda self, w, e: (lambda q, w, e: q * w + e - 7)(w, e, 10)
    def __init__(self, x, y):
        self.value = self.b(x, y)*1000+self.a
        #print(self.value)
    def __str__(self):
        return str(self.value)
y=YYY(3,6)

print(y)4564*03*okg183*16*pk1.pya=100
b=200
c=300
from okg.pk2 import *
def gen(x,y):
    try:
        for i in range(10):
            yield i+x*y
        x+=2
    finally:
        print('gen end')2543*03*pk2309*16*sss.pya1=100
b2=200
c3=300
def repeat_func(func):
    for i in range(5):
        func()
class Guava:
    def __init__(self,l):
        print('this is Guava')
        self.k=100*l
    def print(self):
        print(self.k)
    def __add__(self, other):
        self.k+=other
        return self400*111*__init__.pyimport okg.pk2.sss
fg='this is good'
#LO=okg.pk2.sss.repeat_func
#bbb=okg.pk2.sss.a1
class OKK:
    def __init__(self):
        print('this is init')
    def __enter__(self):
        print('enter')
        self.tem=okg.pk2.sss.Guava(3.5)
        return self.tem
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
        print('my tem is ',self.tem.k)1813*011*__pycache__909*118*sss.cpython-37.pycB
    cOe-  ã               @   s&   d Z dZdZdd„ ZG dd„ dƒZdS )éd   éÈ   i,  c             C   s   xt dƒD ]
}| ƒ  q
W d S )Né   )Úrange)ÚfuncÚi© r   ú5C:\Users\allen\Desktop\py\py\test_data\okg\pk2\sss.pyÚrepeat_func   s    r	   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚGuavac             C   s   t dƒ d| | _d S )Nzthis is Guavar   )ÚprintÚk)ÚselfÚlr   r   r   Ú__init__   s    zGuava.__init__c             C   s   t | jƒ d S )N)r   r   )r   r   r   r   r      s    zGuava.printc             C   s   |  j |7  _ | S )N)r   )r   Úotherr   r   r   Ú__add__   s    zGuava.__add__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r
      s   r
   N)Za1Zb2Zc3r	   r
   r   r   r   r   Ú<module>   s   880*123*__init__.cpython-37.pycB
    cOe‚  ã               @   s   d dl ZdZG dd„ dƒZdS )é    Nzthis is goodc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOKKc             C   s   t dƒ d S )Nzthis is init)Úprint)Úself© r   ú:C:\Users\allen\Desktop\py\py\test_data\okg\pk2\__init__.pyÚ__init__   s    zOKK.__init__c             C   s   t dƒ tjj d¡| _| jS )NZenterg      @)r   ÚokgÚpk2ÚsssZGuavaÚtem)r   r   r   r   Ú	__enter__   s    zOKK.__enter__c             C   s   t dƒ t d| jjƒ d S )NÚexitz
my tem is )r   r   Úk)r   Úexc_typeZexc_valZexc_tbr   r   r   Ú__exit__   s    zOKK.__exit__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   )Úokg.pk2.sssr   Zfgr   r   r   r   r   Ú<module>   s   403*111*__init__.pyimport okg
import okg.pk1
a=100
a*=okg.pk1.a
from okg.pk1 import *
class ABC:
    def __init__(self):
        self.test='hello'
    def asd(self):
        self.test+='_asd'
    def func(self,rp):
        print(f'{rp} {self.test}')
print('okg')
print(a+b+c)
s=gen(3,5)
for i in range(5):
    print(next(s))
with OKK() as ok:
    for i in range(3):
        ok+=next(s)

1408*011*__pycache__417*118*pk1.cpython-37.pycB
    cOe¯   ã               @   s    d Z dZdZddlT dd„ ZdS )éd   éÈ   i,  é    )Ú*c             c   s<   z,xt dƒD ]}|| |  V  qW | d7 } W d tdƒ X d S )Né
   é   zgen end)ÚrangeÚprint)ÚxÚyÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\okg\pk1.pyÚgen   s
    r   N)ÚaÚbÚcZokg.pk2r   r   r   r   r   Ú<module>   s   967*123*__init__.cpython-37.pycB
    cOe…  ã            	   @   sª   d dl Z d dlZ dZee jj9 Zd dlT G dd„ dƒZedƒ eee e ƒ eddƒZ	xe
dƒD ]Zeee	ƒƒ qbW eƒ $Zxe
dƒD ]Zeee	ƒ7 ZqˆW W dQ R X dS )	é    Néd   )Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚABCc             C   s
   d| _ d S )NZhello)Útest)Úself© r   ú6C:\Users\allen\Desktop\py\py\test_data\okg\__init__.pyÚ__init__   s    zABC.__init__c             C   s   |  j d7  _ d S )NZ_asd)r   )r   r   r   r   Úasd	   s    zABC.asdc             C   s   t |› d| j› ƒ d S )Nú )Úprintr   )r   Zrpr   r   r   Úfunc   s    zABC.funcN)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r   r      s   r   Úokgé   é   )r   Zokg.pk1ÚaZpk1r   r   ÚbÚcÚgenÚsÚrangeÚiÚnextZOKKZokr   r   r   r   Ú<module>   s   
252*17*oper.py#'''
#é€™è£¡æ”¾ç½®åŸºæœ¬é‹ç®—
#'''
a=12
b=23
c=a+b
d=c-b
e=a*b
f=a/b
g=a**b
h=c%d
i=c//d
j=e>>d
k=e<<d
l=int(f)&g
m=l^g
n=l|g
answer=[c,d,e,f,g,h,i,j,k,l,m,n]
print(answer)
o=a*b-c+d//e-(a+b/3+120-g)*d
print(sum(answer)*o)722*19*string.pyeasy='hello world'
print(easy)
easy2="hello he+"
print(easy2)
string1='\'""\"sa\\\''
print(string1)
r_string1=r'\'""\"sa\\\''
print(r_string1)
string2="\'123\n\'\\\"\'''"
print(string2)
r_string2=r"\'123\n\'\\\"\'''"
print(r_string2)
string3=f'abc\'{{"12\'3"}}12{345}}}\"\''
print(string3)
r_string3=r'abc\'{{"12\'3"}}12{345}}}\"\''
print(r_string3)
n_string3='abc\'{{"12\'3"}}12{345}}}\"\''
print(n_string3)
x=f'12{"hello"}}}{{\'\""\'"}}'.join(['"',"'"])
y='"\''
print(x)
print(y)
class ABC:
    def __init__(self,a):
        print(f'this is \' self. {a} \' init ! ')
        self.k=0
    def func(self):
        print(f'this is \'self.{self.k}\' init ! ')
abc=ABC(10)
abc.func()
2011*16*try.py
a=100
b='200'

try:
    print('try')
    c=a+b
except NameError:
    print('name error')
except ValueError:
    print('value error')
except Exception as e:
    print('except is ',e)
else:
    print('else')
finally:
    print('fist try end')
class NEW:
    def __init__(self):
        print('new init')
        class new:
            def __init__(self):
                self.value=10
            def __getitem__(self, item):
                return self.value*item
            def __setitem__(self, key, value):
                self.value+=key+value
        self.sss=new()
    def __add__(self, other):
       # print('my sss:', self.sss.value)
       # print('other sss:', other.sss.value)
        self.sss.value+=other.sss.value
       # print('my sss:',self.sss.value)
        return self
    def __setitem__(self, key, value):
        self.sss[key]=value
    def __getitem__(self, item):
        return self.sss[item]
    def __del__(self):
        print('with value:',self.sss.value,' be destroy')
    def yield_loop(self):
        try:
            for i in range(10):
                self.sss[i]=i**2
                yield self.sss[10]
        finally:
            print('loop end with:',self.sss.value)
class DEF:
    def Class(self,a,b):
        self.a=a
        self.b=b
        print('this is class test')
    def __init__(this,a,b):
        this.Class(b,a)
        print('__init__')
        this.k=10
        this.abc=100
        this.random=300
    def __enter__(self):
        print('enter!')
        self.k+=20
        new=NEW()
        new.sss[self.a]=self.b
        return new
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
with DEF(10,20) as rew:
    new=NEW()
    print(rew.sss.value)
    print(new.sss.value)
  #  $stop
    rew+=new
    print(rew.sss.value)
    print('happy')
print(rew.sss[100])
x=rew.yield_loop()
y=new.yield_loop()
for i in range(10):
    print(next(x)*next(y))7883*011*__pycache__1081*122*import2.cpython-37.pycB
    ñ^Oe§  ã               @   sP   d dl Z d dl T G dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zeejƒ dS )é    N)Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú1C:\Users\allen\Desktop\py\py\test_data\import2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__	   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   )Zimport3r   r   Úbr   Úar   r   r   r   r   Ú<module>   s   
470*122*import3.cpython-37.pycB
    aeOeÒ   ã               @   s0   d dl Z dZd dlT dd„ Zedeeeeƒ dS )é    Nzthis is test)Ú*c             C   s.   x| D ]}t |ƒ qW t | ƒ t tjjƒ d S )N)ÚprintZtest2Ztest3Úq)ÚstringÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\import3.pyÚtest_function   s    
r	   zanswer:--------------------)	Úimport2r   Zmixr	   r   ÚsÚaÚbÚyr   r   r   r   Ú<module>   s   1250*123*keyword2.cpython-37.pycB
    ”ÑPe,  ã               @   s†   d dl T d dlZd dlZG dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zede	e ƒ dƒ› d	ej
ƒ ed
ej d¡rzdnd ƒ dS )é    )Ú*Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__
   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   znow time is é   z	 and a.k=znew.txt is znew.txtÚfileznot file)ZtimeÚkeyword3Zos.pathÚosr   r   Úbr   ÚaÚroundr   ÚpathÚisfiler   r   r   r   Ú<module>   s   
347*123*keyword3.cpython-37.pycB
    ŞĞPem   ã               @   s   d dl mZ dd„ ZdS )é    )Úlistdirc             C   s"   x| D ]}t |ƒ qW t | ƒ d S )N)Úprint)ÚstringÚi© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword3.pyÚtest_function   s    
r   N)Úosr   r   r   r   r   r   Ú<module>   s   4693*118*mix.cpython-37.pycB
    *ØGeğ	  ã               @   s¤  d d„ Z e ddƒZeeƒ dd„ Zdd„ ZeddƒZzZy&x edƒD ]Zeeeƒd	d
 qBW W n.   eedƒƒ dd„ ZG dd„ dƒZ	Y nX W ddd„ Z
e
Zx®edƒD ]¢Zz‚yheddƒZx$edƒD ]Zeeeƒe d	d
 qÂW e	ddƒZe e¡ eed	d
 edkred7 ZP W n   edƒ Y nX W deed	d
 edkrFP X q¦W X dddgZeeeeƒƒZ ee ƒ dd„ ddddƒZG dd„ dƒZ	e	ddƒZeeƒ dS )c             C   s   | d |d  d S )Né   é   é   © )ÚxÚyr   r   ú-C:\Users\allen\Desktop\py\py\test_data\mix.pyÚ<lambda>   ó    r   r   é   c             C   s   dd„ t | ƒD ƒS )Nc             S   s   g | ]}|d  dkr|‘qS )r   é    r   )Ú.0Úir   r   r   ú
<listcomp>   s    z<lambda>.<locals>.<listcomp>)Úrange)r   r   r   r   r      r	   c                s   ‡ ‡fdd„t dƒD ƒS )Nc             3   s(   | ] }|d  dkrˆ ˆ | V V  qdS )r   é   Nr   )r   r   )r   r   r   r   ú	<genexpr>   s    z<lambda>.<locals>.<genexpr>é
   )r   )r   r   r   )r   r   r   r      r	   r   r   éd   ú )Úendr   c                s   ‡ ‡fdd„}|ƒ S )Nc              3   s$   xt dƒD ]} ˆ ˆ |  V  q
W d S )Nr   )r   )r   )r   r   r   r   Úp   s    zabc.<locals>.pr   )r   r   r   r   )r   r   r   Úabc   s    r   c               @   s>   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ Zdd„ ZdS )ÚYYYc             C   s   |||  S )Nr   )Úselfr   r   Úzr   r   r   r      r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )ÚqÚwÚer   r   r   r      r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r      r	   c             C   s   |   ||¡| _d S )N)ÚbÚvalue)r   r   r   r   r   r   Ú__init__   s    zYYY.__init__c             C   s
   t | jƒS )N)Ústrr   )r   r   r   r   Ú__str__   s    zYYY.__str__c             C   s
   |ƒ  d S )Nr   )r   Úfuncr   r   r   r#      s    zYYY.funcN)Ú__name__Ú
__module__Ú__qualname__Úar   r    r"   r#   r   r   r   r   r      s
   r   Nc           
      sº   G dd„ dƒ} | ƒ œ‰ d‰xˆdk r¢| ƒ 0 t dƒ ‡ ‡fdd„}|ƒ }t dt|ƒƒ W d Q R X ˆd	7 ‰ˆ jd
kr„t dˆ j› ƒ ntdk r”t dƒ t ˆ jtƒ qW t dƒ W d Q R X d S )Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )zthis_is_mix_try.<locals>.testc             S   s   t dƒ d S )Nr    )Úprint)r   r   r   r   r        s    z&this_is_mix_try.<locals>.test.__init__c             S   s   t dƒ tddƒS )NÚ	__enter__r   é   )r(   r   )r   r   r   r   r)   "   s    z'this_is_mix_try.<locals>.test.__enter__c             S   s   t dƒ d S )NÚ__exit__)r(   )r   Úexc_typeZexc_valZexc_tbr   r   r   r+   %   s    z&this_is_mix_try.<locals>.test.__exit__N)r$   r%   r&   r    r)   r+   r   r   r   r   Útest   s   r-   r   r   zinside testc              3   s&   x t dƒD ]} ˆd ˆ j V  q
W d S )Nr   r   )r   r   )r   )ÚTÚkr   r   Úlock,   s    zthis_is_mix_try.<locals>.lockzyield:r   r   zT is bigger:é   z
s is smallzthis is else leave)r(   Únextr   Ús)r-   r0   Zlor   )r.   r/   r   Úthis_is_mix_try   s     

r4   r*   é   za except occuré   r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   O   r	   r   c               @   s6   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ ZdS )r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   Q   r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )r   r   r   r   r   r   r   R   r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r   R   r	   c             C   s   |   ||¡d | j | _d S )Niè  )r   r'   r   )r   r   r   r   r   r   r    S   s    zYYY.__init__c             C   s
   t | jƒS )N)r!   r   )r   r   r   r   r"   V   s    zYYY.__str__N)r$   r%   r&   r'   r   r    r"   r   r   r   r   r   P   s   )r   r3   r(   ÚcÚdÚgr   r2   r   r   r4   Ússsr   r'   r   r#   ÚlistÚmapr!   r   r   r   r   Ú<module>   sJ   









554*14*m.pyfrom apython import Apython
p=Apython()
p.load('test.py')
#p.load('test_data/string.py')
#p.load('backup3/m.py')
#p.load('test_data/import.py')
#p.load('test_data/oper.py')
#p.load('test_data/function.py')
#p.load('test_data/loop.py')
#p.load('test_data/try.py')
#p.load('test_data/mix.py')
#p.load('test_data/del.py')
#p.load('test_data/keyword.py')
#p.load('C:\\Users\\allen\\Desktop\\pyå¤§ç¦®åŒ…\\æœŸæœ«\\æ°´.py')
#p.save('new.ec')
p.parse()
p.run(tf=1)
#p.load('new.ec')
#p.parse()
#p.run()
#ap=Apython()
#ap.run('test.py')496*17*main.pyfrom apython import Apython
from sys import argv
from os.path import isfile
apython=Apython()
cmd=argv
hint='''
+any python file to execute
-o filename    =>save as filename
'''
if len(argv)==1:
    print('This is Apython')
    print(hint)
    apython.REPL()
else:
    if isfile(argv[1]):
        apython.load(argv[1])
        if len(argv)>=4 and argv[2]=='-o':
            apython.save(argv[3])
        apython.run()
    else:
        print(f'"{argv[1]}" not exist')816726*15*mm.ecmov $importer [dict]
namespace &apython_1 "&apython_1" "Packager,Executer,Apython"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"] &apython_1
mov &tem_import_1 &apython_1
mov &apython_4 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &package_6 "&package_6" "listdir,getcwd,chdir,isdir,isfile,Code,parse_code,next_element,get_var,next_codeline,parse_codeline,parse_block,From_Import,Import,Read_ex_func,Importer,importer,Packager,Integer,Float,String,Byte,Var_name,Namespace,Variable,SubVariable,Slice,IndexVariable,List,Tuple,Dict,Set,is_number,Lambda,Def,FuncCall,Backtrack,Var_declare,Try_Except,With,Stop,Command,sub_if_else,If_else,While,sub_for_loop,For_loop,Mark,Pass,TFN,Class,two_object_write,Multiple_Mov,Oper,Tf,AndOr,Deny,Bool,Assert,STR,Info"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/package.py"] &package_6
mov &tem_import_4 &package_6
module &os_9 "os"
mov $importer["os"] &os_9
mov &tem_import_9 &os_9
push $importer["os"]
mov <&package_6+0> <esp+1>.listdir
mov <&package_6+1> <esp+1>.getcwd
mov <&package_6+2> <esp+1>.chdir
inc esp
mov &os_17 $importer["os"]
pass
module &path_19 "os.path"
mov $importer["os.path"] &path_19
mov &tem_import_17 &path_19
push $importer["os.path"]
mov <&package_6+3> <esp+1>.isdir
mov <&package_6+4> <esp+1>.isfile
inc esp
mov &apython_26 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &code_28 "&code_28" "Undefine,Code"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/code.py"] &code_28
mov &tem_import_26 &code_28
mov &apython_31 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &executer_33 "&executer_33" "Undefine,class_obj,Func,generator,fetch_error,atype,built_in_functions,Error_class,else_built_in,bifs,key,Executer,Ex_module,Namespace_stack,namespace_stack_var,bcolors,built_in_operator,time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"] &executer_33
mov &tem_import_31 &executer_33
mov &apython_36 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &built_in_38 "&built_in_38" "bcolors,built_in_operator,time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/built_in.py"] &built_in_38
mov &tem_import_36 &built_in_38
mov &apython_41 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &ex_func_43 "&ex_func_43" "time,math,os,sys"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/ex_func.py"] &ex_func_43
mov &tem_import_41 &ex_func_43
module &time_46 "time"
mov $importer["time"] &time_46
mov <&ex_func_43+0> &time_46  ;©w¸qtime
module &math_49 "math"
mov $importer["math"] &math_49
mov <&ex_func_43+1> &math_49  ;©w¸qmath
mov &os_52 $importer["os"]
mov <&ex_func_43+2> &os_52
mov &os_54 $importer["os"]
mov <&ex_func_43+2> &os_54
mov &path_56 $importer["os.path"]
mov &os_54.path &path_56
module &sys_58 "sys"
mov $importer["sys"] &sys_58
mov <&ex_func_43+3> &sys_58  ;©w¸qsys
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/ex_func.py"]
mov <&built_in_38+2> <esp+1>.time    ;import *
mov <&built_in_38+3> <esp+1>.math    ;import *
mov <&built_in_38+4> <esp+1>.os    ;import *
mov <&built_in_38+5> <esp+1>.sys    ;import *
inc esp
Function <&built_in_38+0> 69 None "bcolors^15" 1
name <&built_in_38+0> "<class '__main__.bcolors'>"
jmp 107
tf $Inheritance "equ" None
$jmp 74 "t"
mov <bcolors^15> $Inheritance
push 1
jmp 76
mov <bcolors^15> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <bcolors^15> <&built_in_38+0>
push "[92m"
mov <bcolors^15>.OK <esp+1>
inc esp
push "[93m"
mov <bcolors^15>.WARNING <esp+1>
inc esp
push "[91m"
mov <bcolors^15>.FAIL <esp+1>
inc esp
push "[0m"
mov <bcolors^15>.RESET <esp+1>
inc esp
mov AX <bcolors^15>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 105 "=="
tf AX "Ctn" "__init__"
$jmp 103 "t"
jmp 105
call AX.__init__
mov AX <bcolors^15>
end "Function" "bcolors^15"
pop ip
Function <&built_in_38+1> 109 None "built_in_operator_109" 6
jmp 2884           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 117 "!="
tf <esp+2> "in" "obj"
$jmp 119 "t"
mov <esp+2>["obj"] None
jmp 119
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 125 "!="
tf <esp+2> "in" "op"
$jmp 127 "t"
mov <esp+2>["op"] None
jmp 127
mov <esp+2>["op"] <esp+1>[1]
dec CX
mov <built_in_operator_109+1> <esp+2>["obj"]
mov <built_in_operator_109+2> <esp+2>["op"]


push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <built_in_operator_109+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <built_in_operator_109+3> <esp+1>
inc esp
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'str'>"
$jmp 153 "f"
mov AX True
jmp 154
mov AX False
cmp AX 1
$jmp 652 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 161 "f"
mov AX True
jmp 162
mov AX False
cmp AX 1
$jmp 167 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.join
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 172 "f"
mov AX True
jmp 173
mov AX False
cmp AX 1
$jmp 178 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 183 "f"
mov AX True
jmp 184
mov AX False
cmp AX 1
$jmp 189 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.split
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 194 "f"
mov AX True
jmp 195
mov AX False
cmp AX 1
$jmp 200 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "format"
$jmp 205 "f"
mov AX True
jmp 206
mov AX False
cmp AX 1
$jmp 211 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.format
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "encode"
$jmp 216 "f"
mov AX True
jmp 217
mov AX False
cmp AX 1
$jmp 222 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.encode
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "replace"
$jmp 227 "f"
mov AX True
jmp 228
mov AX False
cmp AX 1
$jmp 233 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.replace
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "capitalize"
$jmp 238 "f"
mov AX True
jmp 239
mov AX False
cmp AX 1
$jmp 244 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.capitalize
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "casefold"
$jmp 249 "f"
mov AX True
jmp 250
mov AX False
cmp AX 1
$jmp 255 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.casefold
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "center"
$jmp 260 "f"
mov AX True
jmp 261
mov AX False
cmp AX 1
$jmp 266 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.center
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "endswith"
$jmp 271 "f"
mov AX True
jmp 272
mov AX False
cmp AX 1
$jmp 277 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.endswith
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "expandtabs"
$jmp 282 "f"
mov AX True
jmp 283
mov AX False
cmp AX 1
$jmp 288 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.expandtabs
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "find"
$jmp 293 "f"
mov AX True
jmp 294
mov AX False
cmp AX 1
$jmp 299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.find
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "format_map"
$jmp 304 "f"
mov AX True
jmp 305
mov AX False
cmp AX 1
$jmp 310 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.format_map
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalnum"
$jmp 315 "f"
mov AX True
jmp 316
mov AX False
cmp AX 1
$jmp 321 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalnum
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalpha"
$jmp 326 "f"
mov AX True
jmp 327
mov AX False
cmp AX 1
$jmp 332 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalpha
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isascii"
$jmp 337 "f"
mov AX True
jmp 338
mov AX False
cmp AX 1
$jmp 343 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isascii
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdecimal"
$jmp 348 "f"
mov AX True
jmp 349
mov AX False
cmp AX 1
$jmp 354 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdecimal
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdigit"
$jmp 359 "f"
mov AX True
jmp 360
mov AX False
cmp AX 1
$jmp 365 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdigit
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isidentifier"
$jmp 370 "f"
mov AX True
jmp 371
mov AX False
cmp AX 1
$jmp 376 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isidentifier
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "islower"
$jmp 381 "f"
mov AX True
jmp 382
mov AX False
cmp AX 1
$jmp 387 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.islower
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isnumeric"
$jmp 392 "f"
mov AX True
jmp 393
mov AX False
cmp AX 1
$jmp 398 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isnumeric
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isprintable"
$jmp 403 "f"
mov AX True
jmp 404
mov AX False
cmp AX 1
$jmp 409 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isprintable
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isspace"
$jmp 414 "f"
mov AX True
jmp 415
mov AX False
cmp AX 1
$jmp 420 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isspace
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "istitle"
$jmp 425 "f"
mov AX True
jmp 426
mov AX False
cmp AX 1
$jmp 431 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.istitle
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isupper"
$jmp 436 "f"
mov AX True
jmp 437
mov AX False
cmp AX 1
$jmp 442 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isupper
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ljust"
$jmp 447 "f"
mov AX True
jmp 448
mov AX False
cmp AX 1
$jmp 453 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.ljust
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lower"
$jmp 458 "f"
mov AX True
jmp 459
mov AX False
cmp AX 1
$jmp 464 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lower
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lstrip"
$jmp 469 "f"
mov AX True
jmp 470
mov AX False
cmp AX 1
$jmp 475 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lstrip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "maketrans"
$jmp 480 "f"
mov AX True
jmp 481
mov AX False
cmp AX 1
$jmp 486 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.maketrans
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "partition"
$jmp 491 "f"
mov AX True
jmp 492
mov AX False
cmp AX 1
$jmp 497 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.partition
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rfind"
$jmp 502 "f"
mov AX True
jmp 503
mov AX False
cmp AX 1
$jmp 508 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rfind
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rindex"
$jmp 513 "f"
mov AX True
jmp 514
mov AX False
cmp AX 1
$jmp 519 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rindex
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rjust"
$jmp 524 "f"
mov AX True
jmp 525
mov AX False
cmp AX 1
$jmp 530 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rjust
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rpartition"
$jmp 535 "f"
mov AX True
jmp 536
mov AX False
cmp AX 1
$jmp 541 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rpartition
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rsplit"
$jmp 546 "f"
mov AX True
jmp 547
mov AX False
cmp AX 1
$jmp 552 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rsplit
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rstrip"
$jmp 557 "f"
mov AX True
jmp 558
mov AX False
cmp AX 1
$jmp 563 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rstrip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitlines"
$jmp 568 "f"
mov AX True
jmp 569
mov AX False
cmp AX 1
$jmp 574 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.splitlines
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "startswith"
$jmp 579 "f"
mov AX True
jmp 580
mov AX False
cmp AX 1
$jmp 585 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.startswith
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strip"
$jmp 590 "f"
mov AX True
jmp 591
mov AX False
cmp AX 1
$jmp 596 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.strip
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "swapcase"
$jmp 601 "f"
mov AX True
jmp 602
mov AX False
cmp AX 1
$jmp 607 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.swapcase
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "title"
$jmp 612 "f"
mov AX True
jmp 613
mov AX False
cmp AX 1
$jmp 618 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.title
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "translate"
$jmp 623 "f"
mov AX True
jmp 624
mov AX False
cmp AX 1
$jmp 629 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.translate
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "upper"
$jmp 634 "f"
mov AX True
jmp 635
mov AX False
cmp AX 1
$jmp 640 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.upper
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "zfill"
$jmp 645 "f"
mov AX True
jmp 646
mov AX False
cmp AX 1
$jmp 651 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.zfill
jmp 2881
jmp 651        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'list'>"
$jmp 657 "f"
mov AX True
jmp 658
mov AX False
cmp AX 1
$jmp 782 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "append"
$jmp 665 "f"
mov AX True
jmp 666
mov AX False
cmp AX 1
$jmp 671 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.append
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 676 "f"
mov AX True
jmp 677
mov AX False
cmp AX 1
$jmp 682 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 687 "f"
mov AX True
jmp 688
mov AX False
cmp AX 1
$jmp 693 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 698 "f"
mov AX True
jmp 699
mov AX False
cmp AX 1
$jmp 704 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.remove
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "insert"
$jmp 709 "f"
mov AX True
jmp 710
mov AX False
cmp AX 1
$jmp 715 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.insert
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 720 "f"
mov AX True
jmp 721
mov AX False
cmp AX 1
$jmp 726 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 731 "f"
mov AX True
jmp 732
mov AX False
cmp AX 1
$jmp 737 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 742 "f"
mov AX True
jmp 743
mov AX False
cmp AX 1
$jmp 748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "extend"
$jmp 753 "f"
mov AX True
jmp 754
mov AX False
cmp AX 1
$jmp 759 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.extend
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "reverse"
$jmp 764 "f"
mov AX True
jmp 765
mov AX False
cmp AX 1
$jmp 770 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.reverse
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sort"
$jmp 775 "f"
mov AX True
jmp 776
mov AX False
cmp AX 1
$jmp 781 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.sort
jmp 2881
jmp 781        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'tuple'>"
$jmp 787 "f"
mov AX True
jmp 788
mov AX False
cmp AX 1
$jmp 813 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 795 "f"
mov AX True
jmp 796
mov AX False
cmp AX 1
$jmp 801 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 812        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 806 "f"
mov AX True
jmp 807
mov AX False
cmp AX 1
$jmp 812 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 812        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'dict'>"
$jmp 818 "f"
mov AX True
jmp 819
mov AX False
cmp AX 1
$jmp 943 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 826 "f"
mov AX True
jmp 827
mov AX False
cmp AX 1
$jmp 832 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "get"
$jmp 837 "f"
mov AX True
jmp 838
mov AX False
cmp AX 1
$jmp 843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.get
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 848 "f"
mov AX True
jmp 849
mov AX False
cmp AX 1
$jmp 854 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 859 "f"
mov AX True
jmp 860
mov AX False
cmp AX 1
$jmp 865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "update"
$jmp 870 "f"
mov AX True
jmp 871
mov AX False
cmp AX 1
$jmp 876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.update
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "keys"
$jmp 881 "f"
mov AX True
jmp 882
mov AX False
cmp AX 1
$jmp 887 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.keys
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fromkeys"
$jmp 892 "f"
mov AX True
jmp 893
mov AX False
cmp AX 1
$jmp 898 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.fromkeys
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "items"
$jmp 903 "f"
mov AX True
jmp 904
mov AX False
cmp AX 1
$jmp 909 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.items
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "popitem"
$jmp 914 "f"
mov AX True
jmp 915
mov AX False
cmp AX 1
$jmp 920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.popitem
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setdefault"
$jmp 925 "f"
mov AX True
jmp 926
mov AX False
cmp AX 1
$jmp 931 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.setdefault
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "values"
$jmp 936 "f"
mov AX True
jmp 937
mov AX False
cmp AX 1
$jmp 942 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.values
jmp 2881
jmp 942        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'bytes'>"
$jmp 948 "f"
mov AX True
jmp 949
mov AX False
cmp AX 1
$jmp 1370 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 956 "f"
mov AX True
jmp 957
mov AX False
cmp AX 1
$jmp 962 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.join
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "count"
$jmp 967 "f"
mov AX True
jmp 968
mov AX False
cmp AX 1
$jmp 973 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.count
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 978 "f"
mov AX True
jmp 979
mov AX False
cmp AX 1
$jmp 984 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.split
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "index"
$jmp 989 "f"
mov AX True
jmp 990
mov AX False
cmp AX 1
$jmp 995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.index
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "decode"
$jmp 1000 "f"
mov AX True
jmp 1001
mov AX False
cmp AX 1
$jmp 1006 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.decode
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "replace"
$jmp 1011 "f"
mov AX True
jmp 1012
mov AX False
cmp AX 1
$jmp 1017 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.replace
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "capitalize"
$jmp 1022 "f"
mov AX True
jmp 1023
mov AX False
cmp AX 1
$jmp 1028 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.capitalize
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "center"
$jmp 1033 "f"
mov AX True
jmp 1034
mov AX False
cmp AX 1
$jmp 1039 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.center
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "endswith"
$jmp 1044 "f"
mov AX True
jmp 1045
mov AX False
cmp AX 1
$jmp 1050 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.endswith
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "expandtabs"
$jmp 1055 "f"
mov AX True
jmp 1056
mov AX False
cmp AX 1
$jmp 1061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.expandtabs
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "find"
$jmp 1066 "f"
mov AX True
jmp 1067
mov AX False
cmp AX 1
$jmp 1072 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.find
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalnum"
$jmp 1077 "f"
mov AX True
jmp 1078
mov AX False
cmp AX 1
$jmp 1083 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalnum
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isalpha"
$jmp 1088 "f"
mov AX True
jmp 1089
mov AX False
cmp AX 1
$jmp 1094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isalpha
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isascii"
$jmp 1099 "f"
mov AX True
jmp 1100
mov AX False
cmp AX 1
$jmp 1105 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isascii
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdigit"
$jmp 1110 "f"
mov AX True
jmp 1111
mov AX False
cmp AX 1
$jmp 1116 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdigit
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "islower"
$jmp 1121 "f"
mov AX True
jmp 1122
mov AX False
cmp AX 1
$jmp 1127 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.islower
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isspace"
$jmp 1132 "f"
mov AX True
jmp 1133
mov AX False
cmp AX 1
$jmp 1138 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isspace
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "istitle"
$jmp 1143 "f"
mov AX True
jmp 1144
mov AX False
cmp AX 1
$jmp 1149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.istitle
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isupper"
$jmp 1154 "f"
mov AX True
jmp 1155
mov AX False
cmp AX 1
$jmp 1160 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isupper
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ljust"
$jmp 1165 "f"
mov AX True
jmp 1166
mov AX False
cmp AX 1
$jmp 1171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.ljust
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lower"
$jmp 1176 "f"
mov AX True
jmp 1177
mov AX False
cmp AX 1
$jmp 1182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lower
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "lstrip"
$jmp 1187 "f"
mov AX True
jmp 1188
mov AX False
cmp AX 1
$jmp 1193 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.lstrip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "maketrans"
$jmp 1198 "f"
mov AX True
jmp 1199
mov AX False
cmp AX 1
$jmp 1204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.maketrans
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "partition"
$jmp 1209 "f"
mov AX True
jmp 1210
mov AX False
cmp AX 1
$jmp 1215 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.partition
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rfind"
$jmp 1220 "f"
mov AX True
jmp 1221
mov AX False
cmp AX 1
$jmp 1226 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rfind
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rindex"
$jmp 1231 "f"
mov AX True
jmp 1232
mov AX False
cmp AX 1
$jmp 1237 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rindex
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rjust"
$jmp 1242 "f"
mov AX True
jmp 1243
mov AX False
cmp AX 1
$jmp 1248 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rjust
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rpartition"
$jmp 1253 "f"
mov AX True
jmp 1254
mov AX False
cmp AX 1
$jmp 1259 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rpartition
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rsplit"
$jmp 1264 "f"
mov AX True
jmp 1265
mov AX False
cmp AX 1
$jmp 1270 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rsplit
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rstrip"
$jmp 1275 "f"
mov AX True
jmp 1276
mov AX False
cmp AX 1
$jmp 1281 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.rstrip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitlines"
$jmp 1286 "f"
mov AX True
jmp 1287
mov AX False
cmp AX 1
$jmp 1292 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.splitlines
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "startswith"
$jmp 1297 "f"
mov AX True
jmp 1298
mov AX False
cmp AX 1
$jmp 1303 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.startswith
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strip"
$jmp 1308 "f"
mov AX True
jmp 1309
mov AX False
cmp AX 1
$jmp 1314 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.strip
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "swapcase"
$jmp 1319 "f"
mov AX True
jmp 1320
mov AX False
cmp AX 1
$jmp 1325 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.swapcase
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "title"
$jmp 1330 "f"
mov AX True
jmp 1331
mov AX False
cmp AX 1
$jmp 1336 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.title
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "translate"
$jmp 1341 "f"
mov AX True
jmp 1342
mov AX False
cmp AX 1
$jmp 1347 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.translate
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "upper"
$jmp 1352 "f"
mov AX True
jmp 1353
mov AX False
cmp AX 1
$jmp 1358 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.upper
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "zfill"
$jmp 1363 "f"
mov AX True
jmp 1364
mov AX False
cmp AX 1
$jmp 1369 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.zfill
jmp 2881
jmp 1369        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class 'set'>"
$jmp 1375 "f"
mov AX True
jmp 1376
mov AX False
cmp AX 1
$jmp 1566 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pop"
$jmp 1383 "f"
mov AX True
jmp 1384
mov AX False
cmp AX 1
$jmp 1389 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.pop
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "add"
$jmp 1394 "f"
mov AX True
jmp 1395
mov AX False
cmp AX 1
$jmp 1400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.add
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 1405 "f"
mov AX True
jmp 1406
mov AX False
cmp AX 1
$jmp 1411 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.remove
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copy"
$jmp 1416 "f"
mov AX True
jmp 1417
mov AX False
cmp AX 1
$jmp 1422 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.copy
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "clear"
$jmp 1427 "f"
mov AX True
jmp 1428
mov AX False
cmp AX 1
$jmp 1433 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.clear
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "update"
$jmp 1438 "f"
mov AX True
jmp 1439
mov AX False
cmp AX 1
$jmp 1444 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "difference"
$jmp 1449 "f"
mov AX True
jmp 1450
mov AX False
cmp AX 1
$jmp 1455 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.difference
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "difference_update"
$jmp 1460 "f"
mov AX True
jmp 1461
mov AX False
cmp AX 1
$jmp 1466 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.difference_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "discard"
$jmp 1471 "f"
mov AX True
jmp 1472
mov AX False
cmp AX 1
$jmp 1477 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.discard
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "intersection"
$jmp 1482 "f"
mov AX True
jmp 1483
mov AX False
cmp AX 1
$jmp 1488 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.intersection
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "intersection_update"
$jmp 1493 "f"
mov AX True
jmp 1494
mov AX False
cmp AX 1
$jmp 1499 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.intersection_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isdisjoint"
$jmp 1504 "f"
mov AX True
jmp 1505
mov AX False
cmp AX 1
$jmp 1510 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isdisjoint
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "issubset"
$jmp 1515 "f"
mov AX True
jmp 1516
mov AX False
cmp AX 1
$jmp 1521 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.issubset
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "issuperset"
$jmp 1526 "f"
mov AX True
jmp 1527
mov AX False
cmp AX 1
$jmp 1532 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.issuperset
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "symmetric_difference"
$jmp 1537 "f"
mov AX True
jmp 1538
mov AX False
cmp AX 1
$jmp 1543 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.symmetric_difference
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "symmetric_difference_update"
$jmp 1548 "f"
mov AX True
jmp 1549
mov AX False
cmp AX 1
$jmp 1554 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.symmetric_difference_update
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "union"
$jmp 1559 "f"
mov AX True
jmp 1560
mov AX False
cmp AX 1
$jmp 1565 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.union
jmp 2881
jmp 1565        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+3>
tf DX "equ" "<class '_io.TextIOWrapper'>"
$jmp 1571 "f"
mov AX True
jmp 1572
mov AX False
cmp AX 1
$jmp 1762 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "write"
$jmp 1579 "f"
mov AX True
jmp 1580
mov AX False
cmp AX 1
$jmp 1585 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.write
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tell"
$jmp 1590 "f"
mov AX True
jmp 1591
mov AX False
cmp AX 1
$jmp 1596 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tell
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "read"
$jmp 1601 "f"
mov AX True
jmp 1602
mov AX False
cmp AX 1
$jmp 1607 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.read
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "close"
$jmp 1612 "f"
mov AX True
jmp 1613
mov AX False
cmp AX 1
$jmp 1618 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.close
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "seek"
$jmp 1623 "f"
mov AX True
jmp 1624
mov AX False
cmp AX 1
$jmp 1629 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.seek
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fileno"
$jmp 1634 "f"
mov AX True
jmp 1635
mov AX False
cmp AX 1
$jmp 1640 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.fileno
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "flush"
$jmp 1645 "f"
mov AX True
jmp 1646
mov AX False
cmp AX 1
$jmp 1651 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.flush
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isatty"
$jmp 1656 "f"
mov AX True
jmp 1657
mov AX False
cmp AX 1
$jmp 1662 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.isatty
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readable"
$jmp 1667 "f"
mov AX True
jmp 1668
mov AX False
cmp AX 1
$jmp 1673 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readline"
$jmp 1678 "f"
mov AX True
jmp 1679
mov AX False
cmp AX 1
$jmp 1684 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readline
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "readlines"
$jmp 1689 "f"
mov AX True
jmp 1690
mov AX False
cmp AX 1
$jmp 1695 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.readlines
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "seekable"
$jmp 1700 "f"
mov AX True
jmp 1701
mov AX False
cmp AX 1
$jmp 1706 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.seekable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "truncate"
$jmp 1711 "f"
mov AX True
jmp 1712
mov AX False
cmp AX 1
$jmp 1717 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.truncate
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "writable"
$jmp 1722 "f"
mov AX True
jmp 1723
mov AX False
cmp AX 1
$jmp 1728 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.writable
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "writelines"
$jmp 1733 "f"
mov AX True
jmp 1734
mov AX False
cmp AX 1
$jmp 1739 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.writelines
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "__enter__"
$jmp 1744 "f"
mov AX True
jmp 1745
mov AX False
cmp AX 1
$jmp 1750 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.__enter__
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "__exit__"
$jmp 1755 "f"
mov AX True
jmp 1756
mov AX False
cmp AX 1
$jmp 1761 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.__exit__
jmp 2881
jmp 1761        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
tf <built_in_operator_109+3> "in" "Ex_module"
mov AX TF
cmp AX 1
$jmp 2758 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <built_in_operator_109+1>.module_name
mov <built_in_operator_109+4> <esp+1>
inc esp
mov DX <built_in_operator_109+4>
tf DX "equ" "time"
$jmp 1774 "f"
mov AX True
jmp 1775
mov AX False
cmp AX 1
$jmp 1877 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "time"
$jmp 1782 "f"
mov AX True
jmp 1783
mov AX False
cmp AX 1
$jmp 1788 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.time
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sleep"
$jmp 1793 "f"
mov AX True
jmp 1794
mov AX False
cmp AX 1
$jmp 1799 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.sleep
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ctime"
$jmp 1804 "f"
mov AX True
jmp 1805
mov AX False
cmp AX 1
$jmp 1810 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.ctime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "localtime"
$jmp 1815 "f"
mov AX True
jmp 1816
mov AX False
cmp AX 1
$jmp 1821 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.localtime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "gmtime"
$jmp 1826 "f"
mov AX True
jmp 1827
mov AX False
cmp AX 1
$jmp 1832 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.gmtime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "mktime"
$jmp 1837 "f"
mov AX True
jmp 1838
mov AX False
cmp AX 1
$jmp 1843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.mktime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "asctime"
$jmp 1848 "f"
mov AX True
jmp 1849
mov AX False
cmp AX 1
$jmp 1854 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.asctime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strftime"
$jmp 1859 "f"
mov AX True
jmp 1860
mov AX False
cmp AX 1
$jmp 1865 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.strftime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "strptime"
$jmp 1870 "f"
mov AX True
jmp 1871
mov AX False
cmp AX 1
$jmp 1876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+2>.strptime
jmp 2881
jmp 1876        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "math"
$jmp 1882 "f"
mov AX True
jmp 1883
mov AX False
cmp AX 1
$jmp 2205 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "pi"
$jmp 1890 "f"
mov AX True
jmp 1891
mov AX False
cmp AX 1
$jmp 1896 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.pi
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "e"
$jmp 1901 "f"
mov AX True
jmp 1902
mov AX False
cmp AX 1
$jmp 1907 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.e
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "ceil"
$jmp 1912 "f"
mov AX True
jmp 1913
mov AX False
cmp AX 1
$jmp 1918 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.ceil
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "floor"
$jmp 1923 "f"
mov AX True
jmp 1924
mov AX False
cmp AX 1
$jmp 1929 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.floor
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "copysign"
$jmp 1934 "f"
mov AX True
jmp 1935
mov AX False
cmp AX 1
$jmp 1940 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.copysign
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fabs"
$jmp 1945 "f"
mov AX True
jmp 1946
mov AX False
cmp AX 1
$jmp 1951 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fabs
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fmod"
$jmp 1956 "f"
mov AX True
jmp 1957
mov AX False
cmp AX 1
$jmp 1962 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fmod
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "fsum"
$jmp 1967 "f"
mov AX True
jmp 1968
mov AX False
cmp AX 1
$jmp 1973 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.fsum
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "gcd"
$jmp 1978 "f"
mov AX True
jmp 1979
mov AX False
cmp AX 1
$jmp 1984 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.gcd
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "pow"
$jmp 1989 "f"
mov AX True
jmp 1990
mov AX False
cmp AX 1
$jmp 1995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.pow
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sqrt"
$jmp 2000 "f"
mov AX True
jmp 2001
mov AX False
cmp AX 1
$jmp 2006 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.sqrt
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "factorial"
$jmp 2011 "f"
mov AX True
jmp 2012
mov AX False
cmp AX 1
$jmp 2017 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.factorial
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "degrees"
$jmp 2022 "f"
mov AX True
jmp 2023
mov AX False
cmp AX 1
$jmp 2028 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.degrees
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "radians"
$jmp 2033 "f"
mov AX True
jmp 2034
mov AX False
cmp AX 1
$jmp 2039 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.radians
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sin"
$jmp 2044 "f"
mov AX True
jmp 2045
mov AX False
cmp AX 1
$jmp 2050 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.sin
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "cos"
$jmp 2055 "f"
mov AX True
jmp 2056
mov AX False
cmp AX 1
$jmp 2061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.cos
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tan"
$jmp 2066 "f"
mov AX True
jmp 2067
mov AX False
cmp AX 1
$jmp 2072 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.tan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "asin"
$jmp 2077 "f"
mov AX True
jmp 2078
mov AX False
cmp AX 1
$jmp 2083 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.asin
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "acos"
$jmp 2088 "f"
mov AX True
jmp 2089
mov AX False
cmp AX 1
$jmp 2094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.acos
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "atan"
$jmp 2099 "f"
mov AX True
jmp 2100
mov AX False
cmp AX 1
$jmp 2105 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.atan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exp"
$jmp 2110 "f"
mov AX True
jmp 2111
mov AX False
cmp AX 1
$jmp 2116 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.exp
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log"
$jmp 2121 "f"
mov AX True
jmp 2122
mov AX False
cmp AX 1
$jmp 2127 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log1p"
$jmp 2132 "f"
mov AX True
jmp 2133
mov AX False
cmp AX 1
$jmp 2138 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log1p
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log2"
$jmp 2143 "f"
mov AX True
jmp 2144
mov AX False
cmp AX 1
$jmp 2149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log2
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "log10"
$jmp 2154 "f"
mov AX True
jmp 2155
mov AX False
cmp AX 1
$jmp 2160 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.log10
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isclose"
$jmp 2165 "f"
mov AX True
jmp 2166
mov AX False
cmp AX 1
$jmp 2171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isclose
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isfinite"
$jmp 2176 "f"
mov AX True
jmp 2177
mov AX False
cmp AX 1
$jmp 2182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isfinite
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isinf"
$jmp 2187 "f"
mov AX True
jmp 2188
mov AX False
cmp AX 1
$jmp 2193 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isinf
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isnan"
$jmp 2198 "f"
mov AX True
jmp 2199
mov AX False
cmp AX 1
$jmp 2204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+3>.isnan
jmp 2881
jmp 2204        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "os"
$jmp 2210 "f"
mov AX True
jmp 2211
mov AX False
cmp AX 1
$jmp 2368 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "getcwd"
$jmp 2218 "f"
mov AX True
jmp 2219
mov AX False
cmp AX 1
$jmp 2224 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.getcwd
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "listdir"
$jmp 2229 "f"
mov AX True
jmp 2230
mov AX False
cmp AX 1
$jmp 2235 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.listdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "mkdir"
$jmp 2240 "f"
mov AX True
jmp 2241
mov AX False
cmp AX 1
$jmp 2246 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.mkdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "chdir"
$jmp 2251 "f"
mov AX True
jmp 2252
mov AX False
cmp AX 1
$jmp 2257 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.chdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rmdir"
$jmp 2262 "f"
mov AX True
jmp 2263
mov AX False
cmp AX 1
$jmp 2268 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.rmdir
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "open"
$jmp 2273 "f"
mov AX True
jmp 2274
mov AX False
cmp AX 1
$jmp 2279 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.open
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "write"
$jmp 2284 "f"
mov AX True
jmp 2285
mov AX False
cmp AX 1
$jmp 2290 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.write
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "rename"
$jmp 2295 "f"
mov AX True
jmp 2296
mov AX False
cmp AX 1
$jmp 2301 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.rename
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "remove"
$jmp 2306 "f"
mov AX True
jmp 2307
mov AX False
cmp AX 1
$jmp 2312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.remove
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stat"
$jmp 2317 "f"
mov AX True
jmp 2318
mov AX False
cmp AX 1
$jmp 2323 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.stat
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "close"
$jmp 2328 "f"
mov AX True
jmp 2329
mov AX False
cmp AX 1
$jmp 2334 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.close
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "path"
$jmp 2339 "f"
mov AX True
jmp 2340
mov AX False
cmp AX 1
$jmp 2345 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "system"
$jmp 2350 "f"
mov AX True
jmp 2351
mov AX False
cmp AX 1
$jmp 2356 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.system
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "walk"
$jmp 2361 "f"
mov AX True
jmp 2362
mov AX False
cmp AX 1
$jmp 2367 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.walk
jmp 2881
jmp 2367        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "os.path"
$jmp 2373 "f"
mov AX True
jmp 2374
mov AX False
cmp AX 1
$jmp 2605 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "isdir"
$jmp 2381 "f"
mov AX True
jmp 2382
mov AX False
cmp AX 1
$jmp 2388 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isdir
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isfile"
$jmp 2393 "f"
mov AX True
jmp 2394
mov AX False
cmp AX 1
$jmp 2400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isfile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "abspath"
$jmp 2405 "f"
mov AX True
jmp 2406
mov AX False
cmp AX 1
$jmp 2412 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.abspath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "basename"
$jmp 2417 "f"
mov AX True
jmp 2418
mov AX False
cmp AX 1
$jmp 2424 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.basename
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "dirname"
$jmp 2429 "f"
mov AX True
jmp 2430
mov AX False
cmp AX 1
$jmp 2436 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.dirname
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exists"
$jmp 2441 "f"
mov AX True
jmp 2442
mov AX False
cmp AX 1
$jmp 2448 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.exists
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getatime"
$jmp 2453 "f"
mov AX True
jmp 2454
mov AX False
cmp AX 1
$jmp 2460 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getatime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getmtime"
$jmp 2465 "f"
mov AX True
jmp 2466
mov AX False
cmp AX 1
$jmp 2472 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getmtime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getctime"
$jmp 2477 "f"
mov AX True
jmp 2478
mov AX False
cmp AX 1
$jmp 2484 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getctime
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "getsize"
$jmp 2489 "f"
mov AX True
jmp 2490
mov AX False
cmp AX 1
$jmp 2496 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.getsize
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "isabs"
$jmp 2501 "f"
mov AX True
jmp 2502
mov AX False
cmp AX 1
$jmp 2508 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.isabs
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "join"
$jmp 2513 "f"
mov AX True
jmp 2514
mov AX False
cmp AX 1
$jmp 2520 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.join
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "realpath"
$jmp 2525 "f"
mov AX True
jmp 2526
mov AX False
cmp AX 1
$jmp 2532 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.realpath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "relpath"
$jmp 2537 "f"
mov AX True
jmp 2538
mov AX False
cmp AX 1
$jmp 2544 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.relpath
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "samefile"
$jmp 2549 "f"
mov AX True
jmp 2550
mov AX False
cmp AX 1
$jmp 2556 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.samefile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "sameopenfile"
$jmp 2561 "f"
mov AX True
jmp 2562
mov AX False
cmp AX 1
$jmp 2568 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.sameopenfile
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "samestat"
$jmp 2573 "f"
mov AX True
jmp 2574
mov AX False
cmp AX 1
$jmp 2580 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.samestat
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "split"
$jmp 2585 "f"
mov AX True
jmp 2586
mov AX False
cmp AX 1
$jmp 2592 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.split
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "splitext"
$jmp 2597 "f"
mov AX True
jmp 2598
mov AX False
cmp AX 1
$jmp 2604 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+4>.path      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.splitext
jmp 2881
jmp 2604        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+4>
tf DX "equ" "sys"
$jmp 2610 "f"
mov AX True
jmp 2611
mov AX False
cmp AX 1
$jmp 2757 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "argv"
$jmp 2618 "f"
mov AX True
jmp 2619
mov AX False
cmp AX 1
$jmp 2624 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.argv
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "platform"
$jmp 2629 "f"
mov AX True
jmp 2630
mov AX False
cmp AX 1
$jmp 2635 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.platform
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "version_info"
$jmp 2640 "f"
mov AX True
jmp 2641
mov AX False
cmp AX 1
$jmp 2646 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.version_info
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "path"
$jmp 2651 "f"
mov AX True
jmp 2652
mov AX False
cmp AX 1
$jmp 2657 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.path
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stdin"
$jmp 2662 "f"
mov AX True
jmp 2663
mov AX False
cmp AX 1
$jmp 2668 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stdin
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stdout"
$jmp 2673 "f"
mov AX True
jmp 2674
mov AX False
cmp AX 1
$jmp 2679 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stdout
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "stderr"
$jmp 2684 "f"
mov AX True
jmp 2685
mov AX False
cmp AX 1
$jmp 2690 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.stderr
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "displayhook"
$jmp 2695 "f"
mov AX True
jmp 2696
mov AX False
cmp AX 1
$jmp 2701 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.displayhook
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "exceptionhook"
$jmp 2706 "f"
mov AX True
jmp 2707
mov AX False
cmp AX 1
$jmp 2712 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.exceptionhook
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setrecursionlimit"
$jmp 2717 "f"
mov AX True
jmp 2718
mov AX False
cmp AX 1
$jmp 2723 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setrecursionlimit
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setswitchinterval"
$jmp 2728 "f"
mov AX True
jmp 2729
mov AX False
cmp AX 1
$jmp 2734 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setswitchinterval
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "settrace"
$jmp 2739 "f"
mov AX True
jmp 2740
mov AX False
cmp AX 1
$jmp 2745 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.settrace
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "setprofile"
$jmp 2750 "f"
mov AX True
jmp 2751
mov AX False
cmp AX 1
$jmp 2756 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&built_in_38+5>.setprofile
jmp 2881
jmp 2756        ;¸õ¦Ü©³³¡
jmp 2757        ;¸õ¦Ü©³³¡
jmp 2758        ;¸õ¦Ü©³³¡
push <built_in_operator_109+1>.__name__
mov <built_in_operator_109+5> <esp+1>
inc esp
mov DX <built_in_operator_109+2>
tf DX "equ" "__name__"
$jmp 2766 "f"
mov AX True
jmp 2767
mov AX False
cmp AX 1
$jmp 2772 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+5>
jmp 2881
jmp 2772        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+5>
tf DX "equ" "localtime"
$jmp 2777 "f"
mov AX True
jmp 2778
mov AX False
cmp AX 1
$jmp 2858 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_year"
$jmp 2785 "f"
mov AX True
jmp 2786
mov AX False
cmp AX 1
$jmp 2791 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_year
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_mon"
$jmp 2796 "f"
mov AX True
jmp 2797
mov AX False
cmp AX 1
$jmp 2802 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_mon
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_mday"
$jmp 2807 "f"
mov AX True
jmp 2808
mov AX False
cmp AX 1
$jmp 2813 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_mday
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_hour"
$jmp 2818 "f"
mov AX True
jmp 2819
mov AX False
cmp AX 1
$jmp 2824 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_hour
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_min"
$jmp 2829 "f"
mov AX True
jmp 2830
mov AX False
cmp AX 1
$jmp 2835 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_min
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_sec"
$jmp 2840 "f"
mov AX True
jmp 2841
mov AX False
cmp AX 1
$jmp 2846 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_sec
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
mov DX <built_in_operator_109+2>
tf DX "equ" "tm_wday"
$jmp 2851 "f"
mov AX True
jmp 2852
mov AX False
cmp AX 1
$jmp 2857 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <built_in_operator_109+1>.tm_wday
jmp 2881
jmp 2857        ;¸õ¦Ü©³³¡
jmp 2858        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <&built_in_38+0>.FAIL
oper <esp+1> "+" AX
oper <esp+1> "+" "apython built_in error:\n    "
ex_func AX "str" <built_in_operator_109+1>
oper <esp+1> "+" AX
oper <esp+1> "+" " has no attribute "
ex_func AX "str" <built_in_operator_109+2>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <&built_in_38+0>.RESET
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX Exception
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "built_in_operator_109" "0,1,2,3,4,5"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/built_in.py"]
mov <&executer_33+15> <esp+1>.bcolors    ;import *
mov <&executer_33+16> <esp+1>.built_in_operator    ;import *
mov <&executer_33+17> <esp+1>.time    ;import *
mov <&executer_33+18> <esp+1>.math    ;import *
mov <&executer_33+19> <esp+1>.os    ;import *
mov <&executer_33+20> <esp+1>.sys    ;import *
inc esp
Function <&executer_33+0> 2895 None "Undefine^7" 1
name <&executer_33+0> "<class '__main__.Undefine'>"
jmp 2957
tf $Inheritance "equ" None
$jmp 2900 "t"
mov <Undefine^7> $Inheritance
push 1
jmp 2902
mov <Undefine^7> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Undefine^7> <&executer_33+0>
Function BX 2910 <Undefine^7> "__init___2910" 2
mov <Undefine^7>.__init__ BX
jmp 2924           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "[91m"
mov <__init___2910+0>.Fail <esp+1>
inc esp
push "[0m"
mov <__init___2910+0>.RESET <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___2910" "0,1"
pop ip
Function BX 2927 <Undefine^7> "__str___2927" 2
mov <Undefine^7>.__str__ BX
jmp 2943           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___2927+0>.Fail
oper <esp+1> "+" AX
oper <esp+1> "+" "<undefined>"
ex_func AX "str" <__str___2927+0>.RESET
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 2940         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___2927" "0,1"
pop ip
mov AX <Undefine^7>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 2955 "=="
tf AX "Ctn" "__init__"
$jmp 2953 "t"
jmp 2955
call AX.__init__
mov AX <Undefine^7>
end "Function" "Undefine^7"
pop ip
Function <&executer_33+1> 2960 None "class_obj^8" 1
name <&executer_33+1> "<class '__main__.class_obj'>"
jmp 3702
tf $Inheritance "equ" None
$jmp 2965 "t"
mov <class_obj^8> $Inheritance
push 1
jmp 2967
mov <class_obj^8> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <class_obj^8> <&executer_33+1>
Function BX 2975 <class_obj^8> "__init___2975" 3
mov <class_obj^8>.__init__ BX
jmp 3004           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 2983 "!="
tf <esp+2> "in" "ram"
$jmp 2985 "t"
mov <esp+2>["ram"] None
jmp 2985
mov <esp+2>["ram"] <esp+1>[0]
dec CX
mov <__init___2975+2> <esp+2>["ram"]


push <__init___2975+2>
mov <__init___2975+0>.ram <esp+1>
inc esp
push None
mov <__init___2975+0>.atype <esp+1>
inc esp
push [dict]
mov <__init___2975+0>.vars <esp+1>
inc esp
push 0
mov <__init___2975+0>.print_lock <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___2975" "0,1,2"
pop ip
Function BX 3007 <class_obj^8> "__str___3007" 2
mov <class_obj^8>.__str__ BX
jmp 3047           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__str___3007+0>.print_lock
tf DX "equ" 0
$jmp 3016 "f"
mov AX True
jmp 3017
mov AX False
cmp AX 1
$jmp 3025 "!="
tf <__str___3007+0>.vars "in" "__str__"
mov AX TF
cmp AX 1
$jmp 3025 "!="
mov AX 1
jmp 3026
mov AX 0
cmp AX 1
$jmp 3042 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__str___3007+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__str___3007+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__str__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3044         ;returnÂI
jmp 3042        ;¸õ¦Ü©³³¡
mov AX "<class_obj>"
jmp 3044         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___3007" "0,1"
pop ip
Function BX 3050 <class_obj^8> "__add___3050" 3
mov <class_obj^8>.__add__ BX
jmp 3100           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3058 "!="
tf <esp+2> "in" "other"
$jmp 3060 "t"
mov <esp+2>["other"] None
jmp 3060
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__add___3050+2> <esp+2>["other"]


mov DX <__add___3050+0>.print_lock
tf DX "equ" 0
$jmp 3068 "f"
mov AX True
jmp 3069
mov AX False
cmp AX 1
$jmp 3077 "!="
tf <__add___3050+0>.vars "in" "__add__"
mov AX TF
cmp AX 1
$jmp 3077 "!="
mov AX 1
jmp 3078
mov AX 0
cmp AX 1
$jmp 3096 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__add___3050+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__add___3050+0>
push [1]
mov <esp+1>[0] <__add___3050+2>
pop <esp+1>[1]
mov <esp+1>[2] "__add__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3097
jmp 3096        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__add___3050" "0,1,2"
pop ip
Function BX 3103 <class_obj^8> "__sub___3103" 3
mov <class_obj^8>.__sub__ BX
jmp 3153           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3111 "!="
tf <esp+2> "in" "other"
$jmp 3113 "t"
mov <esp+2>["other"] None
jmp 3113
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__sub___3103+2> <esp+2>["other"]


mov DX <__sub___3103+0>.print_lock
tf DX "equ" 0
$jmp 3121 "f"
mov AX True
jmp 3122
mov AX False
cmp AX 1
$jmp 3130 "!="
tf <__sub___3103+0>.vars "in" "__sub__"
mov AX TF
cmp AX 1
$jmp 3130 "!="
mov AX 1
jmp 3131
mov AX 0
cmp AX 1
$jmp 3149 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__sub___3103+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__sub___3103+0>
push [1]
mov <esp+1>[0] <__sub___3103+2>
pop <esp+1>[1]
mov <esp+1>[2] "__sub__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3150
jmp 3149        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__sub___3103" "0,1,2"
pop ip
Function BX 3156 <class_obj^8> "__len___3156" 2
mov <class_obj^8>.__len__ BX
jmp 3195           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__len___3156+0>.print_lock
tf DX "equ" 0
$jmp 3165 "f"
mov AX True
jmp 3166
mov AX False
cmp AX 1
$jmp 3174 "!="
tf <__len___3156+0>.vars "in" "__len__"
mov AX TF
cmp AX 1
$jmp 3174 "!="
mov AX 1
jmp 3175
mov AX 0
cmp AX 1
$jmp 3191 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__len___3156+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__len___3156+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__len__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3192
jmp 3191        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___3156" "0,1"
pop ip
Function BX 3198 <class_obj^8> "__setitem___3198" 4
mov <class_obj^8>.__setitem__ BX
jmp 3258           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3206 "!="
tf <esp+2> "in" "key"
$jmp 3208 "t"
mov <esp+2>["key"] None
jmp 3208
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3214 "!="
tf <esp+2> "in" "value"
$jmp 3216 "t"
mov <esp+2>["value"] None
jmp 3216
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___3198+2> <esp+2>["key"]
mov <__setitem___3198+3> <esp+2>["value"]


mov DX <__setitem___3198+0>.print_lock
tf DX "equ" 0
$jmp 3225 "f"
mov AX True
jmp 3226
mov AX False
cmp AX 1
$jmp 3234 "!="
tf <__setitem___3198+0>.vars "in" "__setitem__"
mov AX TF
cmp AX 1
$jmp 3234 "!="
mov AX 1
jmp 3235
mov AX 0
cmp AX 1
$jmp 3254 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__setitem___3198+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__setitem___3198+0>
push [2]
mov <esp+1>[0] <__setitem___3198+2>
mov <esp+1>[1] <__setitem___3198+3>
pop <esp+1>[1]
mov <esp+1>[2] "__setitem__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3255
jmp 3254        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___3198" "0,1,2,3"
pop ip
Function BX 3261 <class_obj^8> "__getitem___3261" 3
mov <class_obj^8>.__getitem__ BX
jmp 3311           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3269 "!="
tf <esp+2> "in" "item"
$jmp 3271 "t"
mov <esp+2>["item"] None
jmp 3271
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___3261+2> <esp+2>["item"]


mov DX <__getitem___3261+0>.print_lock
tf DX "equ" 0
$jmp 3279 "f"
mov AX True
jmp 3280
mov AX False
cmp AX 1
$jmp 3288 "!="
tf <__getitem___3261+0>.vars "in" "__getitem__"
mov AX TF
cmp AX 1
$jmp 3288 "!="
mov AX 1
jmp 3289
mov AX 0
cmp AX 1
$jmp 3307 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__getitem___3261+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__getitem___3261+0>
push [1]
mov <esp+1>[0] <__getitem___3261+2>
pop <esp+1>[1]
mov <esp+1>[2] "__getitem__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3308
jmp 3307        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___3261" "0,1,2"
pop ip
Function BX 3314 <class_obj^8> "__contains___3314" 3
mov <class_obj^8>.__contains__ BX
jmp 3364           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3322 "!="
tf <esp+2> "in" "item"
$jmp 3324 "t"
mov <esp+2>["item"] None
jmp 3324
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___3314+2> <esp+2>["item"]


mov DX <__contains___3314+0>.print_lock
tf DX "equ" 0
$jmp 3332 "f"
mov AX True
jmp 3333
mov AX False
cmp AX 1
$jmp 3341 "!="
tf <__contains___3314+0>.vars "in" "__contains__"
mov AX TF
cmp AX 1
$jmp 3341 "!="
mov AX 1
jmp 3342
mov AX 0
cmp AX 1
$jmp 3360 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__contains___3314+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__contains___3314+0>
push [1]
mov <esp+1>[0] <__contains___3314+2>
pop <esp+1>[1]
mov <esp+1>[2] "__contains__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3361
jmp 3360        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___3314" "0,1,2"
pop ip
Function BX 3367 <class_obj^8> "__next___3367" 2
mov <class_obj^8>.__next__ BX
jmp 3425           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__next___3367+0>.print_lock
tf DX "equ" 0
$jmp 3376 "f"
mov AX True
jmp 3377
mov AX False
cmp AX 1
$jmp 3385 "!="
tf <__next___3367+0>.vars "in" "__next__"
mov AX TF
cmp AX 1
$jmp 3385 "!="
mov AX 1
jmp 3386
mov AX 0
cmp AX 1
$jmp 3402 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next___3367+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next___3367+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__next__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3422
jmp 3421        ;¸õ¦Ü©³³¡
tf <__next___3367+0>.vars "in" "__getitem__"
mov AX TF
cmp AX 1
$jmp 3421 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push False
mov <__next___3367+0>.error <esp+1>
inc esp
push 1
$mov <__next___3367+0>.item_k "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__next___3367+0>.item_k
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__next___3367+0>.__getitem__
jmp 3422
jmp 3421        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next___3367" "0,1"
pop ip
Function BX 3428 <class_obj^8> "__iter___3428" 2
mov <class_obj^8>.__iter__ BX
jmp 3473           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX 1
$oper AX "-"
push AX
mov <__iter___3428+0>.item_k <esp+1>
inc esp
mov DX <__iter___3428+0>.print_lock
tf DX "equ" 0
$jmp 3442 "f"
mov AX True
jmp 3443
mov AX False
cmp AX 1
$jmp 3451 "!="
tf <__iter___3428+0>.vars "in" "__iter__"
mov AX TF
cmp AX 1
$jmp 3451 "!="
mov AX 1
jmp 3452
mov AX 0
cmp AX 1
$jmp 3468 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__iter___3428+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__iter___3428+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__iter__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3470         ;returnÂI
jmp 3468        ;¸õ¦Ü©³³¡
mov AX <__iter___3428+0>
jmp 3470         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__iter___3428" "0,1"
pop ip
Function BX 3476 <class_obj^8> "__exit___3476" 5
mov <class_obj^8>.__exit__ BX
jmp 3546           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3484 "!="
tf <esp+2> "in" "exc_type"
$jmp 3486 "t"
mov <esp+2>["exc_type"] None
jmp 3486
mov <esp+2>["exc_type"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3492 "!="
tf <esp+2> "in" "exc_val"
$jmp 3494 "t"
mov <esp+2>["exc_val"] None
jmp 3494
mov <esp+2>["exc_val"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3500 "!="
tf <esp+2> "in" "exc_tb"
$jmp 3502 "t"
mov <esp+2>["exc_tb"] None
jmp 3502
mov <esp+2>["exc_tb"] <esp+1>[2]
dec CX
mov <__exit___3476+2> <esp+2>["exc_type"]
mov <__exit___3476+3> <esp+2>["exc_val"]
mov <__exit___3476+4> <esp+2>["exc_tb"]


mov DX <__exit___3476+0>.print_lock
tf DX "equ" 0
$jmp 3512 "f"
mov AX True
jmp 3513
mov AX False
cmp AX 1
$jmp 3521 "!="
tf <__exit___3476+0>.vars "in" "__exit__"
mov AX TF
cmp AX 1
$jmp 3521 "!="
mov AX 1
jmp 3522
mov AX 0
cmp AX 1
$jmp 3542 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__exit___3476+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__exit___3476+0>
push [3]
mov <esp+1>[0] <__exit___3476+2>
mov <esp+1>[1] <__exit___3476+3>
mov <esp+1>[2] <__exit___3476+4>
pop <esp+1>[1]
mov <esp+1>[2] "__exit__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3543
jmp 3542        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__exit___3476" "0,1,2,3,4"
pop ip
Function BX 3549 <class_obj^8> "__call___3549" 4
mov <class_obj^8>.__call__ BX
jmp 3593           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___3549+2> <esp+2>["args"]
mov <__call___3549+3> <esp+2>["kwargs"]


mov DX <__call___3549+0>.print_lock
tf DX "equ" 0
$jmp 3562 "f"
mov AX True
jmp 3563
mov AX False
cmp AX 1
$jmp 3571 "!="
tf <__call___3549+0>.vars "in" "__call__"
mov AX TF
cmp AX 1
$jmp 3571 "!="
mov AX 1
jmp 3572
mov AX 0
cmp AX 1
$jmp 3589 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__call___3549+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <__call___3549+0>
mov <esp+1>[1] <__call___3549+2>
mov <esp+1>[2] "__call__"
mov <esp+1>[3] <__call___3549+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3590
jmp 3589        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___3549" "0,1,2,3"
pop ip
Function BX 3596 <class_obj^8> "__del___3596" 2
mov <class_obj^8>.__del__ BX
jmp 3635           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__del___3596+0>.print_lock
tf DX "equ" 0
$jmp 3605 "f"
mov AX True
jmp 3606
mov AX False
cmp AX 1
$jmp 3614 "!="
tf <__del___3596+0>.vars "in" "__del__"
mov AX TF
cmp AX 1
$jmp 3614 "!="
mov AX 1
jmp 3615
mov AX 0
cmp AX 1
$jmp 3631 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__del___3596+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__del___3596+0>
mov <esp+1>[1] [0]
mov <esp+1>[2] "__del__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3632
jmp 3631        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__del___3596" "0,1"
pop ip
Function BX 3638 <class_obj^8> "__eq___3638" 3
mov <class_obj^8>.__eq__ BX
jmp 3688           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3646 "!="
tf <esp+2> "in" "other"
$jmp 3648 "t"
mov <esp+2>["other"] None
jmp 3648
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__eq___3638+2> <esp+2>["other"]


mov DX <__eq___3638+0>.print_lock
tf DX "equ" 0
$jmp 3656 "f"
mov AX True
jmp 3657
mov AX False
cmp AX 1
$jmp 3665 "!="
tf <__eq___3638+0>.vars "in" "__eq__"
mov AX TF
cmp AX 1
$jmp 3665 "!="
mov AX 1
jmp 3666
mov AX 0
cmp AX 1
$jmp 3684 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__eq___3638+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.call_obj_function
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__eq___3638+0>
push [1]
mov <esp+1>[0] <__eq___3638+2>
pop <esp+1>[1]
mov <esp+1>[2] "__eq__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 3685
jmp 3684        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__eq___3638" "0,1,2"
pop ip
mov AX <class_obj^8>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 3700 "=="
tf AX "Ctn" "__init__"
$jmp 3698 "t"
jmp 3700
call AX.__init__
mov AX <class_obj^8>
end "Function" "class_obj^8"
pop ip
Function <&executer_33+2> 3705 None "Func^9" 1
name <&executer_33+2> "<class '__main__.Func'>"
jmp 3894
tf $Inheritance "equ" None
$jmp 3710 "t"
mov <Func^9> $Inheritance
push 1
jmp 3712
mov <Func^9> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Func^9> <&executer_33+2>
Function BX 3720 <Func^9> "__init___3720" 8
mov <Func^9>.__init__ BX
jmp 3807           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3728 "!="
tf <esp+2> "in" "ram"
$jmp 3730 "t"
mov <esp+2>["ram"] None
jmp 3730
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3736 "!="
tf <esp+2> "in" "$$ip"
$jmp 3738 "t"
mov <esp+2>["$$ip"] None
jmp 3738
mov <esp+2>["$$ip"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3744 "!="
tf <esp+2> "in" "class_obj"
$jmp 3746 "t"
mov <esp+2>["class_obj"] None
jmp 3746
mov <esp+2>["class_obj"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 3752 "!="
tf <esp+2> "in" "func_var"
$jmp 3754 "t"
mov <esp+2>["func_var"] None
jmp 3754
mov <esp+2>["func_var"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 3760 "!="
tf <esp+2> "in" "stack_len"
$jmp 3762 "t"
mov <esp+2>["stack_len"] None
jmp 3762
mov <esp+2>["stack_len"] <esp+1>[4]
dec CX
cmp CX 0
$jmp 3768 "!="
tf <esp+2> "in" "import_funcs"
$jmp 3770 "t"
mov <esp+2>["import_funcs"] None
jmp 3770
mov <esp+2>["import_funcs"] <esp+1>[5]
dec CX
mov <__init___3720+2> <esp+2>["ram"]
mov <__init___3720+3> <esp+2>["$$ip"]
mov <__init___3720+4> <esp+2>["class_obj"]
mov <__init___3720+5> <esp+2>["func_var"]
mov <__init___3720+6> <esp+2>["stack_len"]
mov <__init___3720+7> <esp+2>["import_funcs"]


push "Function"
mov <__init___3720+0>.name <esp+1>
inc esp
push "Function"
mov <__init___3720+0>.atype <esp+1>
inc esp
push <__init___3720+2>
mov <__init___3720+0>.ram <esp+1>
inc esp
push [dict]
mov BX "ip"
mov <esp+1>[BX] <__init___3720+3>
mov BX "class_obj"
mov <esp+1>[BX] <__init___3720+4>
mov <__init___3720+0>.vars <esp+1>
inc esp
push <__init___3720+5>
mov <__init___3720+0>.stack_name <esp+1>
inc esp
push <__init___3720+6>
mov <__init___3720+0>.stack_len <esp+1>
inc esp
push <__init___3720+7>
mov <__init___3720+0>.import_funcs <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___3720" "0,1,2,3,4,5,6,7"
pop ip
Function BX 3810 <Func^9> "__str___3810" 2
mov <Func^9>.__str__ BX
jmp 3825           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___3810+0>.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
jmp 3822         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___3810" "0,1"
pop ip
Function BX 3828 <Func^9> "__call___3828" 5
mov <Func^9>.__call__ BX
jmp 3880           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___3828+2> <esp+2>["args"]
mov <__call___3828+3> <esp+2>["kwargs"]


push <__call___3828+2>
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.args_location
pop AX
mov AX[BX] <esp+1>
inc esp
push <__call___3828+3>
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.kwargs_location
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <__call___3828+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_run
push 5        ;Àx¦sCX
push [5]
push <__call___3828+0>.vars
mov BX "ip"
pop AX
mov <esp+1>[0] AX[BX]
push <__call___3828+0>.vars
mov BX "class_obj"
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <__call___3828+0>.stack_name
mov <esp+1>[3] <__call___3828+0>.stack_len
mov <esp+1>[4] <__call___3828+0>.import_funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__call___3828+4> <esp+1>
inc esp
mov AX <__call___3828+4>
jmp 3877         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___3828" "0,1,2,3,4"
pop ip
mov AX <Func^9>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 3892 "=="
tf AX "Ctn" "__init__"
$jmp 3890 "t"
jmp 3892
call AX.__init__
mov AX <Func^9>
end "Function" "Func^9"
pop ip
Function <&executer_33+3> 3897 None "generator^10" 1
name <&executer_33+3> "<class '__main__.generator'>"
jmp 4450
tf $Inheritance "equ" None
$jmp 3902 "t"
mov <generator^10> $Inheritance
push 1
jmp 3904
mov <generator^10> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <generator^10> <&executer_33+3>
Function BX 3912 <generator^10> "__init___3912" 6
mov <generator^10>.__init__ BX
jmp 4024           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3920 "!="
tf <esp+2> "in" "ram"
$jmp 3922 "t"
mov <esp+2>["ram"] None
jmp 3922
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 3928 "!="
tf <esp+2> "in" "start_ip"
$jmp 3930 "t"
mov <esp+2>["start_ip"] None
jmp 3930
mov <esp+2>["start_ip"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 3936 "!="
tf <esp+2> "in" "import_funcs"
$jmp 3938 "t"
mov <esp+2>["import_funcs"] None
jmp 3938
mov <esp+2>["import_funcs"] <esp+1>[2]
dec CX
mov <__init___3912+2> <esp+2>["ram"]
mov <__init___3912+3> <esp+2>["start_ip"]
mov <__init___3912+4> <esp+2>["import_funcs"]


push <__init___3912+2>
mov <__init___3912+0>.ram <esp+1>
inc esp
push <__init___3912+3>
mov <__init___3912+0>.next_ip <esp+1>
inc esp
push <__init___3912+4>
mov <__init___3912+0>.import_funcs <esp+1>
inc esp
push [0]
mov <__init___3912+0>.ex_stack <esp+1>
inc esp
push 0
mov <__init___3912+0>.enter <esp+1>
inc esp
push True
mov <__init___3912+0>.next_lock <esp+1>
inc esp
push False
mov <__init___3912+0>.send <esp+1>
inc esp
push None
mov <__init___3912+0>.send_obj <esp+1>
inc esp
push [0]
mov <__init___3912+0>.finally_box <esp+1>
inc esp
Function <__init___3912+5> 3972 None "send_3972" 2 "__init___3912"
jmp 4015           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 3980 "!="
tf <esp+2> "in" "value"
$jmp 3982 "t"
mov <esp+2>["value"] None
jmp 3982
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <send_3972+1> <esp+2>["value"]


mov AX <__init___3912+0>.next_lock
$oper AX "not"
cmp AX 1
$jmp 4003 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
mov <__init___3912+0>.send <esp+1>
inc esp
push <send_3972+1>
mov <__init___3912+0>.send_obj <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___3912+0>.__next
jmp 4012
jmp 4003        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "can't send non-None value to a just-started generator"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call TypeError
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "send_3972" "0,1"
pop ip
push [dict]
mov BX "send"
mov <esp+1>[BX] <__init___3912+5>
mov <__init___3912+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___3912" "0,1,2,3,4"
pop ip
Function BX 4027 <generator^10> "__str___4027" 2
mov <generator^10>.__str__ BX
jmp 4036           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<generator_obj>"
jmp 4033         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___4027" "0,1"
pop ip
Function BX 4039 <generator^10> "__getitem___4039" 3
mov <generator^10>.__getitem__ BX
jmp 4062           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4047 "!="
tf <esp+2> "in" "item"
$jmp 4049 "t"
mov <esp+2>["item"] None
jmp 4049
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___4039+2> <esp+2>["item"]


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__getitem___4039+0>.__next
jmp 4059         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___4039" "0,1,2"
pop ip
Function BX 4065 <generator^10> "__next___4065" 2
mov <generator^10>.__next__ BX
jmp 4088           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push False
mov <__next___4065+0>.next_lock <esp+1>
inc esp
cmp <__next___4065+0>.send 1
$jmp 4078 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
mov <__next___4065+0>.send_obj <esp+1>
inc esp
jmp 4078        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__next___4065+0>.__next
jmp 4085         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next___4065" "0,1"
pop ip
Function BX 4091 <generator^10> "__next_4091" 9
mov <generator^10>.__next BX
jmp 4263           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov DX <__next_4091+0>.enter
tf DX "equ" 1
$jmp 4100 "f"
mov AX True
jmp 4101
mov AX False
cmp AX 1
$jmp 4106 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX StopIteration
raise AX
jmp 4259        ;¸õ¦Ü©³³¡
push 1
mov <__next_4091+0>.enter <esp+1>
inc esp
mov AX <__next_4091+0>.send
$oper AX "not"
cmp AX 1
$jmp 4132 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next_4091+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.yield_run
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next_4091+0>.next_ip
mov <esp+1>[1] <__next_4091+0>.ex_stack
mov <esp+1>[2] <__next_4091+0>.import_funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__next_4091+2> <esp+1>[0]
mov <__next_4091+0>.ex_stack <esp+1>[1]
mov <__next_4091+3> <esp+1>[2]
mov <__next_4091+4> <esp+1>[3]
inc esp
jmp 4153        ;¸õ¦Ü©³³¡
mov AX <__next_4091+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.yield_run
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__next_4091+0>.next_ip
mov <esp+1>[1] <__next_4091+0>.ex_stack
mov <esp+1>[2] <__next_4091+0>.import_funcs
push [dict]
mov BX "send_obj"
mov <esp+1>[BX] <__next_4091+0>.send_obj
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__next_4091+2> <esp+1>[0]
mov <__next_4091+0>.ex_stack <esp+1>[1]
mov <__next_4091+3> <esp+1>[2]
mov <__next_4091+4> <esp+1>[3]
inc esp
mov DX <__next_4091+2>
tf DX "equ" None
$jmp 4158 "t"
mov AX True
jmp 4159
mov AX False
cmp AX 1
$jmp 4257 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__next_4091+2>
mov <__next_4091+0>.next_ip <esp+1>[0]
mov <__next_4091+5> <esp+1>[1]
inc esp
ex_func AX "iter" <__next_4091+5>
push AX
fetch AX <esp+1>
$jmp 4250 "f"
mov <__next_4091+6> AX
push <__next_4091+6>
mov BX 0
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
cmp DX AX
$jmp 4181 "<="
mov AX True
jmp 4182
mov AX False
cmp AX 1
$jmp 4208 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__next_4091+4>
push <__next_4091+6>
mov BX 1
pop AX
oper <esp+1> "-" AX[BX]
mov <__next_4091+7> <esp+1>
inc esp
mov AX <__next_4091+0>.finally_box      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push [2]
push <__next_4091+6>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <__next_4091+7>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4249        ;¸õ¦Ü©³³¡
ex_func AX "iter" <__next_4091+0>.finally_box
push AX
fetch AX <esp+1>
$jmp 4248 "f"
mov <__next_4091+8> AX
push <__next_4091+8>
mov BX 0
pop AX
push AX[BX]
push 1        ;Àx¦sCX
push [1]
push <__next_4091+6>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call abs
pop DX
tf DX "equ" AX
$jmp 4232 "f"
mov AX True
jmp 4233
mov AX False
cmp AX 1
$jmp 4247 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__next_4091+0>.finally_box      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.remove
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__next_4091+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4248          ;break¥X°j°é
jmp 4247        ;¸õ¦Ü©³³¡
jmp 4210
inc esp
jmp 4167
inc esp
push 0
mov <__next_4091+0>.enter <esp+1>
inc esp
mov AX <__next_4091+3>
jmp 4260
jmp 4257        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__next_4091" "0,1,2,3,4,5,6,7,8"
pop ip
Function BX 4266 <generator^10> "__del___4266" 6
mov <generator^10>.__del__ BX
jmp 4436           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


ex_func AX "iter" <__del___4266+0>.finally_box
push AX
fetch AX <esp+1>
$jmp 4431 "f"
mov <__del___4266+2> AX
push <__del___4266+2>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "+" 1
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.data
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov BX AX.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push [dict]
mov <__del___4266+3> <esp+1>
inc esp
ex_func AX "iter" <__del___4266+0>.import_funcs
push AX
fetch AX <esp+1>
$jmp 4316 "f"
mov <__del___4266+4> AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
push AX[BX]
push <__del___4266+3>
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__del___4266+0>.import_funcs
mov BX <__del___4266+4>
pop AX
push AX[BX]
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4292
inc esp
push 1        ;Àx¦sCX
push [1]
push <__del___4266+2>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4346 "f"
mov <__del___4266+5> AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
push <__del___4266+0>.ex_stack
mov BX <__del___4266+5>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 4329
inc esp
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.push
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
finally 4401
try 4381
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.one_run
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "finally yield run"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
try "end"
jmp 4396    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 4395 "f"
mov e $Exception
mov $Exception 0
try 4399
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
try "end"
jmp 4396  ;¸õ¨ìpush 1
jmp 4399 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 4401    ;¸õ¨ìfinally
push None
push 0
finally -4401
push $Exception
mov $Exception 0
ex_func AX "iter" <__del___4266+3>
push AX
fetch AX <esp+1>
$jmp 4420 "f"
mov <__del___4266+4> AX
push <__del___4266+3>
mov BX <__del___4266+4>
pop AX
push AX[BX]
mov AX <__del___4266+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__del___4266+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4406
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 4428 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
jmp 4272
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__del___4266" "0,1,2,3,4,5"
pop ip
mov AX <generator^10>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 4448 "=="
tf AX "Ctn" "__init__"
$jmp 4446 "t"
jmp 4448
call AX.__init__
mov AX <generator^10>
end "Function" "generator^10"
pop ip
Function <&executer_33+4> 4452 None "fetch_error_4452" 5
jmp 4522           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4460 "!="
tf <esp+2> "in" "e"
$jmp 4462 "t"
mov <esp+2>["e"] None
jmp 4462
mov <esp+2>["e"] <esp+1>[0]
dec CX
mov <fetch_error_4452+1> <esp+2>["e"]


push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <fetch_error_4452+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <fetch_error_4452+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "'"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <fetch_error_4452+2>.index
push AX
mov <fetch_error_4452+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "'"
push <fetch_error_4452+3>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <fetch_error_4452+2>.index
push AX
mov <fetch_error_4452+4> <esp+1>
inc esp
push <fetch_error_4452+2>
push [3]
push <fetch_error_4452+3>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <fetch_error_4452+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov AX AX[BX]
jmp 4519         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "fetch_error_4452" "0,1,2,3,4"
pop ip
Function <&executer_33+5> 4524 None "atype_4524" 2
jmp 4588           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4532 "!="
tf <esp+2> "in" "obj"
$jmp 4534 "t"
mov <esp+2>["obj"] None
jmp 4534
mov <esp+2>["obj"] <esp+1>[0]
dec CX
mov <atype_4524+1> <esp+2>["obj"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4524+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+1>
$jmp 4549 "f"
mov AX True
jmp 4550
mov AX False
cmp AX 1
$jmp 4555 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <atype_4524+1>.atype
jmp 4585         ;returnÂI
jmp 4577        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4524+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+2>
$jmp 4567 "f"
mov AX True
jmp 4568
mov AX False
cmp AX 1
$jmp 4577 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<class \'__main__."
ex_func AX "str" <atype_4524+1>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "\'>"
pop AX
jmp 4585         ;returnÂI
jmp 4577        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <atype_4524+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
jmp 4585         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "atype_4524" "0,1"
pop ip
push [66]
mov <esp+1>[0] abs
mov <esp+1>[1] all
mov <esp+1>[2] any
mov <esp+1>[3] ascii
mov <esp+1>[4] bin
mov <esp+1>[5] bool
mov <esp+1>[6] breakpoint
mov <esp+1>[7] bytearray
mov <esp+1>[8] bytes
mov <esp+1>[9] callable
mov <esp+1>[10] chr
mov <esp+1>[11] classmethod
mov <esp+1>[12] compile
mov <esp+1>[13] complex
mov <esp+1>[14] delattr
mov <esp+1>[15] dict
mov <esp+1>[16] dir
mov <esp+1>[17] divmod
mov <esp+1>[18] enumerate
mov <esp+1>[19] eval
mov <esp+1>[20] exec
mov <esp+1>[21] filter
mov <esp+1>[22] float
mov <esp+1>[23] format
mov <esp+1>[24] frozenset
mov <esp+1>[25] getattr
mov <esp+1>[26] globals
mov <esp+1>[27] hasattr
mov <esp+1>[28] hash
mov <esp+1>[29] hex
mov <esp+1>[30] id
mov <esp+1>[31] input
mov <esp+1>[32] int
mov <esp+1>[33] isinstance
mov <esp+1>[34] issubclass
mov <esp+1>[35] iter
mov <esp+1>[36] len
mov <esp+1>[37] list
mov <esp+1>[38] locals
mov <esp+1>[39] map
mov <esp+1>[40] max
mov <esp+1>[41] memoryview
mov <esp+1>[42] min
mov <esp+1>[43] next
mov <esp+1>[44] object
mov <esp+1>[45] oct
mov <esp+1>[46] open
mov <esp+1>[47] ord
mov <esp+1>[48] pow
mov <esp+1>[49] print
mov <esp+1>[50] property
mov <esp+1>[51] range
mov <esp+1>[52] repr
mov <esp+1>[53] reversed
mov <esp+1>[54] round
mov <esp+1>[55] set
mov <esp+1>[56] setattr
mov <esp+1>[57] slice
mov <esp+1>[58] sorted
mov <esp+1>[59] staticmethod
mov <esp+1>[60] str
mov <esp+1>[61] sum
mov <esp+1>[62] super
mov <esp+1>[63] tuple
mov <esp+1>[64] vars
mov <esp+1>[65] zip
mov <&executer_33+6> <esp+1>
inc esp
push [14]
mov <esp+1>[0] NameError
mov <esp+1>[1] IndexError
mov <esp+1>[2] TypeError
mov <esp+1>[3] SyntaxError
mov <esp+1>[4] ValueError
mov <esp+1>[5] KeyboardInterrupt
mov <esp+1>[6] AssertionError
mov <esp+1>[7] Exception
mov <esp+1>[8] RecursionError
mov <esp+1>[9] KeyError
mov <esp+1>[10] ZeroDivisionError
mov <esp+1>[11] AttributeError
mov <esp+1>[12] IndentationError
mov <esp+1>[13] UnboundLocalError
mov <&executer_33+7> <esp+1>
inc esp
push [5]
mov <esp+1>[0] StopIteration
mov <esp+1>[1] StopAsyncIteration
mov <esp+1>[2] SyntaxWarning
mov <esp+1>[3] FileNotFoundError
mov <esp+1>[4] ModuleNotFoundError
mov <&executer_33+8> <esp+1>
inc esp
push [dict]
mov BX "IOError"
mov <esp+1>[BX] IOError
mov BX "type"
mov <esp+1>[BX] <&executer_33+5>
mov <&executer_33+9> <esp+1>
inc esp
push <&executer_33+6>
oper <esp+1> "+" <&executer_33+7>
oper <esp+1> "+" <&executer_33+8>
pop AX
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4705 "f"
mov <&executer_33+10> AX
push <&executer_33+10>
push <&executer_33+9>
mov BX <&executer_33+10>.__name__
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4695
inc esp
Function <&executer_33+11> 4709 None "Executer^11" 1
name <&executer_33+11> "<class '__main__.Executer'>"
jmp 10938
tf $Inheritance "equ" None
$jmp 4714 "t"
mov <Executer^11> $Inheritance
push 1
jmp 4716
mov <Executer^11> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Executer^11> <&executer_33+11>
Function BX 4724 <Executer^11> "__init___4724" 3
mov <Executer^11>.__init__ BX
jmp 4759           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4732 "!="
tf <esp+2> "in" "code"
$jmp 4734 "t"
mov <esp+2>["code"] None
jmp 4734
mov <esp+2>["code"] <esp+1>[0]
dec CX
mov <__init___4724+2> <esp+2>["code"]


push <__init___4724+2>
mov <__init___4724+0>.code <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+9>.copy
push AX
mov <__init___4724+0>.ex_function <esp+1>
inc esp
push [0]
mov <__init___4724+0>.run_layer <esp+1>
inc esp
push [dict]
mov <__init___4724+0>.func_stack <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___4724" "0,1,2"
pop ip
Function BX 4762 <Executer^11> "set_4762" 5
mov <Executer^11>.set BX
jmp 4800           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4770 "!="
tf <esp+2> "in" "var_name"
$jmp 4772 "t"
mov <esp+2>["var_name"] None
jmp 4772
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 4778 "!="
tf <esp+2> "in" "value"
$jmp 4780 "t"
mov <esp+2>["value"] None
jmp 4780
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <set_4762+2> <esp+2>["var_name"]
mov <set_4762+3> <esp+2>["value"]


push <set_4762+0>.data_dict
mov BX <set_4762+2>
pop AX
push AX[BX]
mov <set_4762+4> <esp+1>
inc esp
push <set_4762+3>
push <set_4762+0>.data
mov BX <set_4762+4>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "set_4762" "0,1,2,3,4"
pop ip
Function BX 4803 <Executer^11> "push_4803" 3
mov <Executer^11>.push BX
jmp 4835           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4811 "!="
tf <esp+2> "in" "value"
$jmp 4813 "t"
mov <esp+2>["value"] None
jmp 4813
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <push_4803+2> <esp+2>["value"]


push <push_4803+2>
push <push_4803+0>.esp_stack
push <push_4803+0>.data
mov BX <push_4803+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <push_4803+0>.data
mov BX <push_4803+0>.$$esp
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "push_4803" "0,1,2"
pop ip
Function BX 4838 <Executer^11> "pop_4838" 2
mov <Executer^11>.pop BX
jmp 4859           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1
push <pop_4838+0>.data
mov BX <pop_4838+0>.$$esp
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <pop_4838+0>.esp_stack
push <pop_4838+0>.data
mov BX <pop_4838+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 4856         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "pop_4838" "0,1"
pop ip
Function BX 4862 <Executer^11> "login_4862" 3
mov <Executer^11>.login BX
jmp 4901           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4870 "!="
tf <esp+2> "in" "var_name"
$jmp 4872 "t"
mov <esp+2>["var_name"] None
jmp 4872
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
mov <login_4862+2> <esp+2>["var_name"]


tf <login_4862+0>.var_dict "in" <login_4862+2>
mov AX TF
cmp AX 1
$jmp 4885 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <login_4862+0>.var_dict
mov BX <login_4862+2>
pop AX
mov AX AX[BX]
jmp 4898         ;returnÂI
jmp 4885        ;¸õ¦Ü©³³¡
push <login_4862+0>.used_size
push <login_4862+0>.var_dict
mov BX <login_4862+2>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <login_4862+0>.used_size "+" <esp+1>
inc esp
push <login_4862+0>.used_size
oper <esp+1> "-" 1
pop AX
jmp 4898         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "login_4862" "0,1,2"
pop ip
Function BX 4904 <Executer^11> "get_var_location_4904" 3
mov <Executer^11>.get_var_location BX
jmp 4925           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 4912 "!="
tf <esp+2> "in" "var_name"
$jmp 4914 "t"
mov <esp+2>["var_name"] None
jmp 4914
mov <esp+2>["var_name"] <esp+1>[0]
dec CX
mov <get_var_location_4904+2> <esp+2>["var_name"]


push <get_var_location_4904+0>.var_dict
mov BX <get_var_location_4904+2>
pop AX
mov AX AX[BX]
jmp 4922         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_var_location_4904" "0,1,2"
pop ip
Function BX 4928 <Executer^11> "pushaw_4928" 3
mov <Executer^11>.pushaw BX
jmp 4968           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 5
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 4963 "f"
mov <pushaw_4928+2> AX
push <pushaw_4928+0>.data
mov BX <pushaw_4928+2>
pop AX
push AX[BX]
push <pushaw_4928+0>.esp_stack
push <pushaw_4928+0>.data
mov BX <pushaw_4928+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <pushaw_4928+0>.data
mov BX <pushaw_4928+0>.$$esp
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 4941
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "pushaw_4928" "0,1,2"
pop ip
Function BX 4971 <Executer^11> "popaw_4971" 3
mov <Executer^11>.popaw BX
jmp 5013           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 5
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 5008 "f"
mov <popaw_4971+2> AX
push 1
push <popaw_4971+0>.data
mov BX <popaw_4971+0>.$$esp
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <popaw_4971+0>.esp_stack
push <popaw_4971+0>.data
mov BX <popaw_4971+0>.$$esp
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <popaw_4971+0>.data
push 4
oper <esp+1> "-" <popaw_4971+2>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 4984
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "popaw_4971" "0,1,2"
pop ip
Function BX 5016 <Executer^11> "__setitem___5016" 4
mov <Executer^11>.__setitem__ BX
jmp 5321           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5024 "!="
tf <esp+2> "in" "location"
$jmp 5026 "t"
mov <esp+2>["location"] None
jmp 5026
mov <esp+2>["location"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5032 "!="
tf <esp+2> "in" "value"
$jmp 5034 "t"
mov <esp+2>["value"] None
jmp 5034
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___5016+2> <esp+2>["location"]
mov <__setitem___5016+3> <esp+2>["value"]


push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 5046 "f"
mov AX True
jmp 5047
mov AX False
cmp AX 1
$jmp 5059 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 5067 "f"
mov AX True
jmp 5068
mov AX False
cmp AX 1
$jmp 5087 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___5016+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 5095 "f"
mov AX True
jmp 5096
mov AX False
cmp AX 1
$jmp 5117 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 5125 "f"
mov AX True
jmp 5126
mov AX False
cmp AX 1
$jmp 5146 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.esp_stack
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 5154 "f"
mov AX True
jmp 5155
mov AX False
cmp AX 1
$jmp 5182 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.esp_stack
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___5016+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 5190 "f"
mov AX True
jmp 5191
mov AX False
cmp AX 1
$jmp 5220 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.esp_stack
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 5228 "f"
mov AX True
jmp 5229
mov AX False
cmp AX 1
$jmp 5247 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.func_stack
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 5255 "f"
mov AX True
jmp 5256
mov AX False
cmp AX 1
$jmp 5281 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.func_stack
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__setitem___5016+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
push <__setitem___5016+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 5289 "f"
mov AX True
jmp 5290
mov AX False
cmp AX 1
$jmp 5317 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___5016+3>
push <__setitem___5016+0>.func_stack
push <__setitem___5016+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__setitem___5016+0>.data
push <__setitem___5016+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5317        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___5016" "0,1,2,3"
pop ip
Function BX 5324 <Executer^11> "call_obj_function_5324" 9
mov <Executer^11>.call_obj_function BX
jmp 5467           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5332 "!="
tf <esp+2> "in" "obj"
$jmp 5334 "t"
mov <esp+2>["obj"] None
jmp 5334
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5340 "!="
tf <esp+2> "in" "args"
$jmp 5342 "t"
mov <esp+2>["args"] None
jmp 5342
mov <esp+2>["args"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5348 "!="
tf <esp+2> "in" "funcname"
$jmp 5350 "t"
mov <esp+2>["funcname"] None
jmp 5350
mov <esp+2>["funcname"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5356 "!="
tf <esp+2> "in" "kwargs"
$jmp 5358 "t"
mov <esp+2>["kwargs"] None
jmp 5358
mov <esp+2>["kwargs"] <esp+1>[3]
dec CX
mov <call_obj_function_5324+2> <esp+2>["obj"]
mov <call_obj_function_5324+3> <esp+2>["args"]
mov <call_obj_function_5324+4> <esp+2>["funcname"]
mov <call_obj_function_5324+5> <esp+2>["kwargs"]


push <call_obj_function_5324+0>.data
mov BX <call_obj_function_5324+0>.$$esp
pop AX
push AX[BX]
mov <call_obj_function_5324+6> <esp+1>
inc esp
mov DX <call_obj_function_5324+5>
tf DX "equ" None
$jmp 5375 "f"
mov AX True
jmp 5376
mov AX False
cmp AX 1
$jmp 5382 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
mov <call_obj_function_5324+5> <esp+1>
inc esp
jmp 5382        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5324+0>.pushaw
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <call_obj_function_5324+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
push <call_obj_function_5324+0>.data
mov BX 2
pop AX
mov AX[BX] <esp+1>
inc esp
push <call_obj_function_5324+2>.vars
mov BX <call_obj_function_5324+4>
pop AX
push AX[BX]
mov <call_obj_function_5324+7> <esp+1>
inc esp
push None
mov <call_obj_function_5324+8> <esp+1>
inc esp
finally 5438
try 5432
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <call_obj_function_5324+3>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <call_obj_function_5324+5>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5324+7>
push AX
mov <call_obj_function_5324+8> <esp+1>
inc esp
try "end"
jmp 5433    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5436 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5438    ;¸õ¨ìfinally
push None
push 0
finally -5438
push $Exception
mov $Exception 0
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <call_obj_function_5324+0>.popaw
push <call_obj_function_5324+6>
push <call_obj_function_5324+0>.data
mov BX <call_obj_function_5324+0>.$$esp
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5460 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX <call_obj_function_5324+8>
jmp 5464         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "call_obj_function_5324" "0,1,2,3,4,5,6,7,8"
pop ip
Function BX 5470 <Executer^11> "yield_run_5470" 16
mov <Executer^11>.yield_run BX
jmp 5700           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5478 "!="
tf <esp+2> "in" "$$ip"
$jmp 5480 "t"
mov <esp+2>["$$ip"] None
jmp 5480
mov <esp+2>["$$ip"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5486 "!="
tf <esp+2> "in" "ex_stack"
$jmp 5488 "t"
mov <esp+2>["ex_stack"] None
jmp 5488
mov <esp+2>["ex_stack"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5494 "!="
tf <esp+2> "in" "import_funcs"
$jmp 5496 "t"
mov <esp+2>["import_funcs"] None
jmp 5496
mov <esp+2>["import_funcs"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5502 "!="
tf <esp+2> "in" "send_obj"
$jmp 5504 "t"
mov <esp+2>["send_obj"] None
jmp 5504
mov <esp+2>["send_obj"] <esp+1>[3]
dec CX
mov <yield_run_5470+2> <esp+2>["$$ip"]
mov <yield_run_5470+3> <esp+2>["ex_stack"]
mov <yield_run_5470+4> <esp+2>["import_funcs"]
mov <yield_run_5470+5> <esp+2>["send_obj"]


push <yield_run_5470+0>.data
mov BX <yield_run_5470+0>.$$ip
pop AX
push AX[BX]
mov <yield_run_5470+6> <esp+1>
inc esp
push <yield_run_5470+2>
push <yield_run_5470+0>.data
mov BX <yield_run_5470+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push [dict]
mov <yield_run_5470+7> <esp+1>
inc esp
ex_func AX "iter" <yield_run_5470+4>
push AX
fetch AX <esp+1>
$jmp 5549 "f"
mov <yield_run_5470+8> AX
push <yield_run_5470+0>.func_stack
mov BX <yield_run_5470+8>
pop AX
push AX[BX]
push <yield_run_5470+7>
mov BX <yield_run_5470+8>
pop AX
mov AX[BX] <esp+1>
inc esp
push <yield_run_5470+4>
mov BX <yield_run_5470+8>
pop AX
push AX[BX]
push <yield_run_5470+0>.func_stack
mov BX <yield_run_5470+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5527
inc esp
push <yield_run_5470+0>.data
mov BX <yield_run_5470+0>.$$esp
pop AX
push AX[BX]
mov <yield_run_5470+9> <esp+1>
inc esp
ex_func AX "iter" <yield_run_5470+3>
push AX
fetch AX <esp+1>
$jmp 5569 "f"
mov <yield_run_5470+10> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <yield_run_5470+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5470+0>.push
jmp 5558
inc esp
push None
mov <yield_run_5470+11> <esp+1>
inc esp
push False
mov <yield_run_5470+12> <esp+1>
inc esp
finally 5605
try 5599
push <yield_run_5470+5>
push <yield_run_5470+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "yield run"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5470+0>.__run
push AX
mov <yield_run_5470+13> <esp+1>
inc esp
push True
mov <yield_run_5470+12> <esp+1>
inc esp
try "end"
jmp 5600    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5603 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5605    ;¸õ¨ìfinally
push None
push 0
finally -5605
push $Exception
mov $Exception 0
push <yield_run_5470+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
cmp <yield_run_5470+12> 1
$jmp 5623 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <yield_run_5470+0>.data
mov BX 0
pop AX
push AX[BX]
mov <yield_run_5470+11> <esp+1>
inc esp
jmp 5623        ;¸õ¦Ü©³³¡
push [0]
mov <yield_run_5470+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <yield_run_5470+9>
push <yield_run_5470+0>.data
mov BX <yield_run_5470+0>.$$esp
pop AX
oper <esp+1> "-" AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 5658 "f"
mov <yield_run_5470+15> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] 0
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5470+0>.pop
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <yield_run_5470+14>.insert
jmp 5640
inc esp
ex_func AX "iter" <yield_run_5470+7>
push AX
fetch AX <esp+1>
$jmp 5674 "f"
mov <yield_run_5470+8> AX
push <yield_run_5470+7>
mov BX <yield_run_5470+8>
pop AX
push AX[BX]
push <yield_run_5470+0>.func_stack
mov BX <yield_run_5470+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5661
inc esp
push <yield_run_5470+6>
push <yield_run_5470+0>.data
mov BX <yield_run_5470+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5688 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push (4)
mov <esp+1>[0] <yield_run_5470+13>
mov <esp+1>[1] <yield_run_5470+14>
mov <esp+1>[2] <yield_run_5470+11>
mov <esp+1>[3] <yield_run_5470+9>
pop AX
jmp 5697         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "yield_run_5470" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
pop ip
Function BX 5703 <Executer^11> "func_run_5703" 14
mov <Executer^11>.func_run BX
jmp 5935           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5711 "!="
tf <esp+2> "in" "$$ip"
$jmp 5713 "t"
mov <esp+2>["$$ip"] None
jmp 5713
mov <esp+2>["$$ip"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 5719 "!="
tf <esp+2> "in" "class_obj"
$jmp 5721 "t"
mov <esp+2>["class_obj"] None
jmp 5721
mov <esp+2>["class_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 5727 "!="
tf <esp+2> "in" "stack_name"
$jmp 5729 "t"
mov <esp+2>["stack_name"] None
jmp 5729
mov <esp+2>["stack_name"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 5735 "!="
tf <esp+2> "in" "stack_len"
$jmp 5737 "t"
mov <esp+2>["stack_len"] None
jmp 5737
mov <esp+2>["stack_len"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 5743 "!="
tf <esp+2> "in" "import_funcs"
$jmp 5745 "t"
mov <esp+2>["import_funcs"] None
jmp 5745
mov <esp+2>["import_funcs"] <esp+1>[4]
dec CX
mov <func_run_5703+2> <esp+2>["$$ip"]
mov <func_run_5703+3> <esp+2>["class_obj"]
mov <func_run_5703+4> <esp+2>["stack_name"]
mov <func_run_5703+5> <esp+2>["stack_len"]
mov <func_run_5703+6> <esp+2>["import_funcs"]


push <func_run_5703+0>.data
mov BX <func_run_5703+0>.$$ip
pop AX
push AX[BX]
mov <func_run_5703+7> <esp+1>
inc esp
push <func_run_5703+0>.data
mov BX <func_run_5703+0>.$$esp
pop AX
push AX[BX]
mov <func_run_5703+8> <esp+1>
inc esp
push [dict]
mov <func_run_5703+9> <esp+1>
inc esp
ex_func AX "iter" <func_run_5703+6>
push AX
fetch AX <esp+1>
$jmp 5791 "f"
mov <func_run_5703+10> AX
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+10>
pop AX
push AX[BX]
push <func_run_5703+9>
mov BX <func_run_5703+10>
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5703+6>
mov BX <func_run_5703+10>
pop AX
push AX[BX]
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5769
inc esp
tf <func_run_5703+0>.func_stack "in" <func_run_5703+4>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 5804 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5804        ;¸õ¦Ü©³³¡
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+4>
pop AX
push AX[BX]
mov <func_run_5703+11> <esp+1>
inc esp
push [1]
mov <esp+1>[0] 0
oper <esp+1> "*" <func_run_5703+5>
mov <func_run_5703+12> <esp+1>
inc esp
push <func_run_5703+3>
push <func_run_5703+12>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5703+12>
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5703+2>
oper <esp+1> "+" 1
push <func_run_5703+0>.data
mov BX <func_run_5703+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <func_run_5703+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <func_run_5703+0>.push
push None
mov <func_run_5703+13> <esp+1>
inc esp
finally 5872
try 5866
push 1        ;Àx¦sCX
push [1]
push "Func<"
ex_func AX "str" <func_run_5703+2>
oper <esp+1> "+" AX
oper <esp+1> "+" "> run"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <func_run_5703+0>.__run
try "end"
jmp 5867    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
jmp 5870 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 5872    ;¸õ¨ìfinally
push None
push 0
finally -5872
push $Exception
mov $Exception 0
push <func_run_5703+0>.data
mov BX 0
pop AX
push AX[BX]
mov <func_run_5703+13> <esp+1>
inc esp
push <func_run_5703+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <func_run_5703+7>
push <func_run_5703+0>.data
mov BX <func_run_5703+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
push <func_run_5703+11>
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <func_run_5703+6>
push AX
fetch AX <esp+1>
$jmp 5914 "f"
mov <func_run_5703+10> AX
push <func_run_5703+9>
mov BX <func_run_5703+10>
pop AX
push AX[BX]
push <func_run_5703+0>.func_stack
mov BX <func_run_5703+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 5901
inc esp
push <func_run_5703+8>
push <func_run_5703+0>.data
mov BX <func_run_5703+0>.$$esp
pop AX
mov AX[BX] <esp+1>
inc esp
pop $Exception
pop AX
cmp AX 1
$jmp 5928 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX <func_run_5703+13>
jmp 5932         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "func_run_5703" "0,1,2,3,4,5,6,7,8,9,10,11,12,13"
pop ip
Function BX 5938 <Executer^11> "__getitem___5938" 5
mov <Executer^11>.__getitem__ BX
jmp 6643           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 5946 "!="
tf <esp+2> "in" "location"
$jmp 5948 "t"
mov <esp+2>["location"] None
jmp 5948
mov <esp+2>["location"] <esp+1>[0]
dec CX
mov <__getitem___5938+2> <esp+2>["location"]


push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 5959 "f"
mov AX True
jmp 5960
mov AX False
cmp AX 1
$jmp 5971 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 5979 "f"
mov AX True
jmp 5980
mov AX False
cmp AX 1
$jmp 6114 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__getitem___5938+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+13>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 6027 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+2>
mov BX 2
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6024 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6024        ;¸õ¦Ü©³³¡
mov AX <__getitem___5938+0>.undefined
jmp 6640
jmp 6113        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 6039 "f"
mov AX True
jmp 6040
mov AX False
cmp AX 1
$jmp 6061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push ""
push <__getitem___5938+0>.inverse_data_dict
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " is undefined"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6113        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+12>
$jmp 6073 "f"
mov AX True
jmp 6074
mov AX False
cmp AX 1
$jmp 6085 "!="
push <__getitem___5938+2>
mov BX 2
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6085 "!="
mov AX 1
jmp 6086
mov AX 0
cmp AX 1
$jmp 6097 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6113        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5938+3>
push <__getitem___5938+2>
mov BX 2
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+16>
push AX
mov <__getitem___5938+4> <esp+1>
inc esp
mov AX <__getitem___5938+4>
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 6122 "f"
mov AX True
jmp 6123
mov AX False
cmp AX 1
$jmp 6143 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 6151 "f"
mov AX True
jmp 6152
mov AX False
cmp AX 1
$jmp 6171 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.esp_stack
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 6179 "f"
mov AX True
jmp 6180
mov AX False
cmp AX 1
$jmp 6312 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.esp_stack
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
mov <__getitem___5938+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+13>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 6235 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+2>
mov BX 3
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6232 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6232        ;¸õ¦Ü©³³¡
mov AX <__getitem___5938+0>.undefined
jmp 6640
jmp 6311        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 6247 "f"
mov AX True
jmp 6248
mov AX False
cmp AX 1
$jmp 6259 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "variable is undefined"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6311        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+12>
$jmp 6271 "f"
mov AX True
jmp 6272
mov AX False
cmp AX 1
$jmp 6283 "!="
push <__getitem___5938+2>
mov BX 3
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6283 "!="
mov AX 1
jmp 6284
mov AX 0
cmp AX 1
$jmp 6295 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6311        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5938+3>
push <__getitem___5938+2>
mov BX 3
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+16>
push AX
mov <__getitem___5938+4> <esp+1>
inc esp
mov AX <__getitem___5938+4>
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 6320 "f"
mov AX True
jmp 6321
mov AX False
cmp AX 1
$jmp 6349 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.esp_stack
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
oper <esp+1> "+" AX[BX]
pop BX
pop AX
push AX[BX]
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 6357 "f"
mov AX True
jmp 6358
mov AX False
cmp AX 1
$jmp 6375 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.func_stack
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 6383 "f"
mov AX True
jmp 6384
mov AX False
cmp AX 1
$jmp 6514 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.func_stack
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__getitem___5938+3> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <&executer_33+1>
mov <esp+1>[1] <&executer_33+3>
mov <esp+1>[2] <&executer_33+13>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 6437 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+2>
mov BX 3
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6434 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6434        ;¸õ¦Ü©³³¡
mov AX <__getitem___5938+0>.undefined
jmp 6640
jmp 6513        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+0>
$jmp 6449 "f"
mov AX True
jmp 6450
mov AX False
cmp AX 1
$jmp 6461 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "this variable is undefined"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 6513        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+12>
$jmp 6473 "f"
mov AX True
jmp 6474
mov AX False
cmp AX 1
$jmp 6485 "!="
push <__getitem___5938+2>
mov BX 3
pop AX
tf <__getitem___5938+3>.vars "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 6485 "!="
mov AX 1
jmp 6486
mov AX 0
cmp AX 1
$jmp 6497 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+3>.vars
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6513        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__getitem___5938+3>
push <__getitem___5938+2>
mov BX 3
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+16>
push AX
mov <__getitem___5938+4> <esp+1>
inc esp
mov AX <__getitem___5938+4>
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 6522 "f"
mov AX True
jmp 6523
mov AX False
cmp AX 1
$jmp 6549 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___5938+0>.func_stack
push <__getitem___5938+2>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+2>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__getitem___5938+0>.data
push <__getitem___5938+2>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 10
$jmp 6557 "f"
mov AX True
jmp 6558
mov AX False
cmp AX 1
$jmp 6569 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
mov <esp+1>[0] 0
push <__getitem___5938+2>
mov BX 1
pop AX
oper <esp+1> "*" AX[BX]
pop AX
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 11
$jmp 6577 "f"
mov AX True
jmp 6578
mov AX False
cmp AX 1
$jmp 6583 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX [dict]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 12
$jmp 6591 "f"
mov AX True
jmp 6592
mov AX False
cmp AX 1
$jmp 6603 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
mov <esp+1>[0] 0
push <__getitem___5938+2>
mov BX 1
pop AX
oper <esp+1> "*" AX[BX]
pop AX
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
push <__getitem___5938+2>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 13
$jmp 6611 "f"
mov AX True
jmp 6612
mov AX False
cmp AX 1
$jmp 6639 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__getitem___5938+0>.class_objs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___5938+0>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+1>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <__getitem___5938+0>.class_objs
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]
jmp 6640
jmp 6639        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___5938" "0,1,2,3,4"
pop ip
Function BX 6646 <Executer^11> "__error_print_6646" 5
mov <Executer^11>.__error_print BX
jmp 6686           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6654 "!="
tf <esp+2> "in" "msg"
$jmp 6656 "t"
mov <esp+2>["msg"] None
jmp 6656
mov <esp+2>["msg"] <esp+1>[0]
dec CX
mov <__error_print_6646+2> <esp+2>["msg"]


push "[91m"
mov <__error_print_6646+3> <esp+1>
inc esp
push "[0m"
mov <__error_print_6646+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__error_print_6646+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__error_print_6646+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__error_print_6646+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__error_print_6646" "0,1,2,3,4"
pop ip
Function BX 6689 <Executer^11> "__ok_print_6689" 5
mov <Executer^11>.__ok_print BX
jmp 6729           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6697 "!="
tf <esp+2> "in" "msg"
$jmp 6699 "t"
mov <esp+2>["msg"] None
jmp 6699
mov <esp+2>["msg"] <esp+1>[0]
dec CX
mov <__ok_print_6689+2> <esp+2>["msg"]


push "[92m"
mov <__ok_print_6689+3> <esp+1>
inc esp
push "[0m"
mov <__ok_print_6689+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__ok_print_6689+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__ok_print_6689+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <__ok_print_6689+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__ok_print_6689" "0,1,2,3,4"
pop ip
Function BX 6732 <Executer^11> "one_run_6732" 3
mov <Executer^11>.one_run BX
jmp 6756           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6740 "!="
tf <esp+2> "in" "comment"
$jmp 6742 "t"
mov <esp+2>["comment"] None
jmp 6742
mov <esp+2>["comment"] <esp+1>[0]
dec CX
mov <one_run_6732+2> <esp+2>["comment"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <one_run_6732+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <one_run_6732+0>.__run
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "one_run_6732" "0,1,2"
pop ip
Function BX 6759 <Executer^11> "run_6759" 7
mov <Executer^11>.run BX
jmp 6957           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6767 "!="
tf <esp+2> "in" "tf"
$jmp 6769 "t"
mov <esp+2>["tf"] 0
jmp 6769
mov <esp+2>["tf"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 6775 "!="
tf <esp+2> "in" "stack_size"
$jmp 6777 "t"
mov <esp+2>["stack_size"] 1024
jmp 6777
mov <esp+2>["stack_size"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 6783 "!="
tf <esp+2> "in" "comment"
$jmp 6785 "t"
mov <esp+2>["comment"] "normal"
jmp 6785
mov <esp+2>["comment"] <esp+1>[2]
dec CX
mov <run_6759+2> <esp+2>["tf"]
mov <run_6759+3> <esp+2>["stack_size"]
mov <run_6759+4> <esp+2>["comment"]


mov AX <run_6759+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.parse_code
push 0        ;Àx¦sCX
push [0]
push [dict]
mov BX "start_row"
mov <esp+1>[BX] 0
mov BX "reset"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <run_6759+0>.codes <esp+1>[0]
mov <run_6759+0>.data <esp+1>[1]
mov <run_6759+0>.data_dict <esp+1>[2]
inc esp
push [dict]
mov <run_6759+0>.inverse_data_dict <esp+1>
inc esp
ex_func AX "iter" <run_6759+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 6827 "f"
mov <run_6759+5> AX
push <run_6759+5>
push <run_6759+0>.inverse_data_dict
push <run_6759+0>.data_dict
mov BX <run_6759+5>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 6814
inc esp
push <run_6759+3>
mov <run_6759+0>.stack_size <esp+1>
inc esp
push [1]
mov <esp+1>[0] 0
oper <esp+1> "*" <run_6759+3>
mov <run_6759+0>.esp_stack <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "esp"
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6759+0>.set
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "ip"
mov <esp+1>[1] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6759+0>.set
push <run_6759+0>.data_dict
mov BX "esp"
pop AX
push AX[BX]
mov <run_6759+0>.$$esp <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "ip"
pop AX
push AX[BX]
mov <run_6759+0>.$$ip <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "ZR"
pop AX
push AX[BX]
mov <run_6759+0>.$$ZR <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "TF"
pop AX
push AX[BX]
mov <run_6759+0>.$$TF <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "$Exception"
pop AX
push AX[BX]
mov <run_6759+0>.ER <esp+1>
inc esp
push 0
push <run_6759+0>.data
mov BX <run_6759+0>.ER
pop AX
mov AX[BX] <esp+1>
inc esp
push 0
mov <run_6759+0>.error_line <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "*args"
pop AX
push AX[BX]
mov <run_6759+0>.args_location <esp+1>
inc esp
push <run_6759+0>.data_dict
mov BX "**kwargs"
pop AX
push AX[BX]
mov <run_6759+0>.kwargs_location <esp+1>
inc esp
push [0]
mov <run_6759+0>.class_objs <esp+1>
inc esp
push [dict]
mov <run_6759+0>.func_stack <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
push AX
mov <run_6759+0>.undefined <esp+1>
inc esp
ex_func AX "iter" <run_6759+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 6943 "f"
mov <run_6759+6> AX
tf <run_6759+0>.ex_function "in" <run_6759+6>
mov AX TF
cmp AX 1
$jmp 6942 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <run_6759+0>.ex_function
mov BX <run_6759+6>
pop AX
push AX[BX]
push <run_6759+0>.data
push <run_6759+0>.data_dict
mov BX <run_6759+6>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 6942        ;¸õ¦Ü©³³¡
jmp 6922
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] 0
mov <esp+1>[1] <run_6759+2>
mov <esp+1>[2] <run_6759+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <run_6759+0>.normal_run
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "run_6759" "0,1,2,3,4,5,6"
pop ip
Function BX 6960 <Executer^11> "REPL_run_6960" 5
mov <Executer^11>.REPL_run BX
jmp 7075           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 6968 "!="
tf <esp+2> "in" "row"
$jmp 6970 "t"
mov <esp+2>["row"] None
jmp 6970
mov <esp+2>["row"] <esp+1>[0]
dec CX
mov <REPL_run_6960+2> <esp+2>["row"]


mov DX <REPL_run_6960+2>
tf DX "equ" 0
$jmp 6978 "f"
mov AX True
jmp 6979
mov AX False
cmp AX 1
$jmp 6993 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] 0
mov <esp+1>[1] 1024
push [dict]
mov BX "comment"
mov <esp+1>[BX] "REPL"
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <REPL_run_6960+0>.run
jmp 7067        ;¸õ¦Ü©³³¡
push None
push <REPL_run_6960+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <REPL_run_6960+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.parse_code
push 0        ;Àx¦sCX
push [0]
push [dict]
mov BX "start_row"
mov <esp+1>[BX] <REPL_run_6960+2>
mov BX "reset"
mov <esp+1>[BX] False
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <REPL_run_6960+0>.codes <esp+1>[0]
mov <REPL_run_6960+0>.data <esp+1>[1]
mov <REPL_run_6960+0>.data_dict <esp+1>[2]
inc esp
ex_func AX "iter" <REPL_run_6960+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 7041 "f"
mov <REPL_run_6960+3> AX
tf <REPL_run_6960+0>.ex_function "in" <REPL_run_6960+3>
mov AX TF
cmp AX 1
$jmp 7040 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <REPL_run_6960+0>.ex_function
mov BX <REPL_run_6960+3>
pop AX
push AX[BX]
push <REPL_run_6960+0>.data
push <REPL_run_6960+0>.data_dict
mov BX <REPL_run_6960+3>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 7040        ;¸õ¦Ü©³³¡
jmp 7020
inc esp
ex_func AX "iter" <REPL_run_6960+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 7057 "f"
mov <REPL_run_6960+4> AX
push <REPL_run_6960+4>
push <REPL_run_6960+0>.inverse_data_dict
push <REPL_run_6960+0>.data_dict
mov BX <REPL_run_6960+4>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 7044
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <REPL_run_6960+2>
mov <esp+1>[1] 0
mov <esp+1>[2] "REPL"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <REPL_run_6960+0>.normal_run
push <REPL_run_6960+0>.data
mov BX 0
pop AX
mov AX AX[BX]
jmp 7072         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "REPL_run_6960" "0,1,2,3,4"
pop ip
Function BX 7078 <Executer^11> "normal_run_7078" 8
mov <Executer^11>.normal_run BX
jmp 7348           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 7086 "!="
tf <esp+2> "in" "row"
$jmp 7088 "t"
mov <esp+2>["row"] None
jmp 7088
mov <esp+2>["row"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 7094 "!="
tf <esp+2> "in" "tf"
$jmp 7096 "t"
mov <esp+2>["tf"] None
jmp 7096
mov <esp+2>["tf"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 7102 "!="
tf <esp+2> "in" "comment"
$jmp 7104 "t"
mov <esp+2>["comment"] "normal"
jmp 7104
mov <esp+2>["comment"] <esp+1>[2]
dec CX
mov <normal_run_7078+2> <esp+2>["row"]
mov <normal_run_7078+3> <esp+2>["tf"]
mov <normal_run_7078+4> <esp+2>["comment"]


push <normal_run_7078+3>
mov <normal_run_7078+0>.tf <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "esp"
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.set
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "ip"
mov <esp+1>[1] <normal_run_7078+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.set
finally 7335
try 7186
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <normal_run_7078+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__run
push <normal_run_7078+0>.data
mov BX <normal_run_7078+0>.$$esp
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 7150 "f"
mov AX True
jmp 7151
mov AX False
cmp AX 1
$jmp 7170 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <normal_run_7078+3>
cmp DX 0
$jmp 7158 "<="
mov AX True
jmp 7159
mov AX False
cmp AX 1
$jmp 7169 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\nµ{¦¡µ²§ô--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__ok_print
jmp 7169        ;¸õ¦Ü©³³¡
jmp 7184        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "µ{¦¡Äµ§i:°ïÅ|¥¼ÁÙ­ì---------->   "
push <normal_run_7078+0>.data
mov BX <normal_run_7078+0>.$$esp
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__error_print
try "end"
jmp 7330    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 7329 "f"
mov e $Exception
mov $Exception 0
try 7333
push <normal_run_7078+0>.data
mov BX <normal_run_7078+0>.ER
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 7199 "f"
mov AX True
jmp 7200
mov AX False
cmp AX 1
$jmp 7209 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <normal_run_7078+0>.data
mov BX <normal_run_7078+0>.$$ip
pop AX
push AX[BX]
mov <normal_run_7078+5> <esp+1>
inc esp
jmp 7212        ;¸õ¦Ü©³³¡
push <normal_run_7078+0>.error_line
mov <normal_run_7078+5> <esp+1>
inc esp
mov DX <normal_run_7078+4>
tf DX "equ" "REPL"
$jmp 7217 "t"
mov AX True
jmp 7218
mov AX False
cmp AX 1
$jmp 7270 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <normal_run_7078+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.get_error_msg
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <normal_run_7078+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <normal_run_7078+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "\nTrackback:\nFILE: "
push <normal_run_7078+6>
mov BX "file"
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" ",  line:"
push 1        ;Àx¦sCX
push [1]
push <normal_run_7078+6>
mov BX "row"
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__error_print
push 1        ;Àx¦sCX
push [1]
push "   "
push <normal_run_7078+6>
mov BX "code"
pop AX
oper <esp+1> "+" AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__error_print
jmp 7270        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <normal_run_7078+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <normal_run_7078+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 7292 "<="
mov AX True
jmp 7293
mov AX False
cmp AX 1
$jmp 7300 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push ": "
oper <esp+1> "+" <normal_run_7078+7>
mov <normal_run_7078+7> <esp+1>
inc esp
jmp 7300        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] e
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+4>
push AX
oper <esp+1> "+" <normal_run_7078+7>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <normal_run_7078+0>.__error_print
mov DX <normal_run_7078+3>
cmp DX 0
$jmp 7321 "<="
mov AX True
jmp 7322
mov AX False
cmp AX 1
$jmp 7327 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX e
raise AX
jmp 7327        ;¸õ¦Ü©³³¡
try "end"
jmp 7330  ;¸õ¨ìpush 1
jmp 7333 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 7335    ;¸õ¨ìfinally
push None
push 0
finally -7335
pop AX
cmp AX 1
$jmp 7342 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "normal_run_7078" "0,1,2,3,4,5,6,7"
pop ip
Function BX 7351 <Executer^11> "__run_7351" 54
mov <Executer^11>.__run BX
jmp 10924           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 7359 "!="
tf <esp+2> "in" "run_comment"
$jmp 7361 "t"
mov <esp+2>["run_comment"] None
jmp 7361
mov <esp+2>["run_comment"] <esp+1>[0]
dec CX
mov <__run_7351+2> <esp+2>["run_comment"]


mov AX <__run_7351+0>.run_layer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
Function <__run_7351+3> 7376 None "obj_lock_7376" 3 "__run_7351"
jmp 7403           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 7384 "!="
tf <esp+2> "in" "lock"
$jmp 7386 "t"
mov <esp+2>["lock"] None
jmp 7386
mov <esp+2>["lock"] <esp+1>[0]
dec CX
mov <obj_lock_7376+1> <esp+2>["lock"]


ex_func AX "iter" <__run_7351+0>.class_objs
push AX
fetch AX <esp+1>
$jmp 7398 "f"
mov <obj_lock_7376+2> AX
push <obj_lock_7376+1>
mov <obj_lock_7376+2>.print_lock <esp+1>
inc esp
jmp 7391
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "obj_lock_7376" "0,1,2"
pop ip
Function <__run_7351+4> 7405 None "cpu_state_7405" 8 "__run_7351"
jmp 7680           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "data: "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
ex_func AX "iter" <__run_7351+0>.data_dict
push AX
fetch AX <esp+1>
$jmp 7545 "f"
mov <cpu_state_7405+1> AX
push "\"0123456789-"
oper <esp+1> "+" "'"
push <cpu_state_7405+1>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7449 "!="
push (3)
mov <esp+1>[0] "None"
mov <esp+1>[1] "True"
mov <esp+1>[2] "False"
mov BX <cpu_state_7405+1>
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7449 "!="
mov AX 1
jmp 7450
mov AX 0
cmp AX 1
$jmp 7459 "!="
tf <__run_7351+0>.ex_function "in" <cpu_state_7405+1>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 7459 "!="
mov AX 1
jmp 7460
mov AX 0
cmp AX 1
$jmp 7486 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <cpu_state_7405+1>
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
push <__run_7351+0>.data
push <__run_7351+0>.data_dict
mov BX <cpu_state_7405+1>
pop AX
mov BX AX[BX]
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
push [dict]
mov BX "end"
mov <esp+1>[BX] "  "
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7486        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "TF"
mov <esp+1>[1] "**kwargs"
mov BX <cpu_state_7405+1>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 7506 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7506        ;¸õ¦Ü©³³¡
mov DX <cpu_state_7405+1>
tf DX "equ" "$Exception"
$jmp 7511 "f"
mov AX True
jmp 7512
mov AX False
cmp AX 1
$jmp 7525 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7525        ;¸õ¦Ü©³³¡
mov DX <cpu_state_7405+1>
tf DX "equ" "$Inheritance"
$jmp 7530 "f"
mov AX True
jmp 7531
mov AX False
cmp AX 1
$jmp 7544 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n¦Û¥ÑÅÜ¼Æ:\n      "
push [dict]
mov BX "end"
mov <esp+1>[BX] ""
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7544        ;¸õ¦Ü©³³¡
jmp 7421
inc esp
push "\n\nstack:["
mov <cpu_state_7405+2> <esp+1>
inc esp
push 7
mov <cpu_state_7405+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 25
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 7620 "f"
mov <cpu_state_7405+4> AX
push <__run_7351+0>.esp_stack
mov AX <cpu_state_7405+4>
$oper AX "-"
push AX
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <cpu_state_7405+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <cpu_state_7405+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
oper <esp+1> "+" ","
mov <cpu_state_7405+6> <esp+1>
inc esp
push <cpu_state_7405+4>
oper <esp+1> "+" 1
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call abs
pop DX
cmp DX AX
$jmp 7602 ">="
mov AX True
jmp 7603
mov AX False
cmp AX 1
$jmp 7616 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <cpu_state_7405+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
$mov <cpu_state_7405+3> "+" <esp+1>
inc esp
jmp 7616        ;¸õ¦Ü©³³¡
push <cpu_state_7405+6>
$mov <cpu_state_7405+2> "+" <esp+1>
inc esp
jmp 7561
inc esp
push 1        ;Àx¦sCX
push [1]
push <cpu_state_7405+2>
push [3]
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
push " "
oper <esp+1> "*" <cpu_state_7405+3>
oper <esp+1> "+" "^"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
ex_func AX "iter" <__run_7351+0>.func_stack
push AX
fetch AX <esp+1>
$jmp 7675 "f"
mov <cpu_state_7405+7> AX
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <cpu_state_7405+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ": "
push <__run_7351+0>.func_stack
mov BX <cpu_state_7405+7>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7654
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "cpu_state_7405" "0,1,2,3,4,5,6,7"
pop ip
Function <__run_7351+5> 7682 None "get_status_7682" 2 "__run_7351"
jmp 7785           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+3>
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <get_status_7682+1> <esp+1>
inc esp
mov AX <__run_7351+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.display
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_status_7682+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+4>
push 1        ;Àx¦sCX
push [1]
push "run_layer:"
ex_func AX "str" <__run_7351+0>.run_layer
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push <get_status_7682+1>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+0>.codes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 7739 ">="
mov AX True
jmp 7740
mov AX False
cmp AX 1
$jmp 7767 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] "\n·Ç³Æ°õ¦æ:"
mov AX <__run_7351+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov BX <get_status_7682+1>
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] "                  ¹ïÀ³:"
push <__run_7351+0>.codes
mov BX <get_status_7682+1>
pop AX
mov <esp+1>[3] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "-------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7774        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "µ{§Ç¤wµ²§ô\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+3>
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_status_7682" "0,1"
pop ip
push <__run_7351+0>.$$ip
mov <__run_7351+6> <esp+1>
inc esp
push <__run_7351+0>.$$esp
mov <__run_7351+7> <esp+1>
inc esp
push <__run_7351+0>.$$ZR
mov <__run_7351+8> <esp+1>
inc esp
push <__run_7351+0>.$$TF
mov <__run_7351+9> <esp+1>
inc esp
push <__run_7351+0>.ER
mov <__run_7351+10> <esp+1>
inc esp
push <__run_7351+0>.args_location
mov <__run_7351+11> <esp+1>
inc esp
push <__run_7351+0>.kwargs_location
mov <__run_7351+12> <esp+1>
inc esp
push [0]
mov <__run_7351+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+0>.codes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <__run_7351+14> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov DX AX[BX]
cmp DX <__run_7351+14>
$jmp 7827 ">="
mov AX True
jmp 7828
mov AX False
cmp AX 1
$jmp 10905 "!="
push <__run_7351+0>.codes
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+15> <esp+1>
inc esp
mov DX <__run_7351+0>.tf
tf DX "equ" 1
$jmp 7844 "f"
mov AX True
jmp 7845
mov AX False
cmp AX 1
$jmp 7920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+5>
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call input
push AX
mov <__run_7351+16> <esp+1>
inc esp
mov DX <__run_7351+16>
tf DX "equ" ""
$jmp 7867 "t"
mov AX True
jmp 7868
mov AX False
cmp AX 1
$jmp 7919 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 7882 ">="
mov AX True
jmp 7883
mov AX False
cmp AX 1
$jmp 7889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0.5
mov <__run_7351+0>.tf <esp+1>
inc esp
jmp 7918        ;¸õ¦Ü©³³¡
mov DX <__run_7351+16>
tf DX "equ" "asd"
$jmp 7894 "f"
mov AX True
jmp 7895
mov AX False
cmp AX 1
$jmp 7908 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "°»¿ù!!--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 0.1
mov <__run_7351+0>.tf <esp+1>
inc esp
jmp 7918        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "µ{¦¡¶}©l--------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+0>.__ok_print
push 0
mov <__run_7351+0>.tf <esp+1>
inc esp
jmp 7919        ;¸õ¦Ü©³³¡
jmp 7920        ;¸õ¦Ü©³³¡
mov DX <__run_7351+0>.tf
tf DX "equ" 0.1
$jmp 7925 "f"
mov AX True
jmp 7926
mov AX False
cmp AX 1
$jmp 7964 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <__run_7351+17> <esp+1>
inc esp
push " "
oper <esp+1> "*" 60
mov AX <__run_7351+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.comments
mov BX <__run_7351+17>
pop AX
oper <esp+1> "+" AX[BX]
push "\r       "
mov AX <__run_7351+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov BX <__run_7351+17>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\r"
ex_func AX "str" <__run_7351+17>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
oper <esp+1> "+" AX
mov <__run_7351+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 7964        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 7972 "f"
mov AX True
jmp 7973
mov AX False
cmp AX 1
$jmp 7991 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 7999 "f"
mov AX True
jmp 8000
mov AX False
cmp AX 1
$jmp 8300 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+19> <esp+1>
inc esp
mov DX <__run_7351+19>
tf DX "equ" 0
$jmp 8016 "f"
mov AX True
jmp 8017
mov AX False
cmp AX 1
$jmp 8035 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 1
$jmp 8040 "f"
mov AX True
jmp 8041
mov AX False
cmp AX 1
$jmp 8059 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 2
$jmp 8064 "f"
mov AX True
jmp 8065
mov AX False
cmp AX 1
$jmp 8083 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "*" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 3
$jmp 8088 "f"
mov AX True
jmp 8089
mov AX False
cmp AX 1
$jmp 8107 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "/" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 4
$jmp 8112 "f"
mov AX True
jmp 8113
mov AX False
cmp AX 1
$jmp 8131 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "**" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 5
$jmp 8136 "f"
mov AX True
jmp 8137
mov AX False
cmp AX 1
$jmp 8155 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "%" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 6
$jmp 8160 "f"
mov AX True
jmp 8161
mov AX False
cmp AX 1
$jmp 8179 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "//" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 7
$jmp 8184 "f"
mov AX True
jmp 8185
mov AX False
cmp AX 1
$jmp 8203 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "<<" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 8
$jmp 8208 "f"
mov AX True
jmp 8209
mov AX False
cmp AX 1
$jmp 8227 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] ">>" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 9
$jmp 8232 "f"
mov AX True
jmp 8233
mov AX False
cmp AX 1
$jmp 8251 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "&" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 10
$jmp 8256 "f"
mov AX True
jmp 8257
mov AX False
cmp AX 1
$jmp 8275 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "^" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 11
$jmp 8280 "f"
mov AX True
jmp 8281
mov AX False
cmp AX 1
$jmp 8299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "|" <esp+1>
inc esp
jmp 8299        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 8308 "f"
mov AX True
jmp 8309
mov AX False
cmp AX 1
$jmp 8693 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+19> <esp+1>
inc esp
mov DX <__run_7351+19>
tf DX "equ" 0
$jmp 8325 "f"
mov AX True
jmp 8326
mov AX False
cmp AX 1
$jmp 8351 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "+" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 1
$jmp 8356 "f"
mov AX True
jmp 8357
mov AX False
cmp AX 1
$jmp 8382 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "-" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 2
$jmp 8387 "f"
mov AX True
jmp 8388
mov AX False
cmp AX 1
$jmp 8413 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "*" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 3
$jmp 8418 "f"
mov AX True
jmp 8419
mov AX False
cmp AX 1
$jmp 8444 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "/" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 4
$jmp 8449 "f"
mov AX True
jmp 8450
mov AX False
cmp AX 1
$jmp 8475 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "**" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 5
$jmp 8480 "f"
mov AX True
jmp 8481
mov AX False
cmp AX 1
$jmp 8506 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "%" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 6
$jmp 8511 "f"
mov AX True
jmp 8512
mov AX False
cmp AX 1
$jmp 8537 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "//" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 7
$jmp 8542 "f"
mov AX True
jmp 8543
mov AX False
cmp AX 1
$jmp 8568 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "<<" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 8
$jmp 8573 "f"
mov AX True
jmp 8574
mov AX False
cmp AX 1
$jmp 8599 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> ">>" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 9
$jmp 8604 "f"
mov AX True
jmp 8605
mov AX False
cmp AX 1
$jmp 8630 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "&" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 10
$jmp 8635 "f"
mov AX True
jmp 8636
mov AX False
cmp AX 1
$jmp 8661 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "^" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 11
$jmp 8666 "f"
mov AX True
jmp 8667
mov AX False
cmp AX 1
$jmp 8692 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "|" AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8692        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 3
$jmp 8701 "f"
mov AX True
jmp 8702
mov AX False
cmp AX 1
$jmp 8724 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
oper <esp+1> "-" AX[BX]
push <__run_7351+0>.data
mov BX <__run_7351+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 4
$jmp 8732 "f"
mov AX True
jmp 8733
mov AX False
cmp AX 1
$jmp 8748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 5
$jmp 8756 "f"
mov AX True
jmp 8757
mov AX False
cmp AX 1
$jmp 8995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+19> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+8>
pop AX
push AX[BX]
mov <__run_7351+20> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
push AX[BX]
mov <__run_7351+21> <esp+1>
inc esp
mov DX <__run_7351+19>
tf DX "equ" "=="
$jmp 8785 "f"
mov AX True
jmp 8786
mov AX False
cmp AX 1
$jmp 8798 "!="
mov DX <__run_7351+20>
tf DX "equ" 0
$jmp 8793 "f"
mov AX True
jmp 8794
mov AX False
cmp AX 1
$jmp 8798 "!="
mov AX 1
jmp 8799
mov AX 0
cmp AX 1
$jmp 8824 "=="
mov DX <__run_7351+19>
tf DX "equ" "!="
$jmp 8806 "f"
mov AX True
jmp 8807
mov AX False
cmp AX 1
$jmp 8819 "!="
mov DX <__run_7351+20>
tf DX "equ" 0
$jmp 8814 "t"
mov AX True
jmp 8815
mov AX False
cmp AX 1
$jmp 8819 "!="
mov AX 1
jmp 8820
mov AX 0
cmp AX 1
$jmp 8824 "=="
mov AX 0
jmp 8825
mov AX 1
cmp AX 1
$jmp 8850 "=="
mov DX <__run_7351+19>
tf DX "equ" ">="
$jmp 8832 "f"
mov AX True
jmp 8833
mov AX False
cmp AX 1
$jmp 8845 "!="
mov DX <__run_7351+20>
cmp DX 0
$jmp 8840 "<"
mov AX True
jmp 8841
mov AX False
cmp AX 1
$jmp 8845 "!="
mov AX 1
jmp 8846
mov AX 0
cmp AX 1
$jmp 8850 "=="
mov AX 0
jmp 8851
mov AX 1
cmp AX 1
$jmp 8876 "=="
mov DX <__run_7351+19>
tf DX "equ" "<="
$jmp 8858 "f"
mov AX True
jmp 8859
mov AX False
cmp AX 1
$jmp 8871 "!="
mov DX <__run_7351+20>
cmp DX 0
$jmp 8866 ">"
mov AX True
jmp 8867
mov AX False
cmp AX 1
$jmp 8871 "!="
mov AX 1
jmp 8872
mov AX 0
cmp AX 1
$jmp 8876 "=="
mov AX 0
jmp 8877
mov AX 1
cmp AX 1
$jmp 8902 "=="
mov DX <__run_7351+19>
tf DX "equ" ">"
$jmp 8884 "f"
mov AX True
jmp 8885
mov AX False
cmp AX 1
$jmp 8897 "!="
mov DX <__run_7351+20>
cmp DX 0
$jmp 8892 "<="
mov AX True
jmp 8893
mov AX False
cmp AX 1
$jmp 8897 "!="
mov AX 1
jmp 8898
mov AX 0
cmp AX 1
$jmp 8902 "=="
mov AX 0
jmp 8903
mov AX 1
cmp AX 1
$jmp 8928 "=="
mov DX <__run_7351+19>
tf DX "equ" "<"
$jmp 8910 "f"
mov AX True
jmp 8911
mov AX False
cmp AX 1
$jmp 8923 "!="
mov DX <__run_7351+20>
cmp DX 0
$jmp 8918 ">="
mov AX True
jmp 8919
mov AX False
cmp AX 1
$jmp 8923 "!="
mov AX 1
jmp 8924
mov AX 0
cmp AX 1
$jmp 8928 "=="
mov AX 0
jmp 8929
mov AX 1
cmp AX 1
$jmp 8944 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8994        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" "t"
$jmp 8949 "f"
mov AX True
jmp 8950
mov AX False
cmp AX 1
$jmp 8956 "!="
cmp <__run_7351+21> 1
$jmp 8956 "!="
mov AX 1
jmp 8957
mov AX 0
cmp AX 1
$jmp 8978 "=="
mov DX <__run_7351+19>
tf DX "equ" "f"
$jmp 8964 "f"
mov AX True
jmp 8965
mov AX False
cmp AX 1
$jmp 8973 "!="
mov AX <__run_7351+21>
$oper AX "not"
cmp AX 1
$jmp 8973 "!="
mov AX 1
jmp 8974
mov AX 0
cmp AX 1
$jmp 8978 "=="
mov AX 0
jmp 8979
mov AX 1
cmp AX 1
$jmp 8994 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 8994        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 6
$jmp 9003 "f"
mov AX True
jmp 9004
mov AX False
cmp AX 1
$jmp 9188 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+22> <esp+1>
inc esp
mov DX <__run_7351+22>
tf DX "equ" None
$jmp 9020 "f"
mov AX True
jmp 9021
mov AX False
cmp AX 1
$jmp 9033 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+15>
mov BX 1
pop AX
push AX[BX]
mov BX 3
pop AX
push AX[BX]
mov <__run_7351+22> <esp+1>
inc esp
jmp 9033        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+22>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&executer_33+2>
$jmp 9045 "f"
mov AX True
jmp 9046
mov AX False
cmp AX 1
$jmp 9076 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.data
mov BX <__run_7351+11>
pop AX
push AX[BX]
mov <__run_7351+23> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+12>
pop AX
push AX[BX]
mov <__run_7351+24> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7351+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7351+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+22>
jmp 9187        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+22>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 9088 "f"
mov AX True
jmp 9089
mov AX False
cmp AX 1
$jmp 9142 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.data
mov BX <__run_7351+11>
pop AX
push AX[BX]
mov <__run_7351+23> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+12>
pop AX
push AX[BX]
mov <__run_7351+24> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <__run_7351+25> <esp+1>
inc esp
push <__run_7351+0>.ex_function
mov BX <__run_7351+22>
pop AX
push AX[BX]
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7351+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7351+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7351+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7351+25>
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9187        ;¸õ¦Ü©³³¡
push <__run_7351+0>.data
mov BX <__run_7351+11>
pop AX
push AX[BX]
mov <__run_7351+23> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+12>
pop AX
push AX[BX]
mov <__run_7351+24> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+0>.$$ip
pop AX
push AX[BX]
mov <__run_7351+25> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
ex_func AX "list" <__run_7351+23>
ex_func BX "len" AX
$mov <esp+2> "+" BX
$mov <esp+1> "+" AX
push [dict]
mov *args [1]
mov *args[0] <__run_7351+24>
mov **kwargs [dict]
call <esp+1>.update
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+22>
push AX
push <__run_7351+0>.data
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7351+25>
push <__run_7351+0>.data
mov BX <__run_7351+0>.$$ip
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 7
$jmp 9196 "f"
mov AX True
jmp 9197
mov AX False
cmp AX 1
$jmp 9221 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>.esp_stack
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 8
$jmp 9229 "f"
mov AX True
jmp 9230
mov AX False
cmp AX 1
$jmp 9254 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7351+0>.esp_stack
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 9
$jmp 9262 "f"
mov AX True
jmp 9263
mov AX False
cmp AX 1
$jmp 9400 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+26> <esp+1>
inc esp
mov DX <__run_7351+26>
tf DX "equ" 0
$jmp 9279 "f"
mov AX True
jmp 9280
mov AX False
cmp AX 1
$jmp 9304 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov DX AX[BX]
pop BX
pop AX
tf AX[BX] "in" DX
push TF
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9399        ;¸õ¦Ü©³³¡
mov DX <__run_7351+26>
tf DX "equ" 1
$jmp 9309 "f"
mov AX True
jmp 9310
mov AX False
cmp AX 1
$jmp 9338 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 9330 "f"
mov AX True
jmp 9331
mov AX False
push AX
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9399        ;¸õ¦Ü©³³¡
mov DX <__run_7351+26>
tf DX "equ" 2
$jmp 9343 "f"
mov AX True
jmp 9344
mov AX False
cmp AX 1
$jmp 9369 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
tf AX.vars "in" BX
push TF
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9399        ;¸õ¦Ü©³³¡
mov DX <__run_7351+26>
tf DX "equ" 3
$jmp 9374 "f"
mov AX True
jmp 9375
mov AX False
cmp AX 1
$jmp 9399 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov DX AX[BX]
pop BX
pop AX
tf AX[BX] "is" DX
push TF
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9399        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 10
$jmp 9408 "f"
mov AX True
jmp 9409
mov AX False
cmp AX 1
$jmp 9421 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 11
$jmp 9429 "f"
mov AX True
jmp 9430
mov AX False
cmp AX 1
$jmp 9442 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
$mov AX[BX] "-" <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 12
$jmp 9450 "f"
mov AX True
jmp 9451
mov AX False
cmp AX 1
$jmp 9575 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+19> <esp+1>
inc esp
mov DX <__run_7351+19>
tf DX "equ" 0
$jmp 9467 "f"
mov AX True
jmp 9468
mov AX False
cmp AX 1
$jmp 9522 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
finally 9512
try 9491
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "not"
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9507    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 9506 "f"
mov $Exception 0
try 9510
push False
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9507  ;¸õ¨ìpush 1
jmp 9510 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 9512    ;¸õ¨ìfinally
push None
push 0
finally -9512
pop AX
cmp AX 1
$jmp 9519 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
jmp 9574        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 1
$jmp 9527 "f"
mov AX True
jmp 9528
mov AX False
cmp AX 1
$jmp 9548 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "-"
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9574        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 2
$jmp 9553 "f"
mov AX True
jmp 9554
mov AX False
cmp AX 1
$jmp 9574 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
$oper AX "~"
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9574        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 13
$jmp 9583 "f"
mov AX True
jmp 9584
mov AX False
cmp AX 1
$jmp 9632 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <__run_7351+25> <esp+1>
inc esp
push <__run_7351+0>.ex_function
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7351+25>
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 14
$jmp 9640 "f"
mov AX True
jmp 9641
mov AX False
cmp AX 1
$jmp 9743 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+27> <esp+1>
inc esp
mov DX <__run_7351+27>
tf DX "equ" "end"
$jmp 9657 "f"
mov AX True
jmp 9658
mov AX False
cmp AX 1
$jmp 9663 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 10921
jmp 9663        ;¸õ¦Ü©³³¡
push 1
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
push AX[BX]
mov <__run_7351+28> <esp+1>
inc esp
finally 9727
try 9690
push 1        ;Àx¦sCX
push [1]
push "try "
ex_func AX "str" <__run_7351+27>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+0>.__run
try "end"
jmp 9722    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 9721 "f"
mov e $Exception
mov $Exception 0
try 9725
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <__run_7351+0>.error_line <esp+1>
inc esp
push <__run_7351+28>
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push e
push <__run_7351+0>.data
mov BX <__run_7351+10>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7351+27>
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 9722  ;¸õ¨ìpush 1
jmp 9725 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 9727    ;¸õ¨ìfinally
push None
push 0
finally -9727
pop AX
cmp AX 1
$jmp 9734 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <__run_7351+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 15
$jmp 9751 "f"
mov AX True
jmp 9752
mov AX False
cmp AX 1
$jmp 9777 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+29> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <__run_7351+29>
push <__run_7351+0>.data
mov BX <__run_7351+0>.$$esp
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+13>.append
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 16
$jmp 9785 "f"
mov AX True
jmp 9786
mov AX False
cmp AX 1
$jmp 9797 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
raise AX
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 17
$jmp 9805 "f"
mov AX True
jmp 9806
mov AX False
cmp AX 1
$jmp 9899 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+30> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" list
$jmp 9829 "f"
mov AX True
jmp 9830
mov AX False
cmp AX 1
$jmp 9861 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <__run_7351+30> "in" Exception
mov AX TF
cmp AX 1
$jmp 9843 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9860        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>.data
mov BX <__run_7351+10>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
tf <__run_7351+30> "in" AX
push TF
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9898        ;¸õ¦Ü©³³¡
mov DX <__run_7351+30>
tf DX "equ" Exception
$jmp 9866 "f"
mov AX True
jmp 9867
mov AX False
cmp AX 1
$jmp 9876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push True
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 9898        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>.data
mov BX <__run_7351+10>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <__run_7351+30>
$jmp 9891 "f"
mov AX True
jmp 9892
mov AX False
push AX
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 18
$jmp 9907 "f"
mov AX True
jmp 9908
mov AX False
cmp AX 1
$jmp 9982 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+31> <esp+1>
inc esp
push 3
mov <__run_7351+32> <esp+1>
inc esp
push [dict]
mov <__run_7351+33> <esp+1>
inc esp
push <__run_7351+32>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 9938 ">="
mov AX True
jmp 9939
mov AX False
cmp AX 1
$jmp 9963 "!="
push <__run_7351+0>
push <__run_7351+15>
mov BX <__run_7351+32>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+34> <esp+1>
inc esp
push <__run_7351+0>.func_stack
mov BX <__run_7351+34>
pop AX
push AX[BX]
push <__run_7351+33>
mov BX <__run_7351+34>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7351+32> "+" <esp+1>
inc esp
jmp 9925               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__run_7351+0>
mov <esp+1>[1] <__run_7351+31>
mov <esp+1>[2] <__run_7351+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+3>
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 19
$jmp 9990 "f"
mov AX True
jmp 9991
mov AX False
cmp AX 1
$jmp 10026 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "finally yield run"
$jmp 10003 "f"
mov AX True
jmp 10004
mov AX False
cmp AX 1
$jmp 10015 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "Exception ignored in: <generator object>\nRuntimeError: generator ignored GeneratorExit"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 10015        ;¸õ¦Ü©³³¡
push (2)
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <__run_7351+13>
pop AX
jmp 10921
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 20
$jmp 10034 "f"
mov AX True
jmp 10035
mov AX False
cmp AX 1
$jmp 10125 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
push AX[BX]
mov <__run_7351+28> <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
push AX[BX]
mov <__run_7351+25> <esp+1>
inc esp
finally 10103
try 10084
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+35> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+35>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call next
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push True
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 10098    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error StopIteration
$jmp 10097 "f"
mov e $Exception
mov $Exception 0
try 10101
push False
push <__run_7351+0>.data
mov BX <__run_7351+9>
pop AX
mov AX[BX] <esp+1>
inc esp
try "end"
jmp 10098  ;¸õ¨ìpush 1
jmp 10101 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 10103    ;¸õ¨ìfinally
push None
push 0
finally -10103
pop AX
cmp AX 1
$jmp 10110 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <__run_7351+28>
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push <__run_7351+25>
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 21
$jmp 10133 "f"
mov AX True
jmp 10134
mov AX False
cmp AX 1
$jmp 10153 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] "ip---->"
push <__run_7351+0>.data
mov BX <__run_7351+0>.$$ip
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] "esp------>"
push <__run_7351+0>.data
mov BX <__run_7351+0>.$$esp
pop AX
mov <esp+1>[3] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 22
$jmp 10161 "f"
mov AX True
jmp 10162
mov AX False
cmp AX 1
$jmp 10290 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+36> <esp+1>
inc esp
mov DX <__run_7351+36>
tf DX "equ" "finally_yield"
$jmp 10178 "f"
mov AX True
jmp 10179
mov AX False
cmp AX 1
$jmp 10196 "!="
push <__run_7351+0>.run_layer
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "finally yield run"
$jmp 10191 "f"
mov AX True
jmp 10192
mov AX False
cmp AX 1
$jmp 10196 "!="
mov AX 1
jmp 10197
mov AX 0
cmp AX 1
$jmp 10202 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 10921
jmp 10289        ;¸õ¦Ü©³³¡
mov DX <__run_7351+36>
tf DX "equ" "Function"
$jmp 10207 "f"
mov AX True
jmp 10208
mov AX False
cmp AX 1
$jmp 10289 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+34> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 10231 "<="
mov AX True
jmp 10232
mov AX False
cmp AX 1
$jmp 10288 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7351+37> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] int
mov <esp+1>[1] <__run_7351+37>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call map
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call list
push AX
mov <__run_7351+38> <esp+1>
inc esp
ex_func AX "iter" <__run_7351+38>
push AX
fetch AX <esp+1>
$jmp 10286 "f"
mov <__run_7351+39> AX
push None
push <__run_7351+0>.func_stack
mov BX <__run_7351+34>
pop AX
push AX[BX]
mov BX <__run_7351+39>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10273
inc esp
jmp 10288        ;¸õ¦Ü©³³¡
jmp 10289        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 23
$jmp 10298 "f"
mov AX True
jmp 10299
mov AX False
cmp AX 1
$jmp 10326 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.encode
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 24
$jmp 10334 "f"
mov AX True
jmp 10335
mov AX False
cmp AX 1
$jmp 10422 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+19> <esp+1>
inc esp
mov DX <__run_7351+19>
tf DX "equ" 0
$jmp 10351 "f"
mov AX True
jmp 10352
mov AX False
cmp AX 1
$jmp 10370 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10421        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 1
$jmp 10375 "f"
mov AX True
jmp 10376
mov AX False
cmp AX 1
$jmp 10395 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
del 1 AX BX
jmp 10421        ;¸õ¦Ü©³³¡
mov DX <__run_7351+19>
tf DX "equ" 2
$jmp 10400 "f"
mov AX True
jmp 10401
mov AX False
cmp AX 1
$jmp 10421 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.vars
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov BX AX[BX]
pop AX
del 1 AX BX
jmp 10421        ;¸õ¦Ü©³³¡
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 25
$jmp 10430 "f"
mov AX True
jmp 10431
mov AX False
cmp AX 1
$jmp 10535 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+40> <esp+1>
inc esp
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+41> <esp+1>
inc esp
push <__run_7351+0>
push <__run_7351+15>
mov BX 4
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+42> <esp+1>
inc esp
push <__run_7351+0>
push <__run_7351+15>
mov BX 5
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+43> <esp+1>
inc esp
push 6
mov <__run_7351+32> <esp+1>
inc esp
push [dict]
mov <__run_7351+33> <esp+1>
inc esp
push <__run_7351+32>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__run_7351+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 10488 ">="
mov AX True
jmp 10489
mov AX False
cmp AX 1
$jmp 10513 "!="
push <__run_7351+0>
push <__run_7351+15>
mov BX <__run_7351+32>
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+34> <esp+1>
inc esp
push <__run_7351+0>.func_stack
mov BX <__run_7351+34>
pop AX
push AX[BX]
push <__run_7351+33>
mov BX <__run_7351+34>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7351+32> "+" <esp+1>
inc esp
jmp 10475               ;continue­«¨Ó
push 6        ;Àx¦sCX
push [6]
mov <esp+1>[0] <__run_7351+0>
mov <esp+1>[1] <__run_7351+40>
mov <esp+1>[2] <__run_7351+41>
mov <esp+1>[3] <__run_7351+42>
mov <esp+1>[4] <__run_7351+43>
mov <esp+1>[5] <__run_7351+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+2>
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 26
$jmp 10543 "f"
mov AX True
jmp 10544
mov AX False
cmp AX 1
$jmp 10547 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 28
$jmp 10555 "f"
mov AX True
jmp 10556
mov AX False
cmp AX 1
$jmp 10644 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7351+44> <esp+1>
inc esp
push 0
mov <__run_7351+45> <esp+1>
inc esp
push [dict]
mov <__run_7351+46> <esp+1>
inc esp
ex_func AX "iter" <__run_7351+44>
push AX
fetch AX <esp+1>
$jmp 10598 "f"
mov <__run_7351+47> AX
push <__run_7351+45>
push <__run_7351+46>
mov BX <__run_7351+47>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <__run_7351+45> "+" <esp+1>
inc esp
jmp 10585
inc esp
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+0>
mov <esp+1>[0] AX
oper <esp+1> "*" <__run_7351+45>
mov <__run_7351+48> <esp+1>
inc esp
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+49> <esp+1>
inc esp
push <__run_7351+48>
push <__run_7351+0>.func_stack
mov BX <__run_7351+49>
pop AX
mov AX[BX] <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__run_7351+0>
mov <esp+1>[1] <__run_7351+49>
mov <esp+1>[2] <__run_7351+46>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+13>
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 29
$jmp 10652 "f"
mov AX True
jmp 10653
mov AX False
cmp AX 1
$jmp 10687 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push [3]
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 30
$jmp 10695 "f"
mov AX True
jmp 10696
mov AX False
cmp AX 1
$jmp 10761 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <__run_7351+50> <esp+1>
inc esp
push <__run_7351+0>
push <__run_7351+15>
mov BX 3
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ","
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__run_7351+51> <esp+1>
inc esp
push [dict]
mov <__run_7351+52> <esp+1>
inc esp
ex_func AX "iter" <__run_7351+50>
push AX
fetch AX <esp+1>
$jmp 10750 "f"
mov <__run_7351+53> AX
tf <__run_7351+51> "in" <__run_7351+53>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 10749 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+50>
mov BX <__run_7351+53>
pop AX
push AX[BX]
push <__run_7351+52>
mov BX <__run_7351+53>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10749        ;¸õ¦Ü©³³¡
jmp 10731
inc esp
push <__run_7351+52>
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 31
$jmp 10769 "f"
mov AX True
jmp 10770
mov AX False
cmp AX 1
$jmp 10795 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+12>
push AX
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 32
$jmp 10803 "f"
mov AX True
jmp 10804
mov AX False
cmp AX 1
$jmp 10823 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.atype <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 33
$jmp 10831 "f"
mov AX True
jmp 10832
mov AX False
cmp AX 1
$jmp 10851 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__run_7351+0>
push <__run_7351+15>
mov BX 2
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.name <esp+1>
inc esp
jmp 10876        ;¸õ¦Ü©³³¡
push <__run_7351+15>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" 34
$jmp 10859 "f"
mov AX True
jmp 10860
mov AX False
cmp AX 1
$jmp 10876 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <__run_7351+0>
push <__run_7351+15>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 10876        ;¸õ¦Ü©³³¡
push 1
push <__run_7351+0>.data
mov BX <__run_7351+6>
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
push <__run_7351+0>.data
mov BX <__run_7351+7>
pop AX
mov AX AX[BX]
$oper AX "-"
mov DX AX
cmp DX <__run_7351+0>.stack_size
$jmp 10892 "<="
mov AX True
jmp 10893
mov AX False
cmp AX 1
$jmp 10904 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "maxinum recursion depth exceeded"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call RecursionError
raise AX
jmp 10904        ;¸õ¦Ü©³³¡
jmp 7819               ;continue­«¨Ó
mov DX <__run_7351+0>.tf
cmp DX 0
$jmp 10910 "<="
mov AX True
jmp 10911
mov AX False
cmp AX 1
$jmp 10920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__run_7351+5>
jmp 10920        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__run_7351" "0,1,2,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53"
pop ip
mov AX <Executer^11>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 10936 "=="
tf AX "Ctn" "__init__"
$jmp 10934 "t"
jmp 10936
call AX.__init__
mov AX <Executer^11>
end "Function" "Executer^11"
pop ip
Function <&executer_33+12> 10941 None "Ex_module^12" 1
name <&executer_33+12> "<class '__main__.Ex_module'>"
jmp 11031
tf $Inheritance "equ" None
$jmp 10946 "t"
mov <Ex_module^12> $Inheritance
push 1
jmp 10948
mov <Ex_module^12> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Ex_module^12> <&executer_33+12>
Function BX 10956 <Ex_module^12> "__init___10956" 3
mov <Ex_module^12>.__init__ BX
jmp 10982           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 10964 "!="
tf <esp+2> "in" "module_name"
$jmp 10966 "t"
mov <esp+2>["module_name"] None
jmp 10966
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <__init___10956+2> <esp+2>["module_name"]


push <__init___10956+2>
mov <__init___10956+0>.module_name <esp+1>
inc esp
push "Ex_module"
mov <__init___10956+0>.__name__ <esp+1>
inc esp
push [dict]
mov <__init___10956+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___10956" "0,1,2"
pop ip
Function BX 10985 <Ex_module^12> "__str___10985" 2
mov <Ex_module^12>.__str__ BX
jmp 10994           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX <__str___10985+0>.module_name
jmp 10991         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___10985" "0,1"
pop ip
Function BX 10997 <Ex_module^12> "__call___10997" 4
mov <Ex_module^12>.__call__ BX
jmp 11017           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
*args <esp+2>["args"] <esp+1> 0
**kwargs <esp+2>["kwargs"] <esp+2> "args"
mov <__call___10997+2> <esp+2>["args"]
mov <__call___10997+3> <esp+2>["kwargs"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "'module' object is not callable"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call TypeError
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__call___10997" "0,1,2,3"
pop ip
mov AX <Ex_module^12>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 11029 "=="
tf AX "Ctn" "__init__"
$jmp 11027 "t"
jmp 11029
call AX.__init__
mov AX <Ex_module^12>
end "Function" "Ex_module^12"
pop ip
Function <&executer_33+13> 11034 None "Namespace_stack^13" 1
name <&executer_33+13> "<class '__main__.Namespace_stack'>"
jmp 11129
tf $Inheritance "equ" None
$jmp 11039 "t"
mov <Namespace_stack^13> $Inheritance
push 1
jmp 11041
mov <Namespace_stack^13> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Namespace_stack^13> <&executer_33+13>
Function BX 11049 <Namespace_stack^13> "__init___11049" 5
mov <Namespace_stack^13>.__init__ BX
jmp 11099           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11057 "!="
tf <esp+2> "in" "ram"
$jmp 11059 "t"
mov <esp+2>["ram"] None
jmp 11059
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11065 "!="
tf <esp+2> "in" "stack_name"
$jmp 11067 "t"
mov <esp+2>["stack_name"] None
jmp 11067
mov <esp+2>["stack_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 11073 "!="
tf <esp+2> "in" "var_dict"
$jmp 11075 "t"
mov <esp+2>["var_dict"] None
jmp 11075
mov <esp+2>["var_dict"] <esp+1>[2]
dec CX
mov <__init___11049+2> <esp+2>["ram"]
mov <__init___11049+3> <esp+2>["stack_name"]
mov <__init___11049+4> <esp+2>["var_dict"]


push <__init___11049+3>
mov <__init___11049+0>.stack_name <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <__init___11049+2>
mov <esp+1>[1] <__init___11049+3>
mov <esp+1>[2] <__init___11049+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&executer_33+14>
push AX
mov <__init___11049+0>.vars <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___11049" "0,1,2,3,4"
pop ip
Function BX 11102 <Namespace_stack^13> "__str___11102" 2
mov <Namespace_stack^13>.__str__ BX
jmp 11115           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "module \""
ex_func AX "str" <__str___11102+0>.stack_name
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 11112         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___11102" "0,1"
pop ip
mov AX <Namespace_stack^13>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 11127 "=="
tf AX "Ctn" "__init__"
$jmp 11125 "t"
jmp 11127
call AX.__init__
mov AX <Namespace_stack^13>
end "Function" "Namespace_stack^13"
pop ip
Function <&executer_33+14> 11132 None "namespace_stack_var^14" 1
name <&executer_33+14> "<class '__main__.namespace_stack_var'>"
jmp 11339
tf $Inheritance "equ" None
$jmp 11137 "t"
mov <namespace_stack_var^14> $Inheritance
push 1
jmp 11139
mov <namespace_stack_var^14> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <namespace_stack_var^14> <&executer_33+14>
Function BX 11147 <namespace_stack_var^14> "__init___11147" 5
mov <namespace_stack_var^14>.__init__ BX
jmp 11191           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11155 "!="
tf <esp+2> "in" "ram"
$jmp 11157 "t"
mov <esp+2>["ram"] None
jmp 11157
mov <esp+2>["ram"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11163 "!="
tf <esp+2> "in" "stack_name"
$jmp 11165 "t"
mov <esp+2>["stack_name"] None
jmp 11165
mov <esp+2>["stack_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 11171 "!="
tf <esp+2> "in" "var_dict"
$jmp 11173 "t"
mov <esp+2>["var_dict"] None
jmp 11173
mov <esp+2>["var_dict"] <esp+1>[2]
dec CX
mov <__init___11147+2> <esp+2>["ram"]
mov <__init___11147+3> <esp+2>["stack_name"]
mov <__init___11147+4> <esp+2>["var_dict"]


push <__init___11147+2>
mov <__init___11147+0>.ram <esp+1>
inc esp
push <__init___11147+3>
mov <__init___11147+0>.name <esp+1>
inc esp
push <__init___11147+4>
mov <__init___11147+0>.var_dict <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___11147" "0,1,2,3,4"
pop ip
Function BX 11194 <namespace_stack_var^14> "__contains___11194" 3
mov <namespace_stack_var^14>.__contains__ BX
jmp 11213           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11202 "!="
tf <esp+2> "in" "item"
$jmp 11204 "t"
mov <esp+2>["item"] None
jmp 11204
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___11194+2> <esp+2>["item"]


tf <__contains___11194+0>.var_dict "in" <__contains___11194+2>
mov AX TF
jmp 11210         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___11194" "0,1,2"
pop ip
Function BX 11216 <namespace_stack_var^14> "__setitem___11216" 5
mov <namespace_stack_var^14>.__setitem__ BX
jmp 11294           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11224 "!="
tf <esp+2> "in" "key"
$jmp 11226 "t"
mov <esp+2>["key"] None
jmp 11226
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11232 "!="
tf <esp+2> "in" "value"
$jmp 11234 "t"
mov <esp+2>["value"] None
jmp 11234
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___11216+2> <esp+2>["key"]
mov <__setitem___11216+3> <esp+2>["value"]


tf <__setitem___11216+0>.var_dict "in" <__setitem___11216+2>
mov AX TF
cmp AX 1
$jmp 11256 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__setitem___11216+3>
mov AX <__setitem___11216+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___11216+0>.name
pop AX
push AX[BX]
push <__setitem___11216+0>.var_dict
mov BX <__setitem___11216+2>
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 11290        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov AX <__setitem___11216+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___11216+0>.name
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <__setitem___11216+4> <esp+1>
inc esp
push <__setitem___11216+4>
push <__setitem___11216+0>.var_dict
mov BX <__setitem___11216+2>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <__setitem___11216+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__setitem___11216+0>.name
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__setitem___11216+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___11216" "0,1,2,3,4"
pop ip
Function BX 11297 <namespace_stack_var^14> "__getitem___11297" 3
mov <namespace_stack_var^14>.__getitem__ BX
jmp 11325           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11305 "!="
tf <esp+2> "in" "item"
$jmp 11307 "t"
mov <esp+2>["item"] None
jmp 11307
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___11297+2> <esp+2>["item"]


mov AX <__getitem___11297+0>.ram      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.func_stack
mov BX <__getitem___11297+0>.name
pop AX
push AX[BX]
push <__getitem___11297+0>.var_dict
mov BX <__getitem___11297+2>
pop AX
mov BX AX[BX]
pop AX
mov AX AX[BX]
jmp 11322         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___11297" "0,1,2"
pop ip
mov AX <namespace_stack_var^14>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 11337 "=="
tf AX "Ctn" "__init__"
$jmp 11335 "t"
jmp 11337
call AX.__init__
mov AX <namespace_stack_var^14>
end "Function" "namespace_stack_var^14"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"]
mov <&code_28+0> <esp+1>.Undefine
inc esp
Function <&code_28+1> 11345 None "Code^6" 1
name <&code_28+1> "<class '__main__.Code'>"
jmp 14986
tf $Inheritance "equ" None
$jmp 11350 "t"
mov <Code^6> $Inheritance
push 1
jmp 11352
mov <Code^6> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Code^6> <&code_28+1>
Function BX 11360 <Code^6> "__init___11360" 2
mov <Code^6>.__init__ BX
jmp 11379           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push (2)
mov <esp+1>[0] "AX"
mov <esp+1>[1] "BX"
mov <__init___11360+0>.tem <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___11360+0>.clean
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___11360" "0,1"
pop ip
Function BX 11382 <Code^6> "clean_11382" 2
mov <Code^6>.clean BX
jmp 11416           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <clean_11382+0>.code <esp+1>
inc esp
push [0]
mov <clean_11382+0>.comments <esp+1>
inc esp
push 0
mov <clean_11382+0>.simplify <esp+1>
inc esp
push [0]
mov <clean_11382+0>.base_num <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <clean_11382+0>.base_esp <esp+1>
inc esp
push [0]
mov <clean_11382+0>.file_ed <esp+1>
inc esp
push (3)
mov <esp+1>[0] 0
mov <esp+1>[1] 0
mov <esp+1>[2] 0
mov <clean_11382+0>.base <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "clean_11382" "0,1"
pop ip
Function BX 11419 <Code^6> "__apply_file_11419" 3
mov <Code^6>.__apply_file BX
jmp 11462           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11427 "!="
tf <esp+2> "in" "name"
$jmp 11429 "t"
mov <esp+2>["name"] None
jmp 11429
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <__apply_file_11419+2> <esp+2>["name"]


tf <__apply_file_11419+0>.file_ed "in" <__apply_file_11419+2>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 11448 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <__apply_file_11419+0>.file_ed      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__apply_file_11419+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11448        ;¸õ¦Ü©³³¡
mov AX <__apply_file_11419+0>.file_ed      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.index
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__apply_file_11419+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11459         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__apply_file_11419" "0,1,2"
pop ip
Function BX 11465 <Code^6> "add_newtab_11465" 4
mov <Code^6>.add_newtab BX
jmp 11507           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11473 "!="
tf <esp+2> "in" "name"
$jmp 11475 "t"
mov <esp+2>["name"] None
jmp 11475
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <add_newtab_11465+2> <esp+2>["name"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <add_newtab_11465+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <add_newtab_11465+0>.__apply_file
push AX
mov <add_newtab_11465+3> <esp+1>
inc esp
mov AX <add_newtab_11465+0>.base_num      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <add_newtab_11465+3>
push [1]
mov <esp+1>[0] 0
pop <esp+1>[1]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_newtab_11465" "0,1,2,3"
pop ip
Function BX 11510 <Code^6> "del_newtab_11510" 2
mov <Code^6>.del_newtab BX
jmp 11524           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push <del_newtab_11510+0>.base_num
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "del_newtab_11510" "0,1"
pop ip
Function BX 11527 <Code^6> "add_tab_11527" 2
mov <Code^6>.add_tab BX
jmp 11535           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_tab_11527" "0,1"
pop ip
Function BX 11538 <Code^6> "del_tab_11538" 2
mov <Code^6>.del_tab BX
jmp 11546           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "del_tab_11538" "0,1"
pop ip
Function BX 11549 <Code^6> "get_error_msg_11549" 5
mov <Code^6>.get_error_msg BX
jmp 11643           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11557 "!="
tf <esp+2> "in" "row"
$jmp 11559 "t"
mov <esp+2>["row"] None
jmp 11559
mov <esp+2>["row"] <esp+1>[0]
dec CX
mov <get_error_msg_11549+2> <esp+2>["row"]


push <get_error_msg_11549+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_error_msg_11549+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 11575 ">="
mov AX True
jmp 11576
mov AX False
cmp AX 1
$jmp 11627 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_error_msg_11549+0>.comments
mov BX <get_error_msg_11549+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
push AX[BX]
mov <get_error_msg_11549+3> <esp+1>
inc esp
push <get_error_msg_11549+0>.comments
mov BX <get_error_msg_11549+3>
pop AX
push AX[BX]
mov <get_error_msg_11549+4> <esp+1>
inc esp
push [dict]
push "file"
push <get_error_msg_11549+0>.file_ed
push <get_error_msg_11549+4>
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
push "row"
push <get_error_msg_11549+4>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
push "code"
push <get_error_msg_11549+4>
mov BX 1
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
pop AX
jmp 11640         ;returnÂI
jmp 11640        ;¸õ¦Ü©³³¡
push [dict]
mov BX "file"
mov <esp+1>[BX] ""
mov BX "row"
mov <esp+1>[BX] <get_error_msg_11549+2>
push "code"
push <get_error_msg_11549+0>.code
mov BX <get_error_msg_11549+2>
pop AX
pop BX
mov <esp+1>[BX] AX[BX]
pop AX
jmp 11640         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_error_msg_11549" "0,1,2,3,4"
pop ip
Function BX 11646 <Code^6> "append_11646" 11
mov <Code^6>.append BX
jmp 12491           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 11654 "!="
tf <esp+2> "in" "command"
$jmp 11656 "t"
mov <esp+2>["command"] None
jmp 11656
mov <esp+2>["command"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 11662 "!="
tf <esp+2> "in" "comment"
$jmp 11664 "t"
mov <esp+2>["comment"] None
jmp 11664
mov <esp+2>["comment"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 11670 "!="
tf <esp+2> "in" "simplify"
$jmp 11672 "t"
mov <esp+2>["simplify"] 0
jmp 11672
mov <esp+2>["simplify"] <esp+1>[2]
dec CX
mov <append_11646+2> <esp+2>["command"]
mov <append_11646+3> <esp+2>["comment"]
mov <append_11646+4> <esp+2>["simplify"]


mov DX <append_11646+3>
tf DX "equ" None
$jmp 11682 "t"
mov AX True
jmp 11683
mov AX False
cmp AX 1
$jmp 11698 "!="
push <append_11646+3>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 11693 "t"
mov AX True
jmp 11694
mov AX False
cmp AX 1
$jmp 11698 "!="
mov AX 1
jmp 11699
mov AX 0
cmp AX 1
$jmp 11771 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+3>
mov <append_11646+5> <esp+1>[0]
mov <append_11646+6> <esp+1>[1]
inc esp
push <append_11646+6>
push <append_11646+0>.base_num
mov BX <append_11646+0>.base_esp
pop AX
push AX[BX]
mov BX 1
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <append_11646+0>.base_num
mov BX <append_11646+0>.base_esp
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call sum
push AX
mov <append_11646+7> <esp+1>
inc esp
push <append_11646+0>.base_num
mov BX <append_11646+0>.base_esp
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <append_11646+8> <esp+1>
inc esp
push (3)
mov <esp+1>[0] <append_11646+8>
mov <esp+1>[1] <append_11646+7>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[2] AX
mov <append_11646+0>.base <esp+1>
inc esp
mov AX <append_11646+0>.comments      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <append_11646+0>.base
mov <esp+1>[1] <append_11646+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11771        ;¸õ¦Ü©³³¡
mov DX <append_11646+2>
tf DX "equ" ""
$jmp 11776 "f"
mov AX True
jmp 11777
mov AX False
cmp AX 1
$jmp 11782 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX (0)
jmp 12488
jmp 11782        ;¸õ¦Ü©³³¡
mov DX <append_11646+0>.simplify
tf DX "equ" 0
$jmp 11787 "f"
mov AX True
jmp 11788
mov AX False
cmp AX 1
$jmp 11800 "!="
mov DX <append_11646+4>
tf DX "equ" 0
$jmp 11795 "f"
mov AX True
jmp 11796
mov AX False
cmp AX 1
$jmp 11800 "!="
mov AX 1
jmp 11801
mov AX 0
cmp AX 1
$jmp 11813 "!="
mov DX <append_11646+3>
tf DX "equ" None
$jmp 11808 "f"
mov AX True
jmp 11809
mov AX False
cmp AX 1
$jmp 11813 "!="
mov AX 1
jmp 11814
mov AX 0
cmp AX 1
$jmp 11833 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 11828 "<="
mov AX True
jmp 11829
mov AX False
cmp AX 1
$jmp 11833 "!="
mov AX 1
jmp 11834
mov AX 0
cmp AX 1
$jmp 11853 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 11848 "f"
mov AX True
jmp 11849
mov AX False
cmp AX 1
$jmp 11853 "!="
mov AX 1
jmp 11854
mov AX 0
cmp AX 1
$jmp 11878 "!="
push 1        ;Àx¦sCX
push [1]
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 11873 "f"
mov AX True
jmp 11874
mov AX False
cmp AX 1
$jmp 11878 "!="
mov AX 1
jmp 11879
mov AX 0
cmp AX 1
$jmp 12425 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <append_11646+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <append_11646+2>.split
push AX
mov <append_11646+10> <esp+1>
inc esp
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 11917 "f"
mov AX True
jmp 11918
mov AX False
cmp AX 1
$jmp 11933 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 11928 "f"
mov AX True
jmp 11929
mov AX False
cmp AX 1
$jmp 11933 "!="
mov AX 1
jmp 11934
mov AX 0
cmp AX 1
$jmp 11982 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 11954 "t"
mov AX True
jmp 11955
mov AX False
cmp AX 1
$jmp 11981 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11646+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <append_11646+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 11981        ;¸õ¦Ü©³³¡
jmp 12424        ;¸õ¦Ü©³³¡
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 11990 "f"
mov AX True
jmp 11991
mov AX False
cmp AX 1
$jmp 12006 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 12001 "f"
mov AX True
jmp 12002
mov AX False
cmp AX 1
$jmp 12006 "!="
mov AX 1
jmp 12007
mov AX 0
cmp AX 1
$jmp 12026 "!="
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12021 "f"
mov AX True
jmp 12022
mov AX False
cmp AX 1
$jmp 12026 "!="
mov AX 1
jmp 12027
mov AX 0
cmp AX 1
$jmp 12062 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <append_11646+9>
mov BX 1
pop AX
tf <append_11646+0>.tem "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 12061 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11646+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12061        ;¸õ¦Ü©³³¡
jmp 12424        ;¸õ¦Ü©³³¡
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12070 "f"
mov AX True
jmp 12071
mov AX False
cmp AX 1
$jmp 12086 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "push"
$jmp 12081 "f"
mov AX True
jmp 12082
mov AX False
cmp AX 1
$jmp 12086 "!="
mov AX 1
jmp 12087
mov AX 0
cmp AX 1
$jmp 12106 "!="
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12101 "f"
mov AX True
jmp 12102
mov AX False
cmp AX 1
$jmp 12106 "!="
mov AX 1
jmp 12107
mov AX 0
cmp AX 1
$jmp 12118 "!="
push <append_11646+9>
mov BX 1
pop AX
tf <append_11646+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12118 "!="
mov AX 1
jmp 12119
mov AX 0
cmp AX 1
$jmp 12145 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "push "
push <append_11646+9>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12424        ;¸õ¦Ü©³³¡
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "pop"
$jmp 12153 "f"
mov AX True
jmp 12154
mov AX False
cmp AX 1
$jmp 12169 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12164 "f"
mov AX True
jmp 12165
mov AX False
cmp AX 1
$jmp 12169 "!="
mov AX 1
jmp 12170
mov AX 0
cmp AX 1
$jmp 12189 "!="
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12184 "f"
mov AX True
jmp 12185
mov AX False
cmp AX 1
$jmp 12189 "!="
mov AX 1
jmp 12190
mov AX 0
cmp AX 1
$jmp 12201 "!="
push <append_11646+9>
mov BX 1
pop AX
tf <append_11646+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12201 "!="
mov AX 1
jmp 12202
mov AX 0
cmp AX 1
$jmp 12228 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "pop "
push <append_11646+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12424        ;¸õ¦Ü©³³¡
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12236 "f"
mov AX True
jmp 12237
mov AX False
cmp AX 1
$jmp 12252 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12247 "f"
mov AX True
jmp 12248
mov AX False
cmp AX 1
$jmp 12252 "!="
mov AX 1
jmp 12253
mov AX 0
cmp AX 1
$jmp 12272 "!="
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12267 "f"
mov AX True
jmp 12268
mov AX False
cmp AX 1
$jmp 12272 "!="
mov AX 1
jmp 12273
mov AX 0
cmp AX 1
$jmp 12292 "!="
push <append_11646+9>
mov BX 2
pop AX
push AX[BX]
push <append_11646+10>
mov BX 1
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12287 "f"
mov AX True
jmp 12288
mov AX False
cmp AX 1
$jmp 12292 "!="
mov AX 1
jmp 12293
mov AX 0
cmp AX 1
$jmp 12296 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12424        ;¸õ¦Ü©³³¡
push <append_11646+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12304 "f"
mov AX True
jmp 12305
mov AX False
cmp AX 1
$jmp 12320 "!="
push <append_11646+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "mov"
$jmp 12315 "f"
mov AX True
jmp 12316
mov AX False
cmp AX 1
$jmp 12320 "!="
mov AX 1
jmp 12321
mov AX 0
cmp AX 1
$jmp 12340 "!="
push <append_11646+9>
mov BX 1
pop AX
push AX[BX]
push <append_11646+10>
mov BX 2
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 12335 "f"
mov AX True
jmp 12336
mov AX False
cmp AX 1
$jmp 12340 "!="
mov AX 1
jmp 12341
mov AX 0
cmp AX 1
$jmp 12352 "!="
push <append_11646+9>
mov BX 1
pop AX
tf <append_11646+0>.tem "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 12352 "!="
mov AX 1
jmp 12353
mov AX 0
cmp AX 1
$jmp 12385 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <append_11646+0>.code
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "mov "
push <append_11646+10>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <append_11646+9>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12424        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "add"
mov <esp+1>[1] "sub"
push <append_11646+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 12410 "!="
push <append_11646+10>
mov BX 2
pop AX
mov DX AX[BX]
tf DX "equ" "0"
$jmp 12405 "f"
mov AX True
jmp 12406
mov AX False
cmp AX 1
$jmp 12410 "!="
mov AX 1
jmp 12411
mov AX 0
cmp AX 1
$jmp 12414 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12424        ;¸õ¦Ü©³³¡
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12435        ;¸õ¦Ü©³³¡
mov AX <append_11646+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <append_11646+0>.simplify
cmp DX 0
$jmp 12440 "<="
mov AX True
jmp 12441
mov AX False
cmp AX 1
$jmp 12447 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <append_11646+0>.simplify "-" <esp+1>
inc esp
jmp 12447        ;¸õ¦Ü©³³¡
push <append_11646+4>
$mov <append_11646+0>.simplify "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <append_11646+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 12470 "<="
mov AX True
jmp 12471
mov AX False
cmp AX 1
$jmp 12487 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <append_11646+0>.comments      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <append_11646+0>.base
mov <esp+1>[1] ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 12487        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "append_11646" "0,1,2,3,4,5,6,7,8,9,10"
pop ip
Function BX 12494 <Code^6> "display_12494" 10
mov <Code^6>.display BX
jmp 12777           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12504 "!="
tf <esp+2> "in" "now_ip"
$jmp 12506 "t"
mov AX 1
$oper AX "-"
mov <esp+2>["now_ip"] AX
jmp 12506
mov <esp+2>["now_ip"] <esp+1>[0]
dec CX
mov <display_12494+2> <esp+2>["now_ip"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "--------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <display_12494+3> <esp+1>
inc esp
mov DX <display_12494+2>
cmp DX <display_12494+3>
$jmp 12531 ">="
mov AX True
jmp 12532
mov AX False
cmp AX 1
$jmp 12547 "!="
push <display_12494+2>
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 12542 "t"
mov AX True
jmp 12543
mov AX False
cmp AX 1
$jmp 12547 "!="
mov AX 1
jmp 12548
mov AX 0
cmp AX 1
$jmp 12568 "!="
push <display_12494+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+0>.comments
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 12563 ">="
mov AX True
jmp 12564
mov AX False
cmp AX 1
$jmp 12568 "!="
mov AX 1
jmp 12569
mov AX 0
cmp AX 1
$jmp 12584 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <display_12494+0>.comments
mov BX <display_12494+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
push AX[BX]
mov <display_12494+4> <esp+1>
inc esp
jmp 12587        ;¸õ¦Ü©³³¡
push <display_12494+3>
mov <display_12494+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 12765 "f"
mov <display_12494+5> AX
mov DX <display_12494+2>
tf DX "equ" <display_12494+5>
$jmp 12604 "f"
mov AX True
jmp 12605
mov AX False
cmp AX 1
$jmp 12609 "!="   ;¸õ¨ìfalse
mov AX " ¡´ "   ;true item
jmp 12610   ;Â÷¶}sub_if_else
mov AX "   "   ;false item
push AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
push " "
push 4
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
pop AX
oper <esp+1> "+" AX
oper <esp+1> "+" "|"
push <display_12494+0>.code
mov BX <display_12494+5>
pop AX
oper <esp+1> "+" AX[BX]
mov <display_12494+6> <esp+1>
inc esp
push " "
oper <esp+1> "*" 70
mov <display_12494+7> <esp+1>
inc esp
push <display_12494+0>.comments
mov BX <display_12494+5>
pop AX
push AX[BX]
mov <display_12494+8> <esp+1>
inc esp
push <display_12494+8>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 12665 "t"
mov AX True
jmp 12666
mov AX False
cmp AX 1
$jmp 12723 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <display_12494+5>
tf DX "equ" <display_12494+4>
$jmp 12673 "f"
mov AX True
jmp 12674
mov AX False
cmp AX 1
$jmp 12678 "!="   ;¸õ¨ìfalse
mov AX " ¡´ "   ;true item
jmp 12679   ;Â÷¶}sub_if_else
mov AX "   "   ;false item
push AX
push 1        ;Àx¦sCX
push [1]
push <display_12494+8>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
oper <esp+1> "+" AX
push " "
push 4
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <display_12494+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
pop AX
oper <esp+1> "+" AX
oper <esp+1> "+" "| "
push <display_12494+8>
mov BX 1
pop AX
oper <esp+1> "+" AX[BX]
mov <display_12494+9> <esp+1>
inc esp
jmp 12726        ;¸õ¦Ü©³³¡
push ""
mov <display_12494+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <display_12494+7>
push <display_12494+9>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 40
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" "\r"
oper <esp+1> "+" <display_12494+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov DX <display_12494+5>
cmp DX 100
$jmp 12752 "<="
mov AX True
jmp 12753
mov AX False
cmp AX 1
$jmp 12764 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "row more than 100"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 12765          ;break¥X°j°é
jmp 12764        ;¸õ¦Ü©³³¡
jmp 12596
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "--------------------------------"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "display_12494" "0,1,2,3,4,5,6,7,8,9"
pop ip
Function BX 12780 <Code^6> "parse_code_12780" 25
mov <Code^6>.parse_code BX
jmp 14895           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12788 "!="
tf <esp+2> "in" "start_row"
$jmp 12790 "t"
mov <esp+2>["start_row"] 0
jmp 12790
mov <esp+2>["start_row"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 12796 "!="
tf <esp+2> "in" "reset"
$jmp 12798 "t"
mov <esp+2>["reset"] True
jmp 12798
mov <esp+2>["reset"] <esp+1>[1]
dec CX
mov <parse_code_12780+2> <esp+2>["start_row"]
mov <parse_code_12780+3> <esp+2>["reset"]


Function <parse_code_12780+4> 12804 None "deal_string_12804" 5 "parse_code_12780"
jmp 12893           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12812 "!="
tf <esp+2> "in" "codeline"
$jmp 12814 "t"
mov <esp+2>["codeline"] None
jmp 12814
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 12820 "!="
tf <esp+2> "in" "k"
$jmp 12822 "t"
mov <esp+2>["k"] None
jmp 12822
mov <esp+2>["k"] <esp+1>[1]
dec CX
mov <deal_string_12804+1> <esp+2>["codeline"]
mov <deal_string_12804+2> <esp+2>["k"]


push <deal_string_12804+1>
mov BX <deal_string_12804+2>
pop AX
push AX[BX]
mov <deal_string_12804+3> <esp+1>
inc esp
push 1
$mov <deal_string_12804+2> "+" <esp+1>
inc esp
push <deal_string_12804+2>
mov <deal_string_12804+4> <esp+1>
inc esp
cmp True 1
$jmp 12872 "!="
push <deal_string_12804+1>
mov BX <deal_string_12804+2>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 12848 "f"
mov AX True
jmp 12849
mov AX False
cmp AX 1
$jmp 12855 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <deal_string_12804+2> "+" <esp+1>
inc esp
jmp 12868        ;¸õ¦Ü©³³¡
push <deal_string_12804+1>
mov BX <deal_string_12804+2>
pop AX
mov DX AX[BX]
tf DX "equ" <deal_string_12804+3>
$jmp 12863 "f"
mov AX True
jmp 12864
mov AX False
cmp AX 1
$jmp 12868 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 12872          ;break¥X
jmp 12868        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_12804+2> "+" <esp+1>
inc esp
jmp 12838               ;continue­«¨Ó
push (2)
push <deal_string_12804+3>
push <deal_string_12804+1>
push [3]
mov <esp+1>[0] <deal_string_12804+4>
mov <esp+1>[1] <deal_string_12804+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
oper <esp+1> "+" <deal_string_12804+3>
pop <esp+1>[0]
mov <esp+1>[1] <deal_string_12804+2>
pop AX
jmp 12890         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_string_12804" "0,1,2,3,4"
pop ip
Function <parse_code_12780+5> 12895 None "login_item_12895" 7 "parse_code_12780"
jmp 13177           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 12903 "!="
tf <esp+2> "in" "item"
$jmp 12905 "t"
mov <esp+2>["item"] None
jmp 12905
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <login_item_12895+1> <esp+2>["item"]


tf <parse_code_12780+0>.data_dict "in" <login_item_12895+1>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 13169 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+0>.data
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <parse_code_12780+0>.data_n
pop DX
cmp DX 100
$jmp 12927 ">="
mov AX True
jmp 12928
mov AX False
cmp AX 1
$jmp 12942 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&code_28+0>
mov <esp+1>[0] AX
oper <esp+1> "*" 1024
$mov <parse_code_12780+0>.data "+" <esp+1>
inc esp
jmp 12942        ;¸õ¦Ü©³³¡
push <parse_code_12780+0>.data_n
push <parse_code_12780+0>.data_dict
mov BX <login_item_12895+1>
pop AX
mov AX[BX] <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <login_item_12895+1>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 13126 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <login_item_12895+1>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <login_item_12895+2> <esp+1>
inc esp
push <login_item_12895+1>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 12983 "f"
mov AX True
jmp 12984
mov AX False
cmp AX 1
$jmp 13119 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
mov BX "\\n"
mov <esp+1>[BX] "\n"
mov BX "\\r"
mov <esp+1>[BX] "\r"
mov BX "\\t"
mov <esp+1>[BX] "\t"
mov BX "\\a"
mov <esp+1>[BX] "\a"
mov BX "\\b"
mov <esp+1>[BX] "\b"
mov BX "\\f"
mov <esp+1>[BX] "\f"
mov BX "\\v"
mov <esp+1>[BX] "\v"
mov BX "\\\""
mov <esp+1>[BX] "\""
mov BX "\\\'"
mov <esp+1>[BX] "\'"
mov BX "\\\\"
mov <esp+1>[BX] "\\"
mov <login_item_12895+3> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12895+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <login_item_12895+4> <esp+1>[0]
mov <login_item_12895+5> <esp+1>[1]
inc esp
push [0]
mov <login_item_12895+6> <esp+1>
inc esp
mov DX <login_item_12895+4>
cmp DX <login_item_12895+5>
$jmp 13030 ">="
mov AX True
jmp 13031
mov AX False
cmp AX 1
$jmp 13105 "!="
push <login_item_12895+2>
mov BX <login_item_12895+4>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 13041 "f"
mov AX True
jmp 13042
mov AX False
cmp AX 1
$jmp 13062 "!="
push <login_item_12895+2>
push [3]
mov <esp+1>[0] <login_item_12895+4>
push <login_item_12895+4>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
tf <login_item_12895+3> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 13062 "!="
mov AX 1
jmp 13063
mov AX 0
cmp AX 1
$jmp 13091 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <login_item_12895+3>
push <login_item_12895+2>
push [3]
mov <esp+1>[0] <login_item_12895+4>
push <login_item_12895+4>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <login_item_12895+6>.append
push 1
$mov <login_item_12895+4> "+" <esp+1>
inc esp
jmp 13101        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <login_item_12895+2>
mov BX <login_item_12895+4>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <login_item_12895+6>.append
push 1
$mov <login_item_12895+4> "+" <esp+1>
inc esp
jmp 13025               ;continue­«¨Ó
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12895+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <login_item_12895+2> <esp+1>
inc esp
jmp 13119        ;¸õ¦Ü©³³¡
push <login_item_12895+2>
push <parse_code_12780+0>.data
mov BX <parse_code_12780+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 13165        ;¸õ¦Ü©³³¡
push <login_item_12895+1>
mov BX 0
pop AX
tf "0123456789-" "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 13165 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <login_item_12895+1> "in" "."
mov AX TF
cmp AX 1
$jmp 13151 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12895+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
push <parse_code_12780+0>.data
mov BX <parse_code_12780+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 13164        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <login_item_12895+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
push AX
push <parse_code_12780+0>.data
mov BX <parse_code_12780+0>.data_n
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 13165        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_12780+0>.data_n "+" <esp+1>
inc esp
jmp 13169        ;¸õ¦Ü©³³¡
push <parse_code_12780+0>.data_dict
mov BX <login_item_12895+1>
pop AX
mov AX AX[BX]
jmp 13174         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "login_item_12895" "0,1,2,3,4,5,6"
pop ip
push [dict]
push "mov"
push (2)
mov <esp+1>[0] 0
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "$mov"
push (2)
mov <esp+1>[0] 1
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "oper"
push (2)
mov <esp+1>[0] 2
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "cmp"
push (2)
mov <esp+1>[0] 3
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "jmp"
push (2)
mov <esp+1>[0] 4
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "$jmp"
push (2)
mov <esp+1>[0] 5
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "call"
push (2)
mov <esp+1>[0] 6
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "push"
push (2)
mov <esp+1>[0] 7
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "pop"
push (2)
mov <esp+1>[0] 8
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "tf"
push (2)
mov <esp+1>[0] 9
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "inc"
push (2)
mov <esp+1>[0] 10
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "dec"
push (2)
mov <esp+1>[0] 11
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "$oper"
push (2)
mov <esp+1>[0] 12
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "ex_func"
push (2)
mov <esp+1>[0] 13
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "try"
push (2)
mov <esp+1>[0] 14
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "finally"
push (2)
mov <esp+1>[0] 15
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "raise"
push (2)
mov <esp+1>[0] 16
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "error"
push (2)
mov <esp+1>[0] 17
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
push "Generator"
push (2)
mov <esp+1>[0] 18
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "Yield"
push (2)
mov <esp+1>[0] 19
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "fetch"
push (2)
mov <esp+1>[0] 20
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "stop"
push (2)
mov <esp+1>[0] 21
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "end"
push (2)
mov <esp+1>[0] 22
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "byte"
push (2)
mov <esp+1>[0] 23
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "del"
push (2)
mov <esp+1>[0] 24
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "Function"
push (2)
mov <esp+1>[0] 25
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
pop BX
mov <esp+1>[BX] AX
push "global"
push (2)
mov <esp+1>[0] 26
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "namespace"
push (2)
mov <esp+1>[0] 28
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "pass"
push (2)
mov <esp+1>[0] 26
mov <esp+1>[1] 0
pop AX
pop BX
mov <esp+1>[BX] AX
push "*args"
push (2)
mov <esp+1>[0] 29
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "**kwargs"
push (2)
mov <esp+1>[0] 30
mov <esp+1>[1] 3
pop AX
pop BX
mov <esp+1>[BX] AX
push "module"
push (2)
mov <esp+1>[0] 31
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "type"
push (2)
mov <esp+1>[0] 32
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "name"
push (2)
mov <esp+1>[0] 33
mov <esp+1>[1] 2
pop AX
pop BX
mov <esp+1>[BX] AX
push "print"
push (2)
mov <esp+1>[0] 34
mov <esp+1>[1] 1
pop AX
pop BX
mov <esp+1>[BX] AX
mov <parse_code_12780+6> <esp+1>
inc esp
cmp <parse_code_12780+3> 1
$jmp 13529 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
mov BX "AX"
mov <esp+1>[BX] 0
mov BX "BX"
mov <esp+1>[BX] 1
mov BX "CX"
mov <esp+1>[BX] 2
mov BX "DX"
mov <esp+1>[BX] 3
mov BX "ip"
mov <esp+1>[BX] 4
mov BX "esp"
mov <esp+1>[BX] 5
mov BX "sp"
mov <esp+1>[BX] 6
mov BX "ZR"
mov <esp+1>[BX] 7
mov BX "TF"
mov <esp+1>[BX] 8
mov BX "*args"
mov <esp+1>[BX] 9
mov BX "**kwargs"
mov <esp+1>[BX] 10
mov BX "$Exception"
mov <esp+1>[BX] 11
mov BX "True"
mov <esp+1>[BX] 12
mov BX "False"
mov <esp+1>[BX] 13
mov BX "None"
mov <esp+1>[BX] 14
mov BX "$Inheritance"
mov <esp+1>[BX] 15
mov <parse_code_12780+0>.data_dict <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+0>.data_dict
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call tuple
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_12780+0>.data_n <esp+1>
inc esp
push [1]
mov <esp+1>[0] None
oper <esp+1> "*" <parse_code_12780+0>.data_n
mov <parse_code_12780+0>.data <esp+1>
inc esp
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&code_28+0>
mov <esp+1>[0] AX
oper <esp+1> "*" 1024
$mov <parse_code_12780+0>.data "+" <esp+1>
inc esp
push True
push <parse_code_12780+0>.data
mov BX 12
pop AX
mov AX[BX] <esp+1>
inc esp
push False
push <parse_code_12780+0>.data
mov BX 13
pop AX
mov AX[BX] <esp+1>
inc esp
push None
push <parse_code_12780+0>.data
mov BX 14
pop AX
mov AX[BX] <esp+1>
inc esp
push None
push <parse_code_12780+0>.data
mov BX 15
pop AX
mov AX[BX] <esp+1>
inc esp
push [0]
mov <parse_code_12780+0>.parse_codes <esp+1>
inc esp
jmp 13546        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+0>.data_dict
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call tuple
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_12780+0>.data_n <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <parse_code_12780+7> <esp+1>
inc esp
push 1
$mov <parse_code_12780+2> "-" <esp+1>
inc esp
mov DX <parse_code_12780+2>
cmp DX <parse_code_12780+7>
$jmp 13565 ">="
mov AX True
jmp 13566
mov AX False
cmp AX 1
$jmp 14886 "!="
push 1
$mov <parse_code_12780+2> "+" <esp+1>
inc esp
push <parse_code_12780+0>.code
mov BX <parse_code_12780+2>
pop AX
push AX[BX]
mov <parse_code_12780+8> <esp+1>
inc esp
mov DX <parse_code_12780+8>
tf DX "equ" ""
$jmp 13582 "f"
mov AX True
jmp 13583
mov AX False
cmp AX 1
$jmp 13599 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <parse_code_12780+0>.parse_codes      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push [1]
mov <esp+1>[0] 26
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 13560
jmp 13599        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+8>.split
push AX
mov BX 0
pop AX
push AX[BX]
mov <parse_code_12780+9> <esp+1>
inc esp
push <parse_code_12780+6>
mov BX <parse_code_12780+9>
pop AX
push AX[BX]
mov <parse_code_12780+10> <esp+1>
inc esp
push [1]
push <parse_code_12780+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_code_12780+11> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
mov <parse_code_12780+12> <esp+1>
inc esp
push 0
mov <parse_code_12780+13> <esp+1>
inc esp
push <parse_code_12780+13>
push <parse_code_12780+10>
mov BX 1
pop AX
pop DX
cmp DX AX[BX]
$jmp 13648 ">="
mov AX True
jmp 13649
mov AX False
cmp AX 1
$jmp 13688 "=="
push <parse_code_12780+10>
mov BX 1
pop AX
push AX[BX]
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 13662 "f"
mov AX True
jmp 13663
mov AX False
cmp AX 1
$jmp 13683 "!="
push <parse_code_12780+12>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 13678 ">="
mov AX True
jmp 13679
mov AX False
cmp AX 1
$jmp 13683 "!="
mov AX 1
jmp 13684
mov AX 0
cmp AX 1
$jmp 13688 "=="
mov AX 0
jmp 13689
mov AX 1
cmp AX 1
$jmp 14875 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_12780+8>
mov BX <parse_code_12780+12>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 13959 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_code_12780+8>
mov <esp+1>[1] <parse_code_12780+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+4>
push AX
mov <parse_code_12780+14> <esp+1>[0]
mov <parse_code_12780+12> <esp+1>[1]
inc esp
mov DX <parse_code_12780+13>
tf DX "equ" 1
$jmp 13720 "f"
mov AX True
jmp 13721
mov AX False
cmp AX 1
$jmp 13938 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "$mov"
mov <esp+1>[1] "oper"
mov BX <parse_code_12780+9>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 13795 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (12)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
mov <esp+1>[2] "*"
mov <esp+1>[3] "/"
mov <esp+1>[4] "**"
mov <esp+1>[5] "%"
mov <esp+1>[6] "//"
mov <esp+1>[7] "<<"
mov <esp+1>[8] ">>"
mov <esp+1>[9] "&"
mov <esp+1>[10] "^"
mov <esp+1>[11] "|"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+14>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12780+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 13937        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+9>
tf DX "equ" "tf"
$jmp 13800 "f"
mov AX True
jmp 13801
mov AX False
cmp AX 1
$jmp 13858 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (4)
mov <esp+1>[0] "in"
mov <esp+1>[1] "equ"
mov <esp+1>[2] "Ctn"
mov <esp+1>[3] "is"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+14>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12780+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 13937        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+9>
tf DX "equ" "$oper"
$jmp 13863 "f"
mov AX True
jmp 13864
mov AX False
cmp AX 1
$jmp 13920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (3)
mov <esp+1>[0] "not"
mov <esp+1>[1] "-"
mov <esp+1>[2] "~"
pop AX
push AX.index
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+14>
push [3]
mov <esp+1>[0] 1
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_12780+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 13937        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 13955        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
push 2
$mov <parse_code_12780+12> "+" <esp+1>
inc esp
jmp 14871        ;¸õ¦Ü©³³¡
push <parse_code_12780+8>
mov BX <parse_code_12780+12>
pop AX
tf "0123456789-" "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 14036 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_12780+12>
mov <parse_code_12780+16> <esp+1>
inc esp
push <parse_code_12780+16>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 13982 ">="
mov AX True
jmp 13983
mov AX False
cmp AX 1
$jmp 13994 "!="
push <parse_code_12780+8>
mov BX <parse_code_12780+16>
pop AX
tf "-0123456789." "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 13994 "!="
mov AX 1
jmp 13995
mov AX 0
cmp AX 1
$jmp 14001 "!="
push 1
$mov <parse_code_12780+16> "+" <esp+1>
inc esp
jmp 13969               ;continue­«¨Ó
push <parse_code_12780+8>
push [3]
mov <esp+1>[0] <parse_code_12780+12>
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12780+17> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
push <parse_code_12780+16>
oper <esp+1> "+" 1
mov <parse_code_12780+12> <esp+1>
inc esp
jmp 14871        ;¸õ¦Ü©³³¡
push <parse_code_12780+8>
mov BX <parse_code_12780+12>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 14044 "f"
mov AX True
jmp 14045
mov AX False
cmp AX 1
$jmp 14158 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "]"
mov <esp+1>[1] <parse_code_12780+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+8>.index
push AX
mov <parse_code_12780+16> <esp+1>
inc esp
push <parse_code_12780+8>
push [3]
push <parse_code_12780+12>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12780+18> <esp+1>
inc esp
mov DX <parse_code_12780+18>
tf DX "equ" "dict"
$jmp 14078 "f"
mov AX True
jmp 14079
mov AX False
cmp AX 1
$jmp 14094 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 11
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14153        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+18>
tf DX "equ" "class"
$jmp 14099 "f"
mov AX True
jmp 14100
mov AX False
cmp AX 1
$jmp 14115 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 13
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14153        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+18>
tf DX "equ" "func"
$jmp 14120 "f"
mov AX True
jmp 14121
mov AX False
cmp AX 1
$jmp 14136 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 16
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14153        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 10
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
push <parse_code_12780+16>
oper <esp+1> "+" 2
mov <parse_code_12780+12> <esp+1>
inc esp
jmp 14871        ;¸õ¦Ü©³³¡
push <parse_code_12780+8>
mov BX <parse_code_12780+12>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 14166 "f"
mov AX True
jmp 14167
mov AX False
cmp AX 1
$jmp 14214 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ")"
mov <esp+1>[1] <parse_code_12780+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+8>.index
push AX
mov <parse_code_12780+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 12
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+8>
push [3]
push <parse_code_12780+12>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
push <parse_code_12780+16>
oper <esp+1> "+" 2
mov <parse_code_12780+12> <esp+1>
inc esp
jmp 14871        ;¸õ¦Ü©³³¡
push ""
mov <parse_code_12780+19> <esp+1>
inc esp
push <parse_code_12780+8>
mov BX <parse_code_12780+12>
pop AX
mov DX AX[BX]
tf DX "equ" "<"
$jmp 14225 "f"
mov AX True
jmp 14226
mov AX False
cmp AX 1
$jmp 14330 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ">"
mov <esp+1>[1] <parse_code_12780+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+8>.index
push AX
mov <parse_code_12780+16> <esp+1>
inc esp
push <parse_code_12780+8>
push [3]
push <parse_code_12780+12>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12780+20> <esp+1>
inc esp
tf <parse_code_12780+20> "in" "+"
mov AX TF
cmp AX 1
$jmp 14287 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+20>.split
push AX
mov <parse_code_12780+21> <esp+1>
inc esp
push [2]
push <parse_code_12780+21>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+21>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
mov <esp+1>[1] AX
mov <parse_code_12780+22> <esp+1>
inc esp
jmp 14292        ;¸õ¦Ü©³³¡
push [2]
mov <esp+1>[0] <parse_code_12780+20>
mov <esp+1>[1] 0
mov <parse_code_12780+22> <esp+1>
inc esp
push 1
$mov <parse_code_12780+16> "+" <esp+1>
inc esp
push <parse_code_12780+22>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "esp"
$jmp 14303 "f"
mov AX True
jmp 14304
mov AX False
cmp AX 1
$jmp 14326 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "1"
$mov <parse_code_12780+19> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
push AX
push <parse_code_12780+22>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 14329        ;¸õ¦Ü©³³¡
push "2"
mov <parse_code_12780+19> <esp+1>
inc esp
jmp 14399        ;¸õ¦Ü©³³¡
push <parse_code_12780+12>
mov <parse_code_12780+16> <esp+1>
inc esp
push <parse_code_12780+16>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14346 ">="
mov AX True
jmp 14347
mov AX False
cmp AX 1
$jmp 14359 "!="
push <parse_code_12780+8>
mov BX <parse_code_12780+16>
pop AX
tf "[ ." "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 14359 "!="
mov AX 1
jmp 14360
mov AX 0
cmp AX 1
$jmp 14366 "!="
push 1
$mov <parse_code_12780+16> "+" <esp+1>
inc esp
jmp 14333               ;continue­«¨Ó
push [1]
push <parse_code_12780+8>
push [3]
mov <esp+1>[0] <parse_code_12780+12>
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_code_12780+22> <esp+1>
inc esp
push "0"
$mov <parse_code_12780+19> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
push AX
push <parse_code_12780+22>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_code_12780+16>
oper <esp+1> "+" 1
mov <parse_code_12780+12> <esp+1>
inc esp
push <parse_code_12780+16>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14416 ">="
mov AX True
jmp 14417
mov AX False
cmp AX 1
$jmp 14432 "!="
push <parse_code_12780+8>
mov BX <parse_code_12780+16>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 14427 "f"
mov AX True
jmp 14428
mov AX False
cmp AX 1
$jmp 14432 "!="
mov AX 1
jmp 14433
mov AX 0
cmp AX 1
$jmp 14499 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_12780+16> "+" <esp+1>
inc esp
push <parse_code_12780+16>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14451 ">="
mov AX True
jmp 14452
mov AX False
cmp AX 1
$jmp 14464 "!="
push <parse_code_12780+8>
mov BX <parse_code_12780+16>
pop AX
tf "[ ." "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 14464 "!="
mov AX 1
jmp 14465
mov AX 0
cmp AX 1
$jmp 14471 "!="
push 1
$mov <parse_code_12780+16> "+" <esp+1>
inc esp
jmp 14438               ;continue­«¨Ó
push <parse_code_12780+8>
push [3]
mov <esp+1>[0] <parse_code_12780+12>
mov <esp+1>[1] <parse_code_12780+16>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12780+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+22>.append
push "0"
$mov <parse_code_12780+19> "+" <esp+1>
inc esp
push <parse_code_12780+16>
oper <esp+1> "+" 1
mov <parse_code_12780+12> <esp+1>
inc esp
jmp 14499        ;¸õ¦Ü©³³¡
push <parse_code_12780+16>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 14512 ">="
mov AX True
jmp 14513
mov AX False
cmp AX 1
$jmp 14528 "!="
push <parse_code_12780+8>
mov BX <parse_code_12780+16>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 14523 "f"
mov AX True
jmp 14524
mov AX False
cmp AX 1
$jmp 14528 "!="
mov AX 1
jmp 14529
mov AX 0
cmp AX 1
$jmp 14625 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_12780+8>
push <parse_code_12780+16>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 14577 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_code_12780+8>
push <parse_code_12780+16>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+4>
push AX
mov <parse_code_12780+18> <esp+1>[0]
mov <parse_code_12780+24> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+22>.append
push 1
$mov <parse_code_12780+24> "+" <esp+1>
inc esp
jmp 14617        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "]"
mov <esp+1>[1] <parse_code_12780+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+8>.index
push AX
mov <parse_code_12780+24> <esp+1>
inc esp
push <parse_code_12780+8>
push [3]
push <parse_code_12780+16>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_12780+24>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_12780+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+5>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+22>.append
push "1"
$mov <parse_code_12780+19> "+" <esp+1>
inc esp
push <parse_code_12780+24>
oper <esp+1> "+" 2
mov <parse_code_12780+12> <esp+1>
inc esp
jmp 14625        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "0"
$jmp 14630 "f"
mov AX True
jmp 14631
mov AX False
cmp AX 1
$jmp 14647 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] 0
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "00"
$jmp 14652 "f"
mov AX True
jmp 14653
mov AX False
cmp AX 1
$jmp 14673 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 1
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "01"
$jmp 14678 "f"
mov AX True
jmp 14679
mov AX False
cmp AX 1
$jmp 14699 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 2
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "1"
$jmp 14704 "f"
mov AX True
jmp 14705
mov AX False
cmp AX 1
$jmp 14725 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 3
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "10"
$jmp 14730 "f"
mov AX True
jmp 14731
mov AX False
cmp AX 1
$jmp 14755 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 4
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12780+22>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "11"
$jmp 14760 "f"
mov AX True
jmp 14761
mov AX False
cmp AX 1
$jmp 14785 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 5
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12780+22>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "2"
$jmp 14790 "f"
mov AX True
jmp 14791
mov AX False
cmp AX 1
$jmp 14811 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] 6
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "20"
$jmp 14816 "f"
mov AX True
jmp 14817
mov AX False
cmp AX 1
$jmp 14841 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 7
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12780+22>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
mov DX <parse_code_12780+19>
tf DX "equ" "21"
$jmp 14846 "f"
mov AX True
jmp 14847
mov AX False
cmp AX 1
$jmp 14871 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (4)
mov <esp+1>[0] 8
push <parse_code_12780+22>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_12780+22>
mov BX 1
pop AX
mov <esp+1>[2] AX[BX]
push <parse_code_12780+22>
mov BX 2
pop AX
mov <esp+1>[3] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_12780+11>.append
jmp 14871        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_12780+13> "+" <esp+1>
inc esp
jmp 13639               ;continue­«¨Ó
mov AX <parse_code_12780+0>.parse_codes      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_12780+11>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 13560               ;continue­«¨Ó
push (3)
mov <esp+1>[0] <parse_code_12780+0>.parse_codes
mov <esp+1>[1] <parse_code_12780+0>.data
mov <esp+1>[2] <parse_code_12780+0>.data_dict
pop AX
jmp 14892         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_code_12780" "0,1,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24"
pop ip
Function BX 14898 <Code^6> "__len___14898" 2
mov <Code^6>.__len__ BX
jmp 14913           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___14898+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 14910         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___14898" "0,1"
pop ip
Function BX 14916 <Code^6> "__getitem___14916" 3
mov <Code^6>.__getitem__ BX
jmp 14937           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14924 "!="
tf <esp+2> "in" "item"
$jmp 14926 "t"
mov <esp+2>["item"] None
jmp 14926
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___14916+2> <esp+2>["item"]


push <__getitem___14916+0>.code
mov BX <__getitem___14916+2>
pop AX
mov AX AX[BX]
jmp 14934         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___14916" "0,1,2"
pop ip
Function BX 14940 <Code^6> "__setitem___14940" 4
mov <Code^6>.__setitem__ BX
jmp 14972           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 14948 "!="
tf <esp+2> "in" "key"
$jmp 14950 "t"
mov <esp+2>["key"] None
jmp 14950
mov <esp+2>["key"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 14956 "!="
tf <esp+2> "in" "value"
$jmp 14958 "t"
mov <esp+2>["value"] None
jmp 14958
mov <esp+2>["value"] <esp+1>[1]
dec CX
mov <__setitem___14940+2> <esp+2>["key"]
mov <__setitem___14940+3> <esp+2>["value"]


push <__setitem___14940+3>
push <__setitem___14940+0>.code
mov BX <__setitem___14940+2>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__setitem___14940" "0,1,2,3"
pop ip
mov AX <Code^6>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 14984 "=="
tf AX "Ctn" "__init__"
$jmp 14982 "t"
jmp 14984
call AX.__init__
mov AX <Code^6>
end "Function" "Code^6"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/code.py"]
mov <&package_6+5> <esp+1>.Code
inc esp
mov &apython_14990 $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
pass
namespace &module_14992 "&module_14992" "Integer,Float,String,Byte,Var_name,Namespace,Variable,SubVariable,Slice,IndexVariable,List,Tuple,Dict,Set,is_number,Lambda,Def,FuncCall,Backtrack,Var_declare,Try_Except,With,Stop,Command,sub_if_else,If_else,While,sub_for_loop,For_loop,Mark,Pass,TFN,Class,two_object_write,Multiple_Mov,Oper,Tf,AndOr,Deny,Bool,Assert,STR,Info"
mov $importer["C:/Users/allen/Desktop/py/py/backup2/apython/module.py"] &module_14992
mov &tem_import_14990 &module_14992
Function <&module_14992+0> 14997 None "Integer^16" 1
name <&module_14992+0> "<class '__main__.Integer'>"
jmp 15099
tf $Inheritance "equ" None
$jmp 15002 "t"
mov <Integer^16> $Inheritance
push 1
jmp 15004
mov <Integer^16> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Integer^16> <&module_14992+0>
Function BX 15012 <Integer^16> "__init___15012" 3
mov <Integer^16>.__init__ BX
jmp 15039           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15020 "!="
tf <esp+2> "in" "number"
$jmp 15022 "t"
mov <esp+2>["number"] None
jmp 15022
mov <esp+2>["number"] <esp+1>[0]
dec CX
mov <__init___15012+2> <esp+2>["number"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___15012+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call int
push AX
mov <__init___15012+0>.number <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15012" "0,1,2"
pop ip
Function BX 15042 <Integer^16> "__str___15042" 2
mov <Integer^16>.__str__ BX
jmp 15055           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15042+0>.number
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15052         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15042" "0,1"
pop ip
Function BX 15058 <Integer^16> "write_15058" 3
mov <Integer^16>.write BX
jmp 15085           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15066 "!="
tf <esp+2> "in" "codes"
$jmp 15068 "t"
mov <esp+2>["codes"] None
jmp 15068
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15058+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15058+0>.number
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <write_15058+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15058" "0,1,2"
pop ip
mov AX <Integer^16>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15097 "=="
tf AX "Ctn" "__init__"
$jmp 15095 "t"
jmp 15097
call AX.__init__
mov AX <Integer^16>
end "Function" "Integer^16"
pop ip
Function <&module_14992+1> 15102 None "Float^17" 1
name <&module_14992+1> "<class '__main__.Float'>"
jmp 15204
tf $Inheritance "equ" None
$jmp 15107 "t"
mov <Float^17> $Inheritance
push 1
jmp 15109
mov <Float^17> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Float^17> <&module_14992+1>
Function BX 15117 <Float^17> "__init___15117" 3
mov <Float^17>.__init__ BX
jmp 15144           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15125 "!="
tf <esp+2> "in" "number"
$jmp 15127 "t"
mov <esp+2>["number"] None
jmp 15127
mov <esp+2>["number"] <esp+1>[0]
dec CX
mov <__init___15117+2> <esp+2>["number"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___15117+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
mov <__init___15117+0>.number <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15117" "0,1,2"
pop ip
Function BX 15147 <Float^17> "__str___15147" 2
mov <Float^17>.__str__ BX
jmp 15160           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15147+0>.number
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15157         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15147" "0,1"
pop ip
Function BX 15163 <Float^17> "write_15163" 3
mov <Float^17>.write BX
jmp 15190           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15171 "!="
tf <esp+2> "in" "codes"
$jmp 15173 "t"
mov <esp+2>["codes"] None
jmp 15173
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15163+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15163+0>.number
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
mov <write_15163+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15163" "0,1,2"
pop ip
mov AX <Float^17>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15202 "=="
tf AX "Ctn" "__init__"
$jmp 15200 "t"
jmp 15202
call AX.__init__
mov AX <Float^17>
end "Function" "Float^17"
pop ip
Function <&module_14992+2> 15207 None "String^18" 1
name <&module_14992+2> "<class '__main__.String'>"
jmp 15319
tf $Inheritance "equ" None
$jmp 15212 "t"
mov <String^18> $Inheritance
push 1
jmp 15214
mov <String^18> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <String^18> <&module_14992+2>
Function BX 15222 <String^18> "__init___15222" 4
mov <String^18>.__init__ BX
jmp 15254           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15230 "!="
tf <esp+2> "in" "text"
$jmp 15232 "t"
mov <esp+2>["text"] None
jmp 15232
mov <esp+2>["text"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15238 "!="
tf <esp+2> "in" "change"
$jmp 15240 "t"
mov <esp+2>["change"] True
jmp 15240
mov <esp+2>["change"] <esp+1>[1]
dec CX
mov <__init___15222+2> <esp+2>["text"]
mov <__init___15222+3> <esp+2>["change"]


push <__init___15222+2>
mov <__init___15222+0>.text <esp+1>
inc esp
push <__init___15222+3>
mov <__init___15222+0>.change <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15222" "0,1,2,3"
pop ip
Function BX 15257 <String^18> "__str___15257" 2
mov <String^18>.__str__ BX
jmp 15270           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "\""
ex_func AX "str" <__str___15257+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 15267         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15257" "0,1"
pop ip
Function BX 15273 <String^18> "write_15273" 3
mov <String^18>.write BX
jmp 15305           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15281 "!="
tf <esp+2> "in" "codes"
$jmp 15283 "t"
mov <esp+2>["codes"] None
jmp 15283
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15273+2> <esp+2>["codes"]


cmp <write_15273+0>.change 1
$jmp 15295 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "\""
ex_func AX "str" <write_15273+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_15273+0>.location <esp+1>
inc esp
jmp 15301        ;¸õ¦Ü©³³¡
push "\'"
ex_func AX "str" <write_15273+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\'"
mov <write_15273+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15273" "0,1,2"
pop ip
mov AX <String^18>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15317 "=="
tf AX "Ctn" "__init__"
$jmp 15315 "t"
jmp 15317
call AX.__init__
mov AX <String^18>
end "Function" "String^18"
pop ip
Function <&module_14992+3> 15322 None "Byte^19" 1
name <&module_14992+3> "<class '__main__.Byte'>"
jmp 15421
tf $Inheritance "equ" None
$jmp 15327 "t"
mov <Byte^19> $Inheritance
push 1
jmp 15329
mov <Byte^19> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Byte^19> <&module_14992+3>
Function BX 15337 <Byte^19> "__init___15337" 3
mov <Byte^19>.__init__ BX
jmp 15357           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15345 "!="
tf <esp+2> "in" "text"
$jmp 15347 "t"
mov <esp+2>["text"] None
jmp 15347
mov <esp+2>["text"] <esp+1>[0]
dec CX
mov <__init___15337+2> <esp+2>["text"]


push <__init___15337+2>
mov <__init___15337+0>.text <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15337" "0,1,2"
pop ip
Function BX 15360 <Byte^19> "__str___15360" 2
mov <Byte^19>.__str__ BX
jmp 15373           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "\""
ex_func AX "str" <__str___15360+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop AX
jmp 15370         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15360" "0,1"
pop ip
Function BX 15376 <Byte^19> "write_15376" 3
mov <Byte^19>.write BX
jmp 15407           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15384 "!="
tf <esp+2> "in" "codes"
$jmp 15386 "t"
mov <esp+2>["codes"] None
jmp 15386
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15376+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "byte AX \""
ex_func AX "str" <write_15376+0>.text
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15376+2>.append
push "AX"
mov <write_15376+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15376" "0,1,2"
pop ip
mov AX <Byte^19>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15419 "=="
tf AX "Ctn" "__init__"
$jmp 15417 "t"
jmp 15419
call AX.__init__
mov AX <Byte^19>
end "Function" "Byte^19"
pop ip
Function <&module_14992+4> 15424 None "Var_name^20" 1
name <&module_14992+4> "<class '__main__.Var_name'>"
jmp 15489
tf $Inheritance "equ" None
$jmp 15429 "t"
mov <Var_name^20> $Inheritance
push 1
jmp 15431
mov <Var_name^20> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Var_name^20> <&module_14992+4>
Function BX 15439 <Var_name^20> "__init___15439" 3
mov <Var_name^20>.__init__ BX
jmp 15459           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15447 "!="
tf <esp+2> "in" "name"
$jmp 15449 "t"
mov <esp+2>["name"] None
jmp 15449
mov <esp+2>["name"] <esp+1>[0]
dec CX
mov <__init___15439+2> <esp+2>["name"]


push <__init___15439+2>
mov <__init___15439+0>.name <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15439" "0,1,2"
pop ip
Function BX 15462 <Var_name^20> "__str___15462" 2
mov <Var_name^20>.__str__ BX
jmp 15475           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15462+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15472         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15462" "0,1"
pop ip
mov AX <Var_name^20>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15487 "=="
tf AX "Ctn" "__init__"
$jmp 15485 "t"
jmp 15487
call AX.__init__
mov AX <Var_name^20>
end "Function" "Var_name^20"
pop ip
Function <&module_14992+5> 15492 None "Namespace^21" 1
name <&module_14992+5> "<class '__main__.Namespace'>"
jmp 15637
tf $Inheritance "equ" None
$jmp 15497 "t"
mov <Namespace^21> $Inheritance
push 1
jmp 15499
mov <Namespace^21> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Namespace^21> <&module_14992+5>
Function BX 15507 <Namespace^21> "__init___15507" 3
mov <Namespace^21>.__init__ BX
jmp 15527           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15515 "!="
tf <esp+2> "in" "namespace"
$jmp 15517 "t"
mov <esp+2>["namespace"] ""
jmp 15517
mov <esp+2>["namespace"] <esp+1>[0]
dec CX
mov <__init___15507+2> <esp+2>["namespace"]


push <__init___15507+2>
mov <__init___15507+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15507" "0,1,2"
pop ip
Function BX 15530 <Namespace^21> "__str___15530" 2
mov <Namespace^21>.__str__ BX
jmp 15543           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
ex_func AX "str" <__str___15530+0>.namespace
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 15540         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15530" "0,1"
pop ip
Function BX 15546 <Namespace^21> "__eq___15546" 3
mov <Namespace^21>.__eq__ BX
jmp 15569           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15554 "!="
tf <esp+2> "in" "other"
$jmp 15556 "t"
mov <esp+2>["other"] None
jmp 15556
mov <esp+2>["other"] <esp+1>[0]
dec CX
mov <__eq___15546+2> <esp+2>["other"]


mov DX <__eq___15546+0>.namespace
tf DX "equ" <__eq___15546+2>
$jmp 15564 "f"
mov AX True
jmp 15565
mov AX False
jmp 15566         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__eq___15546" "0,1,2"
pop ip
Function BX 15572 <Namespace^21> "__contains___15572" 3
mov <Namespace^21>.__contains__ BX
jmp 15591           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15580 "!="
tf <esp+2> "in" "item"
$jmp 15582 "t"
mov <esp+2>["item"] None
jmp 15582
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__contains___15572+2> <esp+2>["item"]


tf <__contains___15572+0>.namespace "in" <__contains___15572+2>
mov AX TF
jmp 15588         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__contains___15572" "0,1,2"
pop ip
Function BX 15594 <Namespace^21> "write_15594" 3
mov <Namespace^21>.write BX
jmp 15623           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15602 "!="
tf <esp+2> "in" "codes"
$jmp 15604 "t"
mov <esp+2>["codes"] None
jmp 15604
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15594+2> <esp+2>["codes"]


mov DX <write_15594+0>.namespace
tf DX "equ" ""
$jmp 15612 "t"
mov AX True
jmp 15613
mov AX False
cmp AX 1
$jmp 15619 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_15594+0>.namespace
mov <write_15594+0>.location <esp+1>
inc esp
jmp 15619        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15594" "0,1,2"
pop ip
mov AX <Namespace^21>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15635 "=="
tf AX "Ctn" "__init__"
$jmp 15633 "t"
jmp 15635
call AX.__init__
mov AX <Namespace^21>
end "Function" "Namespace^21"
pop ip
Function <&module_14992+6> 15640 None "Variable^22" 1
name <&module_14992+6> "<class '__main__.Variable'>"
jmp 15769
tf $Inheritance "equ" None
$jmp 15645 "t"
mov <Variable^22> $Inheritance
push 1
jmp 15647
mov <Variable^22> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Variable^22> <&module_14992+6>
Function BX 15655 <Variable^22> "__init___15655" 4
mov <Variable^22>.__init__ BX
jmp 15687           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15663 "!="
tf <esp+2> "in" "name"
$jmp 15665 "t"
mov <esp+2>["name"] None
jmp 15665
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15671 "!="
tf <esp+2> "in" "namespace"
$jmp 15673 "t"
mov <esp+2>["namespace"] None
jmp 15673
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <__init___15655+2> <esp+2>["name"]
mov <__init___15655+3> <esp+2>["namespace"]


push <__init___15655+3>
mov <__init___15655+0>.namespace <esp+1>
inc esp
push <__init___15655+2>
mov <__init___15655+0>.name <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15655" "0,1,2,3"
pop ip
Function BX 15690 <Variable^22> "__str___15690" 2
mov <Variable^22>.__str__ BX
jmp 15703           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<var="
ex_func AX "str" <__str___15690+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 15700         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15690" "0,1"
pop ip
Function BX 15706 <Variable^22> "write_15706" 3
mov <Variable^22>.write BX
jmp 15755           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15714 "!="
tf <esp+2> "in" "codes"
$jmp 15716 "t"
mov <esp+2>["codes"] None
jmp 15716
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15706+2> <esp+2>["codes"]


mov DX <write_15706+0>.namespace
tf DX "equ" ""
$jmp 15724 "t"
mov AX True
jmp 15725
mov AX False
cmp AX 1
$jmp 15748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_15706+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15706+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_15706+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_15706+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15706+0>.location <esp+1>
inc esp
jmp 15751        ;¸õ¦Ü©³³¡
push <write_15706+0>.name
mov <write_15706+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15706" "0,1,2"
pop ip
mov AX <Variable^22>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15767 "=="
tf AX "Ctn" "__init__"
$jmp 15765 "t"
jmp 15767
call AX.__init__
mov AX <Variable^22>
end "Function" "Variable^22"
pop ip
Function <&module_14992+7> 15772 None "SubVariable^23" 1
name <&module_14992+7> "<class '__main__.SubVariable'>"
jmp 15947
tf $Inheritance "equ" None
$jmp 15777 "t"
mov <SubVariable^23> $Inheritance
push 1
jmp 15779
mov <SubVariable^23> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <SubVariable^23> <&module_14992+7>
Function BX 15787 <SubVariable^23> "__init___15787" 4
mov <SubVariable^23>.__init__ BX
jmp 15819           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15795 "!="
tf <esp+2> "in" "obj"
$jmp 15797 "t"
mov <esp+2>["obj"] None
jmp 15797
mov <esp+2>["obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15803 "!="
tf <esp+2> "in" "attr"
$jmp 15805 "t"
mov <esp+2>["attr"] None
jmp 15805
mov <esp+2>["attr"] <esp+1>[1]
dec CX
mov <__init___15787+2> <esp+2>["obj"]
mov <__init___15787+3> <esp+2>["attr"]


push <__init___15787+2>
mov <__init___15787+0>.obj <esp+1>
inc esp
push <__init___15787+3>
mov <__init___15787+0>.attr <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15787" "0,1,2,3"
pop ip
Function BX 15822 <SubVariable^23> "__str___15822" 2
mov <SubVariable^23>.__str__ BX
jmp 15838           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<obj="
ex_func AX "str" <__str___15822+0>.obj
oper <esp+1> "+" AX
oper <esp+1> "+" "  attr="
ex_func AX "str" <__str___15822+0>.attr
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 15835         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___15822" "0,1"
pop ip
Function BX 15841 <SubVariable^23> "write_15841" 4
mov <SubVariable^23>.write BX
jmp 15933           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15849 "!="
tf <esp+2> "in" "codes"
$jmp 15851 "t"
mov <esp+2>["codes"] None
jmp 15851
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_15841+2> <esp+2>["codes"]


mov AX <write_15841+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_15841+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_15841+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
mov <write_15841+3> <esp+1>
inc esp
tf <write_15841+3> "in" "."
mov AX TF
cmp AX 1
$jmp 15878 "=="
tf <write_15841+3> "in" "["
mov AX TF
cmp AX 1
$jmp 15878 "=="
mov AX 0
jmp 15879
mov AX 1
cmp AX 1
$jmp 15895 "=="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_15841+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 15895 "=="
mov AX 0
jmp 15896
mov AX 1
cmp AX 1
$jmp 15918 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_15841+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_15841+2>.append
push "AX."
mov AX <write_15841+0>.attr      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15841+0>.location <esp+1>
inc esp
jmp 15929        ;¸õ¦Ü©³³¡
push ""
mov AX <write_15841+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov AX <write_15841+0>.attr      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_15841+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_15841" "0,1,2,3"
pop ip
mov AX <SubVariable^23>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 15945 "=="
tf AX "Ctn" "__init__"
$jmp 15943 "t"
jmp 15945
call AX.__init__
mov AX <SubVariable^23>
end "Function" "SubVariable^23"
pop ip
Function <&module_14992+8> 15950 None "Slice^24" 1
name <&module_14992+8> "<class '__main__.Slice'>"
jmp 16152
tf $Inheritance "equ" None
$jmp 15955 "t"
mov <Slice^24> $Inheritance
push 1
jmp 15957
mov <Slice^24> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Slice^24> <&module_14992+8>
Function BX 15965 <Slice^24> "__init___15965" 5
mov <Slice^24>.__init__ BX
jmp 16009           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 15973 "!="
tf <esp+2> "in" "start_obj"
$jmp 15975 "t"
mov <esp+2>["start_obj"] None
jmp 15975
mov <esp+2>["start_obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 15981 "!="
tf <esp+2> "in" "end_obj"
$jmp 15983 "t"
mov <esp+2>["end_obj"] None
jmp 15983
mov <esp+2>["end_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 15989 "!="
tf <esp+2> "in" "step_obj"
$jmp 15991 "t"
mov <esp+2>["step_obj"] None
jmp 15991
mov <esp+2>["step_obj"] <esp+1>[2]
dec CX
mov <__init___15965+2> <esp+2>["start_obj"]
mov <__init___15965+3> <esp+2>["end_obj"]
mov <__init___15965+4> <esp+2>["step_obj"]


push <__init___15965+2>
mov <__init___15965+0>.start_obj <esp+1>
inc esp
push <__init___15965+3>
mov <__init___15965+0>.end_obj <esp+1>
inc esp
push <__init___15965+4>
mov <__init___15965+0>.step_obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___15965" "0,1,2,3,4"
pop ip
Function BX 16012 <Slice^24> "__str___16012" 2
mov <Slice^24>.__str__ BX
jmp 16021           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<slice>"
jmp 16018         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16012" "0,1"
pop ip
Function BX 16024 <Slice^24> "write_16024" 3
mov <Slice^24>.write BX
jmp 16138           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16032 "!="
tf <esp+2> "in" "codes"
$jmp 16034 "t"
mov <esp+2>["codes"] None
jmp 16034
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16024+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [3]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
mov AX <write_16024+0>.start_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16024+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[0] "
mov AX <write_16024+0>.start_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
mov AX <write_16024+0>.end_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16024+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[1] "
mov AX <write_16024+0>.end_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
mov AX <write_16024+0>.step_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16024+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[2] "
mov AX <write_16024+0>.step_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call slice"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16024+2>.append
push "AX"
mov <write_16024+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16024" "0,1,2"
pop ip
mov AX <Slice^24>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16150 "=="
tf AX "Ctn" "__init__"
$jmp 16148 "t"
jmp 16150
call AX.__init__
mov AX <Slice^24>
end "Function" "Slice^24"
pop ip
Function <&module_14992+9> 16155 None "IndexVariable^25" 1
name <&module_14992+9> "<class '__main__.IndexVariable'>"
jmp 16309
tf $Inheritance "equ" None
$jmp 16160 "t"
mov <IndexVariable^25> $Inheritance
push 1
jmp 16162
mov <IndexVariable^25> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <IndexVariable^25> <&module_14992+9>
Function BX 16170 <IndexVariable^25> "__init___16170" 4
mov <IndexVariable^25>.__init__ BX
jmp 16202           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16178 "!="
tf <esp+2> "in" "name"
$jmp 16180 "t"
mov <esp+2>["name"] None
jmp 16180
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 16186 "!="
tf <esp+2> "in" "slice_obj"
$jmp 16188 "t"
mov <esp+2>["slice_obj"] None
jmp 16188
mov <esp+2>["slice_obj"] <esp+1>[1]
dec CX
mov <__init___16170+2> <esp+2>["name"]
mov <__init___16170+3> <esp+2>["slice_obj"]


push <__init___16170+2>
mov <__init___16170+0>.name <esp+1>
inc esp
push <__init___16170+3>
mov <__init___16170+0>.slice_obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16170" "0,1,2,3"
pop ip
Function BX 16205 <IndexVariable^25> "__str___16205" 2
mov <IndexVariable^25>.__str__ BX
jmp 16221           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Index "
ex_func AX "str" <__str___16205+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " slice="
ex_func AX "str" <__str___16205+0>.slice_obj
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16218         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16205" "0,1"
pop ip
Function BX 16224 <IndexVariable^25> "write_16224" 3
mov <IndexVariable^25>.write BX
jmp 16295           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16232 "!="
tf <esp+2> "in" "codes"
$jmp 16234 "t"
mov <esp+2>["codes"] None
jmp 16234
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16224+2> <esp+2>["codes"]


mov AX <write_16224+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16224+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_16224+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16224+2>.append
mov AX <write_16224+0>.slice_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16224+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov BX "
mov AX <write_16224+0>.slice_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16224+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16224+2>.append
push "AX[BX]"
mov <write_16224+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16224" "0,1,2"
pop ip
mov AX <IndexVariable^25>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16307 "=="
tf AX "Ctn" "__init__"
$jmp 16305 "t"
jmp 16307
call AX.__init__
mov AX <IndexVariable^25>
end "Function" "IndexVariable^25"
pop ip
Function <&module_14992+10> 16312 None "List^26" 1
name <&module_14992+10> "<class '__main__.List'>"
jmp 16579
tf $Inheritance "equ" None
$jmp 16317 "t"
mov <List^26> $Inheritance
push 1
jmp 16319
mov <List^26> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <List^26> <&module_14992+10>
Function BX 16327 <List^26> "__init___16327" 3
mov <List^26>.__init__ BX
jmp 16347           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16335 "!="
tf <esp+2> "in" "elements"
$jmp 16337 "t"
mov <esp+2>["elements"] None
jmp 16337
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16327+2> <esp+2>["elements"]


push <__init___16327+2>
mov <__init___16327+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16327" "0,1,2"
pop ip
Function BX 16350 <List^26> "__str___16350" 4
mov <List^26>.__str__ BX
jmp 16396           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16350+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16350+0>.elements
push AX
fetch AX <esp+1>
$jmp 16377 "f"
mov <__str___16350+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16350+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16350+2>.append
jmp 16359
inc esp
push "<List  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16350+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16393         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16350" "0,1,2,3"
pop ip
Function BX 16399 <List^26> "__getitem___16399" 3
mov <List^26>.__getitem__ BX
jmp 16440           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16407 "!="
tf <esp+2> "in" "j"
$jmp 16409 "t"
mov <esp+2>["j"] None
jmp 16409
mov <esp+2>["j"] <esp+1>[0]
dec CX
mov <__getitem___16399+2> <esp+2>["j"]


push <__getitem___16399+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___16399+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 16425 ">="
mov AX True
jmp 16426
mov AX False
cmp AX 1
$jmp 16434 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___16399+0>.elements
mov BX <__getitem___16399+2>
pop AX
mov AX AX[BX]
jmp 16437
jmp 16434        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___16399" "0,1,2"
pop ip
Function BX 16443 <List^26> "__len___16443" 2
mov <List^26>.__len__ BX
jmp 16458           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16443+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16455         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16443" "0,1"
pop ip
Function BX 16461 <List^26> "write_16461" 4
mov <List^26>.write BX
jmp 16565           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16469 "!="
tf <esp+2> "in" "codes"
$jmp 16471 "t"
mov <esp+2>["codes"] None
jmp 16471
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16461+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "mov AX ["
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16461+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16461+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16461+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16461+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 16550 "f"
mov <write_16461+3> AX
push <write_16461+0>.elements
mov BX <write_16461+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16461+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>["
ex_func AX "str" <write_16461+3>
oper <esp+1> "+" AX
oper <esp+1> "+" "] "
push <write_16461+0>.elements
mov BX <write_16461+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16461+2>.append
jmp 16515
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16461+2>.append
push "AX"
mov <write_16461+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16461" "0,1,2,3"
pop ip
mov AX <List^26>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16577 "=="
tf AX "Ctn" "__init__"
$jmp 16575 "t"
jmp 16577
call AX.__init__
mov AX <List^26>
end "Function" "List^26"
pop ip
Function <&module_14992+11> 16582 None "Tuple^27" 1
name <&module_14992+11> "<class '__main__.Tuple'>"
jmp 16849
tf $Inheritance "equ" None
$jmp 16587 "t"
mov <Tuple^27> $Inheritance
push 1
jmp 16589
mov <Tuple^27> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Tuple^27> <&module_14992+11>
Function BX 16597 <Tuple^27> "__init___16597" 3
mov <Tuple^27>.__init__ BX
jmp 16617           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16605 "!="
tf <esp+2> "in" "elements"
$jmp 16607 "t"
mov <esp+2>["elements"] None
jmp 16607
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16597+2> <esp+2>["elements"]


push <__init___16597+2>
mov <__init___16597+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16597" "0,1,2"
pop ip
Function BX 16620 <Tuple^27> "__str___16620" 4
mov <Tuple^27>.__str__ BX
jmp 16666           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16620+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16620+0>.elements
push AX
fetch AX <esp+1>
$jmp 16647 "f"
mov <__str___16620+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16620+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16620+2>.append
jmp 16629
inc esp
push "<Tuple  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16620+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16663         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16620" "0,1,2,3"
pop ip
Function BX 16669 <Tuple^27> "__getitem___16669" 3
mov <Tuple^27>.__getitem__ BX
jmp 16710           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16677 "!="
tf <esp+2> "in" "j"
$jmp 16679 "t"
mov <esp+2>["j"] None
jmp 16679
mov <esp+2>["j"] <esp+1>[0]
dec CX
mov <__getitem___16669+2> <esp+2>["j"]


push <__getitem___16669+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___16669+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 16695 ">="
mov AX True
jmp 16696
mov AX False
cmp AX 1
$jmp 16704 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <__getitem___16669+0>.elements
mov BX <__getitem___16669+2>
pop AX
mov AX AX[BX]
jmp 16707
jmp 16704        ;¸õ¦Ü©³³¡
mov AX StopIteration
raise AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___16669" "0,1,2"
pop ip
Function BX 16713 <Tuple^27> "__len___16713" 2
mov <Tuple^27>.__len__ BX
jmp 16728           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16713+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16725         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16713" "0,1"
pop ip
Function BX 16731 <Tuple^27> "write_16731" 4
mov <Tuple^27>.write BX
jmp 16835           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16739 "!="
tf <esp+2> "in" "codes"
$jmp 16741 "t"
mov <esp+2>["codes"] None
jmp 16741
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16731+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
push "mov AX ("
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16731+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ")"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16731+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16731+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16731+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 16820 "f"
mov <write_16731+3> AX
push <write_16731+0>.elements
mov BX <write_16731+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16731+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>["
ex_func AX "str" <write_16731+3>
oper <esp+1> "+" AX
oper <esp+1> "+" "] "
push <write_16731+0>.elements
mov BX <write_16731+3>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16731+2>.append
jmp 16785
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16731+2>.append
push "AX"
mov <write_16731+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16731" "0,1,2,3"
pop ip
mov AX <Tuple^27>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 16847 "=="
tf AX "Ctn" "__init__"
$jmp 16845 "t"
jmp 16847
call AX.__init__
mov AX <Tuple^27>
end "Function" "Tuple^27"
pop ip
Function <&module_14992+12> 16852 None "Dict^28" 1
name <&module_14992+12> "<class '__main__.Dict'>"
jmp 17057
tf $Inheritance "equ" None
$jmp 16857 "t"
mov <Dict^28> $Inheritance
push 1
jmp 16859
mov <Dict^28> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Dict^28> <&module_14992+12>
Function BX 16867 <Dict^28> "__init___16867" 3
mov <Dict^28>.__init__ BX
jmp 16887           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16875 "!="
tf <esp+2> "in" "elements"
$jmp 16877 "t"
mov <esp+2>["elements"] None
jmp 16877
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___16867+2> <esp+2>["elements"]


push <__init___16867+2>
mov <__init___16867+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___16867" "0,1,2"
pop ip
Function BX 16890 <Dict^28> "__str___16890" 5
mov <Dict^28>.__str__ BX
jmp 16937           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [0]
mov <__str___16890+2> <esp+1>
inc esp
ex_func AX "iter" <__str___16890+0>.elements
push AX
fetch AX <esp+1>
$jmp 16918 "f"
mov <__str___16890+3> AX[0]
mov <__str___16890+4> AX[1]
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <__str___16890+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
ex_func AX "str" <__str___16890+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___16890+2>.append
jmp 16899
inc esp
push "<Dict  "
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___16890+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 16934         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___16890" "0,1,2,3,4"
pop ip
Function BX 16940 <Dict^28> "__len___16940" 2
mov <Dict^28>.__len__ BX
jmp 16955           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__len___16940+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
jmp 16952         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__len___16940" "0,1"
pop ip
Function BX 16958 <Dict^28> "write_16958" 5
mov <Dict^28>.write BX
jmp 17043           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 16966 "!="
tf <esp+2> "in" "codes"
$jmp 16968 "t"
mov <esp+2>["codes"] None
jmp 16968
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_16958+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+2>.append
ex_func AX "iter" <write_16958+0>.elements
push AX
fetch AX <esp+1>
$jmp 17028 "f"
mov <write_16958+3> AX[0]
mov <write_16958+4> AX[1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16958+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+3>.write
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_16958+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_16958+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+4>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <esp+1>[BX] "
ex_func AX "str" <write_16958+4>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+2>.append
jmp 16980
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_16958+2>.append
push "AX"
mov <write_16958+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_16958" "0,1,2,3,4"
pop ip
mov AX <Dict^28>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 17055 "=="
tf AX "Ctn" "__init__"
$jmp 17053 "t"
jmp 17055
call AX.__init__
mov AX <Dict^28>
end "Function" "Dict^28"
pop ip
Function <&module_14992+13> 17060 None "Set^29" 1
name <&module_14992+13> "<class '__main__.Set'>"
jmp 17172
tf $Inheritance "equ" None
$jmp 17065 "t"
mov <Set^29> $Inheritance
push 1
jmp 17067
mov <Set^29> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Set^29> <&module_14992+13>
Function BX 17075 <Set^29> "__init___17075" 3
mov <Set^29>.__init__ BX
jmp 17095           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17083 "!="
tf <esp+2> "in" "elements"
$jmp 17085 "t"
mov <esp+2>["elements"] None
jmp 17085
mov <esp+2>["elements"] <esp+1>[0]
dec CX
mov <__init___17075+2> <esp+2>["elements"]


push <__init___17075+2>
mov <__init___17075+0>.elements <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___17075" "0,1,2"
pop ip
Function BX 17098 <Set^29> "__str___17098" 2
mov <Set^29>.__str__ BX
jmp 17107           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<set>"
jmp 17104         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___17098" "0,1"
pop ip
Function BX 17110 <Set^29> "write_17110" 4
mov <Set^29>.write BX
jmp 17158           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17118 "!="
tf <esp+2> "in" "codes"
$jmp 17120 "t"
mov <esp+2>["codes"] None
jmp 17120
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_17110+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17110+0>.elements
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+11>
push AX
mov <write_17110+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17110+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17110+3>.write
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"set\" "
ex_func AX "str" <write_17110+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17110+2>.append
push "AX"
mov <write_17110+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_17110" "0,1,2,3"
pop ip
mov AX <Set^29>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 17170 "=="
tf AX "Ctn" "__init__"
$jmp 17168 "t"
jmp 17170
call AX.__init__
mov AX <Set^29>
end "Function" "Set^29"
pop ip
Function <&module_14992+14> 17174 None "is_number_17174" 3
jmp 17239           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17182 "!="
tf <esp+2> "in" "num"
$jmp 17184 "t"
mov <esp+2>["num"] None
jmp 17184
mov <esp+2>["num"] <esp+1>[0]
dec CX
mov <is_number_17174+1> <esp+2>["num"]


finally 17221
try 17203
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <is_number_17174+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call float
push AX
mov <is_number_17174+2> <esp+1>
inc esp
mov AX True
jmp 17215
try "end"
jmp 17212    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 17211 "f"
mov $Exception 0
try 17219
mov AX False
jmp 17215
try "end"
jmp 17212  ;¸õ¨ìpush 1
jmp 17219 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 17221    ;¸õ¨ìfinally
push AX
try "end"
push 2
jmp 17221    ;¸õ¨ìfinally
push None
push 0
finally -17221
pop AX
cmp AX 2
$jmp 17230 "=="
cmp AX 1
$jmp 17233 "=="
pop AX
mov AX $Exception
raise AX
pop $Exception
pop AX
jmp 17236
pop AX
end "finally_yield"
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "is_number_17174" "0,1,2"
pop ip
Function <&module_14992+15> 17242 None "Lambda^30" 1
name <&module_14992+15> "<class '__main__.Lambda'>"
jmp 17469
tf $Inheritance "equ" None
$jmp 17247 "t"
mov <Lambda^30> $Inheritance
push 1
jmp 17249
mov <Lambda^30> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Lambda^30> <&module_14992+15>
Function BX 17257 <Lambda^30> "__init___17257" 5
mov <Lambda^30>.__init__ BX
jmp 17301           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17265 "!="
tf <esp+2> "in" "params"
$jmp 17267 "t"
mov <esp+2>["params"] None
jmp 17267
mov <esp+2>["params"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 17273 "!="
tf <esp+2> "in" "return_obj"
$jmp 17275 "t"
mov <esp+2>["return_obj"] None
jmp 17275
mov <esp+2>["return_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 17281 "!="
tf <esp+2> "in" "namespace"
$jmp 17283 "t"
mov <esp+2>["namespace"] None
jmp 17283
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
mov <__init___17257+2> <esp+2>["params"]
mov <__init___17257+3> <esp+2>["return_obj"]
mov <__init___17257+4> <esp+2>["namespace"]


push <__init___17257+2>
mov <__init___17257+0>.params <esp+1>
inc esp
push <__init___17257+3>
mov <__init___17257+0>.return_obj <esp+1>
inc esp
push <__init___17257+4>
mov <__init___17257+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___17257" "0,1,2,3,4"
pop ip
Function BX 17304 <Lambda^30> "__str___17304" 2
mov <Lambda^30>.__str__ BX
jmp 17313           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<lambda>"
jmp 17310         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___17304" "0,1"
pop ip
Function BX 17316 <Lambda^30> "write_17316" 9
mov <Lambda^30>.write BX
jmp 17455           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17324 "!="
tf <esp+2> "in" "codes"
$jmp 17326 "t"
mov <esp+2>["codes"] None
jmp 17326
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_17316+2> <esp+2>["codes"]


push "&lambda_"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17316+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17316+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17316+0>.return_obj
mov <esp+1>[1] "return"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+18>
push AX
mov <write_17316+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+42>
push AX
mov <write_17316+5> <esp+1>
inc esp
ex_func AX "iter" <write_17316+0>.params
push AX
fetch AX <esp+1>
$jmp 17385 "f"
mov <write_17316+6> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17316+6>
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17316+5>.add_info
jmp 17365
inc esp
mov AX <write_17316+5>.codelines      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17316+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_17316+3>
mov <esp+1>[1] <write_17316+0>.params
mov <esp+1>[2] <write_17316+5>
mov <esp+1>[3] <write_17316+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+16>
push AX
mov <write_17316+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17316+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17316+7>.write
mov DX <write_17316+0>.namespace
tf DX "equ" ""
$jmp 17421 "f"
mov AX True
jmp 17422
mov AX False
cmp AX 1
$jmp 17428 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17316+3>
mov <write_17316+0>.location <esp+1>
inc esp
jmp 17451        ;¸õ¦Ü©³³¡
mov AX <write_17316+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17316+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_17316+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_17316+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17316+8> <esp+1>
inc esp
push <write_17316+8>
mov <write_17316+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_17316" "0,1,2,3,4,5,6,7,8"
pop ip
mov AX <Lambda^30>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 17467 "=="
tf AX "Ctn" "__init__"
$jmp 17465 "t"
jmp 17467
call AX.__init__
mov AX <Lambda^30>
end "Function" "Lambda^30"
pop ip
Function <&module_14992+16> 17472 None "Def^31" 1
name <&module_14992+16> "<class '__main__.Def'>"
jmp 19750
tf $Inheritance "equ" None
$jmp 17477 "t"
mov <Def^31> $Inheritance
push 1
jmp 17479
mov <Def^31> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Def^31> <&module_14992+16>
Function BX 17487 <Def^31> "__init___17487" 6
mov <Def^31>.__init__ BX
jmp 17555           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17495 "!="
tf <esp+2> "in" "fname"
$jmp 17497 "t"
mov <esp+2>["fname"] None
jmp 17497
mov <esp+2>["fname"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 17503 "!="
tf <esp+2> "in" "params"
$jmp 17505 "t"
mov <esp+2>["params"] None
jmp 17505
mov <esp+2>["params"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 17511 "!="
tf <esp+2> "in" "block_info"
$jmp 17513 "t"
mov <esp+2>["block_info"] None
jmp 17513
mov <esp+2>["block_info"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 17519 "!="
tf <esp+2> "in" "namespace"
$jmp 17521 "t"
mov <esp+2>["namespace"] None
jmp 17521
mov <esp+2>["namespace"] <esp+1>[3]
dec CX
mov <__init___17487+2> <esp+2>["fname"]
mov <__init___17487+3> <esp+2>["params"]
mov <__init___17487+4> <esp+2>["block_info"]
mov <__init___17487+5> <esp+2>["namespace"]


push <__init___17487+2>
mov <__init___17487+0>.name <esp+1>
inc esp
push <__init___17487+3>
mov <__init___17487+0>.params <esp+1>
inc esp
push <__init___17487+5>
mov <__init___17487+0>.namespace <esp+1>
inc esp
push <__init___17487+4>.codelines
mov <__init___17487+0>.codelines <esp+1>
inc esp
push <__init___17487+4>.locals
mov <__init___17487+0>.local_vars <esp+1>
inc esp
tf <__init___17487+0>.namespace "in" "^"
push TF
mov <__init___17487+0>.in_class <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___17487+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___17487" "0,1,2,3,4,5"
pop ip
Function BX 17558 <Def^31> "__str___17558" 5
mov <Def^31>.__str__ BX
jmp 17612           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Def "
ex_func AX "str" <__str___17558+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <__str___17558+2> <esp+1>
inc esp
push [0]
mov <__str___17558+3> <esp+1>
inc esp
ex_func AX "iter" <__str___17558+0>.codelines
push AX
fetch AX <esp+1>
$jmp 17591 "f"
mov <__str___17558+4> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___17558+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___17558+3>.append
jmp 17573
inc esp
push "{"
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___17558+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" "}"
$mov <__str___17558+2> "+" <esp+1>
inc esp
mov AX <__str___17558+2>
jmp 17609         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___17558" "0,1,2,3,4"
pop ip
Function BX 17615 <Def^31> "write_17615" 46
mov <Def^31>.write BX
jmp 19736           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17623 "!="
tf <esp+2> "in" "codes"
$jmp 17625 "t"
mov <esp+2>["codes"] None
jmp 17625
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_17615+2> <esp+2>["codes"]


Function <write_17615+3> 17630 None "get_name_17630" 5 "write_17615"
jmp 17712           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 17638 "!="
tf <esp+2> "in" "string"
$jmp 17640 "t"
mov <esp+2>["string"] None
jmp 17640
mov <esp+2>["string"] <esp+1>[0]
dec CX
mov <get_name_17630+1> <esp+2>["string"]


push ".[ ;"
mov <get_name_17630+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_name_17630+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <get_name_17630+3> <esp+1>[0]
mov <get_name_17630+4> <esp+1>[1]
inc esp
mov DX <get_name_17630+3>
cmp DX <get_name_17630+4>
$jmp 17664 ">="
mov AX True
jmp 17665
mov AX False
cmp AX 1
$jmp 17704 "!="
push <get_name_17630+1>
mov BX <get_name_17630+3>
pop AX
tf <get_name_17630+2> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 17700 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push <get_name_17630+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <get_name_17630+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push <get_name_17630+1>
push [3]
mov <esp+1>[0] <get_name_17630+3>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[1] AX[BX]
pop AX
jmp 17709         ;returnÂI
jmp 17700        ;¸õ¦Ü©³³¡
push 1
$mov <get_name_17630+3> "+" <esp+1>
inc esp
jmp 17659               ;continue­«¨Ó
push (2)
mov <esp+1>[0] <get_name_17630+1>
mov <esp+1>[1] ""
pop AX
jmp 17709         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_name_17630" "0,1,2,3,4"
pop ip
mov DX <write_17615+0>.namespace
tf DX "equ" ""
$jmp 17717 "t"
mov AX True
jmp 17718
mov AX False
cmp AX 1
$jmp 17778 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_17615+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push [5]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov <esp+1>[1] "BX"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop <esp+1>[2]
mov AX <write_17615+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[3] AX.location
mov <esp+1>[4] 0
mov <write_17615+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov "
mov AX <write_17615+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_17615+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " BX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
jmp 17809        ;¸õ¦Ü©³³¡
push [5]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov <esp+1>[1] <write_17615+0>.name
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop <esp+1>[2]
mov <esp+1>[3] None
mov <esp+1>[4] 0
mov <write_17615+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push ""
ex_func AX "str" <write_17615+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "_"
ex_func AX "str" <write_17615+5>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_17615+0>.func_var <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 0
mov <write_17615+6> <esp+1>
inc esp
push [0]
mov <write_17615+7> <esp+1>
inc esp
push None
mov <write_17615+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+0>.params
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call tuple
push AX
mov <write_17615+9> <esp+1>
inc esp
ex_func AX "iter" <write_17615+9>
push AX
fetch AX <esp+1>
$jmp 18245 "f"
mov <write_17615+10> AX
cmp <write_17615+0>.in_class 1
$jmp 17891 "!="
mov DX <write_17615+8>
tf DX "equ" None
$jmp 17886 "f"
mov AX True
jmp 17887
mov AX False
cmp AX 1
$jmp 17891 "!="
mov AX 1
jmp 17892
mov AX 0
cmp AX 1
$jmp 17899 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+10>
mov <write_17615+8> <esp+1>
inc esp
jmp 17876
jmp 17899        ;¸õ¦Ü©³³¡
push <write_17615+10>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 2
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "**"
$jmp 17914 "f"
mov AX True
jmp 17915
mov AX False
cmp AX 1
$jmp 17995 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_17615+11> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "**kwargs <esp+2>[\""
push <write_17615+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+2> \""
ex_func AX "str" <write_17615+11>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
push AX[BX]
push <write_17615+0>.params
push <write_17615+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
del 1 AX BX
push 1        ;Àx¦sCX
push [1]
push <write_17615+10>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+7>.append
jmp 18244        ;¸õ¦Ü©³³¡
push <write_17615+10>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 18003 "f"
mov AX True
jmp 18004
mov AX False
cmp AX 1
$jmp 18071 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "*args <esp+2>[\""
push <write_17615+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+1> "
ex_func AX "str" <write_17615+6>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
push AX[BX]
push <write_17615+0>.params
push <write_17615+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
del 1 AX BX
push 1        ;Àx¦sCX
push [1]
push <write_17615+10>
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+7>.append
jmp 18244        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+7>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp CX 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+12> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
push "tf <esp+2> \"in\" \""
ex_func AX "str" <write_17615+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov <esp+2>[\""
ex_func AX "str" <write_17615+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
push <write_17615+0>.params
mov BX <write_17615+10>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_17615+2>
mov BX <write_17615+12>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov <esp+2>[\""
ex_func AX "str" <write_17615+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] <esp+1>["
ex_func AX "str" <write_17615+6>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "dec CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
push <write_17615+2>
mov BX <write_17615+13>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_17615+6> "+" <esp+1>
inc esp
jmp 17876
inc esp
push 0
mov <write_17615+14> <esp+1>
inc esp
push [dict]
mov <write_17615+15> <esp+1>
inc esp
ex_func AX "iter" <write_17615+0>.params
push AX
fetch AX <esp+1>
$jmp 18267 "f"
mov <write_17615+10> AX
push 1
$mov <write_17615+14> "+" <esp+1>
inc esp
push <write_17615+14>
push <write_17615+15>
mov BX <write_17615+10>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18254
inc esp
ex_func AX "iter" <write_17615+0>.local_vars
push AX
fetch AX <esp+1>
$jmp 18299 "f"
mov <write_17615+16> AX
tf <write_17615+0>.params "in" <write_17615+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18285 "!="
tf <write_17615+15> "in" <write_17615+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18285 "!="
mov AX 1
jmp 18286
mov AX 0
cmp AX 1
$jmp 18298 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <write_17615+14> "+" <esp+1>
inc esp
push <write_17615+14>
push <write_17615+15>
mov BX <write_17615+16>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18298        ;¸õ¦Ü©³³¡
jmp 18270
inc esp
push <write_17615+14>
oper <esp+1> "+" 1
push <write_17615+4>
mov BX 4
pop AX
mov AX[BX] <esp+1>
inc esp
push "Function "
push <write_17615+4>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <write_17615+4>
mov BX 2
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push <write_17615+4>
mov BX 3
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
push <write_17615+4>
mov BX 4
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_17615+2>
push <write_17615+4>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push [0]
mov <write_17615+17> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
ex_func AX "iter" <write_17615+0>.params
push AX
fetch AX <esp+1>
$jmp 18388 "f"
mov <write_17615+10> AX
mov DX <write_17615+10>
tf DX "equ" <write_17615+8>
$jmp 18363 "t"
mov AX True
jmp 18364
mov AX False
cmp AX 1
$jmp 18387 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17615+15>
mov BX <write_17615+10>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "> <esp+2>[\""
ex_func AX "str" <write_17615+10>
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
jmp 18387        ;¸õ¦Ü©³³¡
jmp 18355
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push False
mov <write_17615+19> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+20> <esp+1>
inc esp
ex_func AX "iter" <write_17615+0>.codelines
push AX
fetch AX <esp+1>
$jmp 18439 "f"
mov <write_17615+21> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+21>.write
jmp 18428
inc esp
Function <write_17615+22> 18442 None "save_gen_18442" 2 "write_17615"
jmp 18567           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18450 "!="
tf <esp+2> "in" "num"
$jmp 18452 "t"
mov <esp+2>["num"] None
jmp 18452
mov <esp+2>["num"] <esp+1>[0]
dec CX
mov <save_gen_18442+1> <esp+2>["num"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+25>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18467 "<="
mov AX True
jmp 18468
mov AX False
cmp AX 1
$jmp 18487 "!="
push <write_17615+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push 1
mov DX <save_gen_18442+1>
pop BX
pop AX
tf AX[BX] "in" DX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18487 "!="
mov AX 1
jmp 18488
mov AX 0
cmp AX 1
$jmp 18509 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov BX 1
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_gen_18442+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18509        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 18521 "<="
mov AX True
jmp 18522
mov AX False
cmp AX 1
$jmp 18541 "!="
push <write_17615+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push 1
mov DX <save_gen_18442+1>
pop BX
pop AX
tf AX[BX] "in" DX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 18541 "!="
mov AX 1
jmp 18542
mov AX 0
cmp AX 1
$jmp 18563 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov BX 1
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_gen_18442+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18563        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "save_gen_18442" "0,1"
pop ip
Function <write_17615+23> 18569 None "in_global_18569" 3 "write_17615"
jmp 18603           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18577 "!="
tf <esp+2> "in" "word"
$jmp 18579 "t"
mov <esp+2>["word"] None
jmp 18579
mov <esp+2>["word"] <esp+1>[0]
dec CX
mov <in_global_18569+1> <esp+2>["word"]


ex_func AX "iter" <write_17615+26>
push AX
fetch AX <esp+1>
$jmp 18597 "f"
mov <in_global_18569+2> AX
tf <in_global_18569+2> "in" <in_global_18569+1>
mov AX TF
cmp AX 1
$jmp 18594 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX True
jmp 18595
jmp 18594        ;¸õ¦Ü©³³¡
jmp 18584
inc esp
jmp 18600         ;returnÂI
inc esp
mov AX False
jmp 18600         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "in_global_18569" "0,1,2"
pop ip
push [0]
mov <write_17615+24> <esp+1>
inc esp
push [0]
mov <write_17615+25> <esp+1>
inc esp
push [1]
mov <esp+1>[0] [0]
mov <write_17615+26> <esp+1>
inc esp
push [0]
mov <write_17615+27> <esp+1>
inc esp
push [0]
mov <write_17615+28> <esp+1>
inc esp
push [0]
mov <write_17615+29> <esp+1>
inc esp
Function <write_17615+30> 18624 None "parse_line_18624" 7 "write_17615"
jmp 18774           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 18632 "!="
tf <esp+2> "in" "line"
$jmp 18634 "t"
mov <esp+2>["line"] None
jmp 18634
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <parse_line_18624+1> <esp+2>["line"]


push [0]
mov <parse_line_18624+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_line_18624+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_line_18624+3> <esp+1>[0]
mov <parse_line_18624+4> <esp+1>[1]
inc esp
mov DX <parse_line_18624+3>
cmp DX <parse_line_18624+4>
$jmp 18658 ">="
mov AX True
jmp 18659
mov AX False
cmp AX 1
$jmp 18769 "!="
push <parse_line_18624+3>
mov <parse_line_18624+5> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_line_18624+1>
mov BX <parse_line_18624+5>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 18720 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_line_18624+1>
mov BX <parse_line_18624+5>
pop AX
push AX[BX]
mov <parse_line_18624+6> <esp+1>
inc esp
push <parse_line_18624+5>
oper <esp+1> "+" 1
mov <parse_line_18624+3> <esp+1>
inc esp
push <parse_line_18624+1>
mov BX <parse_line_18624+3>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_line_18624+6>
$jmp 18694 "t"
mov AX True
jmp 18695
mov AX False
cmp AX 1
$jmp 18716 "!="
push <parse_line_18624+1>
mov BX <parse_line_18624+3>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 18705 "f"
mov AX True
jmp 18706
mov AX False
cmp AX 1
$jmp 18712 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_line_18624+3> "+" <esp+1>
inc esp
jmp 18712        ;¸õ¦Ü©³³¡
push 1
$mov <parse_line_18624+3> "+" <esp+1>
inc esp
jmp 18686               ;continue­«¨Ó
push 1
$mov <parse_line_18624+3> "+" <esp+1>
inc esp
jmp 18720        ;¸õ¦Ü©³³¡
mov DX <parse_line_18624+3>
cmp DX <parse_line_18624+4>
$jmp 18725 ">="
mov AX True
jmp 18726
mov AX False
cmp AX 1
$jmp 18741 "!="
push <parse_line_18624+1>
mov BX <parse_line_18624+3>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 18736 "t"
mov AX True
jmp 18737
mov AX False
cmp AX 1
$jmp 18741 "!="
mov AX 1
jmp 18742
mov AX 0
cmp AX 1
$jmp 18748 "!="
push 1
$mov <parse_line_18624+3> "+" <esp+1>
inc esp
jmp 18720               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push <parse_line_18624+1>
push [3]
mov <esp+1>[0] <parse_line_18624+5>
mov <esp+1>[1] <parse_line_18624+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_line_18624+2>.append
push 1
$mov <parse_line_18624+3> "+" <esp+1>
inc esp
jmp 18653               ;continue­«¨Ó
mov AX <parse_line_18624+2>
jmp 18771         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_line_18624" "0,1,2,3,4,5,6"
pop ip
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_17615+20>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19373 "f"
mov <write_17615+6> AX
push <write_17615+2>
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop BX
pop AX
push AX[BX]
mov <write_17615+31> <esp+1>
inc esp
tf <write_17615+31> "in" "\""
mov AX TF
cmp AX 1
$jmp 18813 "=="
tf <write_17615+31> "in" "'"
mov AX TF
cmp AX 1
$jmp 18813 "=="
mov AX 0
jmp 18814
mov AX 1
cmp AX 1
$jmp 18827 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+30>
push AX
mov <write_17615+32> <esp+1>
inc esp
jmp 18837        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+31>.split
push AX
mov <write_17615+32> <esp+1>
inc esp
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "return"
$jmp 18845 "f"
mov AX True
jmp 18846
mov AX False
cmp AX 1
$jmp 18859 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+17>.append
jmp 18792
jmp 18920        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "global"
$jmp 18867 "f"
mov AX True
jmp 18868
mov AX False
cmp AX 1
$jmp 18889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+26>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_17615+32>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 18920        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "nonlocal"
$jmp 18897 "f"
mov AX True
jmp 18898
mov AX False
cmp AX 1
$jmp 18920 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_17615+32>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+27>.append
push 1        ;Àx¦sCX
push [1]
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+28>.append
jmp 18920        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "yield"
$jmp 18928 "f"
mov AX True
jmp 18929
mov AX False
cmp AX 1
$jmp 18941 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "Yield"
push <write_17615+32>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push True
mov <write_17615+19> <esp+1>
inc esp
jmp 19139        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "Function"
$jmp 18949 "f"
mov AX True
jmp 18950
mov AX False
cmp AX 1
$jmp 18972 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop <esp+1>[0]
mov <esp+1>[1] [0]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+25>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+26>.append
jmp 19139        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "Generator"
$jmp 18980 "f"
mov AX True
jmp 18981
mov AX False
cmp AX 1
$jmp 18996 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop <esp+1>[0]
mov <esp+1>[1] [0]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+24>.append
jmp 19139        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "end"
$jmp 19004 "f"
mov AX True
jmp 19005
mov AX False
cmp AX 1
$jmp 19139 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+32>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "\"Function\""
$jmp 19015 "f"
mov AX True
jmp 19016
mov AX False
cmp AX 1
$jmp 19075 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <write_17615+33> <esp+1>[0]
mov <write_17615+34> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+34>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 19039 "<="
mov AX True
jmp 19040
mov AX False
cmp AX 1
$jmp 19062 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+34>
$mov <write_17615+29> "+" <esp+1>
inc esp
push " \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_17615+35> <esp+1>
inc esp
push <write_17615+2>
mov BX <write_17615+33>
pop AX
push AX[BX]
oper <esp+1> "+" <write_17615+35>
push <write_17615+2>
mov BX <write_17615+33>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19062        ;¸õ¦Ü©³³¡
push <write_17615+25>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
push <write_17615+26>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 19137        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "\"Generator\""
$jmp 19083 "f"
mov AX True
jmp 19084
mov AX False
cmp AX 1
$jmp 19137 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <write_17615+36> <esp+1>[0]
mov <write_17615+34> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+34>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 19107 "<="
mov AX True
jmp 19108
mov AX False
cmp AX 1
$jmp 19130 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_17615+34>
$mov <write_17615+29> "+" <esp+1>
inc esp
push " \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
mov <write_17615+37> <esp+1>
inc esp
push <write_17615+2>
mov BX <write_17615+36>
pop AX
push AX[BX]
oper <esp+1> "+" <write_17615+37>
push <write_17615+2>
mov BX <write_17615+36>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19130        ;¸õ¦Ü©³³¡
push <write_17615+24>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 19137        ;¸õ¦Ü©³³¡
jmp 18792
jmp 19139        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+32>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19353 "f"
mov <write_17615+38> AX
mov DX <write_17615+38>
tf DX "equ" 0
$jmp 19163 "f"
mov AX True
jmp 19164
mov AX False
cmp AX 1
$jmp 19179 "=="
push <write_17615+32>
mov BX <write_17615+38>
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 19174 "f"
mov AX True
jmp 19175
mov AX False
cmp AX 1
$jmp 19179 "=="
mov AX 0
jmp 19180
mov AX 1
cmp AX 1
$jmp 19184 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19155
jmp 19184        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_17615+32>
mov BX <write_17615+38>
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 19201 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19155
jmp 19201        ;¸õ¦Ü©³³¡
push <write_17615+32>
mov BX <write_17615+38>
pop AX
push AX[BX]
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ";"
$jmp 19212 "f"
mov AX True
jmp 19213
mov AX False
cmp AX 1
$jmp 19217 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19353          ;break¥X°j°é
jmp 19217        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <write_17615+32>
mov BX <write_17615+38>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+3>
push AX
mov <write_17615+16> <esp+1>[0]
mov <write_17615+39> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+23>
$oper AX "not"
cmp AX 1
$jmp 19248 "!="
tf <write_17615+27> "in" <write_17615+16>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 19248 "!="
mov AX 1
jmp 19249
mov AX 0
cmp AX 1
$jmp 19352 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <write_17615+16>
tf DX "equ" ""
$jmp 19256 "f"
mov AX True
jmp 19257
mov AX False
cmp AX 1
$jmp 19261 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 19353          ;break¥X°j°é
jmp 19351        ;¸õ¦Ü©³³¡
mov DX <write_17615+16>
tf DX "equ" <write_17615+8>
$jmp 19266 "f"
mov AX True
jmp 19267
mov AX False
cmp AX 1
$jmp 19289 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+0>"
oper <esp+1> "+" <write_17615+39>
push <write_17615+32>
mov BX <write_17615+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17615+14>
oper <esp+1> "+" 4
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+22>
jmp 19351        ;¸õ¦Ü©³³¡
tf <write_17615+0>.params "in" <write_17615+16>
mov AX TF
cmp AX 1
$jmp 19320 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17615+15>
mov BX <write_17615+16>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
oper <esp+1> "+" <write_17615+39>
push <write_17615+32>
mov BX <write_17615+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17615+15>
mov BX <write_17615+16>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+22>
jmp 19351        ;¸õ¦Ü©³³¡
tf <write_17615+0>.local_vars "in" <write_17615+16>
mov AX TF
cmp AX 1
$jmp 19351 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "<"
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
push <write_17615+15>
mov BX <write_17615+16>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
oper <esp+1> "+" <write_17615+39>
push <write_17615+32>
mov BX <write_17615+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17615+15>
mov BX <write_17615+16>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+22>
jmp 19351        ;¸õ¦Ü©³³¡
jmp 19352        ;¸õ¦Ü©³³¡
jmp 19155
inc esp
mov AX " "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+32>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <write_17615+2>
push <write_17615+20>
oper <esp+1> "+" <write_17615+6>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 18792
inc esp
push [0]
mov <write_17615+40> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <write_17615+14>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 19412 "f"
mov <write_17615+6> AX
tf <write_17615+29> "in" <write_17615+6>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 19411 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+40>.append
jmp 19411        ;¸õ¦Ü©³³¡
jmp 19388
inc esp
ex_func AX "iter" <write_17615+28>
push AX
fetch AX <esp+1>
$jmp 19425 "f"
mov <write_17615+41> AX
push ""
push <write_17615+2>
mov BX <write_17615+41>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19415
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_17615+42> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 19448 "<="
mov AX True
jmp 19449
mov AX False
cmp AX 1
$jmp 19470 "!="
push <write_17615+17>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
push <write_17615+42>
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 19465 "f"
mov AX True
jmp 19466
mov AX False
cmp AX 1
$jmp 19470 "!="
mov AX 1
jmp 19471
mov AX 0
cmp AX 1
$jmp 19493 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
ex_func AX "iter" <write_17615+17>
push AX
fetch AX <esp+1>
$jmp 19491 "f"
mov <write_17615+43> AX
push "jmp "
push <write_17615+42>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "         ;returnÂI"
push <write_17615+2>
mov BX <write_17615+43>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19475
inc esp
jmp 19526        ;¸õ¦Ü©³³¡
ex_func AX "iter" <write_17615+17>
push AX
fetch AX <esp+1>
$jmp 19508 "f"
mov <write_17615+43> AX
push "jmp "
ex_func AX "str" <write_17615+42>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_17615+2>
mov BX <write_17615+43>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 19495
inc esp
cmp <write_17615+19> 1
$jmp 19519 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX \"\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
jmp 19526        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
cmp <write_17615+19> 1
$jmp 19641 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "StopIteration"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AX"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+17>
push AX
mov <write_17615+44> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_17615+44>
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+18>
push AX
mov <write_17615+45> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+45>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "stop     ;²z½×¤W¤£·|°õ¦æ¨ì³o¤@¦æ"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push "Generator AX "
push <write_17615+18>
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_17615+2>
mov BX <write_17615+18>
pop AX
mov AX[BX] <esp+1>
inc esp
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "      ;¦]¬°¬Oyield¡Aª½±µ¸õ¨ìpop ip"
push <write_17615+2>
push <write_17615+18>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "end \"Generator\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
jmp 19655        ;¸õ¦Ü©³³¡
push ""
push <write_17615+2>
mov BX <write_17615+18>
pop AX
mov AX[BX] <esp+1>
inc esp
push ""
push <write_17615+2>
push <write_17615+18>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
cmp <write_17615+19> 1
$jmp 19676 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
jmp 19700        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_17615+0>.func_var
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
oper <esp+1> "+" "\""
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+40>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop ip"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_17615+2>.del_tab
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_17615+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "           ;¸õ¹L¦¹¨ç¼Æ"
push <write_17615+2>
mov BX <write_17615+5>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_17615" "0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,27,28,29,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45"
pop ip
mov AX <Def^31>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 19748 "=="
tf AX "Ctn" "__init__"
$jmp 19746 "t"
jmp 19748
call AX.__init__
mov AX <Def^31>
end "Function" "Def^31"
pop ip
Function <&module_14992+17> 19753 None "FuncCall^32" 1
name <&module_14992+17> "<class '__main__.FuncCall'>"
jmp 20433
tf $Inheritance "equ" None
$jmp 19758 "t"
mov <FuncCall^32> $Inheritance
push 1
jmp 19760
mov <FuncCall^32> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <FuncCall^32> <&module_14992+17>
Function BX 19768 <FuncCall^32> "__init___19768" 7
mov <FuncCall^32>.__init__ BX
jmp 19841           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19776 "!="
tf <esp+2> "in" "name"
$jmp 19778 "t"
mov <esp+2>["name"] None
jmp 19778
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 19784 "!="
tf <esp+2> "in" "args"
$jmp 19786 "t"
mov <esp+2>["args"] None
jmp 19786
mov <esp+2>["args"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 19792 "!="
tf <esp+2> "in" "kwargs"
$jmp 19794 "t"
mov <esp+2>["kwargs"] None
jmp 19794
mov <esp+2>["kwargs"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 19800 "!="
tf <esp+2> "in" "s_args"
$jmp 19802 "t"
mov <esp+2>["s_args"] None
jmp 19802
mov <esp+2>["s_args"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 19808 "!="
tf <esp+2> "in" "s_kwargs"
$jmp 19810 "t"
mov <esp+2>["s_kwargs"] (0)
jmp 19810
mov <esp+2>["s_kwargs"] <esp+1>[4]
dec CX
mov <__init___19768+2> <esp+2>["name"]
mov <__init___19768+3> <esp+2>["args"]
mov <__init___19768+4> <esp+2>["kwargs"]
mov <__init___19768+5> <esp+2>["s_args"]
mov <__init___19768+6> <esp+2>["s_kwargs"]


push <__init___19768+2>
mov <__init___19768+0>.name <esp+1>
inc esp
push <__init___19768+3>
mov <__init___19768+0>.args <esp+1>
inc esp
push <__init___19768+4>
mov <__init___19768+0>.kwargs <esp+1>
inc esp
push <__init___19768+5>
mov <__init___19768+0>.s_args <esp+1>
inc esp
push <__init___19768+6>
mov <__init___19768+0>.s_kwargs <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___19768+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___19768" "0,1,2,3,4,5,6"
pop ip
Function BX 19844 <FuncCall^32> "__str___19844" 2
mov <FuncCall^32>.__str__ BX
jmp 19863           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Call "
ex_func AX "str" <__str___19844+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" " args="
ex_func AX "str" <__str___19844+0>.args
oper <esp+1> "+" AX
oper <esp+1> "+" " kwargs="
ex_func AX "str" <__str___19844+0>.kwargs
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 19860         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___19844" "0,1"
pop ip
Function BX 19866 <FuncCall^32> "__getitem___19866" 3
mov <FuncCall^32>.__getitem__ BX
jmp 19906           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19874 "!="
tf <esp+2> "in" "item"
$jmp 19876 "t"
mov <esp+2>["item"] None
jmp 19876
mov <esp+2>["item"] <esp+1>[0]
dec CX
mov <__getitem___19866+2> <esp+2>["item"]


push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AX"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__getitem___19866+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+0>
mov <esp+1>[1] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+9>
jmp 19903         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__getitem___19866" "0,1,2"
pop ip
Function BX 19909 <FuncCall^32> "write_19909" 10
mov <FuncCall^32>.write BX
jmp 20419           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19917 "!="
tf <esp+2> "in" "codes"
$jmp 19919 "t"
mov <esp+2>["codes"] None
jmp 19919
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_19909+2> <esp+2>["codes"]


Function <write_19909+3> 19924 None "deal_cx_args_kwargs_19924" 4 "write_19909"
jmp 20189           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 19932 "!="
tf <esp+2> "in" "args"
$jmp 19934 "t"
mov <esp+2>["args"] None
jmp 19934
mov <esp+2>["args"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 19940 "!="
tf <esp+2> "in" "call_name"
$jmp 19942 "t"
mov <esp+2>["call_name"] None
jmp 19942
mov <esp+2>["call_name"] <esp+1>[1]
dec CX
mov <deal_cx_args_kwargs_19924+1> <esp+2>["args"]
mov <deal_cx_args_kwargs_19924+2> <esp+2>["call_name"]


push 1        ;Àx¦sCX
push [1]
push "push "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_cx_args_kwargs_19924+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "        ;Àx¦sCX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_cx_args_kwargs_19924+1>.write
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <deal_cx_args_kwargs_19924+1>.location
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;¬°call "
ex_func AX "str" <deal_cx_args_kwargs_19924+2>
oper <esp+1> "+" AX
oper <esp+1> "+" " °µ·Ç³Æ"
pop <esp+1>[0]
push [dict]
mov BX "simplify"
mov <esp+1>[BX] <write_19909+0>.in_class
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
mov DX <write_19909+0>.s_args
tf DX "equ" None
$jmp 19993 "t"
mov AX True
jmp 19994
mov AX False
cmp AX 1
$jmp 20040 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_19909+0>.s_args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"list\" "
mov AX <write_19909+0>.s_args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "ex_func BX \"len\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov <esp+2> \"+\" BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov <esp+1> \"+\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
jmp 20040        ;¸õ¦Ü©³³¡
mov AX <write_19909+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+0>.s_kwargs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 20062 "<="
mov AX True
jmp 20063
mov AX False
cmp AX 1
$jmp 20131 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_19909+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
ex_func AX "iter" <write_19909+0>.s_kwargs
push AX
fetch AX <esp+1>
$jmp 20122 "f"
mov <deal_cx_args_kwargs_19924+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_cx_args_kwargs_19924+3>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov *args [1]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov *args[0] "
ex_func AX "str" <deal_cx_args_kwargs_19924+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call <esp+1>.update"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
jmp 20079
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
jmp 20143        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "mov **kwargs "
mov AX <write_19909+0>.kwargs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX     ;¨ú¦^CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
cmp <write_19909+4> 1
$jmp 20174 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
jmp 20185        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "call "
ex_func AX "str" <deal_cx_args_kwargs_19924+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_cx_args_kwargs_19924" "0,1,2,3"
pop ip
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_19909+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <write_19909+0>.name
mov BX "^"
pop AX
tf AX.location "in" BX
push TF
mov <write_19909+0>.in_class <esp+1>
inc esp
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 2
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX"
$jmp 20230 "f"
mov AX True
jmp 20231
mov AX False
cmp AX 1
$jmp 20242 "=="
push <write_19909+0>.name
mov BX "&"
pop AX
tf AX.location "in" BX
mov AX TF
cmp AX 1
$jmp 20242 "=="
mov AX 0
jmp 20243
mov AX 1
push AX
mov <write_19909+4> <esp+1>
inc esp
cmp <write_19909+4> 1
$jmp 20261 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
jmp 20261        ;¸õ¦Ü©³³¡
cmp <write_19909+0>.in_class 1
$jmp 20403 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.location      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_19909+5> <esp+1>[0]
mov <write_19909+6> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push "tf "
ex_func AX "str" <write_19909+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"Ctn\" \""
ex_func AX "str" <write_19909+6>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_19909+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19909+0>.args
mov <esp+1>[1] <write_19909+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+3>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_19909+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
push <write_19909+2>
mov BX <write_19909+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov AX <write_19909+0>.args      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.elements
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+10>
push AX
mov <write_19909+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19909+9>
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.location
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+3>
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_19909+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_19909+2>
mov BX <write_19909+8>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 20412        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_19909+0>.args
mov AX <write_19909+0>.name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.location
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_19909+3>
push "AX"
mov <write_19909+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_19909" "0,1,5,6,7,8,9"
pop ip
mov AX <FuncCall^32>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20431 "=="
tf AX "Ctn" "__init__"
$jmp 20429 "t"
jmp 20431
call AX.__init__
mov AX <FuncCall^32>
end "Function" "FuncCall^32"
pop ip
Function <&module_14992+18> 20436 None "Backtrack^33" 1
name <&module_14992+18> "<class '__main__.Backtrack'>"
jmp 20588
tf $Inheritance "equ" None
$jmp 20441 "t"
mov <Backtrack^33> $Inheritance
push 1
jmp 20443
mov <Backtrack^33> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Backtrack^33> <&module_14992+18>
Function BX 20451 <Backtrack^33> "__init___20451" 4
mov <Backtrack^33>.__init__ BX
jmp 20488           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20459 "!="
tf <esp+2> "in" "value"
$jmp 20461 "t"
mov <esp+2>["value"] None
jmp 20461
mov <esp+2>["value"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20467 "!="
tf <esp+2> "in" "cmd"
$jmp 20469 "t"
mov <esp+2>["cmd"] None
jmp 20469
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___20451+2> <esp+2>["value"]
mov <__init___20451+3> <esp+2>["cmd"]


push <__init___20451+2>
mov <__init___20451+0>.A <esp+1>
inc esp
push <__init___20451+3>
mov <__init___20451+0>.cmd <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___20451+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20451" "0,1,2,3"
pop ip
Function BX 20491 <Backtrack^33> "__str___20491" 2
mov <Backtrack^33>.__str__ BX
jmp 20507           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___20491+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___20491+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 20504         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20491" "0,1"
pop ip
Function BX 20510 <Backtrack^33> "write_20510" 3
mov <Backtrack^33>.write BX
jmp 20574           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20518 "!="
tf <esp+2> "in" "codes"
$jmp 20520 "t"
mov <esp+2>["codes"] None
jmp 20520
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20510+2> <esp+2>["codes"]


mov AX <write_20510+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20510+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_20510+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 20539 "t"
mov AX True
jmp 20540
mov AX False
cmp AX 1
$jmp 20555 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_20510+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20510+2>.append
jmp 20555        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push ""
ex_func AX "str" <write_20510+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " AX"
pop <esp+1>[0]
mov <esp+1>[1] <write_20510+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20510+2>.append
push "AX"
mov <write_20510+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20510" "0,1,2"
pop ip
mov AX <Backtrack^33>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20586 "=="
tf AX "Ctn" "__init__"
$jmp 20584 "t"
jmp 20586
call AX.__init__
mov AX <Backtrack^33>
end "Function" "Backtrack^33"
pop ip
Function <&module_14992+19> 20591 None "Var_declare^34" 1
name <&module_14992+19> "<class '__main__.Var_declare'>"
jmp 20801
tf $Inheritance "equ" None
$jmp 20596 "t"
mov <Var_declare^34> $Inheritance
push 1
jmp 20598
mov <Var_declare^34> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Var_declare^34> <&module_14992+19>
Function BX 20606 <Var_declare^34> "__init___20606" 4
mov <Var_declare^34>.__init__ BX
jmp 20638           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20614 "!="
tf <esp+2> "in" "value"
$jmp 20616 "t"
mov <esp+2>["value"] None
jmp 20616
mov <esp+2>["value"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20622 "!="
tf <esp+2> "in" "cmd"
$jmp 20624 "t"
mov <esp+2>["cmd"] None
jmp 20624
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___20606+2> <esp+2>["value"]
mov <__init___20606+3> <esp+2>["cmd"]


push <__init___20606+2>
mov <__init___20606+0>.value <esp+1>
inc esp
push <__init___20606+3>
mov <__init___20606+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20606" "0,1,2,3"
pop ip
Function BX 20641 <Var_declare^34> "__str___20641" 2
mov <Var_declare^34>.__str__ BX
jmp 20657           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___20641+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___20641+0>.value
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 20654         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20641" "0,1"
pop ip
Function BX 20660 <Var_declare^34> "write_20660" 5
mov <Var_declare^34>.write BX
jmp 20787           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20668 "!="
tf <esp+2> "in" "codes"
$jmp 20670 "t"
mov <esp+2>["codes"] None
jmp 20670
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20660+2> <esp+2>["codes"]


mov AX <write_20660+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20660+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <write_20660+0>.cmd
tf DX "equ" "del"
$jmp 20688 "f"
mov AX True
jmp 20689
mov AX False
cmp AX 1
$jmp 20768 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20660+0>.value
mov BX "."
pop AX
tf AX.location "in" BX
mov AX TF
cmp AX 1
$jmp 20728 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_20660+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX AX.location      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_20660+3> <esp+1>[0]
mov <write_20660+4> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
push "del 2 "
ex_func AX "str" <write_20660+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_20660+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20660+2>.append
jmp 20767        ;¸õ¦Ü©³³¡
mov AX <write_20660+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX["
$jmp 20744 "f"
mov AX True
jmp 20745
mov AX False
cmp AX 1
$jmp 20755 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "del 1 AX BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20660+2>.append
jmp 20767        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "del 0 "
mov AX <write_20660+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " None"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20660+2>.append
jmp 20783        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push ""
ex_func AX "str" <write_20660+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_20660+0>.value      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20660+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20660" "0,1,2,3,4"
pop ip
mov AX <Var_declare^34>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 20799 "=="
tf AX "Ctn" "__init__"
$jmp 20797 "t"
jmp 20799
call AX.__init__
mov AX <Var_declare^34>
end "Function" "Var_declare^34"
pop ip
Function <&module_14992+20> 20804 None "Try_Except^35" 1
name <&module_14992+20> "<class '__main__.Try_Except'>"
jmp 22469
tf $Inheritance "equ" None
$jmp 20809 "t"
mov <Try_Except^35> $Inheritance
push 1
jmp 20811
mov <Try_Except^35> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Try_Except^35> <&module_14992+20>
Function BX 20819 <Try_Except^35> "__init___20819" 7
mov <Try_Except^35>.__init__ BX
jmp 20890           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20827 "!="
tf <esp+2> "in" "try_codelines"
$jmp 20829 "t"
mov <esp+2>["try_codelines"] None
jmp 20829
mov <esp+2>["try_codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 20835 "!="
tf <esp+2> "in" "except_objects"
$jmp 20837 "t"
mov <esp+2>["except_objects"] None
jmp 20837
mov <esp+2>["except_objects"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 20843 "!="
tf <esp+2> "in" "else_codelines"
$jmp 20845 "t"
mov <esp+2>["else_codelines"] (0)
jmp 20845
mov <esp+2>["else_codelines"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 20851 "!="
tf <esp+2> "in" "finally_codelines"
$jmp 20853 "t"
mov <esp+2>["finally_codelines"] (0)
jmp 20853
mov <esp+2>["finally_codelines"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 20859 "!="
tf <esp+2> "in" "namespace"
$jmp 20861 "t"
mov <esp+2>["namespace"] ""
jmp 20861
mov <esp+2>["namespace"] <esp+1>[4]
dec CX
mov <__init___20819+2> <esp+2>["try_codelines"]
mov <__init___20819+3> <esp+2>["except_objects"]
mov <__init___20819+4> <esp+2>["else_codelines"]
mov <__init___20819+5> <esp+2>["finally_codelines"]
mov <__init___20819+6> <esp+2>["namespace"]


push <__init___20819+2>
mov <__init___20819+0>.try_codelines <esp+1>
inc esp
push <__init___20819+3>
mov <__init___20819+0>.except_objects <esp+1>
inc esp
push <__init___20819+4>
mov <__init___20819+0>.else_codelines <esp+1>
inc esp
push <__init___20819+5>
mov <__init___20819+0>.finally_codelines <esp+1>
inc esp
push <__init___20819+6>
mov <__init___20819+0>.namespace <esp+1>
inc esp
push [0]
mov <__init___20819+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___20819" "0,1,2,3,4,5,6"
pop ip
Function BX 20893 <Try_Except^35> "__str___20893" 2
mov <Try_Except^35>.__str__ BX
jmp 20902           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<Try Except>"
jmp 20899         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___20893" "0,1"
pop ip
Function BX 20905 <Try_Except^35> "write_20905" 39
mov <Try_Except^35>.write BX
jmp 22455           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 20913 "!="
tf <esp+2> "in" "codes"
$jmp 20915 "t"
mov <esp+2>["codes"] None
jmp 20915
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_20905+2> <esp+2>["codes"]


push 0
mov <write_20905+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] 0
push <write_20905+0>.orig_lines
mov BX <write_20905+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push [dict]
push "continue"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "break"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "return"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
mov <write_20905+6> <esp+1>
inc esp
push [0]
mov <write_20905+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+8> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.add_tab
ex_func AX "iter" <write_20905+0>.try_codelines
push AX
fetch AX <esp+1>
$jmp 21006 "f"
mov <write_20905+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+9>.write
jmp 20995
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.del_tab
push 1
$mov <write_20905+3> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20905+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21077 "f"
mov <write_20905+10> AX
push <write_20905+2>
push <write_20905+8>
oper <esp+1> "+" <write_20905+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20905+11> <esp+1>
inc esp
mov DX <write_20905+11>
tf DX "equ" "yield"
$jmp 21063 "f"
mov AX True
jmp 21064
mov AX False
cmp AX 1
$jmp 21076 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_20905+8>
oper <esp+1> "+" <write_20905+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+7>.append
jmp 21076        ;¸õ¦Ü©³³¡
jmp 21034
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+12> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
mov DX <write_20905+0>.namespace
tf DX "equ" ""
$jmp 21107 "t"
mov AX True
jmp 21108
mov AX False
cmp AX 1
$jmp 21128 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_20905+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_20905+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_20905+13> <esp+1>
inc esp
jmp 21131        ;¸õ¦Ü©³³¡
push ""
mov <write_20905+13> <esp+1>
inc esp
push 0
mov <write_20905+14> <esp+1>
inc esp
push "try "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_20905+15> <esp+1>
inc esp
push [0]
mov <write_20905+16> <esp+1>
inc esp
push [0]
mov <write_20905+17> <esp+1>
inc esp
push [0]
mov <write_20905+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+0>.except_objects
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21435 "f"
mov <write_20905+10> AX
mov DX <write_20905+14>
tf DX "equ" 0
$jmp 21185 "f"
mov AX True
jmp 21186
mov AX False
cmp AX 1
$jmp 21198 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20905+15>
push <write_20905+2>
mov BX <write_20905+5>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
mov <write_20905+14> <esp+1>
inc esp
jmp 21217        ;¸õ¦Ü©³³¡
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"f\""
push <write_20905+2>
mov BX <write_20905+5>
pop AX
mov AX[BX] <esp+1>
inc esp
push <write_20905+10>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+0>.except_objects
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 21230 ">="
mov AX True
jmp 21231
mov AX False
cmp AX 1
$jmp 21413 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20905+0>.orig_lines
mov BX <write_20905+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1
$mov <write_20905+3> "+" <esp+1>
inc esp
push <write_20905+0>.except_objects
mov BX <write_20905+10>
pop AX
push AX[BX]
mov <write_20905+19> <esp+1>
inc esp
push <write_20905+19>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "error "
push <write_20905+19>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push <write_20905+19>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" None
$jmp 21306 "t"
mov AX True
jmp 21307
mov AX False
cmp AX 1
$jmp 21327 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_20905+13>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20905+19>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " $Exception"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 21327        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Exception 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+16>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.add_tab
push <write_20905+19>
mov BX 2
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 21377 "f"
mov <write_20905+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+9>.write
jmp 21366
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.del_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+18>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 21434        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+17>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 21177
inc esp
ex_func AX "iter" <write_20905+7>
push AX
fetch AX <esp+1>
$jmp 21493 "f"
mov <write_20905+20> AX
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " ;³B²ztry¤¤ªºyield"
push <write_20905+2>
mov BX <write_20905+20>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "yield AX          ;try¤¤ªºyield§ï¨ì³o¸Ì"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
ex_func AX "str" <write_20905+20>
oper <esp+1> "+" AX
oper <esp+1> "+" "     ;ªğ¦^try¤¤ªºyield¤U¤@¦æ"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 21438
inc esp
push [0]
mov <write_20905+21> <esp+1>
inc esp
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;try¥¿±`µ²§ô¡A¸õ¨ìelse"
push <write_20905+2>
mov BX <write_20905+12>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21528 "<="
mov AX True
jmp 21529
mov AX False
cmp AX 1
$jmp 21600 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20905+0>.orig_lines
mov BX <write_20905+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1
$mov <write_20905+3> "+" <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.add_tab
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+16>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
ex_func AX "iter" <write_20905+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 21585 "f"
mov <write_20905+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+9>.write
jmp 21574
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.del_tab
jmp 21600        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20905+22> <esp+1>
inc esp
ex_func AX "iter" <write_20905+18>
push AX
fetch AX <esp+1>
$jmp 21626 "f"
mov <write_20905+23> AX
push "jmp "
ex_func AX "str" <write_20905+22>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;¸õ¨ìpush 1"
push <write_20905+2>
mov BX <write_20905+23>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21613
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None  ;±À¤JNone"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 1     ;¥Nªí¥¿±`"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+21>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push [dict]
mov <write_20905+24> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20905+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 21749 "f"
mov <write_20905+10> AX
push 1        ;Àx¦sCX
push [1]
push <write_20905+2>
push <write_20905+8>
oper <esp+1> "+" <write_20905+10>
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 21703 "f"
mov AX True
jmp 21704
mov AX False
cmp AX 1
$jmp 21748 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20905+2>
push <write_20905+8>
oper <esp+1> "+" <write_20905+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20905+11> <esp+1>
inc esp
tf <write_20905+6> "in" <write_20905+11>
mov AX TF
cmp AX 1
$jmp 21747 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20905+6>
mov BX <write_20905+11>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_20905+8>
oper <esp+1> "+" <write_20905+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 21747        ;¸õ¦Ü©³³¡
jmp 21748        ;¸õ¦Ü©³³¡
jmp 21683
inc esp
push 2
mov <write_20905+25> <esp+1>
inc esp
ex_func AX "iter" <write_20905+6>
push AX
fetch AX <esp+1>
$jmp 21879 "f"
mov <write_20905+26> AX
push 1        ;Àx¦sCX
push [1]
push <write_20905+6>
mov BX <write_20905+26>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 21773 "<="
mov AX True
jmp 21774
mov AX False
cmp AX 1
$jmp 21878 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20905+27> <esp+1>
inc esp
push <write_20905+6>
mov BX <write_20905+26>
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 21805 "f"
mov <write_20905+28> AX
push "jmp "
ex_func AX "str" <write_20905+27>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20905+2>
mov BX <write_20905+28>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21792
inc esp
mov DX <write_20905+26>
tf DX "equ" "return"
$jmp 21811 "f"
mov AX True
jmp 21812
mov AX False
cmp AX 1
$jmp 21822 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 21829        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "try \"end\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_20905+25>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+21>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push <write_20905+26>
push <write_20905+24>
mov BX <write_20905+25>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_20905+25> "+" <esp+1>
inc esp
jmp 21878        ;¸õ¦Ü©³³¡
jmp 21755
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20905+29> <esp+1>
inc esp
ex_func AX "iter" <write_20905+16>
push AX
fetch AX <esp+1>
$jmp 21906 "f"
mov <write_20905+30> AX
push "try "
ex_func AX "str" <write_20905+29>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20905+2>
mov BX <write_20905+30>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21893
inc esp
ex_func AX "iter" <write_20905+17>
push AX
fetch AX <esp+1>
$jmp 21922 "f"
mov <write_20905+23> AX
push "jmp "
ex_func AX "str" <write_20905+29>
oper <esp+1> "+" AX
oper <esp+1> "+" " ;push 0"
push <write_20905+2>
mov BX <write_20905+23>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21909
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20905+31> <esp+1>
inc esp
push "finally "
ex_func AX "str" <write_20905+31>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20905+2>
mov BX <write_20905+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_20905+21>
push AX
fetch AX <esp+1>
$jmp 21972 "f"
mov <write_20905+32> AX
push "jmp "
ex_func AX "str" <write_20905+31>
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;¸õ¨ìfinally"
push <write_20905+2>
mov BX <write_20905+32>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 21959
inc esp
push 1        ;Àx¦sCX
push [1]
push "finally -"
ex_func AX "str" <write_20905+31>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+33> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+0>.finally_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 22006 "<="
mov AX True
jmp 22007
mov AX False
cmp AX 1
$jmp 22064 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Exception 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_20905+0>.orig_lines
mov BX <write_20905+3>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1
$mov <write_20905+3> "+" <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.add_tab
ex_func AX "iter" <write_20905+0>.finally_codelines
push AX
fetch AX <esp+1>
$jmp 22056 "f"
mov <write_20905+9> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+9>.write
jmp 22045
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.del_tab
jmp 22064        ;¸õ¦Ü©³³¡
push [dict]
push "continue"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "break"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
push "return"
mov AX [0]
pop BX
mov <esp+1>[BX] AX
mov <write_20905+34> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_20905+33>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 22163 "f"
mov <write_20905+10> AX
push 1        ;Àx¦sCX
push [1]
push <write_20905+2>
push <write_20905+33>
oper <esp+1> "+" <write_20905+10>
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 22117 "f"
mov AX True
jmp 22118
mov AX False
cmp AX 1
$jmp 22162 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20905+2>
push <write_20905+33>
oper <esp+1> "+" <write_20905+10>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_20905+11> <esp+1>
inc esp
tf <write_20905+34> "in" <write_20905+11>
mov AX TF
cmp AX 1
$jmp 22161 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_20905+34>
mov BX <write_20905+11>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_20905+33>
oper <esp+1> "+" <write_20905+10>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 22161        ;¸õ¦Ü©³³¡
jmp 22162        ;¸õ¦Ü©³³¡
jmp 22097
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+0>.finally_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 22176 "<="
mov AX True
jmp 22177
mov AX False
cmp AX 1
$jmp 22187 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 22187        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push [dict]
mov <write_20905+35> <esp+1>
inc esp
ex_func AX "iter" <write_20905+24>
push AX
fetch AX <esp+1>
$jmp 22237 "f"
mov <write_20905+25> AX
push 1        ;Àx¦sCX
push [1]
push "cmp AX "
ex_func AX "str" <write_20905+25>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push <write_20905+24>
mov BX <write_20905+25>
pop AX
push AX[BX]
push <write_20905+35>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov BX AX
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 22199
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp AX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_20905+36> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "$Exception"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+18>
push AX
mov <write_20905+37> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+37>.write
ex_func AX "iter" <write_20905+34>
push AX
fetch AX <esp+1>
$jmp 22367 "f"
mov <write_20905+26> AX
push 1        ;Àx¦sCX
push [1]
push <write_20905+34>
mov BX <write_20905+26>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 22315 "<="
mov AX True
jmp 22316
mov AX False
cmp AX 1
$jmp 22366 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_20905+27> <esp+1>
inc esp
push <write_20905+34>
mov BX <write_20905+26>
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 22350 "f"
mov <write_20905+28> AX
push "jmp "
ex_func AX "str" <write_20905+27>
oper <esp+1> "+" AX
oper <esp+1> "+" "       ;¸õ¦Üfinally¤¤ªº¨Æ¥ó:"
ex_func AX "str" <write_20905+26>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_20905+2>
mov BX <write_20905+28>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 22334
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 3"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 22366        ;¸õ¦Ü©³³¡
jmp 22297
inc esp
ex_func AX "iter" <write_20905+35>
push AX
fetch AX <esp+1>
$jmp 22417 "f"
mov <write_20905+38> AX
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_20905+2>
mov BX <write_20905+38>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop $Exception"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
push <write_20905+35>
mov BX <write_20905+38>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
jmp 22370
inc esp
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_20905+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_20905+2>
mov BX <write_20905+36>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "end \"finally_yield\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_20905+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_20905" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38"
pop ip
mov AX <Try_Except^35>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22467 "=="
tf AX "Ctn" "__init__"
$jmp 22465 "t"
jmp 22467
call AX.__init__
mov AX <Try_Except^35>
end "Function" "Try_Except^35"
pop ip
Function <&module_14992+21> 22472 None "With^36" 1
name <&module_14992+21> "<class '__main__.With'>"
jmp 22862
tf $Inheritance "equ" None
$jmp 22477 "t"
mov <With^36> $Inheritance
push 1
jmp 22479
mov <With^36> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <With^36> <&module_14992+21>
Function BX 22487 <With^36> "__init___22487" 7
mov <With^36>.__init__ BX
jmp 22560           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22495 "!="
tf <esp+2> "in" "call_obj"
$jmp 22497 "t"
mov <esp+2>["call_obj"] None
jmp 22497
mov <esp+2>["call_obj"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 22503 "!="
tf <esp+2> "in" "orig_as_name"
$jmp 22505 "t"
mov <esp+2>["orig_as_name"] None
jmp 22505
mov <esp+2>["orig_as_name"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 22511 "!="
tf <esp+2> "in" "as_name"
$jmp 22513 "t"
mov <esp+2>["as_name"] None
jmp 22513
mov <esp+2>["as_name"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 22519 "!="
tf <esp+2> "in" "with_codelines"
$jmp 22521 "t"
mov <esp+2>["with_codelines"] None
jmp 22521
mov <esp+2>["with_codelines"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 22527 "!="
tf <esp+2> "in" "namespace"
$jmp 22529 "t"
mov <esp+2>["namespace"] None
jmp 22529
mov <esp+2>["namespace"] <esp+1>[4]
dec CX
mov <__init___22487+2> <esp+2>["call_obj"]
mov <__init___22487+3> <esp+2>["orig_as_name"]
mov <__init___22487+4> <esp+2>["as_name"]
mov <__init___22487+5> <esp+2>["with_codelines"]
mov <__init___22487+6> <esp+2>["namespace"]


push <__init___22487+2>
mov <__init___22487+0>.call_obj <esp+1>
inc esp
push <__init___22487+3>
mov <__init___22487+0>.orig_as_name <esp+1>
inc esp
push <__init___22487+4>
mov <__init___22487+0>.as_name <esp+1>
inc esp
push <__init___22487+5>
mov <__init___22487+0>.with_codelines <esp+1>
inc esp
push <__init___22487+6>
mov <__init___22487+0>.namespace <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___22487+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22487" "0,1,2,3,4,5,6"
pop ip
Function BX 22563 <With^36> "__str___22563" 2
mov <With^36>.__str__ BX
jmp 22572           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<with>"
jmp 22569         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22563" "0,1"
pop ip
Function BX 22575 <With^36> "write_22575" 10
mov <With^36>.write BX
jmp 22848           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22583 "!="
tf <esp+2> "in" "codes"
$jmp 22585 "t"
mov <esp+2>["codes"] None
jmp 22585
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22575+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_22575+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.add_tab
mov AX <write_22575+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22575+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_22575+0>.call_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22575+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
mov AX <write_22575+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_22575+0>.call_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.append
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
push ""
mov AX <write_22575+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ".__enter__"
pop <esp+1>[0]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+17>
push AX
mov <write_22575+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22575+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+3>.write
mov DX <write_22575+0>.as_name
tf DX "equ" None
$jmp 22689 "t"
mov AX True
jmp 22690
mov AX False
cmp AX 1
$jmp 22726 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
ex_func AX "str" <write_22575+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.append
mov AX <write_22575+0>.as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22575+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "pop "
mov AX <write_22575+0>.as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.append
jmp 22726        ;¸õ¦Ü©³³¡
push <write_22575+0>.with_codelines
mov <write_22575+4> <esp+1>
inc esp
push [0]
mov <write_22575+5> <esp+1>
inc esp
push [0]
mov <write_22575+6> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
push ""
mov AX <write_22575+0>.orig_as_name      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ".__exit__"
pop <esp+1>[0]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [3]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+31>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+31>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+31>
mov <esp+1>[2] AX
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+17>
push AX
mov <write_22575+7> <esp+1>
inc esp
push [1]
mov <esp+1>[0] <write_22575+7>
mov <write_22575+8> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_22575+4>
mov <esp+1>[1] <write_22575+5>
mov <esp+1>[2] <write_22575+6>
mov <esp+1>[3] <write_22575+8>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+20>
push AX
mov <write_22575+9> <esp+1>
inc esp
push [3]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[2]
mov <write_22575+9>.orig_lines <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22575+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+9>.write
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22575+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22575" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <With^36>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22860 "=="
tf AX "Ctn" "__init__"
$jmp 22858 "t"
jmp 22860
call AX.__init__
mov AX <With^36>
end "Function" "With^36"
pop ip
Function <&module_14992+22> 22865 None "Stop^37" 1
name <&module_14992+22> "<class '__main__.Stop'>"
jmp 22941
tf $Inheritance "equ" None
$jmp 22870 "t"
mov <Stop^37> $Inheritance
push 1
jmp 22872
mov <Stop^37> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Stop^37> <&module_14992+22>
Function BX 22880 <Stop^37> "__init___22880" 2
mov <Stop^37>.__init__ BX
jmp 22888           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22880" "0,1"
pop ip
Function BX 22891 <Stop^37> "__str___22891" 2
mov <Stop^37>.__str__ BX
jmp 22900           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<$stop>"
jmp 22897         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22891" "0,1"
pop ip
Function BX 22903 <Stop^37> "write_22903" 3
mov <Stop^37>.write BX
jmp 22927           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22911 "!="
tf <esp+2> "in" "codes"
$jmp 22913 "t"
mov <esp+2>["codes"] None
jmp 22913
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22903+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "stop"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22903+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22903" "0,1,2"
pop ip
mov AX <Stop^37>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 22939 "=="
tf AX "Ctn" "__init__"
$jmp 22937 "t"
jmp 22939
call AX.__init__
mov AX <Stop^37>
end "Function" "Stop^37"
pop ip
Function <&module_14992+23> 22944 None "Command^38" 1
name <&module_14992+23> "<class '__main__.Command'>"
jmp 23039
tf $Inheritance "equ" None
$jmp 22949 "t"
mov <Command^38> $Inheritance
push 1
jmp 22951
mov <Command^38> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Command^38> <&module_14992+23>
Function BX 22959 <Command^38> "__init___22959" 3
mov <Command^38>.__init__ BX
jmp 22979           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 22967 "!="
tf <esp+2> "in" "cmd_list"
$jmp 22969 "t"
mov <esp+2>["cmd_list"] None
jmp 22969
mov <esp+2>["cmd_list"] <esp+1>[0]
dec CX
mov <__init___22959+2> <esp+2>["cmd_list"]


push <__init___22959+2>
mov <__init___22959+0>.cmd_list <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___22959" "0,1,2"
pop ip
Function BX 22982 <Command^38> "__str___22982" 2
mov <Command^38>.__str__ BX
jmp 22991           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<cmd_list>"
jmp 22988         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___22982" "0,1"
pop ip
Function BX 22994 <Command^38> "write_22994" 4
mov <Command^38>.write BX
jmp 23025           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23002 "!="
tf <esp+2> "in" "codes"
$jmp 23004 "t"
mov <esp+2>["codes"] None
jmp 23004
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_22994+2> <esp+2>["codes"]


ex_func AX "iter" <write_22994+0>.cmd_list
push AX
fetch AX <esp+1>
$jmp 23020 "f"
mov <write_22994+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_22994+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_22994+2>.append
jmp 23009
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_22994" "0,1,2,3"
pop ip
mov AX <Command^38>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23037 "=="
tf AX "Ctn" "__init__"
$jmp 23035 "t"
jmp 23037
call AX.__init__
mov AX <Command^38>
end "Function" "Command^38"
pop ip
Function <&module_14992+24> 23042 None "sub_if_else^39" 1
name <&module_14992+24> "<class '__main__.sub_if_else'>"
jmp 23311
tf $Inheritance "equ" None
$jmp 23047 "t"
mov <sub_if_else^39> $Inheritance
push 1
jmp 23049
mov <sub_if_else^39> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <sub_if_else^39> <&module_14992+24>
Function BX 23057 <sub_if_else^39> "__init___23057" 5
mov <sub_if_else^39>.__init__ BX
jmp 23101           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23065 "!="
tf <esp+2> "in" "event"
$jmp 23067 "t"
mov <esp+2>["event"] None
jmp 23067
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23073 "!="
tf <esp+2> "in" "true_item"
$jmp 23075 "t"
mov <esp+2>["true_item"] None
jmp 23075
mov <esp+2>["true_item"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 23081 "!="
tf <esp+2> "in" "false_item"
$jmp 23083 "t"
mov <esp+2>["false_item"] None
jmp 23083
mov <esp+2>["false_item"] <esp+1>[2]
dec CX
mov <__init___23057+2> <esp+2>["event"]
mov <__init___23057+3> <esp+2>["true_item"]
mov <__init___23057+4> <esp+2>["false_item"]


push <__init___23057+2>
mov <__init___23057+0>.event <esp+1>
inc esp
push <__init___23057+3>
mov <__init___23057+0>.true_item <esp+1>
inc esp
push <__init___23057+4>
mov <__init___23057+0>.false_item <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23057" "0,1,2,3,4"
pop ip
Function BX 23104 <sub_if_else^39> "__str___23104" 2
mov <sub_if_else^39>.__str__ BX
jmp 23113           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<A if else B>"
jmp 23110         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23104" "0,1"
pop ip
Function BX 23116 <sub_if_else^39> "write_23116" 5
mov <sub_if_else^39>.write BX
jmp 23297           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23124 "!="
tf <esp+2> "in" "codes"
$jmp 23126 "t"
mov <esp+2>["codes"] None
jmp 23126
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23116+2> <esp+2>["codes"]


mov AX <write_23116+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_23116+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23116+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23116+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23116+2>.append
mov AX <write_23116+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_23116+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 23184 "t"
mov AX True
jmp 23185
mov AX False
cmp AX 1
$jmp 23200 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_23116+0>.true_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;true item"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23116+2>.append
jmp 23200        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23116+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23116+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\"   ;¸õ¨ìfalse"
push <write_23116+2>
mov BX <write_23116+3>
pop AX
mov AX[BX] <esp+1>
inc esp
mov AX <write_23116+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_23116+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 23252 "t"
mov AX True
jmp 23253
mov AX False
cmp AX 1
$jmp 23271 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_23116+0>.false_item      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;false item"
pop <esp+1>[0]
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_23116+2>.append
jmp 23271        ;¸õ¦Ü©³³¡
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23116+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "   ;Â÷¶}sub_if_else"
push <write_23116+2>
mov BX <write_23116+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push "AX"
mov <write_23116+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23116" "0,1,2,3,4"
pop ip
mov AX <sub_if_else^39>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23309 "=="
tf AX "Ctn" "__init__"
$jmp 23307 "t"
jmp 23309
call AX.__init__
mov AX <sub_if_else^39>
end "Function" "sub_if_else^39"
pop ip
Function <&module_14992+25> 23314 None "If_else^40" 1
name <&module_14992+25> "<class '__main__.If_else'>"
jmp 23767
tf $Inheritance "equ" None
$jmp 23319 "t"
mov <If_else^40> $Inheritance
push 1
jmp 23321
mov <If_else^40> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <If_else^40> <&module_14992+25>
Function BX 23329 <If_else^40> "__init___23329" 4
mov <If_else^40>.__init__ BX
jmp 23364           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23337 "!="
tf <esp+2> "in" "if_items"
$jmp 23339 "t"
mov <esp+2>["if_items"] None
jmp 23339
mov <esp+2>["if_items"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23345 "!="
tf <esp+2> "in" "else_codelines"
$jmp 23347 "t"
mov <esp+2>["else_codelines"] None
jmp 23347
mov <esp+2>["else_codelines"] <esp+1>[1]
dec CX
mov <__init___23329+2> <esp+2>["if_items"]
mov <__init___23329+3> <esp+2>["else_codelines"]


push <__init___23329+2>
mov <__init___23329+0>.if_items <esp+1>
inc esp
push <__init___23329+3>
mov <__init___23329+0>.else_codelines <esp+1>
inc esp
push [0]
mov <__init___23329+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23329" "0,1,2,3"
pop ip
Function BX 23367 <If_else^40> "__str___23367" 5
mov <If_else^40>.__str__ BX
jmp 23525           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push [1]
push "if "
push <__str___23367+0>.if_items
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
pop <esp+1>[0]
mov <__str___23367+2> <esp+1>
inc esp
push <__str___23367+0>.if_items
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23411 "f"
mov <__str___23367+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23367+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23367+2>.append
jmp 23393
inc esp
push <__str___23367+0>.if_items
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23466 "f"
mov <__str___23367+4> AX
push 1        ;Àx¦sCX
push [1]
push "elif "
push <__str___23367+4>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ":"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23367+2>.append
push <__str___23367+4>
mov BX 1
pop AX
ex_func AX "iter" AX[BX]
push AX
fetch AX <esp+1>
$jmp 23464 "f"
mov <__str___23367+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23367+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23367+2>.append
jmp 23446
inc esp
jmp 23424
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23367+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 23479 "<="
mov AX True
jmp 23480
mov AX False
cmp AX 1
$jmp 23511 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "else:"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23367+2>.append
ex_func AX "iter" <__str___23367+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 23509 "f"
mov <__str___23367+3> AX
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23367+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__str___23367+2>.append
jmp 23491
inc esp
jmp 23511        ;¸õ¦Ü©³³¡
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___23367+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 23522         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23367" "0,1,2,3,4"
pop ip
Function BX 23528 <If_else^40> "write_23528" 10
mov <If_else^40>.write BX
jmp 23753           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23536 "!="
tf <esp+2> "in" "codes"
$jmp 23538 "t"
mov <esp+2>["codes"] None
jmp 23538
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23528+2> <esp+2>["codes"]


push [0]
mov <write_23528+3> <esp+1>
inc esp
push 0
mov <write_23528+4> <esp+1>
inc esp
ex_func AX "iter" <write_23528+0>.if_items
push AX
fetch AX <esp+1>
$jmp 23669 "f"
mov <write_23528+5> AX[0]
mov <write_23528+6> AX[1]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_23528+0>.orig_lines
mov BX <write_23528+4>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.append
push 1
$mov <write_23528+4> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+5>.write
push 1        ;Àx¦sCX
push [1]
push "cmp "
ex_func AX "str" <write_23528+5>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23528+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.append
ex_func AX "iter" <write_23528+6>
push AX
fetch AX <esp+1>
$jmp 23621 "f"
mov <write_23528+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+8>.write
jmp 23610
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.append
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\"        ;¸õ¨ì¤U¤@¥y§PÂ_"
push <write_23528+2>
mov BX <write_23528+7>
pop AX
mov AX[BX] <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.del_tab
jmp 23549
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+0>.else_codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 23682 "<="
mov AX True
jmp 23683
mov AX False
cmp AX 1
$jmp 23723 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
push <write_23528+0>.orig_lines
mov BX <write_23528+4>
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.add_tab
ex_func AX "iter" <write_23528+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 23715 "f"
mov <write_23528+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+8>.write
jmp 23704
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23528+2>.del_tab
jmp 23723        ;¸õ¦Ü©³³¡
ex_func AX "iter" <write_23528+3>
push AX
fetch AX <esp+1>
$jmp 23748 "f"
mov <write_23528+9> AX
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23528+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "        ;¸õ¦Ü©³³¡"
push <write_23528+2>
mov BX <write_23528+9>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 23725
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23528" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <If_else^40>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 23765 "=="
tf AX "Ctn" "__init__"
$jmp 23763 "t"
jmp 23765
call AX.__init__
mov AX <If_else^40>
end "Function" "If_else^40"
pop ip
Function <&module_14992+26> 23770 None "While^41" 1
name <&module_14992+26> "<class '__main__.While'>"
jmp 24143
tf $Inheritance "equ" None
$jmp 23775 "t"
mov <While^41> $Inheritance
push 1
jmp 23777
mov <While^41> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <While^41> <&module_14992+26>
Function BX 23785 <While^41> "__init___23785" 5
mov <While^41>.__init__ BX
jmp 23834           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23793 "!="
tf <esp+2> "in" "event"
$jmp 23795 "t"
mov <esp+2>["event"] None
jmp 23795
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 23801 "!="
tf <esp+2> "in" "codelines"
$jmp 23803 "t"
mov <esp+2>["codelines"] None
jmp 23803
mov <esp+2>["codelines"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 23809 "!="
tf <esp+2> "in" "else_codelines"
$jmp 23811 "t"
mov <esp+2>["else_codelines"] None
jmp 23811
mov <esp+2>["else_codelines"] <esp+1>[2]
dec CX
mov <__init___23785+2> <esp+2>["event"]
mov <__init___23785+3> <esp+2>["codelines"]
mov <__init___23785+4> <esp+2>["else_codelines"]


push <__init___23785+2>
mov <__init___23785+0>.event <esp+1>
inc esp
push <__init___23785+3>
mov <__init___23785+0>.codelines <esp+1>
inc esp
push <__init___23785+4>
mov <__init___23785+0>.else_codelines <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___23785+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___23785" "0,1,2,3,4"
pop ip
Function BX 23837 <While^41> "__str___23837" 2
mov <While^41>.__str__ BX
jmp 23853           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "event:"
ex_func AX "str" <__str___23837+0>.event
oper <esp+1> "+" AX
oper <esp+1> "+" " do:"
ex_func AX "str" <__str___23837+0>.codelines
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
jmp 23850         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___23837" "0,1"
pop ip
Function BX 23856 <While^41> "write_23856" 13
mov <While^41>.write BX
jmp 24129           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 23864 "!="
tf <esp+2> "in" "codes"
$jmp 23866 "t"
mov <esp+2>["codes"] None
jmp 23866
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_23856+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23856+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_23856+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.append
mov AX <write_23856+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_23856+0>.event      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23856+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.append
push [0]
mov <write_23856+5> <esp+1>
inc esp
ex_func AX "iter" <write_23856+0>.codelines
push AX
fetch AX <esp+1>
$jmp 24043 "f"
mov <write_23856+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_23856+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+6>.write
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_23856+7>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 24041 "f"
mov <write_23856+8> AX
push <write_23856+2>
push <write_23856+7>
oper <esp+1> "+" <write_23856+8>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_23856+9> <esp+1>
inc esp
mov DX <write_23856+9>
tf DX "equ" "continue"
$jmp 24004 "f"
mov AX True
jmp 24005
mov AX False
cmp AX 1
$jmp 24022 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "jmp "
push <write_23856+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_23856+2>
push <write_23856+7>
oper <esp+1> "+" <write_23856+8>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24040        ;¸õ¦Ü©³³¡
mov DX <write_23856+9>
tf DX "equ" "break"
$jmp 24027 "f"
mov AX True
jmp 24028
mov AX False
cmp AX 1
$jmp 24040 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_23856+7>
oper <esp+1> "+" <write_23856+8>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+5>.append
jmp 24040        ;¸õ¦Ü©³³¡
jmp 23975
inc esp
jmp 23937
inc esp
push 1        ;Àx¦sCX
push [1]
push "jmp "
push <write_23856+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" "               ;continue­«¨Ó"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_23856+10> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_23856+10>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_23856+2>
mov BX <write_23856+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_23856+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 24091 "f"
mov <write_23856+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+6>.write
jmp 24080
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_23856+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_23856+11> <esp+1>
inc esp
ex_func AX "iter" <write_23856+5>
push AX
fetch AX <esp+1>
$jmp 24118 "f"
mov <write_23856+12> AX
push "jmp "
ex_func AX "str" <write_23856+11>
oper <esp+1> "+" AX
oper <esp+1> "+" "          ;break¥X"
push <write_23856+2>
mov BX <write_23856+12>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24105
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_23856+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_23856" "0,1,2,3,4,5,6,7,8,9,10,11,12"
pop ip
mov AX <While^41>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24141 "=="
tf AX "Ctn" "__init__"
$jmp 24139 "t"
jmp 24141
call AX.__init__
mov AX <While^41>
end "Function" "While^41"
pop ip
Function <&module_14992+27> 24146 None "sub_for_loop^42" 1
name <&module_14992+27> "<class '__main__.sub_for_loop'>"
jmp 24487
tf $Inheritance "equ" None
$jmp 24151 "t"
mov <sub_for_loop^42> $Inheritance
push 1
jmp 24153
mov <sub_for_loop^42> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <sub_for_loop^42> <&module_14992+27>
Function BX 24161 <sub_for_loop^42> "__init___24161" 7
mov <sub_for_loop^42>.__init__ BX
jmp 24229           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24169 "!="
tf <esp+2> "in" "express"
$jmp 24171 "t"
mov <esp+2>["express"] None
jmp 24171
mov <esp+2>["express"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 24177 "!="
tf <esp+2> "in" "vnames"
$jmp 24179 "t"
mov <esp+2>["vnames"] None
jmp 24179
mov <esp+2>["vnames"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 24185 "!="
tf <esp+2> "in" "base_obj"
$jmp 24187 "t"
mov <esp+2>["base_obj"] None
jmp 24187
mov <esp+2>["base_obj"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 24193 "!="
tf <esp+2> "in" "if_obj"
$jmp 24195 "t"
mov <esp+2>["if_obj"] None
jmp 24195
mov <esp+2>["if_obj"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 24201 "!="
tf <esp+2> "in" "is_list"
$jmp 24203 "t"
mov <esp+2>["is_list"] None
jmp 24203
mov <esp+2>["is_list"] <esp+1>[4]
dec CX
mov <__init___24161+2> <esp+2>["express"]
mov <__init___24161+3> <esp+2>["vnames"]
mov <__init___24161+4> <esp+2>["base_obj"]
mov <__init___24161+5> <esp+2>["if_obj"]
mov <__init___24161+6> <esp+2>["is_list"]


push <__init___24161+2>
mov <__init___24161+0>.express <esp+1>
inc esp
push <__init___24161+3>
mov <__init___24161+0>.vnames <esp+1>
inc esp
push <__init___24161+4>
mov <__init___24161+0>.base_obj <esp+1>
inc esp
push <__init___24161+5>
mov <__init___24161+0>.if_obj <esp+1>
inc esp
push <__init___24161+6>
mov <__init___24161+0>.is_list <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24161" "0,1,2,3,4,5,6"
pop ip
Function BX 24232 <sub_for_loop^42> "__str___24232" 2
mov <sub_for_loop^42>.__str__ BX
jmp 24241           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<sub for loop>"
jmp 24238         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24232" "0,1"
pop ip
Function BX 24244 <sub_for_loop^42> "write_24244" 10
mov <sub_for_loop^42>.write BX
jmp 24473           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24252 "!="
tf <esp+2> "in" "codes"
$jmp 24254 "t"
mov <esp+2>["codes"] None
jmp 24254
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24244+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_24244+0>.express
mov <esp+1>[1] "yield"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+18>
push AX
mov <write_24244+3> <esp+1>
inc esp
mov DX <write_24244+0>.if_obj
tf DX "equ" None
$jmp 24273 "t"
mov AX True
jmp 24274
mov AX False
cmp AX 1
$jmp 24325 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push [1]
push [2]
mov <esp+1>[0] <write_24244+0>.if_obj
push [1]
mov <esp+1>[0] <write_24244+3>
pop <esp+1>[1]
pop <esp+1>[0]
pop <esp+1>[0]
mov <esp+1>[1] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+25>
push AX
mov <write_24244+4> <esp+1>
inc esp
push [3]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[2]
mov <write_24244+4>.orig_lines <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_24244+0>.vnames
mov <esp+1>[1] <write_24244+0>.base_obj
push [1]
mov <esp+1>[0] <write_24244+4>
pop <esp+1>[2]
mov <esp+1>[3] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+28>
push AX
mov <write_24244+5> <esp+1>
inc esp
jmp 24340        ;¸õ¦Ü©³³¡
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <write_24244+0>.vnames
mov <esp+1>[1] <write_24244+0>.base_obj
push [1]
mov <esp+1>[0] <write_24244+3>
pop <esp+1>[2]
mov <esp+1>[3] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+28>
push AX
mov <write_24244+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+42>
push AX
mov <write_24244+6> <esp+1>
inc esp
ex_func AX "iter" <write_24244+0>.vnames
push AX
fetch AX <esp+1>
$jmp 24364 "f"
mov <write_24244+7> AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <write_24244+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+6>.add_info
jmp 24352
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_24244+5>
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+6>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24244+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24244+8> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
push "&generator_"
ex_func AX "str" <write_24244+8>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] [dict]
mov <esp+1>[2] <write_24244+6>
mov <esp+1>[3] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+16>
push AX
mov <write_24244+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24244+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+9>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0        ;Àx¦sCX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push [0]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX     ;¨ú¦^CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
push 1        ;Àx¦sCX
push [1]
push "call &generator_"
ex_func AX "str" <write_24244+8>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
cmp <write_24244+0>.is_list 1
$jmp 24466 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "ex_func AX \"list\" AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24244+2>.append
jmp 24466        ;¸õ¦Ü©³³¡
push "AX"
mov <write_24244+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24244" "0,1,2,3,4,5,6,7,8,9"
pop ip
mov AX <sub_for_loop^42>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 24485 "=="
tf AX "Ctn" "__init__"
$jmp 24483 "t"
jmp 24485
call AX.__init__
mov AX <sub_for_loop^42>
end "Function" "sub_for_loop^42"
pop ip
Function <&module_14992+28> 24490 None "For_loop^43" 1
name <&module_14992+28> "<class '__main__.For_loop'>"
jmp 25058
tf $Inheritance "equ" None
$jmp 24495 "t"
mov <For_loop^43> $Inheritance
push 1
jmp 24497
mov <For_loop^43> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <For_loop^43> <&module_14992+28>
Function BX 24505 <For_loop^43> "__init___24505" 6
mov <For_loop^43>.__init__ BX
jmp 24566           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24513 "!="
tf <esp+2> "in" "vnames"
$jmp 24515 "t"
mov <esp+2>["vnames"] None
jmp 24515
mov <esp+2>["vnames"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 24521 "!="
tf <esp+2> "in" "base_obj"
$jmp 24523 "t"
mov <esp+2>["base_obj"] None
jmp 24523
mov <esp+2>["base_obj"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 24529 "!="
tf <esp+2> "in" "codelines"
$jmp 24531 "t"
mov <esp+2>["codelines"] None
jmp 24531
mov <esp+2>["codelines"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 24537 "!="
tf <esp+2> "in" "else_codelines"
$jmp 24539 "t"
mov <esp+2>["else_codelines"] None
jmp 24539
mov <esp+2>["else_codelines"] <esp+1>[3]
dec CX
mov <__init___24505+2> <esp+2>["vnames"]
mov <__init___24505+3> <esp+2>["base_obj"]
mov <__init___24505+4> <esp+2>["codelines"]
mov <__init___24505+5> <esp+2>["else_codelines"]


push <__init___24505+2>
mov <__init___24505+0>.vnames <esp+1>
inc esp
push <__init___24505+3>
mov <__init___24505+0>.base_obj <esp+1>
inc esp
push <__init___24505+4>
mov <__init___24505+0>.codelines <esp+1>
inc esp
push <__init___24505+5>
mov <__init___24505+0>.else_codelines <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___24505+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___24505" "0,1,2,3,4,5"
pop ip
Function BX 24569 <For_loop^43> "__str___24569" 2
mov <For_loop^43>.__str__ BX
jmp 24578           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<For loop>"
jmp 24575         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___24569" "0,1"
pop ip
Function BX 24581 <For_loop^43> "write_24581" 16
mov <For_loop^43>.write BX
jmp 25044           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 24589 "!="
tf <esp+2> "in" "codes"
$jmp 24591 "t"
mov <esp+2>["codes"] None
jmp 24591
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_24581+2> <esp+2>["codes"]


mov AX <write_24581+0>.base_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 2        ;Àx¦sCX
push [2]
push "ex_func AX \"iter\" "
mov AX <write_24581+0>.base_obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] <write_24581+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24581+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "fetch AX <esp+1>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24581+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+0>.vnames
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 24676 "f"
mov AX True
jmp 24677
mov AX False
cmp AX 1
$jmp 24708 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_24581+0>.vnames
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_24581+0>.vnames
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " AX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
jmp 24760        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+0>.vnames
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 24759 "f"
mov <write_24581+5> AX
push <write_24581+0>.vnames
mov BX <write_24581+5>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_24581+0>.vnames
mov BX <write_24581+5>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " AX["
ex_func AX "str" <write_24581+5>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
jmp 24724
inc esp
push [0]
mov <write_24581+6> <esp+1>
inc esp
push [0]
mov <write_24581+7> <esp+1>
inc esp
ex_func AX "iter" <write_24581+0>.codelines
push AX
fetch AX <esp+1>
$jmp 24892 "f"
mov <write_24581+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24581+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+8>.write
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_24581+9>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 24890 "f"
mov <write_24581+5> AX
push <write_24581+2>
push <write_24581+9>
oper <esp+1> "+" <write_24581+5>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov BX 0
pop AX
push AX[BX]
mov <write_24581+10> <esp+1>
inc esp
mov DX <write_24581+10>
tf DX "equ" "continue"
$jmp 24835 "f"
mov AX True
jmp 24836
mov AX False
cmp AX 1
$jmp 24853 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "jmp "
push <write_24581+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_24581+2>
push <write_24581+9>
oper <esp+1> "+" <write_24581+5>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24889        ;¸õ¦Ü©³³¡
mov DX <write_24581+10>
tf DX "equ" "break"
$jmp 24858 "f"
mov AX True
jmp 24859
mov AX False
cmp AX 1
$jmp 24871 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_24581+9>
oper <esp+1> "+" <write_24581+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+6>.append
jmp 24889        ;¸õ¦Ü©³³¡
mov DX <write_24581+10>
tf DX "equ" "return"
$jmp 24876 "f"
mov AX True
jmp 24877
mov AX False
cmp AX 1
$jmp 24889 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <write_24581+9>
oper <esp+1> "+" <write_24581+5>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+7>.append
jmp 24889        ;¸õ¦Ü©³³¡
jmp 24806
inc esp
jmp 24768
inc esp
push 1        ;Àx¦sCX
push [1]
push "jmp "
push <write_24581+3>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 24919 "<="
mov AX True
jmp 24920
mov AX False
cmp AX 1
$jmp 24966 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_24581+11> <esp+1>
inc esp
ex_func AX "iter" <write_24581+7>
push AX
fetch AX <esp+1>
$jmp 24950 "f"
mov <write_24581+12> AX
push "jmp "
push <write_24581+11>
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_24581+2>
mov BX <write_24581+12>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 24934
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "return AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
jmp 24966        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_24581+13> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_24581+13>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"f\""
push <write_24581+2>
mov BX <write_24581+4>
pop AX
mov AX[BX] <esp+1>
inc esp
ex_func AX "iter" <write_24581+0>.else_codelines
push AX
fetch AX <esp+1>
$jmp 24999 "f"
mov <write_24581+8> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+8>.write
jmp 24988
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_24581+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_24581+14> <esp+1>
inc esp
ex_func AX "iter" <write_24581+6>
push AX
fetch AX <esp+1>
$jmp 25026 "f"
mov <write_24581+15> AX
push "jmp "
ex_func AX "str" <write_24581+14>
oper <esp+1> "+" AX
oper <esp+1> "+" "          ;break¥X°j°é"
push <write_24581+2>
mov BX <write_24581+15>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 25013
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_24581+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_24581" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
pop ip
mov AX <For_loop^43>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25056 "=="
tf AX "Ctn" "__init__"
$jmp 25054 "t"
jmp 25056
call AX.__init__
mov AX <For_loop^43>
end "Function" "For_loop^43"
pop ip
Function <&module_14992+29> 25061 None "Mark^44" 1
name <&module_14992+29> "<class '__main__.Mark'>"
jmp 25153
tf $Inheritance "equ" None
$jmp 25066 "t"
mov <Mark^44> $Inheritance
push 1
jmp 25068
mov <Mark^44> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Mark^44> <&module_14992+29>
Function BX 25076 <Mark^44> "__init___25076" 3
mov <Mark^44>.__init__ BX
jmp 25096           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25084 "!="
tf <esp+2> "in" "mark"
$jmp 25086 "t"
mov <esp+2>["mark"] None
jmp 25086
mov <esp+2>["mark"] <esp+1>[0]
dec CX
mov <__init___25076+2> <esp+2>["mark"]


push <__init___25076+2>
mov <__init___25076+0>.mark <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25076" "0,1,2"
pop ip
Function BX 25099 <Mark^44> "__str___25099" 2
mov <Mark^44>.__str__ BX
jmp 25112           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<mark "
ex_func AX "str" <__str___25099+0>.mark
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 25109         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___25099" "0,1"
pop ip
Function BX 25115 <Mark^44> "write_25115" 3
mov <Mark^44>.write BX
jmp 25139           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25123 "!="
tf <esp+2> "in" "codes"
$jmp 25125 "t"
mov <esp+2>["codes"] None
jmp 25125
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_25115+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25115+0>.mark
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25115+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_25115" "0,1,2"
pop ip
mov AX <Mark^44>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25151 "=="
tf AX "Ctn" "__init__"
$jmp 25149 "t"
jmp 25151
call AX.__init__
mov AX <Mark^44>
end "Function" "Mark^44"
pop ip
Function <&module_14992+30> 25156 None "Pass^45" 1
name <&module_14992+30> "<class '__main__.Pass'>"
jmp 25225
tf $Inheritance "equ" None
$jmp 25161 "t"
mov <Pass^45> $Inheritance
push 1
jmp 25163
mov <Pass^45> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Pass^45> <&module_14992+30>
Function BX 25171 <Pass^45> "__init___25171" 2
mov <Pass^45>.__init__ BX
jmp 25179           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25171" "0,1"
pop ip
Function BX 25182 <Pass^45> "__str___25182" 2
mov <Pass^45>.__str__ BX
jmp 25191           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<pass>"
jmp 25188         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___25182" "0,1"
pop ip
Function BX 25194 <Pass^45> "write_25194" 3
mov <Pass^45>.write BX
jmp 25211           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25202 "!="
tf <esp+2> "in" "codes"
$jmp 25204 "t"
mov <esp+2>["codes"] None
jmp 25204
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_25194+2> <esp+2>["codes"]


mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_25194" "0,1,2"
pop ip
mov AX <Pass^45>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25223 "=="
tf AX "Ctn" "__init__"
$jmp 25221 "t"
jmp 25223
call AX.__init__
mov AX <Pass^45>
end "Function" "Pass^45"
pop ip
Function <&module_14992+31> 25228 None "TFN^46" 1
name <&module_14992+31> "<class '__main__.TFN'>"
jmp 25316
tf $Inheritance "equ" None
$jmp 25233 "t"
mov <TFN^46> $Inheritance
push 1
jmp 25235
mov <TFN^46> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <TFN^46> <&module_14992+31>
Function BX 25243 <TFN^46> "__init___25243" 3
mov <TFN^46>.__init__ BX
jmp 25263           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25251 "!="
tf <esp+2> "in" "value"
$jmp 25253 "t"
mov <esp+2>["value"] None
jmp 25253
mov <esp+2>["value"] <esp+1>[0]
dec CX
mov <__init___25243+2> <esp+2>["value"]


push <__init___25243+2>
mov <__init___25243+0>.value <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25243" "0,1,2"
pop ip
Function BX 25266 <TFN^46> "__str___25266" 2
mov <TFN^46>.__str__ BX
jmp 25279           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___25266+0>.value
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 25276         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___25266" "0,1"
pop ip
Function BX 25282 <TFN^46> "write_25282" 3
mov <TFN^46>.write BX
jmp 25302           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25290 "!="
tf <esp+2> "in" "codes"
$jmp 25292 "t"
mov <esp+2>["codes"] None
jmp 25292
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_25282+2> <esp+2>["codes"]


push <write_25282+0>.value
mov <write_25282+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_25282" "0,1,2"
pop ip
mov AX <TFN^46>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 25314 "=="
tf AX "Ctn" "__init__"
$jmp 25312 "t"
jmp 25314
call AX.__init__
mov AX <TFN^46>
end "Function" "TFN^46"
pop ip
Function <&module_14992+32> 25319 None "Class^47" 1
name <&module_14992+32> "<class '__main__.Class'>"
jmp 26029
tf $Inheritance "equ" None
$jmp 25324 "t"
mov <Class^47> $Inheritance
push 1
jmp 25326
mov <Class^47> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Class^47> <&module_14992+32>
Function BX 25334 <Class^47> "__init___25334" 7
mov <Class^47>.__init__ BX
jmp 25410           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25342 "!="
tf <esp+2> "in" "name"
$jmp 25344 "t"
mov <esp+2>["name"] None
jmp 25344
mov <esp+2>["name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 25350 "!="
tf <esp+2> "in" "info"
$jmp 25352 "t"
mov <esp+2>["info"] None
jmp 25352
mov <esp+2>["info"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 25358 "!="
tf <esp+2> "in" "namespace"
$jmp 25360 "t"
mov <esp+2>["namespace"] None
jmp 25360
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 25366 "!="
tf <esp+2> "in" "class_esp"
$jmp 25368 "t"
mov <esp+2>["class_esp"] None
jmp 25368
mov <esp+2>["class_esp"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 25374 "!="
tf <esp+2> "in" "father"
$jmp 25376 "t"
mov <esp+2>["father"] None
jmp 25376
mov <esp+2>["father"] <esp+1>[4]
dec CX
mov <__init___25334+2> <esp+2>["name"]
mov <__init___25334+3> <esp+2>["info"]
mov <__init___25334+4> <esp+2>["namespace"]
mov <__init___25334+5> <esp+2>["class_esp"]
mov <__init___25334+6> <esp+2>["father"]


push <__init___25334+2>
mov <__init___25334+0>.name <esp+1>
inc esp
push <__init___25334+3>.funcs
mov <__init___25334+0>.functions <esp+1>
inc esp
push <__init___25334+3>.codelines
mov <__init___25334+0>.codelines <esp+1>
inc esp
push <__init___25334+4>
mov <__init___25334+0>.namespace <esp+1>
inc esp
push <__init___25334+5>
mov <__init___25334+0>.class_esp <esp+1>
inc esp
push <__init___25334+6>
mov <__init___25334+0>.father <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___25334+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___25334" "0,1,2,3,4,5,6"
pop ip
Function BX 25413 <Class^47> "__str___25413" 2
mov <Class^47>.__str__ BX
jmp 25426           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<class "
ex_func AX "str" <__str___25413+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 25423         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___25413" "0,1"
pop ip
Function BX 25429 <Class^47> "write_25429" 11
mov <Class^47>.write BX
jmp 26015           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 25437 "!="
tf <esp+2> "in" "codes"
$jmp 25439 "t"
mov <esp+2>["codes"] None
jmp 25439
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_25429+2> <esp+2>["codes"]


mov DX <write_25429+0>.namespace
tf DX "equ" ""
$jmp 25447 "t"
mov AX True
jmp 25448
mov AX False
cmp AX 1
$jmp 25511 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_25429+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 2        ;Àx¦sCX
push [2]
push "Function BX "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 3
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " "
mov AX <write_25429+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\" 1"
pop <esp+1>[0]
mov <esp+1>[1] <write_25429+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push ""
mov AX <write_25429+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_25429+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_25429+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_25429+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " BX"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
jmp 25542        ;¸õ¦Ü©³³¡
push <write_25429+0>.name
mov <write_25429+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push "Function "
ex_func AX "str" <write_25429+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " None \""
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\" 1"
pop <esp+1>[0]
mov <esp+1>[1] <write_25429+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "name "
ex_func AX "str" <write_25429+3>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"<class \'__main__."
ex_func AX "str" <write_25429+0>.name
oper <esp+1> "+" AX
oper <esp+1> "+" "\'>\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.add_tab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25429+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "tf $Inheritance \"equ\" None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 3
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> $Inheritance"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 2
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> [class]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $Inheritance None"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
mov DX <write_25429+0>.father
tf DX "equ" None
$jmp 25697 "t"
mov AX True
jmp 25698
mov AX False
cmp AX 1
$jmp 25782 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+0>.father
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&module_14992+11>
$jmp 25712 "f"
mov AX True
jmp 25713
mov AX False
cmp AX 1
$jmp 25720 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_25429+0>.father      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.elements
mov <write_25429+5> <esp+1>
inc esp
jmp 25724        ;¸õ¦Ü©³³¡
push [1]
mov <esp+1>[0] <write_25429+0>.father
mov <write_25429+5> <esp+1>
inc esp
ex_func AX "iter" <write_25429+5>
push AX
fetch AX <esp+1>
$jmp 25780 "f"
mov <write_25429+6> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+6>.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov **kwargs <esp+1>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov *args <esp+2>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov CX <esp+3>"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $Inheritance <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "call "
ex_func AX "str" <write_25429+6>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
jmp 25726
inc esp
jmp 25782        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "type <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "> "
ex_func AX "str" <write_25429+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
ex_func AX "iter" <write_25429+0>.codelines
push AX
fetch AX <esp+1>
$jmp 25809 "f"
mov <write_25429+7> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+7>.write
jmp 25798
inc esp
push 1        ;Àx¦sCX
push [1]
push "mov AX <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop **kwargs"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop *args"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop CX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "cmp BX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25429+8> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "tf AX \"Ctn\" \"__init__\""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "$jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" " \"t\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_25429+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "call AX.__init__"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov AX <"
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_25429+10> <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_25429+10>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_25429+2>
mov BX <write_25429+8>
pop AX
mov AX[BX] <esp+1>
inc esp
push "jmp "
ex_func AX "str" <write_25429+10>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_25429+2>
mov BX <write_25429+9>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "end \"Function\" \""
ex_func AX "str" <write_25429+0>.class_esp
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop ip"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.append
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_25429+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_25429+2>
mov BX <write_25429+4>
pop AX
mov AX[BX] <esp+1>
inc esp
push "AX"
mov <write_25429+0>.location <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_25429+2>.del_tab
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_25429" "0,1,2,3,4,5,6,7,8,9,10"
pop ip
mov AX <Class^47>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26027 "=="
tf AX "Ctn" "__init__"
$jmp 26025 "t"
jmp 26027
call AX.__init__
mov AX <Class^47>
end "Function" "Class^47"
pop ip
Function <&module_14992+33> 26031 None "two_object_write_26031" 5
jmp 26219           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26039 "!="
tf <esp+2> "in" "A"
$jmp 26041 "t"
mov <esp+2>["A"] None
jmp 26041
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26047 "!="
tf <esp+2> "in" "B"
$jmp 26049 "t"
mov <esp+2>["B"] None
jmp 26049
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26055 "!="
tf <esp+2> "in" "codes"
$jmp 26057 "t"
mov <esp+2>["codes"] None
jmp 26057
mov <esp+2>["codes"] <esp+1>[2]
dec CX
mov <two_object_write_26031+1> <esp+2>["A"]
mov <two_object_write_26031+2> <esp+2>["B"]
mov <two_object_write_26031+3> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_26031+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+1>.write
push <two_object_write_26031+1>.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX."
$jmp 26084 "f"
mov AX True
jmp 26085
mov AX False
cmp AX 1
$jmp 26097 "=="
mov DX <two_object_write_26031+1>.location
tf DX "equ" "AX"
$jmp 26092 "f"
mov AX True
jmp 26093
mov AX False
cmp AX 1
$jmp 26097 "=="
mov AX 0
jmp 26098
mov AX 1
cmp AX 1
$jmp 26136 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_26031+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+2>.write
push 1        ;Àx¦sCX
push [1]
push "mov BX "
ex_func AX "str" <two_object_write_26031+2>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push "BX"
mov <two_object_write_26031+4> <esp+1>
inc esp
jmp 26214        ;¸õ¦Ü©³³¡
push <two_object_write_26031+1>.location
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] 3
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "AX["
$jmp 26151 "f"
mov AX True
jmp 26152
mov AX False
cmp AX 1
$jmp 26204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "push BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_26031+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+2>.write
push 1        ;Àx¦sCX
push [1]
push "mov DX "
ex_func AX "str" <two_object_write_26031+2>.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop BX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+3>.append
push "DX"
mov <two_object_write_26031+4> <esp+1>
inc esp
jmp 26214        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <two_object_write_26031+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <two_object_write_26031+2>.write
push <two_object_write_26031+2>.location
mov <two_object_write_26031+4> <esp+1>
inc esp
mov AX <two_object_write_26031+4>
jmp 26216         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "two_object_write_26031" "0,1,2,3,4"
pop ip
Function <&module_14992+34> 26222 None "Multiple_Mov^48" 1
name <&module_14992+34> "<class '__main__.Multiple_Mov'>"
jmp 26564
tf $Inheritance "equ" None
$jmp 26227 "t"
mov <Multiple_Mov^48> $Inheritance
push 1
jmp 26229
mov <Multiple_Mov^48> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Multiple_Mov^48> <&module_14992+34>
Function BX 26237 <Multiple_Mov^48> "__init___26237" 5
mov <Multiple_Mov^48>.__init__ BX
jmp 26316           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26245 "!="
tf <esp+2> "in" "obj_list"
$jmp 26247 "t"
mov <esp+2>["obj_list"] None
jmp 26247
mov <esp+2>["obj_list"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26253 "!="
tf <esp+2> "in" "target"
$jmp 26255 "t"
mov <esp+2>["target"] None
jmp 26255
mov <esp+2>["target"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26261 "!="
tf <esp+2> "in" "op"
$jmp 26263 "t"
mov <esp+2>["op"] None
jmp 26263
mov <esp+2>["op"] <esp+1>[2]
dec CX
mov <__init___26237+2> <esp+2>["obj_list"]
mov <__init___26237+3> <esp+2>["target"]
mov <__init___26237+4> <esp+2>["op"]


push <__init___26237+2>
mov <__init___26237+0>.obj_list <esp+1>
inc esp
push <__init___26237+3>
mov <__init___26237+0>.target <esp+1>
inc esp
mov DX <__init___26237+4>
tf DX "equ" "="
$jmp 26279 "f"
mov AX True
jmp 26280
mov AX False
cmp AX 1
$jmp 26289 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <__init___26237+0>.ctype <esp+1>
inc esp
push "mov"
mov <__init___26237+0>.cmd <esp+1>
inc esp
jmp 26307        ;¸õ¦Ü©³³¡
push 1
mov <__init___26237+0>.ctype <esp+1>
inc esp
push <__init___26237+4>
push [3]
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <__init___26237+0>.cmd <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___26237+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26237" "0,1,2,3,4"
pop ip
Function BX 26319 <Multiple_Mov^48> "__str___26319" 2
mov <Multiple_Mov^48>.__str__ BX
jmp 26328           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX "<Multiple mov>"
jmp 26325         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26319" "0,1"
pop ip
Function BX 26331 <Multiple_Mov^48> "write_26331" 5
mov <Multiple_Mov^48>.write BX
jmp 26550           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26339 "!="
tf <esp+2> "in" "codes"
$jmp 26341 "t"
mov <esp+2>["codes"] None
jmp 26341
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26331+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_26331+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
mov AX <write_26331+0>.target      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26331+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_26331+0>.target      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
ex_func AX "iter" <write_26331+0>.obj_list
push AX
fetch AX <esp+1>
$jmp 26538 "f"
mov <write_26331+3> AX
push (2)
mov <esp+1>[0] <&module_14992+11>
mov <esp+1>[1] <&module_14992+10>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26331+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 26487 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26331+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 26485 "f"
mov <write_26331+4> AX
push <write_26331+3>
mov BX <write_26331+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26331+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <write_26331+0>.ctype
tf DX "equ" 0
$jmp 26432 "f"
mov AX True
jmp 26433
mov AX False
cmp AX 1
$jmp 26454 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
push <write_26331+3>
mov BX <write_26331+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>["
ex_func AX "str" <write_26331+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
jmp 26484        ;¸õ¦Ü©³³¡
mov DX <write_26331+0>.ctype
tf DX "equ" 1
$jmp 26459 "f"
mov AX True
jmp 26460
mov AX False
cmp AX 1
$jmp 26484 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "$mov "
push <write_26331+3>
mov BX <write_26331+4>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26331+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" <esp+1>["
ex_func AX "str" <write_26331+4>
oper <esp+1> "+" AX
oper <esp+1> "+" "]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
jmp 26484        ;¸õ¦Ü©³³¡
jmp 26411
inc esp
jmp 26537        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26331+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+3>.write
mov DX <write_26331+0>.ctype
tf DX "equ" 0
$jmp 26499 "f"
mov AX True
jmp 26500
mov AX False
cmp AX 1
$jmp 26514 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_26331+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
jmp 26537        ;¸õ¦Ü©³³¡
mov DX <write_26331+0>.ctype
tf DX "equ" 1
$jmp 26519 "f"
mov AX True
jmp 26520
mov AX False
cmp AX 1
$jmp 26537 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "$mov "
ex_func AX "str" <write_26331+3>.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26331+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" <esp+1>"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
jmp 26537        ;¸õ¦Ü©³³¡
jmp 26376
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26331+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26331" "0,1,2,3,4"
pop ip
mov AX <Multiple_Mov^48>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26562 "=="
tf AX "Ctn" "__init__"
$jmp 26560 "t"
jmp 26562
call AX.__init__
mov AX <Multiple_Mov^48>
end "Function" "Multiple_Mov^48"
pop ip
Function <&module_14992+35> 26567 None "Oper^49" 1
name <&module_14992+35> "<class '__main__.Oper'>"
jmp 26739
tf $Inheritance "equ" None
$jmp 26572 "t"
mov <Oper^49> $Inheritance
push 1
jmp 26574
mov <Oper^49> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Oper^49> <&module_14992+35>
Function BX 26582 <Oper^49> "__init___26582" 5
mov <Oper^49>.__init__ BX
jmp 26626           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26590 "!="
tf <esp+2> "in" "A"
$jmp 26592 "t"
mov <esp+2>["A"] None
jmp 26592
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26598 "!="
tf <esp+2> "in" "B"
$jmp 26600 "t"
mov <esp+2>["B"] None
jmp 26600
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26606 "!="
tf <esp+2> "in" "symbol"
$jmp 26608 "t"
mov <esp+2>["symbol"] None
jmp 26608
mov <esp+2>["symbol"] <esp+1>[2]
dec CX
mov <__init___26582+2> <esp+2>["A"]
mov <__init___26582+3> <esp+2>["B"]
mov <__init___26582+4> <esp+2>["symbol"]


push <__init___26582+2>
mov <__init___26582+0>.A <esp+1>
inc esp
push <__init___26582+3>
mov <__init___26582+0>.B <esp+1>
inc esp
push <__init___26582+4>
mov <__init___26582+0>.symbol <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26582" "0,1,2,3,4"
pop ip
Function BX 26629 <Oper^49> "__str___26629" 2
mov <Oper^49>.__str__ BX
jmp 26648           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26629+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26629+0>.symbol
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26629+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26645         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26629" "0,1"
pop ip
Function BX 26651 <Oper^49> "write_26651" 3
mov <Oper^49>.write BX
jmp 26725           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26659 "!="
tf <esp+2> "in" "codes"
$jmp 26661 "t"
mov <esp+2>["codes"] None
jmp 26661
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26651+2> <esp+2>["codes"]


mov AX <write_26651+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26651+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_26651+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26651+2>.append
mov AX <write_26651+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26651+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "oper <esp+1> \""
ex_func AX "str" <write_26651+0>.symbol
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
mov AX <write_26651+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26651+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop AX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26651+2>.append
push "AX"
mov <write_26651+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26651" "0,1,2"
pop ip
mov AX <Oper^49>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26737 "=="
tf AX "Ctn" "__init__"
$jmp 26735 "t"
jmp 26737
call AX.__init__
mov AX <Oper^49>
end "Function" "Oper^49"
pop ip
Function <&module_14992+36> 26742 None "Tf^50" 1
name <&module_14992+36> "<class '__main__.Tf'>"
jmp 26897
tf $Inheritance "equ" None
$jmp 26747 "t"
mov <Tf^50> $Inheritance
push 1
jmp 26749
mov <Tf^50> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Tf^50> <&module_14992+36>
Function BX 26757 <Tf^50> "__init___26757" 5
mov <Tf^50>.__init__ BX
jmp 26801           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26765 "!="
tf <esp+2> "in" "A"
$jmp 26767 "t"
mov <esp+2>["A"] None
jmp 26767
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26773 "!="
tf <esp+2> "in" "B"
$jmp 26775 "t"
mov <esp+2>["B"] None
jmp 26775
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26781 "!="
tf <esp+2> "in" "cmd"
$jmp 26783 "t"
mov <esp+2>["cmd"] None
jmp 26783
mov <esp+2>["cmd"] <esp+1>[2]
dec CX
mov <__init___26757+2> <esp+2>["A"]
mov <__init___26757+3> <esp+2>["B"]
mov <__init___26757+4> <esp+2>["cmd"]


push <__init___26757+2>
mov <__init___26757+0>.A <esp+1>
inc esp
push <__init___26757+3>
mov <__init___26757+0>.B <esp+1>
inc esp
push <__init___26757+4>
mov <__init___26757+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26757" "0,1,2,3,4"
pop ip
Function BX 26804 <Tf^50> "__str___26804" 2
mov <Tf^50>.__str__ BX
jmp 26823           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26804+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26804+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26804+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26820         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26804" "0,1"
pop ip
Function BX 26826 <Tf^50> "write_26826" 4
mov <Tf^50>.write BX
jmp 26883           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26834 "!="
tf <esp+2> "in" "codes"
$jmp 26836 "t"
mov <esp+2>["codes"] None
jmp 26836
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26826+2> <esp+2>["codes"]


push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <write_26826+0>.A
mov <esp+1>[1] <write_26826+0>.B
mov <esp+1>[2] <write_26826+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+33>
push AX
mov <write_26826+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push "tf "
mov AX <write_26826+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_26826+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\" "
ex_func AX "str" <write_26826+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26826+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX TF"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26826+2>.append
push "AX"
mov <write_26826+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26826" "0,1,2,3"
pop ip
mov AX <Tf^50>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 26895 "=="
tf AX "Ctn" "__init__"
$jmp 26893 "t"
jmp 26895
call AX.__init__
mov AX <Tf^50>
end "Function" "Tf^50"
pop ip
Function <&module_14992+37> 26900 None "AndOr^51" 1
name <&module_14992+37> "<class '__main__.AndOr'>"
jmp 27248
tf $Inheritance "equ" None
$jmp 26905 "t"
mov <AndOr^51> $Inheritance
push 1
jmp 26907
mov <AndOr^51> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <AndOr^51> <&module_14992+37>
Function BX 26915 <AndOr^51> "__init___26915" 5
mov <AndOr^51>.__init__ BX
jmp 26959           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26923 "!="
tf <esp+2> "in" "A"
$jmp 26925 "t"
mov <esp+2>["A"] None
jmp 26925
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 26931 "!="
tf <esp+2> "in" "B"
$jmp 26933 "t"
mov <esp+2>["B"] None
jmp 26933
mov <esp+2>["B"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 26939 "!="
tf <esp+2> "in" "cmd"
$jmp 26941 "t"
mov <esp+2>["cmd"] None
jmp 26941
mov <esp+2>["cmd"] <esp+1>[2]
dec CX
mov <__init___26915+2> <esp+2>["A"]
mov <__init___26915+3> <esp+2>["B"]
mov <__init___26915+4> <esp+2>["cmd"]


push <__init___26915+2>
mov <__init___26915+0>.A <esp+1>
inc esp
push <__init___26915+3>
mov <__init___26915+0>.B <esp+1>
inc esp
push <__init___26915+4>
mov <__init___26915+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___26915" "0,1,2,3,4"
pop ip
Function BX 26962 <AndOr^51> "__str___26962" 2
mov <AndOr^51>.__str__ BX
jmp 26981           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___26962+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26962+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___26962+0>.B
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 26978         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___26962" "0,1"
pop ip
Function BX 26984 <AndOr^51> "write_26984" 7
mov <AndOr^51>.write BX
jmp 27234           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 26992 "!="
tf <esp+2> "in" "codes"
$jmp 26994 "t"
mov <esp+2>["codes"] None
jmp 26994
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_26984+2> <esp+2>["codes"]


mov AX <write_26984+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_26984+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_26984+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
mov AX <write_26984+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "cmp "
mov AX <write_26984+0>.B      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" " 1"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_26984+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
mov DX <write_26984+0>.cmd
tf DX "equ" "and"
$jmp 27080 "f"
mov AX True
jmp 27081
mov AX False
cmp AX 1
$jmp 27151 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 1"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_26984+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 0"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push "$jmp "
ex_func AX "str" <write_26984+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_26984+2>
mov BX <write_26984+3>
pop AX
mov AX[BX] <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_26984+5>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"!=\""
push <write_26984+2>
mov BX <write_26984+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27227        ;¸õ¦Ü©³³¡
mov DX <write_26984+0>.cmd
tf DX "equ" "or"
$jmp 27156 "f"
mov AX True
jmp 27157
mov AX False
cmp AX 1
$jmp 27227 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 0"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_26984+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_26984+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX 1"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_26984+2>.append
push "$jmp "
ex_func AX "str" <write_26984+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_26984+2>
mov BX <write_26984+3>
pop AX
mov AX[BX] <esp+1>
inc esp
push "$jmp "
ex_func AX "str" <write_26984+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " \"==\""
push <write_26984+2>
mov BX <write_26984+4>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27227        ;¸õ¦Ü©³³¡
push "AX"
mov <write_26984+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_26984" "0,1,2,3,4,5,6"
pop ip
mov AX <AndOr^51>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27246 "=="
tf AX "Ctn" "__init__"
$jmp 27244 "t"
jmp 27246
call AX.__init__
mov AX <AndOr^51>
end "Function" "AndOr^51"
pop ip
Function <&module_14992+38> 27251 None "Deny^52" 1
name <&module_14992+38> "<class '__main__.Deny'>"
jmp 27397
tf $Inheritance "equ" None
$jmp 27256 "t"
mov <Deny^52> $Inheritance
push 1
jmp 27258
mov <Deny^52> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Deny^52> <&module_14992+38>
Function BX 27266 <Deny^52> "__init___27266" 4
mov <Deny^52>.__init__ BX
jmp 27298           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27274 "!="
tf <esp+2> "in" "A"
$jmp 27276 "t"
mov <esp+2>["A"] None
jmp 27276
mov <esp+2>["A"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 27282 "!="
tf <esp+2> "in" "cmd"
$jmp 27284 "t"
mov <esp+2>["cmd"] None
jmp 27284
mov <esp+2>["cmd"] <esp+1>[1]
dec CX
mov <__init___27266+2> <esp+2>["A"]
mov <__init___27266+3> <esp+2>["cmd"]


push <__init___27266+2>
mov <__init___27266+0>.A <esp+1>
inc esp
push <__init___27266+3>
mov <__init___27266+0>.cmd <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27266" "0,1,2,3"
pop ip
Function BX 27301 <Deny^52> "__str___27301" 2
mov <Deny^52>.__str__ BX
jmp 27317           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<"
ex_func AX "str" <__str___27301+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <__str___27301+0>.A
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 27314         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27301" "0,1"
pop ip
Function BX 27320 <Deny^52> "write_27320" 3
mov <Deny^52>.write BX
jmp 27383           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27328 "!="
tf <esp+2> "in" "codes"
$jmp 27330 "t"
mov <esp+2>["codes"] None
jmp 27330
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27320+2> <esp+2>["codes"]


mov AX <write_27320+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27320+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <write_27320+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.location
tf DX "equ" "AX"
$jmp 27349 "t"
mov AX True
jmp 27350
mov AX False
cmp AX 1
$jmp 27365 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov AX "
mov AX <write_27320+0>.A      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27320+2>.append
jmp 27365        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "$oper AX \""
ex_func AX "str" <write_27320+0>.cmd
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27320+2>.append
push "AX"
mov <write_27320+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27320" "0,1,2"
pop ip
mov AX <Deny^52>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27395 "=="
tf AX "Ctn" "__init__"
$jmp 27393 "t"
jmp 27395
call AX.__init__
mov AX <Deny^52>
end "Function" "Deny^52"
pop ip
Function <&module_14992+39> 27400 None "Bool^53" 1
name <&module_14992+39> "<class '__main__.Bool'>"
jmp 27841
tf $Inheritance "equ" None
$jmp 27405 "t"
mov <Bool^53> $Inheritance
push 1
jmp 27407
mov <Bool^53> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Bool^53> <&module_14992+39>
Function BX 27415 <Bool^53> "__init___27415" 3
mov <Bool^53>.__init__ BX
jmp 27435           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27423 "!="
tf <esp+2> "in" "enequalbox"
$jmp 27425 "t"
mov <esp+2>["enequalbox"] None
jmp 27425
mov <esp+2>["enequalbox"] <esp+1>[0]
dec CX
mov <__init___27415+2> <esp+2>["enequalbox"]


push <__init___27415+2>
mov <__init___27415+0>.enebox <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27415" "0,1,2"
pop ip
Function BX 27438 <Bool^53> "__str___27438" 4
mov <Bool^53>.__str__ BX
jmp 27467           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ""
mov <__str___27438+2> <esp+1>
inc esp
ex_func AX "iter" <__str___27438+0>.enebox
push AX
fetch AX <esp+1>
$jmp 27461 "f"
mov <__str___27438+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__str___27438+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
$mov <__str___27438+2> "+" <esp+1>
inc esp
jmp 27447
inc esp
mov AX <__str___27438+2>
jmp 27464         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27438" "0,1,2,3"
pop ip
Function BX 27470 <Bool^53> "write_27470" 9
mov <Bool^53>.write BX
jmp 27827           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27478 "!="
tf <esp+2> "in" "codes"
$jmp 27480 "t"
mov <esp+2>["codes"] None
jmp 27480
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27470+2> <esp+2>["codes"]


push 0
mov <write_27470+3> <esp+1>
inc esp
push <write_27470+0>.enebox
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
push <write_27470+0>.enebox
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push [0]
mov <write_27470+4> <esp+1>
inc esp
push [0]
mov <write_27470+5> <esp+1>
inc esp
push [dict]
mov BX "=="
mov <esp+1>[BX] "f"
mov BX "!="
mov <esp+1>[BX] "t"
mov BX ">"
mov <esp+1>[BX] "<="
mov BX "<"
mov <esp+1>[BX] ">="
mov BX ">="
mov <esp+1>[BX] "<"
mov BX "<="
mov <esp+1>[BX] ">"
mov <write_27470+6> <esp+1>
inc esp
push <write_27470+3>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+0>.enebox
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
cmp DX AX
$jmp 27551 ">="
mov AX True
jmp 27552
mov AX False
cmp AX 1
$jmp 27721 "!="
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pop DX"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push (2)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 27633 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "tf DX \"equ\" "
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
push <write_27470+6>
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+5>.append
jmp 27675        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "cmp DX "
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
push <write_27470+6>
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+4>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push <write_27470+3>
oper <esp+1> "+" 3
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+0>.enebox
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 27696 ">="
mov AX True
jmp 27697
mov AX False
cmp AX 1
$jmp 27717 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "push "
push <write_27470+0>.enebox
push <write_27470+3>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
jmp 27717        ;¸õ¦Ü©³³¡
push 2
$mov <write_27470+3> "+" <esp+1>
inc esp
jmp 27535               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX True"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push 1        ;Àx¦sCX
push [1]
push "jmp "
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "+" 1
pop AX
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27470+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
mov <write_27470+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov AX False"
push [dict]
mov BX "simplify"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <write_27470+2>.append
ex_func AX "iter" <write_27470+4>
push AX
fetch AX <esp+1>
$jmp 27794 "f"
mov <write_27470+8> AX
push "$jmp "
ex_func AX "str" <write_27470+7>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_27470+8>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_27470+2>
push <write_27470+8>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27772
inc esp
ex_func AX "iter" <write_27470+5>
push AX
fetch AX <esp+1>
$jmp 27819 "f"
mov <write_27470+8> AX
push "$jmp "
ex_func AX "str" <write_27470+7>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_27470+8>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_27470+2>
push <write_27470+8>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 27797
inc esp
push "AX"
mov <write_27470+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27470" "0,1,2,3,4,5,6,7,8"
pop ip
mov AX <Bool^53>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 27839 "=="
tf AX "Ctn" "__init__"
$jmp 27837 "t"
jmp 27839
call AX.__init__
mov AX <Bool^53>
end "Function" "Bool^53"
pop ip
Function <&module_14992+40> 27844 None "Assert^54" 1
name <&module_14992+40> "<class '__main__.Assert'>"
jmp 28047
tf $Inheritance "equ" None
$jmp 27849 "t"
mov <Assert^54> $Inheritance
push 1
jmp 27851
mov <Assert^54> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Assert^54> <&module_14992+40>
Function BX 27859 <Assert^54> "__init___27859" 4
mov <Assert^54>.__init__ BX
jmp 27896           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27867 "!="
tf <esp+2> "in" "event"
$jmp 27869 "t"
mov <esp+2>["event"] None
jmp 27869
mov <esp+2>["event"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 27875 "!="
tf <esp+2> "in" "msg"
$jmp 27877 "t"
mov <esp+2>["msg"] None
jmp 27877
mov <esp+2>["msg"] <esp+1>[1]
dec CX
mov <__init___27859+2> <esp+2>["event"]
mov <__init___27859+3> <esp+2>["msg"]


push <__init___27859+2>
mov <__init___27859+0>.event <esp+1>
inc esp
push <__init___27859+3>
mov <__init___27859+0>.msg <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___27859+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___27859" "0,1,2,3"
pop ip
Function BX 27899 <Assert^54> "__str___27899" 2
mov <Assert^54>.__str__ BX
jmp 27915           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<assert "
ex_func AX "str" <__str___27899+0>.event
oper <esp+1> "+" AX
oper <esp+1> "+" ", "
ex_func AX "str" <__str___27899+0>.msg
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 27912         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___27899" "0,1"
pop ip
Function BX 27918 <Assert^54> "write_27918" 7
mov <Assert^54>.write BX
jmp 28033           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 27926 "!="
tf <esp+2> "in" "codes"
$jmp 27928 "t"
mov <esp+2>["codes"] None
jmp 27928
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_27918+2> <esp+2>["codes"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_27918+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27918+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_27918+0>.event
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+38>
push AX
mov <write_27918+3> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "AssertionError"
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+6>
mov <esp+1>[0] AX
push 1        ;Àx¦sCX
push [1]
push [1]
mov <esp+1>[0] <write_27918+0>.msg
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+10>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] [dict]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+12>
mov <esp+1>[2] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+17>
push AX
mov <write_27918+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_27918+4>
mov <esp+1>[1] "raise"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+18>
push AX
mov <write_27918+5> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push [1]
push [2]
mov <esp+1>[0] <write_27918+3>
push [1]
mov <esp+1>[0] <write_27918+5>
pop <esp+1>[1]
pop <esp+1>[0]
pop <esp+1>[0]
mov <esp+1>[1] [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&module_14992+25>
push AX
mov <write_27918+6> <esp+1>
inc esp
push [1]
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
pop <esp+1>[0]
mov <write_27918+6>.orig_lines <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_27918+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_27918+6>.write
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_27918" "0,1,2,3,4,5,6"
pop ip
mov AX <Assert^54>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 28045 "=="
tf AX "Ctn" "__init__"
$jmp 28043 "t"
jmp 28045
call AX.__init__
mov AX <Assert^54>
end "Function" "Assert^54"
pop ip
Function <&module_14992+41> 28050 None "STR^55" 1
name <&module_14992+41> "<class '__main__.STR'>"
jmp 28160
tf $Inheritance "equ" None
$jmp 28055 "t"
mov <STR^55> $Inheritance
push 1
jmp 28057
mov <STR^55> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <STR^55> <&module_14992+41>
Function BX 28065 <STR^55> "__init___28065" 3
mov <STR^55>.__init__ BX
jmp 28085           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28073 "!="
tf <esp+2> "in" "obj"
$jmp 28075 "t"
mov <esp+2>["obj"] None
jmp 28075
mov <esp+2>["obj"] <esp+1>[0]
dec CX
mov <__init___28065+2> <esp+2>["obj"]


push <__init___28065+2>
mov <__init___28065+0>.obj <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___28065" "0,1,2"
pop ip
Function BX 28088 <STR^55> "__str___28088" 2
mov <STR^55>.__str__ BX
jmp 28101           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<STR: "
ex_func AX "str" <__str___28088+0>.obj
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 28098         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___28088" "0,1"
pop ip
Function BX 28104 <STR^55> "write_28104" 3
mov <STR^55>.write BX
jmp 28146           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28112 "!="
tf <esp+2> "in" "codes"
$jmp 28114 "t"
mov <esp+2>["codes"] None
jmp 28114
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_28104+2> <esp+2>["codes"]


mov AX <write_28104+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_28104+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "ex_func AX \"str\" "
mov AX <write_28104+0>.obj      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_28104+2>.append
push "AX"
mov <write_28104+0>.location <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_28104" "0,1,2"
pop ip
mov AX <STR^55>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 28158 "=="
tf AX "Ctn" "__init__"
$jmp 28156 "t"
jmp 28158
call AX.__init__
mov AX <STR^55>
end "Function" "STR^55"
pop ip
Function <&module_14992+42> 28163 None "Info^56" 1
name <&module_14992+42> "<class '__main__.Info'>"
jmp 28492
tf $Inheritance "equ" None
$jmp 28168 "t"
mov <Info^56> $Inheritance
push 1
jmp 28170
mov <Info^56> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Info^56> <&module_14992+42>
Function BX 28178 <Info^56> "__init___28178" 3
mov <Info^56>.__init__ BX
jmp 28213           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28186 "!="
tf <esp+2> "in" "namespace"
$jmp 28188 "t"
mov <esp+2>["namespace"] None
jmp 28188
mov <esp+2>["namespace"] <esp+1>[0]
dec CX
mov <__init___28178+2> <esp+2>["namespace"]


push [0]
mov <__init___28178+0>.locals <esp+1>
inc esp
push [dict]
mov <__init___28178+0>.vars <esp+1>
inc esp
push [dict]
mov <__init___28178+0>.funcs <esp+1>
inc esp
push [dict]
mov <__init___28178+0>.classes <esp+1>
inc esp
push [0]
mov <__init___28178+0>.codelines <esp+1>
inc esp
push <__init___28178+2>
mov <__init___28178+0>.namespace <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___28178" "0,1,2"
pop ip
Function BX 28216 <Info^56> "add_info_28216" 4
mov <Info^56>.add_info BX
jmp 28303           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28224 "!="
tf <esp+2> "in" "type"
$jmp 28226 "t"
mov <esp+2>["type"] None
jmp 28226
mov <esp+2>["type"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 28232 "!="
tf <esp+2> "in" "obj"
$jmp 28234 "t"
mov <esp+2>["obj"] None
jmp 28234
mov <esp+2>["obj"] <esp+1>[1]
dec CX
mov <add_info_28216+2> <esp+2>["type"]
mov <add_info_28216+3> <esp+2>["obj"]


mov DX <add_info_28216+2>
tf DX "equ" "var"
$jmp 28243 "f"
mov AX True
jmp 28244
mov AX False
cmp AX 1
$jmp 28253 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_28216+3>
push <add_info_28216+0>.vars
mov BX <add_info_28216+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 28283        ;¸õ¦Ü©³³¡
mov DX <add_info_28216+2>
tf DX "equ" "func"
$jmp 28258 "f"
mov AX True
jmp 28259
mov AX False
cmp AX 1
$jmp 28268 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_28216+3>
push <add_info_28216+0>.funcs
mov BX <add_info_28216+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 28283        ;¸õ¦Ü©³³¡
mov DX <add_info_28216+2>
tf DX "equ" "class"
$jmp 28273 "f"
mov AX True
jmp 28274
mov AX False
cmp AX 1
$jmp 28283 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <add_info_28216+3>
push <add_info_28216+0>.classes
mov BX <add_info_28216+3>.name
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 28283        ;¸õ¦Ü©³³¡
tf <add_info_28216+0>.locals "in" <add_info_28216+3>.name
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 28299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <add_info_28216+0>.locals      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <add_info_28216+3>.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 28299        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "add_info_28216" "0,1,2,3"
pop ip
Function BX 28306 <Info^56> "update_28306" 3
mov <Info^56>.update BX
jmp 28356           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28314 "!="
tf <esp+2> "in" "info"
$jmp 28316 "t"
mov <esp+2>["info"] None
jmp 28316
mov <esp+2>["info"] <esp+1>[0]
dec CX
mov <update_28306+2> <esp+2>["info"]


push <update_28306+2>.locals
$mov <update_28306+0>.locals "+" <esp+1>
inc esp
mov AX <update_28306+0>.vars      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28306+2>.vars
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <update_28306+0>.funcs      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28306+2>.funcs
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <update_28306+0>.classes      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.update
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <update_28306+2>.classes
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "update_28306" "0,1,2"
pop ip
Function BX 28359 <Info^56> "write_28359" 5
mov <Info^56>.write BX
jmp 28478           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28367 "!="
tf <esp+2> "in" "codeline"
$jmp 28369 "t"
mov <esp+2>["codeline"] None
jmp 28369
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 28375 "!="
tf <esp+2> "in" "orig_codelines"
$jmp 28377 "t"
mov <esp+2>["orig_codelines"] None
jmp 28377
mov <esp+2>["orig_codelines"] <esp+1>[1]
dec CX
mov <write_28359+2> <esp+2>["codeline"]
mov <write_28359+3> <esp+2>["orig_codelines"]


Function <write_28359+4> 28383 None "deal_orig_28383" 4 "write_28359"
jmp 28461           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28391 "!="
tf <esp+2> "in" "orig_codeline"
$jmp 28393 "t"
mov <esp+2>["orig_codeline"] None
jmp 28393
mov <esp+2>["orig_codeline"] <esp+1>[0]
dec CX
mov <deal_orig_28383+1> <esp+2>["orig_codeline"]


push [0]
mov <deal_orig_28383+2> <esp+1>
inc esp
ex_func AX "iter" <deal_orig_28383+1>
push AX
fetch AX <esp+1>
$jmp 28446 "f"
mov <deal_orig_28383+3> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28383+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" int
$jmp 28416 "f"
mov AX True
jmp 28417
mov AX False
cmp AX 1
$jmp 28429 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push " "
oper <esp+1> "*" <deal_orig_28383+3>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_orig_28383+2>.append
jmp 28445        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28383+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call str
push AX
oper <esp+1> "+" " "
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_orig_28383+2>.append
jmp 28401
inc esp
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_orig_28383+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 28458         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_orig_28383" "0,1,2,3"
pop ip
mov AX <write_28359+0>.codelines      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_28359+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <write_28359+3>
mov <write_28359+2>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_28359" "0,1,2,3"
pop ip
mov AX <Info^56>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 28490 "=="
tf AX "Ctn" "__init__"
$jmp 28488 "t"
jmp 28490
call AX.__init__
mov AX <Info^56>
end "Function" "Info^56"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/module.py"]
mov <&package_6+18> <esp+1>.Integer    ;import *
mov <&package_6+19> <esp+1>.Float    ;import *
mov <&package_6+20> <esp+1>.String    ;import *
mov <&package_6+21> <esp+1>.Byte    ;import *
mov <&package_6+22> <esp+1>.Var_name    ;import *
mov <&package_6+23> <esp+1>.Namespace    ;import *
mov <&package_6+24> <esp+1>.Variable    ;import *
mov <&package_6+25> <esp+1>.SubVariable    ;import *
mov <&package_6+26> <esp+1>.Slice    ;import *
mov <&package_6+27> <esp+1>.IndexVariable    ;import *
mov <&package_6+28> <esp+1>.List    ;import *
mov <&package_6+29> <esp+1>.Tuple    ;import *
mov <&package_6+30> <esp+1>.Dict    ;import *
mov <&package_6+31> <esp+1>.Set    ;import *
mov <&package_6+32> <esp+1>.is_number    ;import *
mov <&package_6+33> <esp+1>.Lambda    ;import *
mov <&package_6+34> <esp+1>.Def    ;import *
mov <&package_6+35> <esp+1>.FuncCall    ;import *
mov <&package_6+36> <esp+1>.Backtrack    ;import *
mov <&package_6+37> <esp+1>.Var_declare    ;import *
mov <&package_6+38> <esp+1>.Try_Except    ;import *
mov <&package_6+39> <esp+1>.With    ;import *
mov <&package_6+40> <esp+1>.Stop    ;import *
mov <&package_6+41> <esp+1>.Command    ;import *
mov <&package_6+42> <esp+1>.sub_if_else    ;import *
mov <&package_6+43> <esp+1>.If_else    ;import *
mov <&package_6+44> <esp+1>.While    ;import *
mov <&package_6+45> <esp+1>.sub_for_loop    ;import *
mov <&package_6+46> <esp+1>.For_loop    ;import *
mov <&package_6+47> <esp+1>.Mark    ;import *
mov <&package_6+48> <esp+1>.Pass    ;import *
mov <&package_6+49> <esp+1>.TFN    ;import *
mov <&package_6+50> <esp+1>.Class    ;import *
mov <&package_6+51> <esp+1>.two_object_write    ;import *
mov <&package_6+52> <esp+1>.Multiple_Mov    ;import *
mov <&package_6+53> <esp+1>.Oper    ;import *
mov <&package_6+54> <esp+1>.Tf    ;import *
mov <&package_6+55> <esp+1>.AndOr    ;import *
mov <&package_6+56> <esp+1>.Deny    ;import *
mov <&package_6+57> <esp+1>.Bool    ;import *
mov <&package_6+58> <esp+1>.Assert    ;import *
mov <&package_6+59> <esp+1>.STR    ;import *
mov <&package_6+60> <esp+1>.Info    ;import *
inc esp
Function <&package_6+6> 28539 None "parse_code_28539" 34
jmp 30746           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28547 "!="
tf <esp+2> "in" "code"
$jmp 28549 "t"
mov <esp+2>["code"] None
jmp 28549
mov <esp+2>["code"] <esp+1>[0]
dec CX
mov <parse_code_28539+1> <esp+2>["code"]


Function <parse_code_28539+2> 28554 None "deal_string_28554" 10 "parse_code_28539"
jmp 28946           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 28562 "!="
tf <esp+2> "in" "k"
$jmp 28564 "t"
mov <esp+2>["k"] None
jmp 28564
mov <esp+2>["k"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 28570 "!="
tf <esp+2> "in" "change"
$jmp 28572 "t"
mov <esp+2>["change"] True
jmp 28572
mov <esp+2>["change"] <esp+1>[1]
dec CX
mov <deal_string_28554+1> <esp+2>["k"]
mov <deal_string_28554+2> <esp+2>["change"]


push <parse_code_28539+1>
mov BX <deal_string_28554+1>
pop AX
push AX[BX]
mov <deal_string_28554+3> <esp+1>
inc esp
push 1
$mov <deal_string_28554+1> "+" <esp+1>
inc esp
push <deal_string_28554+1>
mov <deal_string_28554+4> <esp+1>
inc esp
cmp True 1
$jmp 28637 "!="
push <parse_code_28539+1>
mov BX <deal_string_28554+1>
pop AX
push AX[BX]
mov <deal_string_28554+5> <esp+1>
inc esp
mov DX <deal_string_28554+5>
tf DX "equ" "\n"
$jmp 28601 "f"
mov AX True
jmp 28602
mov AX False
cmp AX 1
$jmp 28611 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28539+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 28611        ;¸õ¦Ü©³³¡
mov DX <deal_string_28554+5>
tf DX "equ" "\\"
$jmp 28616 "f"
mov AX True
jmp 28617
mov AX False
cmp AX 1
$jmp 28623 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <deal_string_28554+1> "+" <esp+1>
inc esp
jmp 28633        ;¸õ¦Ü©³³¡
mov DX <deal_string_28554+5>
tf DX "equ" <deal_string_28554+3>
$jmp 28628 "f"
mov AX True
jmp 28629
mov AX False
cmp AX 1
$jmp 28633 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 28637          ;break¥X
jmp 28633        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_28554+1> "+" <esp+1>
inc esp
jmp 28588               ;continue­«¨Ó
push <parse_code_28539+1>
push [3]
mov <esp+1>[0] <deal_string_28554+4>
mov <esp+1>[1] <deal_string_28554+1>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <deal_string_28554+6> <esp+1>
inc esp
mov DX <deal_string_28554+3>
tf DX "equ" "'"
$jmp 28655 "f"
mov AX True
jmp 28656
mov AX False
cmp AX 1
$jmp 28664 "!="
mov AX <deal_string_28554+2>
$oper AX "not"
cmp AX 1
$jmp 28664 "!="
mov AX 1
jmp 28665
mov AX 0
cmp AX 1
$jmp 28684 "=="
mov DX <deal_string_28554+3>
tf DX "equ" "\""
$jmp 28672 "f"
mov AX True
jmp 28673
mov AX False
cmp AX 1
$jmp 28679 "!="
cmp <deal_string_28554+2> 1
$jmp 28679 "!="
mov AX 1
jmp 28680
mov AX 0
cmp AX 1
$jmp 28684 "=="
mov AX 0
jmp 28685
mov AX 1
cmp AX 1
$jmp 28703 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28554+6>
push [dict]
mov BX "change"
mov <esp+1>[BX] <deal_string_28554+2>
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28554+1>
pop AX
jmp 28943
jmp 28942        ;¸õ¦Ü©³³¡
mov DX <deal_string_28554+3>
tf DX "equ" "'"
$jmp 28708 "f"
mov AX True
jmp 28709
mov AX False
cmp AX 1
$jmp 28715 "!="
cmp <deal_string_28554+2> 1
$jmp 28715 "!="
mov AX 1
jmp 28716
mov AX 0
cmp AX 1
$jmp 28826 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <deal_string_28554+7> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28554+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <deal_string_28554+8> <esp+1>[0]
mov <deal_string_28554+9> <esp+1>[1]
inc esp
mov DX <deal_string_28554+8>
cmp DX <deal_string_28554+9>
$jmp 28739 ">="
mov AX True
jmp 28740
mov AX False
cmp AX 1
$jmp 28800 "!="
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 28750 "f"
mov AX True
jmp 28751
mov AX False
cmp AX 1
$jmp 28761 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
jmp 28761        ;¸õ¦Ü©³³¡
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 28769 "f"
mov AX True
jmp 28770
mov AX False
cmp AX 1
$jmp 28786 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
push 1
$mov <deal_string_28554+8> "+" <esp+1>
inc esp
jmp 28786        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
push 1
$mov <deal_string_28554+8> "+" <esp+1>
inc esp
jmp 28734               ;continue­«¨Ó
push (2)
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28554+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
push [dict]
mov BX "change"
mov <esp+1>[BX] <deal_string_28554+2>
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28554+1>
pop AX
jmp 28943
jmp 28942        ;¸õ¦Ü©³³¡
mov DX <deal_string_28554+3>
tf DX "equ" "\""
$jmp 28831 "f"
mov AX True
jmp 28832
mov AX False
cmp AX 1
$jmp 28840 "!="
mov AX <deal_string_28554+2>
$oper AX "not"
cmp AX 1
$jmp 28840 "!="
mov AX 1
jmp 28841
mov AX 0
cmp AX 1
$jmp 28942 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <deal_string_28554+7> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28554+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <deal_string_28554+8> <esp+1>[0]
mov <deal_string_28554+9> <esp+1>[1]
inc esp
mov DX <deal_string_28554+8>
cmp DX <deal_string_28554+9>
$jmp 28864 ">="
mov AX True
jmp 28865
mov AX False
cmp AX 1
$jmp 28919 "!="
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\""
$jmp 28875 "f"
mov AX True
jmp 28876
mov AX False
cmp AX 1
$jmp 28886 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
jmp 28886        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
push <deal_string_28554+6>
mov BX <deal_string_28554+8>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 28904 "f"
mov AX True
jmp 28905
mov AX False
cmp AX 1
$jmp 28915 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_string_28554+7>.append
jmp 28915        ;¸õ¦Ü©³³¡
push 1
$mov <deal_string_28554+8> "+" <esp+1>
inc esp
jmp 28859               ;continue­«¨Ó
push (2)
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_string_28554+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <deal_string_28554+1>
pop AX
jmp 28943
jmp 28942        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_string_28554" "0,1,2,3,4,5,6,7,8,9"
pop ip
push [34]
mov <esp+1>[0] "def"
mov <esp+1>[1] "while"
mov <esp+1>[2] "for"
mov <esp+1>[3] "in"
mov <esp+1>[4] "if"
mov <esp+1>[5] "elif"
mov <esp+1>[6] "else"
mov <esp+1>[7] "class"
mov <esp+1>[8] "break"
mov <esp+1>[9] "continue"
mov <esp+1>[10] "return"
mov <esp+1>[11] ":"
mov <esp+1>[12] "and"
mov <esp+1>[13] "not"
mov <esp+1>[14] "or"
mov <esp+1>[15] "True"
mov <esp+1>[16] "False"
mov <esp+1>[17] "None"
mov <esp+1>[18] "from"
mov <esp+1>[19] "import"
mov <esp+1>[20] "as"
mov <esp+1>[21] "is"
mov <esp+1>[22] "with"
mov <esp+1>[23] "raise"
mov <esp+1>[24] "try"
mov <esp+1>[25] "except"
mov <esp+1>[26] "finally"
mov <esp+1>[27] "yield"
mov <esp+1>[28] "lambda"
mov <esp+1>[29] "del"
mov <esp+1>[30] "global"
mov <esp+1>[31] "nonlocal"
mov <esp+1>[32] "assert"
mov <esp+1>[33] "$stop"
mov <parse_code_28539+3> <esp+1>
inc esp
push [dict]
mov BX "AX"
mov <esp+1>[BX] 0
mov BX "BX"
mov <esp+1>[BX] 1
mov BX "CX"
mov <esp+1>[BX] 2
mov BX "DX"
mov <esp+1>[BX] 3
mov BX "ip"
mov <esp+1>[BX] 4
mov BX "esp"
mov <esp+1>[BX] 5
mov BX "sp"
mov <esp+1>[BX] 6
mov BX "ZR"
mov <esp+1>[BX] 7
mov BX "TF"
mov <esp+1>[BX] 8
mov <parse_code_28539+4> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_code_28539+5> <esp+1>[0]
mov <parse_code_28539+6> <esp+1>[1]
inc esp
push [0]
mov <parse_code_28539+7> <esp+1>
inc esp
push 0
mov <parse_code_28539+8> <esp+1>
inc esp
push 0
mov <parse_code_28539+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+1>.split
push AX
mov <parse_code_28539+10> <esp+1>
inc esp
push [1]
mov <esp+1>[0] 1
mov <parse_code_28539+11> <esp+1>
inc esp
push [1]
push (3)
mov <esp+1>[0] 0
push <parse_code_28539+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28539+10>
push <parse_code_28539+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov <parse_code_28539+12> <esp+1>
inc esp
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 29064 ">="
mov AX True
jmp 29065
mov AX False
cmp AX 1
$jmp 30718 "!="
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
push AX[BX]
mov <parse_code_28539+13> <esp+1>
inc esp
tf "0123456789" "in" <parse_code_28539+13>
mov AX TF
cmp AX 1
$jmp 29154 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+5>
mov <parse_code_28539+14> <esp+1>
inc esp
push "0123456789."
mov <parse_code_28539+15> <esp+1>
inc esp
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 29088 ">="
mov AX True
jmp 29089
mov AX False
cmp AX 1
$jmp 29104 "!="
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
tf <parse_code_28539+15> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 29102 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29103        ;¸õ¦Ü©³³¡
jmp 29104          ;break¥X
jmp 29083               ;continue­«¨Ó
push <parse_code_28539+1>
push [3]
mov <esp+1>[0] <parse_code_28539+14>
mov <esp+1>[1] <parse_code_28539+5>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+16> <esp+1>
inc esp
tf <parse_code_28539+16> "in" "."
mov AX TF
cmp AX 1
$jmp 29136 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+19>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 29150        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push 1
$mov <parse_code_28539+5> "-" <esp+1>
inc esp
jmp 30714        ;¸õ¦Ü©³³¡
tf "+-*/,()[]{}!=%:><.&^|~" "in" <parse_code_28539+13>
mov AX TF
cmp AX 1
$jmp 29452 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+5>
oper <esp+1> "+" 2
pop DX
cmp DX <parse_code_28539+6>
$jmp 29165 ">="
mov AX True
jmp 29166
mov AX False
cmp AX 1
$jmp 29207 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+1>
push [3]
mov <esp+1>[0] <parse_code_28539+5>
push <parse_code_28539+5>
oper <esp+1> "+" 3
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+17> <esp+1>
inc esp
push (4)
mov <esp+1>[0] "**="
mov <esp+1>[1] "//="
mov <esp+1>[2] ">>="
mov <esp+1>[3] "<<="
mov BX <parse_code_28539+17>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push 3
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29059
jmp 29206        ;¸õ¦Ü©³³¡
jmp 29207        ;¸õ¦Ü©³³¡
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28539+6>
$jmp 29214 ">="
mov AX True
jmp 29215
mov AX False
cmp AX 1
$jmp 29270 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+1>
push [3]
mov <esp+1>[0] <parse_code_28539+5>
push <parse_code_28539+5>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+18> <esp+1>
inc esp
push (18)
mov <esp+1>[0] "+="
mov <esp+1>[1] "-="
mov <esp+1>[2] "*="
mov <esp+1>[3] "/="
mov <esp+1>[4] "=="
mov <esp+1>[5] "!="
mov <esp+1>[6] "**"
mov <esp+1>[7] ">"
mov <esp+1>[8] "<"
mov <esp+1>[9] ">="
mov <esp+1>[10] "<="
mov <esp+1>[11] "%="
mov <esp+1>[12] "//"
mov <esp+1>[13] ">>"
mov <esp+1>[14] "<<"
mov <esp+1>[15] "&="
mov <esp+1>[16] "^="
mov <esp+1>[17] "|="
mov BX <parse_code_28539+18>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29269 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push 2
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29059
jmp 29269        ;¸õ¦Ü©³³¡
jmp 29270        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push (3)
mov <esp+1>[0] "("
mov <esp+1>[1] "["
mov <esp+1>[2] "{"
mov BX <parse_code_28539+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29291 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+8> "+" <esp+1>
inc esp
jmp 29305        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
mov BX <parse_code_28539+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29305 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+8> "-" <esp+1>
inc esp
jmp 29305        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" ":"
$jmp 29310 "f"
mov AX True
jmp 29311
mov AX False
cmp AX 1
$jmp 29323 "!="
mov DX <parse_code_28539+8>
tf DX "equ" 0
$jmp 29318 "f"
mov AX True
jmp 29319
mov AX False
cmp AX 1
$jmp 29323 "!="
mov AX 1
jmp 29324
mov AX 0
cmp AX 1
$jmp 29451 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28539+9>
cmp DX 0
$jmp 29331 "<="
mov AX True
jmp 29332
mov AX False
cmp AX 1
$jmp 29338 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+9> "-" <esp+1>
inc esp
jmp 29450        ;¸õ¦Ü©³³¡
finally 29375
try 29353
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\n"
mov <esp+1>[1] <parse_code_28539+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+1>.index
push AX
mov <parse_code_28539+19> <esp+1>
inc esp
try "end"
jmp 29370    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error Exception
$jmp 29369 "f"
mov $Exception 0
try 29373
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_28539+19> <esp+1>
inc esp
try "end"
jmp 29370  ;¸õ¨ìpush 1
jmp 29373 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 29375    ;¸õ¨ìfinally
push None
push 0
finally -29375
pop AX
cmp AX 1
$jmp 29382 "=="
pop AX
mov AX $Exception
raise AX
pop AX
end "finally_yield"
push <parse_code_28539+19>
oper <esp+1> "-" <parse_code_28539+5>
pop DX
cmp DX 1
$jmp 29391 "<="
mov AX True
jmp 29392
mov AX False
cmp AX 1
$jmp 29450 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+7>.append
push [1]
push (3)
push <parse_code_28539+12>
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "+" 4
pop <esp+1>[0]
push <parse_code_28539+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28539+10>
push <parse_code_28539+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov <parse_code_28539+12> <esp+1>
inc esp
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 29439 "f"
mov AX True
jmp 29440
mov AX False
cmp AX 1
$jmp 29446 "!="
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29431               ;continue­«¨Ó
push 1
$mov <parse_code_28539+5> "-" <esp+1>
inc esp
jmp 29450        ;¸õ¦Ü©³³¡
jmp 29451        ;¸õ¦Ü©³³¡
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" "#"
$jmp 29457 "f"
mov AX True
jmp 29458
mov AX False
cmp AX 1
$jmp 29492 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 29465 ">="
mov AX True
jmp 29466
mov AX False
cmp AX 1
$jmp 29481 "!="
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
mov DX AX[BX]
tf DX "equ" "\n"
$jmp 29476 "t"
mov AX True
jmp 29477
mov AX False
cmp AX 1
$jmp 29481 "!="
mov AX 1
jmp 29482
mov AX 0
cmp AX 1
$jmp 29488 "!="
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29460               ;continue­«¨Ó
push 1
$mov <parse_code_28539+5> "-" <esp+1>
inc esp
jmp 30714        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
mov BX <parse_code_28539+13>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29568 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+2>
push AX
mov <parse_code_28539+20> <esp+1>[0]
mov <parse_code_28539+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29524 "<="
mov AX True
jmp 29525
mov AX False
cmp AX 1
$jmp 29549 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 29544 "f"
mov AX True
jmp 29545
mov AX False
cmp AX 1
$jmp 29549 "!="
mov AX 1
jmp 29550
mov AX 0
cmp AX 1
$jmp 29560 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 29560        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" "\n"
$jmp 29573 "f"
mov AX True
jmp 29574
mov AX False
cmp AX 1
$jmp 29689 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28539+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
mov DX <parse_code_28539+8>
tf DX "equ" 0
$jmp 29587 "f"
mov AX True
jmp 29588
mov AX False
cmp AX 1
$jmp 29688 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 29602 "<="
mov AX True
jmp 29603
mov AX False
cmp AX 1
$jmp 29613 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+7>.append
jmp 29613        ;¸õ¦Ü©³³¡
push [0]
mov <parse_code_28539+12> <esp+1>
inc esp
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 29624 ">="
mov AX True
jmp 29625
mov AX False
cmp AX 1
$jmp 29684 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <parse_code_28539+21> <esp+1>
inc esp
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 29635 ">="
mov AX True
jmp 29636
mov AX False
cmp AX 1
$jmp 29651 "!="
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 29646 "f"
mov AX True
jmp 29647
mov AX False
cmp AX 1
$jmp 29651 "!="
mov AX 1
jmp 29652
mov AX 0
cmp AX 1
$jmp 29661 "!="
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
push 1
$mov <parse_code_28539+21> "+" <esp+1>
inc esp
jmp 29630               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] <parse_code_28539+21>
push <parse_code_28539+11>
mov BX 0
pop AX
mov <esp+1>[1] AX[BX]
push <parse_code_28539+10>
push <parse_code_28539+11>
mov BX 0
pop AX
push AX[BX]
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[2] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 29684        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28539+5> "-" <esp+1>
inc esp
jmp 29688        ;¸õ¦Ü©³³¡
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" "r"
$jmp 29694 "f"
mov AX True
jmp 29695
mov AX False
cmp AX 1
$jmp 29709 "!="
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28539+6>
$jmp 29704 ">="
mov AX True
jmp 29705
mov AX False
cmp AX 1
$jmp 29709 "!="
mov AX 1
jmp 29710
mov AX 0
cmp AX 1
$jmp 29728 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28539+1>
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29728 "!="
mov AX 1
jmp 29729
mov AX 0
cmp AX 1
$jmp 29804 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+5>
push [dict]
mov BX "change"
mov <esp+1>[BX] False
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+2>
push AX
mov <parse_code_28539+20> <esp+1>[0]
mov <parse_code_28539+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29760 "<="
mov AX True
jmp 29761
mov AX False
cmp AX 1
$jmp 29785 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 29780 "f"
mov AX True
jmp 29781
mov AX False
cmp AX 1
$jmp 29785 "!="
mov AX 1
jmp 29786
mov AX 0
cmp AX 1
$jmp 29796 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 29796        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" "b"
$jmp 29809 "f"
mov AX True
jmp 29810
mov AX False
cmp AX 1
$jmp 29824 "!="
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28539+6>
$jmp 29819 ">="
mov AX True
jmp 29820
mov AX False
cmp AX 1
$jmp 29824 "!="
mov AX 1
jmp 29825
mov AX 0
cmp AX 1
$jmp 29843 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28539+1>
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29843 "!="
mov AX 1
jmp 29844
mov AX 0
cmp AX 1
$jmp 29923 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+2>
push AX
mov <parse_code_28539+20> <esp+1>[0]
mov <parse_code_28539+5> <esp+1>[1]
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 29872 "<="
mov AX True
jmp 29873
mov AX False
cmp AX 1
$jmp 29897 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+21>
$jmp 29892 "f"
mov AX True
jmp 29893
mov AX False
cmp AX 1
$jmp 29897 "!="
mov AX 1
jmp 29898
mov AX 0
cmp AX 1
$jmp 29908 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 29908        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+20>.text
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+21>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" "f"
$jmp 29928 "f"
mov AX True
jmp 29929
mov AX False
cmp AX 1
$jmp 29943 "!="
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_code_28539+6>
$jmp 29938 ">="
mov AX True
jmp 29939
mov AX False
cmp AX 1
$jmp 29943 "!="
mov AX 1
jmp 29944
mov AX 0
cmp AX 1
$jmp 29962 "!="
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28539+1>
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 29962 "!="
mov AX 1
jmp 29963
mov AX 0
cmp AX 1
$jmp 30513 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "("
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push <parse_code_28539+1>
push <parse_code_28539+5>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_code_28539+22> <esp+1>
inc esp
push <parse_code_28539+5>
oper <esp+1> "+" 2
mov <parse_code_28539+19> <esp+1>
inc esp
push <parse_code_28539+1>
mov BX <parse_code_28539+19>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_code_28539+22>
$jmp 29992 "t"
mov AX True
jmp 29993
mov AX False
cmp AX 1
$jmp 30010 "=="
push <parse_code_28539+1>
push <parse_code_28539+19>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 30005 "f"
mov AX True
jmp 30006
mov AX False
cmp AX 1
$jmp 30010 "=="
mov AX 0
jmp 30011
mov AX 1
cmp AX 1
$jmp 30017 "!="
push 1
$mov <parse_code_28539+19> "+" <esp+1>
inc esp
jmp 29984               ;continue­«¨Ó
push <parse_code_28539+1>
push [3]
push <parse_code_28539+5>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] <parse_code_28539+19>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_code_28539+24> <esp+1>
inc esp
push 0
mov <parse_code_28539+25> <esp+1>
inc esp
push [0]
mov <parse_code_28539+26> <esp+1>
inc esp
mov DX <parse_code_28539+25>
cmp DX <parse_code_28539+24>
$jmp 30053 ">="
mov AX True
jmp 30054
mov AX False
cmp AX 1
$jmp 30478 "!="
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov DX AX[BX]
tf DX "equ" "\n"
$jmp 30064 "f"
mov AX True
jmp 30065
mov AX False
cmp AX 1
$jmp 30074 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
push <parse_code_28539+11>
mov BX 0
pop AX
$mov AX[BX] "+" <esp+1>
inc esp
jmp 30074        ;¸õ¦Ü©³³¡
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov DX AX[BX]
tf DX "equ" "{"
$jmp 30082 "f"
mov AX True
jmp 30083
mov AX False
cmp AX 1
$jmp 30349 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+23>
push <parse_code_28539+25>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "{"
$jmp 30095 "f"
mov AX True
jmp 30096
mov AX False
cmp AX 1
$jmp 30109 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "{"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
jmp 30348        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 30121 "<="
mov AX True
jmp 30122
mov AX False
cmp AX 1
$jmp 30146 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+12>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+20>
$jmp 30141 "f"
mov AX True
jmp 30142
mov AX False
cmp AX 1
$jmp 30146 "!="
mov AX 1
jmp 30147
mov AX 0
cmp AX 1
$jmp 30157 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30157        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push [0]
mov <parse_code_28539+26> <esp+1>
inc esp
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
push <parse_code_28539+25>
mov <parse_code_28539+14> <esp+1>
inc esp
push 0
mov <parse_code_28539+27> <esp+1>
inc esp
push 1
mov <parse_code_28539+13> <esp+1>
inc esp
mov DX <parse_code_28539+13>
cmp DX 0
$jmp 30201 "<="
mov AX True
jmp 30202
mov AX False
cmp AX 1
$jmp 30290 "!="
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
push AX[BX]
mov <parse_code_28539+28> <esp+1>
inc esp
mov DX <parse_code_28539+27>
tf DX "equ" 0
$jmp 30215 "f"
mov AX True
jmp 30216
mov AX False
cmp AX 1
$jmp 30256 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28539+28>
tf DX "equ" "{"
$jmp 30223 "f"
mov AX True
jmp 30224
mov AX False
cmp AX 1
$jmp 30230 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+13> "+" <esp+1>
inc esp
jmp 30255        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+28>
tf DX "equ" "}"
$jmp 30235 "f"
mov AX True
jmp 30236
mov AX False
cmp AX 1
$jmp 30242 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+13> "-" <esp+1>
inc esp
jmp 30255        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "'"
mov <esp+1>[1] "\""
mov BX <parse_code_28539+28>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30255 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_code_28539+28>
mov <parse_code_28539+27> <esp+1>
inc esp
jmp 30255        ;¸õ¦Ü©³³¡
jmp 30286        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+28>
tf DX "equ" <parse_code_28539+27>
$jmp 30261 "f"
mov AX True
jmp 30262
mov AX False
cmp AX 1
$jmp 30279 "!="
push <parse_code_28539+23>
push <parse_code_28539+25>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 30274 "t"
mov AX True
jmp 30275
mov AX False
cmp AX 1
$jmp 30279 "!="
mov AX 1
jmp 30280
mov AX 0
cmp AX 1
$jmp 30286 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0
mov <parse_code_28539+27> <esp+1>
inc esp
jmp 30286        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
jmp 30196               ;continue­«¨Ó
push 1
$mov <parse_code_28539+25> "-" <esp+1>
inc esp
push <parse_code_28539+23>
push [3]
mov <esp+1>[0] <parse_code_28539+14>
mov <esp+1>[1] <parse_code_28539+25>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+29> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+29>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov BX 0
pop AX
push AX[BX]
push [3]
mov <esp+1>[0] 1
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_code_28539+30> <esp+1>
inc esp
push [3]
mov <esp+1>[0] "+"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$str"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+22>
mov <esp+1>[1] AX
mov <esp+1>[2] "("
oper <esp+1> "+" <parse_code_28539+30>
push [2]
mov <esp+1>[0] ")"
mov <esp+1>[1] "+"
pop AX
oper <esp+1> "+" AX
$mov <parse_code_28539+12> "+" <esp+1>
inc esp
jmp 30474        ;¸õ¦Ü©³³¡
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov DX AX[BX]
tf DX "equ" "}"
$jmp 30357 "f"
mov AX True
jmp 30358
mov AX False
cmp AX 1
$jmp 30382 "!="
push <parse_code_28539+23>
push [3]
mov <esp+1>[0] <parse_code_28539+25>
push <parse_code_28539+25>
oper <esp+1> "+" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "}}"
$jmp 30377 "f"
mov AX True
jmp 30378
mov AX False
cmp AX 1
$jmp 30382 "!="
mov AX 1
jmp 30383
mov AX 0
cmp AX 1
$jmp 30399 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
jmp 30474        ;¸õ¦Ü©³³¡
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 30407 "f"
mov AX True
jmp 30408
mov AX False
cmp AX 1
$jmp 30434 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
jmp 30474        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30464 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\\"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
jmp 30474        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+23>
mov BX <parse_code_28539+25>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+26>.append
push 1
$mov <parse_code_28539+25> "+" <esp+1>
inc esp
jmp 30048               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push <parse_code_28539+19>
mov <parse_code_28539+5> <esp+1>
inc esp
jmp 30714        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+13>
tf DX "equ" " "
$jmp 30518 "t"
mov AX True
jmp 30519
mov AX False
cmp AX 1
$jmp 30714 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_code_28539+31> <esp+1>
inc esp
push "+-*/,()[]{}!=%:><.&^|~\\# \n:"
mov <parse_code_28539+32> <esp+1>
inc esp
mov DX <parse_code_28539+5>
cmp DX <parse_code_28539+6>
$jmp 30532 ">="
mov AX True
jmp 30533
mov AX False
cmp AX 1
$jmp 30559 "!="
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
tf <parse_code_28539+32> "in" AX[BX]
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 30557 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <parse_code_28539+1>
mov BX <parse_code_28539+5>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+31>.append
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 30558        ;¸õ¦Ü©³³¡
jmp 30559          ;break¥X
jmp 30527               ;continue­«¨Ó
mov AX ""      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <parse_code_28539+33> <esp+1>
inc esp
tf <parse_code_28539+3> "in" <parse_code_28539+33>
mov AX TF
cmp AX 1
$jmp 30687 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_code_28539+33>
tf DX "equ" "True"
$jmp 30581 "f"
mov AX True
jmp 30582
mov AX False
cmp AX 1
$jmp 30599 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] True
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30674        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+33>
tf DX "equ" "False"
$jmp 30604 "f"
mov AX True
jmp 30605
mov AX False
cmp AX 1
$jmp 30622 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] False
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30674        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+33>
tf DX "equ" "None"
$jmp 30627 "f"
mov AX True
jmp 30628
mov AX False
cmp AX 1
$jmp 30645 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30674        ;¸õ¦Ü©³³¡
mov DX <parse_code_28539+33>
tf DX "equ" "$stop"
$jmp 30650 "f"
mov AX True
jmp 30651
mov AX False
cmp AX 1
$jmp 30667 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+40>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
jmp 30674        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
mov DX <parse_code_28539+33>
tf DX "equ" "lambda"
$jmp 30679 "f"
mov AX True
jmp 30680
mov AX False
cmp AX 1
$jmp 30686 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_code_28539+9> "+" <esp+1>
inc esp
jmp 30686        ;¸õ¦Ü©³³¡
jmp 30710        ;¸õ¦Ü©³³¡
tf <parse_code_28539+4> "in" <parse_code_28539+33>
mov AX TF
cmp AX 1
$jmp 30696 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "$$"
oper <esp+1> "+" <parse_code_28539+33>
mov <parse_code_28539+33> <esp+1>
inc esp
jmp 30696        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+33>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+22>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+12>.append
push 1
$mov <parse_code_28539+5> "-" <esp+1>
inc esp
jmp 30714        ;¸õ¦Ü©³³¡
push 1
$mov <parse_code_28539+5> "+" <esp+1>
inc esp
jmp 29059               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 30730 "<="
mov AX True
jmp 30731
mov AX False
cmp AX 1
$jmp 30741 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_code_28539+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_code_28539+7>.append
jmp 30741        ;¸õ¦Ü©³³¡
mov AX <parse_code_28539+7>
jmp 30743         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_code_28539" "0,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33"
pop ip
Function <&package_6+7> 30748 None "next_element_30748" 9
jmp 30917           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 30756 "!="
tf <esp+2> "in" "codeline"
$jmp 30758 "t"
mov <esp+2>["codeline"] None
jmp 30758
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 30764 "!="
tf <esp+2> "in" "k"
$jmp 30766 "t"
mov <esp+2>["k"] None
jmp 30766
mov <esp+2>["k"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 30772 "!="
tf <esp+2> "in" "elements"
$jmp 30774 "t"
mov <esp+2>["elements"] None
jmp 30774
mov <esp+2>["elements"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 30780 "!="
tf <esp+2> "in" "end"
$jmp 30782 "t"
mov <esp+2>["end"] False
jmp 30782
mov <esp+2>["end"] <esp+1>[3]
dec CX
cmp CX 0
$jmp 30788 "!="
tf <esp+2> "in" "stop"
$jmp 30790 "t"
mov <esp+2>["stop"] (0)
jmp 30790
mov <esp+2>["stop"] <esp+1>[4]
dec CX
mov <next_element_30748+1> <esp+2>["codeline"]
mov <next_element_30748+2> <esp+2>["k"]
mov <next_element_30748+3> <esp+2>["elements"]
mov <next_element_30748+4> <esp+2>["end"]
mov <next_element_30748+5> <esp+2>["stop"]


push 0
mov <next_element_30748+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_element_30748+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <next_element_30748+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_element_30748+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call list
push AX
mov <next_element_30748+3> <esp+1>
inc esp
mov DX <next_element_30748+2>
cmp DX <next_element_30748+7>
$jmp 30825 ">="
mov AX True
jmp 30826
mov AX False
cmp AX 1
$jmp 30906 "!="
push <next_element_30748+1>
mov BX <next_element_30748+2>
pop AX
push AX[BX]
mov <next_element_30748+8> <esp+1>
inc esp
mov DX <next_element_30748+6>
tf DX "equ" 0
$jmp 30839 "f"
mov AX True
jmp 30840
mov AX False
cmp AX 1
$jmp 30863 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <next_element_30748+3> "in" <next_element_30748+8>
mov AX TF
cmp AX 1
$jmp 30849 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30748+2>
jmp 30914         ;returnÂI
jmp 30862        ;¸õ¦Ü©³³¡
tf <next_element_30748+5> "in" <next_element_30748+8>
mov AX TF
cmp AX 1
$jmp 30862 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
cmp <next_element_30748+4> 1
$jmp 30858 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30748+2>
jmp 30914         ;returnÂI
jmp 30858        ;¸õ¦Ü©³³¡
mov AX 1
$oper AX "-"
jmp 30914         ;returnÂI
jmp 30862        ;¸õ¦Ü©³³¡
jmp 30863        ;¸õ¦Ü©³³¡
mov DX <next_element_30748+6>
cmp DX 0
$jmp 30868 ">="
mov AX True
jmp 30869
mov AX False
cmp AX 1
$jmp 30874 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30748+2>
jmp 30914         ;returnÂI
jmp 30874        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] "("
mov <esp+1>[1] "["
mov <esp+1>[2] "{"
mov BX <next_element_30748+8>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30888 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <next_element_30748+6> "+" <esp+1>
inc esp
jmp 30902        ;¸õ¦Ü©³³¡
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
mov BX <next_element_30748+8>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 30902 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <next_element_30748+6> "-" <esp+1>
inc esp
jmp 30902        ;¸õ¦Ü©³³¡
push 1
$mov <next_element_30748+2> "+" <esp+1>
inc esp
jmp 30820               ;continue­«¨Ó
cmp <next_element_30748+4> 1
$jmp 30911 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <next_element_30748+7>
jmp 30914         ;returnÂI
jmp 30911        ;¸õ¦Ü©³³¡
mov AX 1
$oper AX "-"
jmp 30914         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "next_element_30748" "0,1,2,3,4,5,6,7,8"
pop ip
Function <&package_6+8> 30919 None "get_var_30919" 21
jmp 32064           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 30927 "!="
tf <esp+2> "in" "codeline"
$jmp 30929 "t"
mov <esp+2>["codeline"] None
jmp 30929
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 30935 "!="
tf <esp+2> "in" "k"
$jmp 30937 "t"
mov <esp+2>["k"] None
jmp 30937
mov <esp+2>["k"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 30943 "!="
tf <esp+2> "in" "namespace"
$jmp 30945 "t"
mov <esp+2>["namespace"] None
jmp 30945
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
mov <get_var_30919+1> <esp+2>["codeline"]
mov <get_var_30919+2> <esp+2>["k"]
mov <get_var_30919+3> <esp+2>["namespace"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <get_var_30919+4> <esp+1>
inc esp
mov DX <get_var_30919+2>
tf DX "equ" <get_var_30919+4>
$jmp 30965 "f"
mov AX True
jmp 30966
mov AX False
cmp AX 1
$jmp 30976 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] None
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
pop AX
jmp 32061
jmp 30976        ;¸õ¦Ü©³³¡
push <get_var_30919+2>
mov <get_var_30919+5> <esp+1>
inc esp
push 1
$mov <get_var_30919+2> "+" <esp+1>
inc esp
push (2)
mov <esp+1>[0] "["
mov <esp+1>[1] "("
mov <get_var_30919+6> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "]"
mov <esp+1>[1] ")"
mov <get_var_30919+7> <esp+1>
inc esp
mov DX <get_var_30919+2>
cmp DX <get_var_30919+4>
$jmp 30997 ">="
mov AX True
jmp 30998
mov AX False
cmp AX 1
$jmp 31025 "!="
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
tf <get_var_30919+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 31020 "=="
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 31015 "f"
mov AX True
jmp 31016
mov AX False
cmp AX 1
$jmp 31020 "=="
mov AX 0
jmp 31021
mov AX 1
cmp AX 1
$jmp 31025 "!="
mov AX 1
jmp 31026
mov AX 0
cmp AX 1
$jmp 31105 "!="
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
tf <get_var_30919+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 31089 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <get_var_30919+8> <esp+1>
inc esp
push 1
$mov <get_var_30919+2> "+" <esp+1>
inc esp
mov DX <get_var_30919+2>
cmp DX <get_var_30919+4>
$jmp 31046 ">="
mov AX True
jmp 31047
mov AX False
cmp AX 1
$jmp 31059 "!="
mov DX <get_var_30919+8>
cmp DX 0
$jmp 31054 "<="
mov AX True
jmp 31055
mov AX False
cmp AX 1
$jmp 31059 "!="
mov AX 1
jmp 31060
mov AX 0
cmp AX 1
$jmp 31088 "!="
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
tf <get_var_30919+6> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 31073 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <get_var_30919+8> "+" <esp+1>
inc esp
jmp 31084        ;¸õ¦Ü©³³¡
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
tf <get_var_30919+7> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 31084 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <get_var_30919+8> "-" <esp+1>
inc esp
jmp 31084        ;¸õ¦Ü©³³¡
push 1
$mov <get_var_30919+2> "+" <esp+1>
inc esp
jmp 31041               ;continue­«¨Ó
jmp 31104        ;¸õ¦Ü©³³¡
push <get_var_30919+1>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 31097 "f"
mov AX True
jmp 31098
mov AX False
cmp AX 1
$jmp 31104 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2
$mov <get_var_30919+2> "+" <esp+1>
inc esp
jmp 31104        ;¸õ¦Ü©³³¡
jmp 30992               ;continue­«¨Ó
push <get_var_30919+1>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <get_var_30919+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 31130 "f"
mov AX True
jmp 31131
mov AX False
cmp AX 1
$jmp 31178 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 31148 "f"
mov AX True
jmp 31149
mov AX False
cmp AX 1
$jmp 31169 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30919+2>
pop AX
jmp 32061
jmp 31177        ;¸õ¦Ü©³³¡
push (2)
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+2>
pop AX
jmp 32061
jmp 32060        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 31193 "f"
mov AX True
jmp 31194
mov AX False
cmp AX 1
$jmp 31210 "!="
push <get_var_30919+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.name
tf DX "equ" "$str"
$jmp 31205 "f"
mov AX True
jmp 31206
mov AX False
cmp AX 1
$jmp 31210 "!="
mov AX 1
jmp 31211
mov AX 0
cmp AX 1
$jmp 31249 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+10> <esp+1>
inc esp
push (2)
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+10>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+59>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30919+2>
pop AX
jmp 32061
jmp 32060        ;¸õ¦Ü©³³¡
push <get_var_30919+9>
mov BX 1
pop AX
tf "([." "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 32060 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
mov <get_var_30919+11> <esp+1>
inc esp
push 1
mov <get_var_30919+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 31277 "f"
mov AX True
jmp 31278
mov AX False
cmp AX 1
$jmp 31299 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
mov BX 0
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
push <get_var_30919+9>
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 31299        ;¸õ¦Ü©³³¡
push $importer["time"]
mov <get_var_30919+12> <esp+1>.time
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+12>
push AX
oper <esp+1> "+" 1
mov <get_var_30919+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 1
$jmp 31324 "<="
mov AX True
jmp 31325
mov AX False
cmp AX 1
$jmp 32051 "!="
push <get_var_30919+9>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 31335 "f"
mov AX True
jmp 31336
mov AX False
cmp AX 1
$jmp 31691 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <get_var_30919+14> <esp+1>
inc esp
push [0]
mov <get_var_30919+15> <esp+1>
inc esp
push None
mov <get_var_30919+16> <esp+1>
inc esp
push [0]
mov <get_var_30919+17> <esp+1>
inc esp
push <get_var_30919+9>
push <get_var_30919+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" ")"
$jmp 31360 "t"
mov AX True
jmp 31361
mov AX False
cmp AX 1
$jmp 31642 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 31376 ">="
mov AX True
jmp 31377
mov AX False
cmp AX 1
$jmp 31641 "!="
push <get_var_30919+9>
push <get_var_30919+2>
oper <esp+1> "+" 2
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 31389 "f"
mov AX True
jmp 31390
mov AX False
cmp AX 1
$jmp 31453 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
oper <esp+1> "+" 3
mov <get_var_30919+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+9>
mov <esp+1>[1] <get_var_30919+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30919+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push 1        ;Àx¦sCX
push [1]
push <get_var_30919+9>
push <get_var_30919+5>
oper <esp+1> "-" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
mov <esp+1>[0] AX
mov <esp+1>[1] <get_var_30919+18>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+15>.append
jmp 31627        ;¸õ¦Ü©³³¡
push <get_var_30919+9>
push <get_var_30919+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 31463 "f"
mov AX True
jmp 31464
mov AX False
cmp AX 1
$jmp 31528 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
oper <esp+1> "+" 2
mov <get_var_30919+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+9>
mov <esp+1>[1] <get_var_30919+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30919+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+18> <esp+1>
inc esp
mov DX <get_var_30919+16>
tf DX "equ" None
$jmp 31508 "f"
mov AX True
jmp 31509
mov AX False
cmp AX 1
$jmp 31515 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+18>
mov <get_var_30919+16> <esp+1>
inc esp
jmp 31527        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+16>
mov <esp+1>[1] <get_var_30919+18>
mov <esp+1>[2] "+"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+53>
push AX
mov <get_var_30919+16> <esp+1>
inc esp
jmp 31627        ;¸õ¦Ü©³³¡
push <get_var_30919+9>
push <get_var_30919+2>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "**"
$jmp 31538 "f"
mov AX True
jmp 31539
mov AX False
cmp AX 1
$jmp 31583 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
oper <esp+1> "+" 2
mov <get_var_30919+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+9>
mov <esp+1>[1] <get_var_30919+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30919+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+17>.append
jmp 31627        ;¸õ¦Ü©³³¡
push <get_var_30919+2>
oper <esp+1> "+" 1
mov <get_var_30919+5> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+9>
mov <esp+1>[1] <get_var_30919+5>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30919+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+18> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+14>.append
push <get_var_30919+9>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" ")"
$jmp 31635 "f"
mov AX True
jmp 31636
mov AX False
cmp AX 1
$jmp 31640 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 31641          ;break¥X
jmp 31640        ;¸õ¦Ü©³³¡
jmp 31363               ;continue­«¨Ó
jmp 31645        ;¸õ¦Ü©³³¡
push 1
$mov <get_var_30919+2> "+" <esp+1>
inc esp
push [1]
push 5        ;Àx¦sCX
push [5]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+28>
mov <esp+1>[1] AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+30>
mov <esp+1>[2] AX
mov <esp+1>[3] <get_var_30919+16>
mov <esp+1>[4] <get_var_30919+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+35>
mov <esp+1>[0] AX
push <get_var_30919+9>
push [3]
push <get_var_30919+2>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30919+9> <esp+1>
inc esp
jmp 32024        ;¸õ¦Ü©³³¡
push <get_var_30919+9>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" "["
$jmp 31699 "f"
mov AX True
jmp 31700
mov AX False
cmp AX 1
$jmp 31977 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_var_30919+2>
oper <esp+1> "+" 1
mov <get_var_30919+5> <esp+1>
inc esp
push [0]
mov <get_var_30919+19> <esp+1>
inc esp
cmp True 1
$jmp 31873 "!="
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <get_var_30919+9>
mov <esp+1>[1] <get_var_30919+5>
mov <esp+1>[2] ":]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <get_var_30919+2> <esp+1>
inc esp
push <get_var_30919+9>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 31731 "f"
mov AX True
jmp 31732
mov AX False
cmp AX 1
$jmp 31786 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <get_var_30919+2>
tf DX "equ" <get_var_30919+5>
$jmp 31739 "f"
mov AX True
jmp 31740
mov AX False
cmp AX 1
$jmp 31753 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
mov <get_var_30919+18> <esp+1>
inc esp
jmp 31774        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+18> <esp+1>
inc esp
push <get_var_30919+2>
oper <esp+1> "+" 1
mov <get_var_30919+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+19>.append
jmp 31872        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 31798 "f"
mov AX True
jmp 31799
mov AX False
cmp AX 1
$jmp 31823 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <get_var_30919+19> <esp+1>
inc esp
jmp 31871        ;¸õ¦Ü©³³¡
mov DX <get_var_30919+2>
tf DX "equ" <get_var_30919+5>
$jmp 31828 "f"
mov AX True
jmp 31829
mov AX False
cmp AX 1
$jmp 31846 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+19>.append
jmp 31871        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
push [3]
mov <esp+1>[0] <get_var_30919+5>
mov <esp+1>[1] <get_var_30919+2>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+19>.append
jmp 31873          ;break¥X
jmp 31709               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" list
$jmp 31885 "f"
mov AX True
jmp 31886
mov AX False
cmp AX 1
$jmp 31948 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 3
$jmp 31900 ">="
mov AX True
jmp 31901
mov AX False
cmp AX 1
$jmp 31926 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
mov <esp+1>[0] AX
push 3
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_var_30919+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
oper <esp+1> "-" AX
pop AX
oper <esp+1> "*" AX
$mov <get_var_30919+19> "+" <esp+1>
inc esp
jmp 31926        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <get_var_30919+19>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push <get_var_30919+19>
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
push <get_var_30919+19>
mov BX 2
pop AX
mov <esp+1>[2] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+26>
push AX
mov <get_var_30919+19> <esp+1>
inc esp
jmp 31948        ;¸õ¦Ü©³³¡
push [1]
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+27>
mov <esp+1>[0] AX
push <get_var_30919+9>
push [3]
push <get_var_30919+2>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30919+9> <esp+1>
inc esp
jmp 32024        ;¸õ¦Ü©³³¡
push <get_var_30919+9>
mov BX <get_var_30919+2>
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 31985 "f"
mov AX True
jmp 31986
mov AX False
cmp AX 1
$jmp 32024 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
push <get_var_30919+9>
mov BX 2
pop AX
mov <esp+1>[1] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+25>
push AX
mov <get_var_30919+20> <esp+1>
inc esp
push [1]
mov <esp+1>[0] <get_var_30919+20>
push <get_var_30919+9>
push [3]
mov <esp+1>[0] 3
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <get_var_30919+9> <esp+1>
inc esp
push 1
$mov <get_var_30919+2> "-" <esp+1>
inc esp
jmp 32024        ;¸õ¦Ü©³³¡
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_var_30919+12>
mov DX AX
cmp DX <get_var_30919+13>
$jmp 32035 "<="
mov AX True
jmp 32036
mov AX False
cmp AX 1
$jmp 32047 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "335 get error"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 32047        ;¸õ¦Ü©³³¡
push 1
mov <get_var_30919+2> <esp+1>
inc esp
jmp 31312               ;continue­«¨Ó
push (2)
push <get_var_30919+9>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <get_var_30919+11>
pop AX
jmp 32061
jmp 32060        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_var_30919" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20"
pop ip
Function <&package_6+9> 32066 None "next_codeline_32066" 6
jmp 32153           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 32074 "!="
tf <esp+2> "in" "codelines"
$jmp 32076 "t"
mov <esp+2>["codelines"] None
jmp 32076
mov <esp+2>["codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 32082 "!="
tf <esp+2> "in" "row"
$jmp 32084 "t"
mov <esp+2>["row"] None
jmp 32084
mov <esp+2>["row"] <esp+1>[1]
dec CX
mov <next_codeline_32066+1> <esp+2>["codelines"]
mov <next_codeline_32066+2> <esp+2>["row"]


push <next_codeline_32066+1>
mov BX <next_codeline_32066+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <next_codeline_32066+3> <esp+1>
inc esp
push <next_codeline_32066+3>
oper <esp+1> "+" 1
mov <next_codeline_32066+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <next_codeline_32066+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <next_codeline_32066+5> <esp+1>
inc esp
mov DX <next_codeline_32066+4>
cmp DX <next_codeline_32066+3>
$jmp 32119 "<="
mov AX True
jmp 32120
mov AX False
cmp AX 1
$jmp 32148 "!="
push 1
$mov <next_codeline_32066+2> "+" <esp+1>
inc esp
mov DX <next_codeline_32066+2>
tf DX "equ" <next_codeline_32066+5>
$jmp 32130 "f"
mov AX True
jmp 32131
mov AX False
cmp AX 1
$jmp 32135 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 32148          ;break¥X
jmp 32135        ;¸õ¦Ü©³³¡
push <next_codeline_32066+1>
mov BX <next_codeline_32066+2>
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov BX 0
pop AX
push AX[BX]
mov <next_codeline_32066+4> <esp+1>
inc esp
jmp 32114               ;continue­«¨Ó
mov AX <next_codeline_32066+2>
jmp 32150         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "next_codeline_32066" "0,1,2,3,4,5"
pop ip
Function <&package_6+10> 32155 None "parse_codeline_32155" 38
jmp 34885           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 32163 "!="
tf <esp+2> "in" "codeline"
$jmp 32165 "t"
mov <esp+2>["codeline"] None
jmp 32165
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 32171 "!="
tf <esp+2> "in" "namespace"
$jmp 32173 "t"
mov <esp+2>["namespace"] None
jmp 32173
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 32179 "!="
tf <esp+2> "in" "is_list"
$jmp 32181 "t"
mov <esp+2>["is_list"] False
jmp 32181
mov <esp+2>["is_list"] <esp+1>[2]
dec CX
mov <parse_codeline_32155+1> <esp+2>["codeline"]
mov <parse_codeline_32155+2> <esp+2>["namespace"]
mov <parse_codeline_32155+3> <esp+2>["is_list"]


push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32202 ">="
mov AX True
jmp 32203
mov AX False
cmp AX 1
$jmp 32466 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
mov DX <parse_codeline_32155+5>
tf DX "equ" "lambda"
$jmp 32216 "f"
mov AX True
jmp 32217
mov AX False
cmp AX 1
$jmp 32462 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+4>
mov <parse_codeline_32155+6> <esp+1>
inc esp
push [dict]
mov <parse_codeline_32155+7> <esp+1>
inc esp
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_32155+8> <esp+1>
inc esp
mov DX <parse_codeline_32155+4>
cmp DX <parse_codeline_32155+8>
$jmp 32243 ">="
mov AX True
jmp 32244
mov AX False
cmp AX 1
$jmp 32377 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 32264 "f"
mov AX True
jmp 32265
mov AX False
cmp AX 1
$jmp 32363 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
push <parse_codeline_32155+7>
mov BX <parse_codeline_32155+5>.name
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_codeline_32155+8>
$jmp 32287 ">="
mov AX True
jmp 32288
mov AX False
cmp AX 1
$jmp 32305 "!="
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 32300 "f"
mov AX True
jmp 32301
mov AX False
cmp AX 1
$jmp 32305 "!="
mov AX 1
jmp 32306
mov AX 0
cmp AX 1
$jmp 32362 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+4>
oper <esp+1> "+" 2
mov <parse_codeline_32155+9> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+9>
mov <esp+1>[2] ",:"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+9>
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
push <parse_codeline_32155+7>
mov BX <parse_codeline_32155+5>.name
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 32356 "f"
mov AX True
jmp 32357
mov AX False
cmp AX 1
$jmp 32361 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 32377          ;break¥X
jmp 32361        ;¸õ¦Ü©³³¡
jmp 32362        ;¸õ¦Ü©³³¡
jmp 32363        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+5>
tf DX "equ" ":"
$jmp 32368 "f"
mov AX True
jmp 32369
mov AX False
cmp AX 1
$jmp 32373 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 32377          ;break¥X
jmp 32373        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 32238               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+4>
push (2)
mov <esp+1>[0] ","
mov <esp+1>[1] ")"
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+11> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+7>
mov <esp+1>[1] <parse_codeline_32155+11>
mov <esp+1>[2] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+33>
push AX
mov <parse_codeline_32155+12> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_32155+6>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+12>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+10>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
jmp 32462        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 32189               ;continue­«¨Ó
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32482 ">="
mov AX True
jmp 32483
mov AX False
cmp AX 1
$jmp 32887 "!="
mov DX <parse_codeline_32155+4>
tf DX "equ" 0
$jmp 32490 "f"
mov AX True
jmp 32491
mov AX False
cmp AX 1
$jmp 32536 "=="
push 1        ;Àx¦sCX
push [1]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32510 "f"
mov AX True
jmp 32511
mov AX False
cmp AX 1
$jmp 32531 "!="
push (3)
mov <esp+1>[0] ")"
mov <esp+1>[1] "]"
mov <esp+1>[2] "}"
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 32531 "!="
mov AX 1
jmp 32532
mov AX 0
cmp AX 1
$jmp 32536 "=="
mov AX 0
jmp 32537
mov AX 1
cmp AX 1
$jmp 32883 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+13> <esp+1>
inc esp
mov DX <parse_codeline_32155+13>
tf DX "equ" "("
$jmp 32550 "f"
mov AX True
jmp 32551
mov AX False
cmp AX 1
$jmp 32621 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
jmp 32882        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+13>
tf DX "equ" "["
$jmp 32626 "f"
mov AX True
jmp 32627
mov AX False
cmp AX 1
$jmp 32700 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
jmp 32882        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+13>
tf DX "equ" "{"
$jmp 32705 "f"
mov AX True
jmp 32706
mov AX False
cmp AX 1
$jmp 32882 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
push [1]
mov <esp+1>[0] "}"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+10> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+10>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+15> <esp+1>
inc esp
push <parse_codeline_32155+15>.elements
mov <parse_codeline_32155+16> <esp+1>
inc esp
tf <parse_codeline_32155+16> "in" ":"
mov AX TF
cmp AX 1
$jmp 32774 "=="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 32769 "f"
mov AX True
jmp 32770
mov AX False
cmp AX 1
$jmp 32774 "=="
mov AX 0
jmp 32775
mov AX 1
cmp AX 1
$jmp 32841 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_codeline_32155+17> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_32155+8> <esp+1>
inc esp
mov DX <parse_codeline_32155+9>
cmp DX <parse_codeline_32155+8>
$jmp 32798 ">="
mov AX True
jmp 32799
mov AX False
cmp AX 1
$jmp 32830 "!="
push <parse_codeline_32155+16>
mov BX <parse_codeline_32155+9>
pop AX
push AX[BX]
mov <parse_codeline_32155+18> <esp+1>
inc esp
push 2
$mov <parse_codeline_32155+9> "+" <esp+1>
inc esp
push <parse_codeline_32155+16>
mov BX <parse_codeline_32155+9>
pop AX
push AX[BX]
mov <parse_codeline_32155+19> <esp+1>
inc esp
push 1
$mov <parse_codeline_32155+9> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <parse_codeline_32155+18>
mov <esp+1>[1] <parse_codeline_32155+19>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+17>.append
jmp 32793               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+30>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
jmp 32851        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+31>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+10>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
jmp 32882        ;¸õ¦Ü©³³¡
jmp 32883        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 32469               ;continue­«¨Ó
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 32903 ">="
mov AX True
jmp 32904
mov AX False
cmp AX 1
$jmp 33060 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32924 "f"
mov AX True
jmp 32925
mov AX False
cmp AX 1
$jmp 32938 "!="
push (2)
mov <esp+1>[0] "break"
mov <esp+1>[1] "continue"
mov BX <parse_codeline_32155+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 32938 "!="
mov AX 1
jmp 32939
mov AX 0
cmp AX 1
$jmp 32950 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+47>
jmp 34882         ;returnÂI
jmp 33056        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 32962 "f"
mov AX True
jmp 32963
mov AX False
cmp AX 1
$jmp 32975 "!="
mov DX <parse_codeline_32155+5>
tf DX "equ" "pass"
$jmp 32970 "f"
mov AX True
jmp 32971
mov AX False
cmp AX 1
$jmp 32975 "!="
mov AX 1
jmp 32976
mov AX 0
cmp AX 1
$jmp 32986 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+48>
jmp 34882         ;returnÂI
jmp 33056        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_codeline_32155+20> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+8>
push AX
mov <parse_codeline_32155+21> <esp+1>[0]
mov <parse_codeline_32155+10> <esp+1>[1]
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <parse_codeline_32155+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+21>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+10>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX <parse_codeline_32155+20>
$jmp 33049 ">="
mov AX True
jmp 33050
mov AX False
cmp AX 1
$jmp 33056 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_codeline_32155+4> "-" <esp+1>
inc esp
jmp 33056        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 32890               ;continue­«¨Ó
Function <parse_codeline_32155+22> 33062 None "deal_single_operator_33062" 7 "parse_codeline_32155"
jmp 33338           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 33070 "!="
tf <esp+2> "in" "codeline"
$jmp 33072 "t"
mov <esp+2>["codeline"] None
jmp 33072
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 33078 "!="
tf <esp+2> "in" "op_box"
$jmp 33080 "t"
mov <esp+2>["op_box"] None
jmp 33080
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 33086 "!="
tf <esp+2> "in" "operator"
$jmp 33088 "t"
mov <esp+2>["operator"] None
jmp 33088
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_single_operator_33062+1> <esp+2>["codeline"]
mov <deal_single_operator_33062+2> <esp+2>["op_box"]
mov <deal_single_operator_33062+3> <esp+2>["operator"]


push 0
mov <deal_single_operator_33062+4> <esp+1>
inc esp
push <deal_single_operator_33062+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_single_operator_33062+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33109 ">="
mov AX True
jmp 33110
mov AX False
cmp AX 1
$jmp 33333 "!="
push <deal_single_operator_33062+1>
mov BX <deal_single_operator_33062+4>
pop AX
push AX[BX]
mov <deal_single_operator_33062+5> <esp+1>
inc esp
tf <deal_single_operator_33062+2> "in" <deal_single_operator_33062+5>
mov AX TF
cmp AX 1
$jmp 33144 "!="
push 1        ;Àx¦sCX
push [1]
push <deal_single_operator_33062+1>
push <deal_single_operator_33062+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 33139 "t"
mov AX True
jmp 33140
mov AX False
cmp AX 1
$jmp 33144 "!="
mov AX 1
jmp 33145
mov AX 0
cmp AX 1
$jmp 33329 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
mov BX <deal_single_operator_33062+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 33277 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_single_operator_33062+4>
tf DX "equ" 0
$jmp 33161 "f"
mov AX True
jmp 33162
mov AX False
cmp AX 1
$jmp 33186 "=="
push 1        ;Àx¦sCX
push [1]
push <deal_single_operator_33062+1>
push <deal_single_operator_33062+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 33181 "f"
mov AX True
jmp 33182
mov AX False
cmp AX 1
$jmp 33186 "=="
mov AX 0
jmp 33187
mov AX 1
cmp AX 1
$jmp 33276 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_single_operator_33062+5>
tf DX "equ" "-"
$jmp 33194 "f"
mov AX True
jmp 33195
mov AX False
cmp AX 1
$jmp 33249 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_33062+1>
push <deal_single_operator_33062+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <deal_single_operator_33062+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_33062+3>
push AX
mov <deal_single_operator_33062+6> <esp+1>
inc esp
push <deal_single_operator_33062+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_33062+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_33062+6>
pop AX
oper <esp+1> "+" AX
push <deal_single_operator_33062+1>
push [3]
push <deal_single_operator_33062+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_33062+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_33062+4> <esp+1>
inc esp
jmp 33275        ;¸õ¦Ü©³³¡
push <deal_single_operator_33062+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_33062+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <deal_single_operator_33062+1>
push [3]
push <deal_single_operator_33062+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_33062+1> <esp+1>
inc esp
jmp 33276        ;¸õ¦Ü©³³¡
jmp 33328        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_33062+1>
push <deal_single_operator_33062+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <deal_single_operator_33062+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_33062+3>
push AX
mov <deal_single_operator_33062+6> <esp+1>
inc esp
push <deal_single_operator_33062+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_33062+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_33062+6>
pop AX
oper <esp+1> "+" AX
push <deal_single_operator_33062+1>
push [3]
push <deal_single_operator_33062+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_single_operator_33062+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_33062+4> <esp+1>
inc esp
jmp 33329        ;¸õ¦Ü©³³¡
push 1
$mov <deal_single_operator_33062+4> "+" <esp+1>
inc esp
jmp 33096               ;continue­«¨Ó
mov AX <deal_single_operator_33062+1>
jmp 33335         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_single_operator_33062" "0,1,2,3,4,5,6"
pop ip
Function <parse_codeline_32155+23> 33340 None "deal_single_operator_all_33340" 8 "parse_codeline_32155"
jmp 33466           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 33348 "!="
tf <esp+2> "in" "codeline"
$jmp 33350 "t"
mov <esp+2>["codeline"] None
jmp 33350
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 33356 "!="
tf <esp+2> "in" "op_box"
$jmp 33358 "t"
mov <esp+2>["op_box"] None
jmp 33358
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 33364 "!="
tf <esp+2> "in" "operator"
$jmp 33366 "t"
mov <esp+2>["operator"] None
jmp 33366
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_single_operator_all_33340+1> <esp+2>["codeline"]
mov <deal_single_operator_all_33340+2> <esp+2>["op_box"]
mov <deal_single_operator_all_33340+3> <esp+2>["operator"]


push 0
mov <deal_single_operator_all_33340+4> <esp+1>
inc esp
push <deal_single_operator_all_33340+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_single_operator_all_33340+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33387 ">="
mov AX True
jmp 33388
mov AX False
cmp AX 1
$jmp 33461 "!="
push <deal_single_operator_all_33340+1>
mov BX <deal_single_operator_all_33340+4>
pop AX
push AX[BX]
mov <deal_single_operator_all_33340+5> <esp+1>
inc esp
tf <deal_single_operator_all_33340+2> "in" <deal_single_operator_all_33340+5>
mov AX TF
cmp AX 1
$jmp 33457 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <deal_single_operator_all_33340+1>
push [3]
push <deal_single_operator_all_33340+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <deal_single_operator_all_33340+6> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <deal_single_operator_all_33340+6>
mov <esp+1>[1] <deal_single_operator_all_33340+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_single_operator_all_33340+3>
push AX
mov <deal_single_operator_all_33340+7> <esp+1>
inc esp
push <deal_single_operator_all_33340+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <deal_single_operator_all_33340+4>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_single_operator_all_33340+7>
pop AX
oper <esp+1> "+" AX
mov <deal_single_operator_all_33340+1> <esp+1>
inc esp
mov AX 1
$oper AX "-"
push AX
mov <deal_single_operator_all_33340+4> <esp+1>
inc esp
jmp 33457        ;¸õ¦Ü©³³¡
push 1
$mov <deal_single_operator_all_33340+4> "+" <esp+1>
inc esp
jmp 33374               ;continue­«¨Ó
mov AX <deal_single_operator_all_33340+1>
jmp 33463         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_single_operator_all_33340" "0,1,2,3,4,5,6,7"
pop ip
Function <parse_codeline_32155+24> 33468 None "deal_operator_33468" 7 "parse_codeline_32155"
jmp 33604           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 33476 "!="
tf <esp+2> "in" "codeline"
$jmp 33478 "t"
mov <esp+2>["codeline"] None
jmp 33478
mov <esp+2>["codeline"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 33484 "!="
tf <esp+2> "in" "op_box"
$jmp 33486 "t"
mov <esp+2>["op_box"] None
jmp 33486
mov <esp+2>["op_box"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 33492 "!="
tf <esp+2> "in" "operator"
$jmp 33494 "t"
mov <esp+2>["operator"] None
jmp 33494
mov <esp+2>["operator"] <esp+1>[2]
dec CX
mov <deal_operator_33468+1> <esp+2>["codeline"]
mov <deal_operator_33468+2> <esp+2>["op_box"]
mov <deal_operator_33468+3> <esp+2>["operator"]


push 0
mov <deal_operator_33468+4> <esp+1>
inc esp
push <deal_operator_33468+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_operator_33468+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33515 ">="
mov AX True
jmp 33516
mov AX False
cmp AX 1
$jmp 33599 "!="
push <deal_operator_33468+1>
mov BX <deal_operator_33468+4>
pop AX
push AX[BX]
mov <deal_operator_33468+5> <esp+1>
inc esp
tf <deal_operator_33468+2> "in" <deal_operator_33468+5>
mov AX TF
cmp AX 1
$jmp 33595 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <deal_operator_33468+4>
cmp DX 0
$jmp 33533 "<="
mov AX True
jmp 33534
mov AX False
cmp AX 1
$jmp 33594 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
push <deal_operator_33468+1>
push <deal_operator_33468+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <deal_operator_33468+1>
push <deal_operator_33468+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <deal_operator_33468+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <deal_operator_33468+3>
push AX
mov <deal_operator_33468+6> <esp+1>
inc esp
push <deal_operator_33468+1>
push [3]
mov <esp+1>[0] None
push <deal_operator_33468+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <deal_operator_33468+6>
pop AX
oper <esp+1> "+" AX
push <deal_operator_33468+1>
push [3]
push <deal_operator_33468+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <deal_operator_33468+1> <esp+1>
inc esp
push 1
$mov <deal_operator_33468+4> "-" <esp+1>
inc esp
jmp 33594        ;¸õ¦Ü©³³¡
jmp 33595        ;¸õ¦Ü©³³¡
push 1
$mov <deal_operator_33468+4> "+" <esp+1>
inc esp
jmp 33502               ;continue­«¨Ó
mov AX <deal_operator_33468+1>
jmp 33601         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_operator_33468" "0,1,2,3,4,5,6"
pop ip
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33620 ">="
mov AX True
jmp 33621
mov AX False
cmp AX 1
$jmp 33746 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
mov DX <parse_codeline_32155+5>
tf DX "equ" "**"
$jmp 33634 "f"
mov AX True
jmp 33635
mov AX False
cmp AX 1
$jmp 33742 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
push <parse_codeline_32155+4>
mov <parse_codeline_32155+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" str
$jmp 33658 "f"
mov AX True
jmp 33659
mov AX False
cmp AX 1
$jmp 33665 "!="
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 33643               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+9>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+25> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_32155+1>
push <parse_codeline_32155+9>
oper <esp+1> "-" 2
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+25>
mov <esp+1>[2] "**"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+53>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+9>
oper <esp+1> "-" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push <parse_codeline_32155+9>
oper <esp+1> "-" 2
mov <parse_codeline_32155+4> <esp+1>
inc esp
jmp 33742        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 33607               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] "~"
mov <esp+1>[1] "-"
mov <esp+1>[2] "+"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+56>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+22>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (4)
mov <esp+1>[0] "*"
mov <esp+1>[1] "/"
mov <esp+1>[2] "%"
mov <esp+1>[3] "//"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (2)
mov <esp+1>[0] "+"
mov <esp+1>[1] "-"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (2)
mov <esp+1>[0] "<<"
mov <esp+1>[1] ">>"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [1]
mov <esp+1>[0] "&"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [1]
mov <esp+1>[0] "^"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [1]
mov <esp+1>[0] "|"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+53>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33867 ">="
mov AX True
jmp 33868
mov AX False
cmp AX 1
$jmp 34001 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
push (6)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
mov <esp+1>[2] ">"
mov <esp+1>[3] "<"
mov <esp+1>[4] ">="
mov <esp+1>[5] "<="
mov BX <parse_codeline_32155+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 33997 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
mov <parse_codeline_32155+26> <esp+1>
inc esp
push <parse_codeline_32155+4>
mov <parse_codeline_32155+9> <esp+1>
inc esp
push (6)
mov <esp+1>[0] "=="
mov <esp+1>[1] "!="
mov <esp+1>[2] ">"
mov <esp+1>[3] "<"
mov <esp+1>[4] ">="
mov <esp+1>[5] "<="
mov BX <parse_codeline_32155+5>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 33952 "!="
push [2]
mov <esp+1>[0] <parse_codeline_32155+5>
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
$mov <parse_codeline_32155+26> "+" <esp+1>
inc esp
push 2
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 33940 ">="
mov AX True
jmp 33941
mov AX False
cmp AX 1
$jmp 33950 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
jmp 33951        ;¸õ¦Ü©³³¡
jmp 33952          ;break¥X
jmp 33901               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+57>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+9>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+4>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push <parse_codeline_32155+9>
oper <esp+1> "-" 1
mov <parse_codeline_32155+4> <esp+1>
inc esp
jmp 33997        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 33854               ;continue­«¨Ó
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 34017 ">="
mov AX True
jmp 34018
mov AX False
cmp AX 1
$jmp 34361 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
mov DX <parse_codeline_32155+5>
tf DX "equ" "for"
$jmp 34031 "f"
mov AX True
jmp 34032
mov AX False
cmp AX 1
$jmp 34052 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+4>
push [1]
mov <esp+1>[0] "in"
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+4> <esp+1>
inc esp
jmp 34357        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+5>
tf DX "equ" "in"
$jmp 34057 "f"
mov AX True
jmp 34058
mov AX False
cmp AX 1
$jmp 34206 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_codeline_32155+4>
cmp DX 0
$jmp 34065 "<="
mov AX True
jmp 34066
mov AX False
cmp AX 1
$jmp 34205 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "not"
$jmp 34078 "f"
mov AX True
jmp 34079
mov AX False
cmp AX 1
$jmp 34147 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 2
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
mov <esp+1>[0] AX
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+56>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+4>
oper <esp+1> "-" 2
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 2
$mov <parse_codeline_32155+4> "-" <esp+1>
inc esp
jmp 34204        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 1
$mov <parse_codeline_32155+4> "-" <esp+1>
inc esp
jmp 34205        ;¸õ¦Ü©³³¡
jmp 34357        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+5>
tf DX "equ" "is"
$jmp 34211 "f"
mov AX True
jmp 34212
mov AX False
cmp AX 1
$jmp 34357 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov DX <parse_codeline_32155+4>
cmp DX 0
$jmp 34219 "<="
mov AX True
jmp 34220
mov AX False
cmp AX 1
$jmp 34356 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "not"
$jmp 34232 "f"
mov AX True
jmp 34233
mov AX False
cmp AX 1
$jmp 34298 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 2
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
mov <esp+1>[0] AX
mov <esp+1>[1] "not"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+56>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 3
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
jmp 34352        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop BX
pop AX
mov <esp+1>[0] AX[BX]
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
mov <esp+1>[1] AX[BX]
mov <esp+1>[2] <parse_codeline_32155+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+54>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 2
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 1
$mov <parse_codeline_32155+4> "-" <esp+1>
inc esp
jmp 34356        ;¸õ¦Ü©³³¡
jmp 34357        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 34004               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [1]
mov <esp+1>[0] "not"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+56>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+22>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (2)
mov <esp+1>[0] "and"
mov <esp+1>[1] "or"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+55>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+24>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 34406 ">="
mov AX True
jmp 34407
mov AX False
cmp AX 1
$jmp 34674 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
push AX[BX]
mov <parse_codeline_32155+5> <esp+1>
inc esp
mov DX <parse_codeline_32155+5>
tf DX "equ" "if"
$jmp 34420 "f"
mov AX True
jmp 34421
mov AX False
cmp AX 1
$jmp 34552 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+4>
push [1]
mov <esp+1>[0] "else"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+27> <esp+1>
inc esp
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_32155+28> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+27>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+29> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+27>
mov <esp+1>[2] ","
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+27>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+30>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+31> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+29>
mov <esp+1>[1] <parse_codeline_32155+28>
mov <esp+1>[2] <parse_codeline_32155+31>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+42>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] None
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push [1]
mov <esp+1>[0] <parse_codeline_32155+14>
pop AX
oper <esp+1> "+" AX
push <parse_codeline_32155+1>
push [3]
mov <esp+1>[0] <parse_codeline_32155+30>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
oper <esp+1> "+" AX[BX]
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
jmp 34670        ;¸õ¦Ü©³³¡
mov DX <parse_codeline_32155+5>
tf DX "equ" "for"
$jmp 34557 "f"
mov AX True
jmp 34558
mov AX False
cmp AX 1
$jmp 34670 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
push <parse_codeline_32155+4>
oper <esp+1> "-" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_32155+32> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+4>
push [1]
mov <esp+1>[0] "in"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+33> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_codeline_32155+1>
push [3]
push <parse_codeline_32155+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_codeline_32155+33>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_codeline_32155+2>
push [dict]
mov BX "is_list"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_codeline_32155+34> <esp+1>
inc esp
push <parse_codeline_32155+1>
push <parse_codeline_32155+33>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_32155+35> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
mov <esp+1>[1] <parse_codeline_32155+33>
push [1]
mov <esp+1>[0] "if"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_codeline_32155+36> <esp+1>
inc esp
push <parse_codeline_32155+36>
mov AX 1
$oper AX "-"
pop DX
tf DX "equ" AX
$jmp 34638 "f"
mov AX True
jmp 34639
mov AX False
cmp AX 1
$jmp 34645 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push None
mov <parse_codeline_32155+37> <esp+1>
inc esp
jmp 34653        ;¸õ¦Ü©³³¡
push <parse_codeline_32155+1>
push <parse_codeline_32155+36>
oper <esp+1> "+" 1
pop BX
pop AX
push AX[BX]
mov <parse_codeline_32155+37> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_codeline_32155+32>
mov <esp+1>[1] <parse_codeline_32155+34>
mov <esp+1>[2] <parse_codeline_32155+35>
mov <esp+1>[3] <parse_codeline_32155+37>
mov <esp+1>[4] <parse_codeline_32155+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+45>
push AX
mov <parse_codeline_32155+14> <esp+1>
inc esp
mov AX <parse_codeline_32155+14>
jmp 34882         ;returnÂI
jmp 34670        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
jmp 34393               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push [1]
mov <esp+1>[0] "yield"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+22>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (2)
mov <esp+1>[0] "return"
mov <esp+1>[1] "raise"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+23>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_codeline_32155+1>
push (3)
mov <esp+1>[0] "del"
mov <esp+1>[1] "global"
mov <esp+1>[2] "nonlocal"
pop <esp+1>[1]
mov <esp+1>[2] <&package_6+37>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_codeline_32155+22>
push AX
mov <parse_codeline_32155+1> <esp+1>
inc esp
push 0
mov <parse_codeline_32155+4> <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
cmp DX AX
$jmp 34738 ">="
mov AX True
jmp 34739
mov AX False
cmp AX 1
$jmp 34791 "!="
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 34749 "f"
mov AX True
jmp 34750
mov AX False
cmp AX 1
$jmp 34757 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
mov BX <parse_codeline_32155+4>
pop AX
del 1 AX BX
jmp 34760        ;¸õ¦Ü©³³¡
push 1
$mov <parse_codeline_32155+4> "+" <esp+1>
inc esp
push <parse_codeline_32155+4>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 34776 "f"
mov AX True
jmp 34777
mov AX False
cmp AX 1
$jmp 34785 "!="
mov AX <parse_codeline_32155+3>
$oper AX "not"
cmp AX 1
$jmp 34785 "!="
mov AX 1
jmp 34786
mov AX 0
cmp AX 1
$jmp 34790 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 34791          ;break¥X
jmp 34790        ;¸õ¦Ü©³³¡
jmp 34722               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 34803 "<="
mov AX True
jmp 34804
mov AX False
cmp AX 1
$jmp 34821 "!="
push <parse_codeline_32155+1>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 34816 "f"
mov AX True
jmp 34817
mov AX False
cmp AX 1
$jmp 34821 "!="
mov AX 1
jmp 34822
mov AX 0
cmp AX 1
$jmp 34842 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
cmp <parse_codeline_32155+3> 1
$jmp 34833 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
mov AX 1
$oper AX "-"
mov BX AX
pop AX
del 1 AX BX
jmp 34841        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+29>
jmp 34882         ;returnÂI
jmp 34842        ;¸õ¦Ü©³³¡
cmp <parse_codeline_32155+3> 1
$jmp 34853 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+28>
jmp 34882         ;returnÂI
jmp 34853        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 1
$jmp 34865 "f"
mov AX True
jmp 34866
mov AX False
cmp AX 1
$jmp 34874 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_codeline_32155+1>
mov BX 0
pop AX
mov AX AX[BX]
jmp 34882         ;returnÂI
jmp 34874        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_codeline_32155+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+29>
jmp 34882         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_codeline_32155" "0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,25,26,27,28,29,30,31,32,33,34,35,36,37"
pop ip
Function <&package_6+11> 34887 None "parse_block_34887" 60
jmp 37934           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 34895 "!="
tf <esp+2> "in" "codelines"
$jmp 34897 "t"
mov <esp+2>["codelines"] None
jmp 34897
mov <esp+2>["codelines"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 34909 "!="
tf <esp+2> "in" "namespace"
$jmp 34911 "t"
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
mov <esp+2>["namespace"] AX
jmp 34911
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <parse_block_34887+1> <esp+2>["codelines"]
mov <parse_block_34887+2> <esp+2>["namespace"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+60>
push AX
mov <parse_block_34887+3> <esp+1>
inc esp
push 0
mov <parse_block_34887+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34887+5> <esp+1>
inc esp
mov DX <parse_block_34887+4>
cmp DX <parse_block_34887+5>
$jmp 34943 ">="
mov AX True
jmp 34944
mov AX False
cmp AX 1
$jmp 37929 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+4>
pop AX
push AX[BX]
mov <parse_block_34887+6> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "def"
$jmp 34960 "f"
mov AX True
jmp 34961
mov AX False
cmp AX 1
$jmp 35224 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+7> <esp+1>
inc esp
push [dict]
mov <parse_block_34887+8> <esp+1>
inc esp
push 4
mov <parse_block_34887+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34887+10> <esp+1>
inc esp
push ""
mov <parse_block_34887+11> <esp+1>
inc esp
mov DX <parse_block_34887+9>
cmp DX <parse_block_34887+10>
$jmp 34994 ">="
mov AX True
jmp 34995
mov AX False
cmp AX 1
$jmp 35129 "!="
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
push AX[BX]
mov <parse_block_34887+12> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "*"
mov <esp+1>[1] "**"
mov BX <parse_block_34887+12>
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 35028 "!="
push (2)
mov <esp+1>[0] "("
mov <esp+1>[1] ","
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "-" 1
pop BX
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 35028 "!="
mov AX 1
jmp 35029
mov AX 0
cmp AX 1
$jmp 35035 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+12>
mov <parse_block_34887+11> <esp+1>
inc esp
jmp 35125        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+12>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 35047 "f"
mov AX True
jmp 35048
mov AX False
cmp AX 1
$jmp 35125 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+11>
oper <esp+1> "+" <parse_block_34887+12>.name
mov <parse_block_34887+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] None
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+49>
push AX
push <parse_block_34887+8>
mov BX <parse_block_34887+13>
pop AX
mov AX[BX] <esp+1>
inc esp
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "="
$jmp 35077 "f"
mov AX True
jmp 35078
mov AX False
cmp AX 1
$jmp 35121 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+9>
oper <esp+1> "+" 2
mov <parse_block_34887+14> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] <parse_block_34887+14>
mov <esp+1>[2] ",)"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] <parse_block_34887+14>
mov <esp+1>[1] <parse_block_34887+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
push <parse_block_34887+8>
mov BX <parse_block_34887+13>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 35121        ;¸õ¦Ü©³³¡
push ""
mov <parse_block_34887+11> <esp+1>
inc esp
jmp 35125        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 34989               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push [dict]
push "namespace"
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34887+7>
mov <esp+1>[1] <parse_block_34887+8>
mov <esp+1>[2] <parse_block_34887+16>
mov <esp+1>[3] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+34>
push AX
mov <parse_block_34887+17> <esp+1>
inc esp
push <parse_block_34887+16>.locals
mov <parse_block_34887+17>.local_vars <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "func"
mov <esp+1>[1] <parse_block_34887+17>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+17>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "class"
$jmp 35232 "f"
mov AX True
jmp 35233
mov AX False
cmp AX 1
$jmp 35402 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+18> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX 3
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 35250 "f"
mov AX True
jmp 35251
mov AX False
cmp AX 1
$jmp 35289 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] 4
push [1]
mov <esp+1>[0] ")"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 4
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+19> <esp+1>
inc esp
jmp 35292        ;¸õ¦Ü©³³¡
push None
mov <parse_block_34887+19> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 1
$mov <&package_6+16>.class_n "+" <esp+1>
inc esp
push ""
ex_func AX "str" <parse_block_34887+18>
oper <esp+1> "+" AX
oper <esp+1> "+" "^"
ex_func AX "str" <&package_6+16>.class_n
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <parse_block_34887+20> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push [dict]
push "namespace"
push 1        ;Àx¦sCX
push [1]
push "<"
ex_func AX "str" <parse_block_34887+20>
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+23>
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34887+18>
mov <esp+1>[1] <parse_block_34887+16>
mov <esp+1>[2] <parse_block_34887+2>
mov <esp+1>[3] <parse_block_34887+20>
mov <esp+1>[4] <parse_block_34887+19>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+50>
push AX
mov <parse_block_34887+21> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "class"
mov <esp+1>[1] <parse_block_34887+21>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+21>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "if"
$jmp 35410 "f"
mov AX True
jmp 35411
mov AX False
cmp AX 1
$jmp 35718 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_block_34887+22> <esp+1>
inc esp
push [0]
mov <parse_block_34887+23> <esp+1>
inc esp
push [0]
mov <parse_block_34887+24> <esp+1>
inc esp
push 0
mov <parse_block_34887+25> <esp+1>
inc esp
mov DX <parse_block_34887+4>
cmp DX <parse_block_34887+5>
$jmp 35430 ">="
mov AX True
jmp 35431
mov AX False
cmp AX 1
$jmp 35698 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+4>
pop AX
push AX[BX]
mov <parse_block_34887+6> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "if"
$jmp 35447 "f"
mov AX True
jmp 35448
mov AX False
cmp AX 1
$jmp 35460 "!="
mov DX <parse_block_34887+25>
tf DX "equ" 0
$jmp 35455 "f"
mov AX True
jmp 35456
mov AX False
cmp AX 1
$jmp 35460 "!="
mov AX 1
jmp 35461
mov AX 0
cmp AX 1
$jmp 35476 "=="
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "elif"
$jmp 35471 "f"
mov AX True
jmp 35472
mov AX False
cmp AX 1
$jmp 35476 "=="
mov AX 0
jmp 35477
mov AX 1
cmp AX 1
$jmp 35611 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_block_34887+25> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+24>.append
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+29>
$jmp 35539 "f"
mov AX True
jmp 35540
mov AX False
cmp AX 1
$jmp 35553 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
push AX
mov <parse_block_34887+26> <esp+1>
inc esp
jmp 35553        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] <parse_block_34887+26>
mov <esp+1>[1] <parse_block_34887+16>.codelines
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+22>.append
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 35697        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 35619 "f"
mov AX True
jmp 35620
mov AX False
cmp AX 1
$jmp 35696 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 35698          ;break¥X
jmp 35697        ;¸õ¦Ü©³³¡
jmp 35698          ;break¥X
jmp 35425               ;continue­«¨Ó
push 1
$mov <parse_block_34887+4> "-" <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+22>
mov <esp+1>[1] <parse_block_34887+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+43>
mov <esp+1>[0] AX
mov <esp+1>[1] <parse_block_34887+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "while"
$jmp 35726 "f"
mov AX True
jmp 35727
mov AX False
cmp AX 1
$jmp 35943 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 2
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+29>
$jmp 35764 "f"
mov AX True
jmp 35765
mov AX False
cmp AX 1
$jmp 35778 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 1
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+18>
push AX
mov <parse_block_34887+26> <esp+1>
inc esp
jmp 35778        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+28> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
mov DX <parse_block_34887+15>
cmp DX <parse_block_34887+5>
$jmp 35830 ">="
mov AX True
jmp 35831
mov AX False
cmp AX 1
$jmp 35849 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 35844 "f"
mov AX True
jmp 35845
mov AX False
cmp AX 1
$jmp 35849 "!="
mov AX 1
jmp 35850
mov AX 0
cmp AX 1
$jmp 35903 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
jmp 35906        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34887+23> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+26>
mov <esp+1>[1] <parse_block_34887+28>
mov <esp+1>[2] <parse_block_34887+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+44>
mov <esp+1>[0] AX
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "for"
$jmp 35951 "f"
mov AX True
jmp 35952
mov AX False
cmp AX 1
$jmp 36241 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [0]
mov <parse_block_34887+29> <esp+1>
inc esp
push 2
mov <parse_block_34887+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 35975 "f"
mov AX True
jmp 35976
mov AX False
cmp AX 1
$jmp 35991 "=="
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 35986 "f"
mov AX True
jmp 35987
mov AX False
cmp AX 1
$jmp 35991 "=="
mov AX 0
jmp 35992
mov AX 1
cmp AX 1
$jmp 36047 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 36009 "f"
mov AX True
jmp 36010
mov AX False
cmp AX 1
$jmp 36043 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.name
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+29>.append
jmp 36043        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 35960               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov AX 1
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+31> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+32> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
mov DX <parse_block_34887+15>
cmp DX <parse_block_34887+5>
$jmp 36124 ">="
mov AX True
jmp 36125
mov AX False
cmp AX 1
$jmp 36143 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 36138 "f"
mov AX True
jmp 36139
mov AX False
cmp AX 1
$jmp 36143 "!="
mov AX 1
jmp 36144
mov AX 0
cmp AX 1
$jmp 36197 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <parse_block_34887+27> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+27>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
jmp 36200        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34887+23> <esp+1>
inc esp
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34887+29>
mov <esp+1>[1] <parse_block_34887+31>
mov <esp+1>[2] <parse_block_34887+32>
mov <esp+1>[3] <parse_block_34887+23>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+46>
push AX
mov <parse_block_34887+33> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+33>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "import"
$jmp 36249 "f"
mov AX True
jmp 36250
mov AX False
cmp AX 1
$jmp 36478 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <&package_6+16>.need_load <esp+1>
inc esp
push [dict]
mov <parse_block_34887+34> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 2
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_block_34887+9> <esp+1>[0]
mov <parse_block_34887+10> <esp+1>[1]
inc esp
mov DX <parse_block_34887+9>
cmp DX <parse_block_34887+10>
$jmp 36276 ">="
mov AX True
jmp 36277
mov AX False
cmp AX 1
$jmp 36443 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 36294 "f"
mov AX True
jmp 36295
mov AX False
cmp AX 1
$jmp 36439 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+35> <esp+1>
inc esp
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34887+10>
$jmp 36311 ">="
mov AX True
jmp 36312
mov AX False
cmp AX 1
$jmp 36329 "!="
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 36324 "f"
mov AX True
jmp 36325
mov AX False
cmp AX 1
$jmp 36329 "!="
mov AX 1
jmp 36330
mov AX 0
cmp AX 1
$jmp 36348 "!="
push "."
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
$mov <parse_block_34887+35> "+" <esp+1>
inc esp
push 2
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36304               ;continue­«¨Ó
push None
mov <parse_block_34887+36> <esp+1>
inc esp
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34887+10>
$jmp 36358 ">="
mov AX True
jmp 36359
mov AX False
cmp AX 1
$jmp 36376 "!="
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 36371 "f"
mov AX True
jmp 36372
mov AX False
cmp AX 1
$jmp 36376 "!="
mov AX 1
jmp 36377
mov AX 0
cmp AX 1
$jmp 36403 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+36>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+30> <esp+1>
inc esp
push 2
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36424        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+35>.split
push AX
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+30> <esp+1>
inc esp
push <parse_block_34887+36>
push <parse_block_34887+34>
mov BX <parse_block_34887+35>
pop AX
mov AX[BX] <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
jmp 36439        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36271               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+34>
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+13>
push AX
mov <parse_block_34887+37> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+37>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "from"
$jmp 36486 "f"
mov AX True
jmp 36487
mov AX False
cmp AX 1
$jmp 36736 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
mov <&package_6+16>.need_load <esp+1>
inc esp
push [0]
mov <parse_block_34887+38> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX 2
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+35> <esp+1>
inc esp
push 2
mov <parse_block_34887+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <parse_block_34887+10> <esp+1>
inc esp
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34887+10>
$jmp 36522 ">="
mov AX True
jmp 36523
mov AX False
cmp AX 1
$jmp 36540 "!="
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "."
$jmp 36535 "f"
mov AX True
jmp 36536
mov AX False
cmp AX 1
$jmp 36540 "!="
mov AX 1
jmp 36541
mov AX 0
cmp AX 1
$jmp 36559 "!="
push "."
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.name
oper <esp+1> "+" AX
oper <esp+1> "+" ""
$mov <parse_block_34887+35> "+" <esp+1>
inc esp
push 2
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36515               ;continue­«¨Ó
push 2
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
mov DX <parse_block_34887+9>
cmp DX <parse_block_34887+10>
$jmp 36567 ">="
mov AX True
jmp 36568
mov AX False
cmp AX 1
$jmp 36699 "!="
push 1        ;Àx¦sCX
push [1]
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+22>
$jmp 36585 "f"
mov AX True
jmp 36586
mov AX False
cmp AX 1
$jmp 36673 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+39> <esp+1>
inc esp
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop DX
cmp DX <parse_block_34887+10>
$jmp 36602 ">="
mov AX True
jmp 36603
mov AX False
cmp AX 1
$jmp 36620 "!="
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 36615 "f"
mov AX True
jmp 36616
mov AX False
cmp AX 1
$jmp 36620 "!="
mov AX 1
jmp 36621
mov AX 0
cmp AX 1
$jmp 36638 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
mov <esp+1>[0] <parse_block_34887+39>
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 2
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[1] AX.name
mov <parse_block_34887+40> <esp+1>
inc esp
push 2
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36643        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] <parse_block_34887+39>
mov <esp+1>[1] <parse_block_34887+39>
mov <parse_block_34887+40> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+40>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+38>.append
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+40>
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+30> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
jmp 36695        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 36681 "f"
mov AX True
jmp 36682
mov AX False
cmp AX 1
$jmp 36695 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push (2)
mov <esp+1>[0] "*"
mov <esp+1>[1] "*"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+38>.append
jmp 36695        ;¸õ¦Ü©³³¡
push 1
$mov <parse_block_34887+9> "+" <esp+1>
inc esp
jmp 36562               ;continue­«¨Ó
push 4        ;Àx¦sCX
push [4]
mov <esp+1>[0] <parse_block_34887+35>
mov <esp+1>[1] <parse_block_34887+38>
mov <esp+1>[2] <parse_block_34887+2>
mov <esp+1>[3] <parse_block_34887+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+12>
push AX
mov <parse_block_34887+41> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+41>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "try"
$jmp 36744 "f"
mov AX True
jmp 36745
mov AX False
cmp AX 1
$jmp 37266 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov <parse_block_34887+24> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+42> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
push [0]
mov <parse_block_34887+43> <esp+1>
inc esp
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
mov DX <parse_block_34887+15>
cmp DX <parse_block_34887+5>
$jmp 36821 ">="
mov AX True
jmp 36822
mov AX False
cmp AX 1
$jmp 36840 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "except"
$jmp 36835 "f"
mov AX True
jmp 36836
mov AX False
cmp AX 1
$jmp 36840 "!="
mov AX 1
jmp 36841
mov AX 0
cmp AX 1
$jmp 37030 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov <parse_block_34887+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+24>.append
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] 1
push (2)
mov <esp+1>[0] ":"
mov <esp+1>[1] "as"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+9> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov DX AX[BX]
tf DX "equ" ":"
$jmp 36894 "f"
mov AX True
jmp 36895
mov AX False
cmp AX 1
$jmp 36944 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+9>
oper <esp+1> "-" 1
pop DX
cmp DX 1
$jmp 36904 "<="
mov AX True
jmp 36905
mov AX False
cmp AX 1
$jmp 36929 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34887+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+44> <esp+1>
inc esp
jmp 36940        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "Exception"
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+44> <esp+1>
inc esp
push None
mov <parse_block_34887+36> <esp+1>
inc esp
jmp 36974        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34887+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+44> <esp+1>
inc esp
push <parse_block_34887+6>
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.name
mov <parse_block_34887+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (3)
mov <esp+1>[0] <parse_block_34887+44>
mov <esp+1>[1] <parse_block_34887+36>
mov <esp+1>[2] <parse_block_34887+16>.codelines
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+43>.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 36816               ;continue­«¨Ó
mov DX <parse_block_34887+15>
cmp DX <parse_block_34887+5>
$jmp 37035 ">="
mov AX True
jmp 37036
mov AX False
cmp AX 1
$jmp 37054 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "else"
$jmp 37049 "f"
mov AX True
jmp 37050
mov AX False
cmp AX 1
$jmp 37054 "!="
mov AX 1
jmp 37055
mov AX 0
cmp AX 1
$jmp 37130 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov <parse_block_34887+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+23> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
jmp 37133        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34887+23> <esp+1>
inc esp
push <parse_block_34887+15>
mov <parse_block_34887+4> <esp+1>
inc esp
mov DX <parse_block_34887+15>
cmp DX <parse_block_34887+5>
$jmp 37141 ">="
mov AX True
jmp 37142
mov AX False
cmp AX 1
$jmp 37160 "!="
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "finally"
$jmp 37155 "f"
mov AX True
jmp 37156
mov AX False
cmp AX 1
$jmp 37160 "!="
mov AX 1
jmp 37161
mov AX 0
cmp AX 1
$jmp 37236 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_block_34887+1>
mov BX <parse_block_34887+15>
pop AX
push AX[BX]
mov <parse_block_34887+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+24>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+15>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push <parse_block_34887+16>.codelines
mov <parse_block_34887+45> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
jmp 37239        ;¸õ¦Ü©³³¡
push [0]
mov <parse_block_34887+45> <esp+1>
inc esp
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34887+42>
mov <esp+1>[1] <parse_block_34887+43>
mov <esp+1>[2] <parse_block_34887+23>
mov <esp+1>[3] <parse_block_34887+45>
mov <esp+1>[4] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+38>
push AX
mov <parse_block_34887+46> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+46>
mov <esp+1>[1] <parse_block_34887+24>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "with"
$jmp 37274 "f"
mov AX True
jmp 37275
mov AX False
cmp AX 1
$jmp 37501 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2
mov <parse_block_34887+9> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] <parse_block_34887+9>
push [2]
mov <esp+1>[0] "as"
mov <esp+1>[1] ":"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] <parse_block_34887+9>
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+47> <esp+1>
inc esp
push 1
$mov <&package_6+16>.class_n "+" <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push "%with_obj_"
ex_func AX "str" <&package_6+16>.class_n
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <parse_block_34887+48> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+48>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
push <parse_block_34887+6>
mov BX <parse_block_34887+15>
pop AX
mov DX AX[BX]
tf DX "equ" "as"
$jmp 37350 "f"
mov AX True
jmp 37351
mov AX False
cmp AX 1
$jmp 37415 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] <parse_block_34887+15>
push [1]
mov <esp+1>[0] ":"
pop <esp+1>[2]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+49> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
push <parse_block_34887+15>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+49>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+36> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37402 "f"
mov AX True
jmp 37403
mov AX False
cmp AX 1
$jmp 37414 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+36>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
jmp 37414        ;¸õ¦Ü©³³¡
jmp 37418        ;¸õ¦Ü©³³¡
push None
mov <parse_block_34887+36> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+1>
mov <esp+1>[1] <parse_block_34887+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+9>
push AX
mov <parse_block_34887+15> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+1>
push [3]
push <parse_block_34887+4>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <parse_block_34887+15>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <parse_block_34887+16> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+16>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.update
push 5        ;Àx¦sCX
push [5]
mov <esp+1>[0] <parse_block_34887+47>
mov <esp+1>[1] <parse_block_34887+48>
mov <esp+1>[2] <parse_block_34887+36>
mov <esp+1>[3] <parse_block_34887+16>.codelines
mov <esp+1>[4] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+39>
push AX
mov <parse_block_34887+50> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+50>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push <parse_block_34887+15>
oper <esp+1> "-" 1
mov <parse_block_34887+4> <esp+1>
inc esp
jmp 37925        ;¸õ¦Ü©³³¡
push <parse_block_34887+6>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" "assert"
$jmp 37509 "f"
mov AX True
jmp 37510
mov AX False
cmp AX 1
$jmp 37651 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] 1
push [1]
mov <esp+1>[0] ","
pop <esp+1>[2]
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+9> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] 2
mov <esp+1>[1] <parse_block_34887+9>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+26> <esp+1>
inc esp
push <parse_block_34887+9>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 37563 ">="
mov AX True
jmp 37564
mov AX False
cmp AX 1
$jmp 37579 "!="
push <parse_block_34887+6>
mov BX <parse_block_34887+9>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 37574 "f"
mov AX True
jmp 37575
mov AX False
cmp AX 1
$jmp 37579 "!="
mov AX 1
jmp 37580
mov AX 0
cmp AX 1
$jmp 37606 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
push <parse_block_34887+9>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+51> <esp+1>
inc esp
jmp 37616        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] ""
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+20>
push AX
mov <parse_block_34887+51> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+26>
mov <esp+1>[1] <parse_block_34887+51>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+58>
push AX
mov <parse_block_34887+52> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+52>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
jmp 37925        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
mov <esp+1>[1] 0
push (13)
mov <esp+1>[0] "="
mov <esp+1>[1] "+="
mov <esp+1>[2] "-="
mov <esp+1>[3] "*="
mov <esp+1>[4] "/="
mov <esp+1>[5] "%="
mov <esp+1>[6] "//="
mov <esp+1>[7] "**="
mov <esp+1>[8] "<<="
mov <esp+1>[9] ">>="
mov <esp+1>[10] "&="
mov <esp+1>[11] "^="
mov <esp+1>[12] "|="
pop <esp+1>[2]
push [dict]
push "stop"
push [1]
mov <esp+1>[0] "lambda"
pop AX
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+53> <esp+1>
inc esp
push <parse_block_34887+6>
mov BX <parse_block_34887+53>
pop AX
push AX[BX]
mov <parse_block_34887+54> <esp+1>
inc esp
push [0]
mov <parse_block_34887+55> <esp+1>
inc esp
push 1
mov <parse_block_34887+56> <esp+1>
inc esp
mov DX <parse_block_34887+53>
cmp DX 0
$jmp 37701 "<="
mov AX True
jmp 37702
mov AX False
cmp AX 1
$jmp 37830 "!="
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] <parse_block_34887+56>
mov <esp+1>[1] <parse_block_34887+53>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+57> <esp+1>
inc esp
push (2)
mov <esp+1>[0] <&package_6+29>
mov <esp+1>[1] <&package_6+28>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 37773 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
ex_func AX "iter" <parse_block_34887+57>
push AX
fetch AX <esp+1>
$jmp 37771 "f"
mov <parse_block_34887+30> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37758 "f"
mov AX True
jmp 37759
mov AX False
cmp AX 1
$jmp 37770 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+30>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
jmp 37770        ;¸õ¦Ü©³³¡
jmp 37743
inc esp
jmp 37797        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+24>
$jmp 37785 "f"
mov AX True
jmp 37786
mov AX False
cmp AX 1
$jmp 37797 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <parse_block_34887+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.add_info
jmp 37797        ;¸õ¦Ü©³³¡
push <parse_block_34887+53>
oper <esp+1> "+" 1
mov <parse_block_34887+56> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+57>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+55>.append
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+6>
push <parse_block_34887+53>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "="
push [dict]
push "stop"
push [1]
mov <esp+1>[0] "lambda"
pop AX
pop BX
mov <esp+1>[BX] AX
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <parse_block_34887+53> <esp+1>
inc esp
jmp 37696               ;continue­«¨Ó
push 2        ;Àx¦sCX
push [2]
push <parse_block_34887+6>
push [3]
mov <esp+1>[0] <parse_block_34887+56>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] <parse_block_34887+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+10>
push AX
mov <parse_block_34887+58> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_block_34887+55>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
tf DX "equ" 0
$jmp 37863 "f"
mov AX True
jmp 37864
mov AX False
cmp AX 1
$jmp 37890 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+58>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
jmp 37925        ;¸õ¦Ü©³³¡
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <parse_block_34887+55>
mov <esp+1>[1] <parse_block_34887+58>
mov <esp+1>[2] <parse_block_34887+54>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+52>
push AX
mov <parse_block_34887+59> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <parse_block_34887+59>
push (2)
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 2
pop AX
mov <esp+1>[0] AX[BX]
push <parse_block_34887+6>
mov BX 0
pop AX
push AX[BX]
mov BX 1
pop AX
mov <esp+1>[1] AX[BX]
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_block_34887+3>.write
push 1
$mov <parse_block_34887+4> "+" <esp+1>
inc esp
jmp 34938               ;continue­«¨Ó
mov AX <parse_block_34887+3>
jmp 37931         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_block_34887" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59"
pop ip
Function <&package_6+12> 37937 None "From_Import^2" 1
name <&package_6+12> "<class '__main__.From_Import'>"
jmp 38336
tf $Inheritance "equ" None
$jmp 37942 "t"
mov <From_Import^2> $Inheritance
push 1
jmp 37944
mov <From_Import^2> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <From_Import^2> <&package_6+12>
Function BX 37952 <From_Import^2> "__init___37952" 6
mov <From_Import^2>.__init__ BX
jmp 38013           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 37960 "!="
tf <esp+2> "in" "module_name"
$jmp 37962 "t"
mov <esp+2>["module_name"] None
jmp 37962
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 37968 "!="
tf <esp+2> "in" "object_names"
$jmp 37970 "t"
mov <esp+2>["object_names"] None
jmp 37970
mov <esp+2>["object_names"] <esp+1>[1]
dec CX
cmp CX 0
$jmp 37976 "!="
tf <esp+2> "in" "namespace"
$jmp 37978 "t"
mov <esp+2>["namespace"] None
jmp 37978
mov <esp+2>["namespace"] <esp+1>[2]
dec CX
cmp CX 0
$jmp 37984 "!="
tf <esp+2> "in" "now_info"
$jmp 37986 "t"
mov <esp+2>["now_info"] None
jmp 37986
mov <esp+2>["now_info"] <esp+1>[3]
dec CX
mov <__init___37952+2> <esp+2>["module_name"]
mov <__init___37952+3> <esp+2>["object_names"]
mov <__init___37952+4> <esp+2>["namespace"]
mov <__init___37952+5> <esp+2>["now_info"]


push <__init___37952+2>
mov <__init___37952+0>.module_name <esp+1>
inc esp
push <__init___37952+3>
mov <__init___37952+0>.object_names <esp+1>
inc esp
push <__init___37952+4>
mov <__init___37952+0>.namespace <esp+1>
inc esp
push <__init___37952+5>
mov <__init___37952+0>.now_info <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___37952+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___37952" "0,1,2,3,4,5"
pop ip
Function BX 38016 <From_Import^2> "__str___38016" 2
mov <From_Import^2>.__str__ BX
jmp 38032           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<From "
ex_func AX "str" <__str___38016+0>.module_name
oper <esp+1> "+" AX
oper <esp+1> "+" " import "
ex_func AX "str" <__str___38016+0>.object_names
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 38029         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___38016" "0,1"
pop ip
Function BX 38035 <From_Import^2> "write_38035" 14
mov <From_Import^2>.write BX
jmp 38322           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38043 "!="
tf <esp+2> "in" "codes"
$jmp 38045 "t"
mov <esp+2>["codes"] None
jmp 38045
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_38035+2> <esp+2>["codes"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38035+0>.module_name
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.get_path
push AX
mov <write_38035+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] ""
mov <esp+1>[1] <write_38035+0>.orig_lines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
push <write_38035+3>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 38074 "t"
mov AX True
jmp 38075
mov AX False
cmp AX 1
$jmp 38114 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push "&tem_import_"
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38035+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
ex_func AX "str" AX
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_38035+4> <esp+1>
inc esp
push [dict]
mov BX <write_38035+0>.module_name
mov <esp+1>[BX] <write_38035+4>
mov <write_38035+5> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_38035+5>
mov <esp+1>[1] <write_38035+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+13>
push AX
mov <write_38035+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38035+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+6>.write
jmp 38114        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "push $importer[\""
push <write_38035+3>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
mov DX <write_38035+0>.namespace
tf DX "equ" ""
$jmp 38133 "t"
mov AX True
jmp 38134
mov AX False
cmp AX 1
$jmp 38165 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_38035+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38035+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "push "
mov AX <write_38035+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
push "<esp+1>."
mov <write_38035+7> <esp+1>
inc esp
push "<esp+2>"
mov <write_38035+8> <esp+1>
inc esp
jmp 38171        ;¸õ¦Ü©³³¡
push ""
mov <write_38035+7> <esp+1>
inc esp
push "<esp+1>"
mov <write_38035+8> <esp+1>
inc esp
ex_func AX "iter" <write_38035+0>.object_names
push AX
fetch AX <esp+1>
$jmp 38294 "f"
mov <write_38035+9> AX
push <write_38035+9>
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" "*"
$jmp 38184 "f"
mov AX True
jmp 38185
mov AX False
cmp AX 1
$jmp 38267 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <&package_6+16>.infos
push <write_38035+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <write_38035+10> <esp+1>
inc esp
mov DX <write_38035+10>
tf DX "equ" "built-in"
$jmp 38201 "f"
mov AX True
jmp 38202
mov AX False
cmp AX 1
$jmp 38214 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <&package_6+16>.module_dict
push <write_38035+3>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
push AX[BX]
mov <write_38035+11> <esp+1>
inc esp
jmp 38217        ;¸õ¦Ü©³³¡
push <write_38035+10>.locals
mov <write_38035+11> <esp+1>
inc esp
ex_func AX "iter" <write_38035+11>
push AX
fetch AX <esp+1>
$jmp 38265 "f"
mov <write_38035+12> AX
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38035+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38035+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38035+8>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
ex_func AX "str" <write_38035+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "    ;import *"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <write_38035+12>
mov <esp+1>[1] <write_38035+0>.namespace
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+24>
push AX
mov <write_38035+13> <esp+1>
inc esp
mov AX <write_38035+0>.now_info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.add_info
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "var"
mov <esp+1>[1] <write_38035+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 38219
inc esp
jmp 38293        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38035+7>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38035+9>
mov BX 1
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38035+8>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
push <write_38035+9>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
jmp 38173
inc esp
mov DX <write_38035+0>.namespace
tf DX "equ" ""
$jmp 38300 "t"
mov AX True
jmp 38301
mov AX False
cmp AX 1
$jmp 38311 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "$mov esp \"+\" 2"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
jmp 38318        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "inc esp"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38035+2>.append
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_38035" "0,1,2,3,4,5,6,7,8,9,10,11,12,13"
pop ip
mov AX <From_Import^2>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 38334 "=="
tf AX "Ctn" "__init__"
$jmp 38332 "t"
jmp 38334
call AX.__init__
mov AX <From_Import^2>
end "Function" "From_Import^2"
pop ip
Function <&package_6+13> 38339 None "Import^3" 1
name <&package_6+13> "<class '__main__.Import'>"
jmp 39566
tf $Inheritance "equ" None
$jmp 38344 "t"
mov <Import^3> $Inheritance
push 1
jmp 38346
mov <Import^3> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Import^3> <&package_6+13>
Function BX 38354 <Import^3> "__init___38354" 4
mov <Import^3>.__init__ BX
jmp 38391           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38362 "!="
tf <esp+2> "in" "package_dict"
$jmp 38364 "t"
mov <esp+2>["package_dict"] None
jmp 38364
mov <esp+2>["package_dict"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 38370 "!="
tf <esp+2> "in" "namespace"
$jmp 38372 "t"
mov <esp+2>["namespace"] None
jmp 38372
mov <esp+2>["namespace"] <esp+1>[1]
dec CX
mov <__init___38354+2> <esp+2>["package_dict"]
mov <__init___38354+3> <esp+2>["namespace"]


push <__init___38354+2>
mov <__init___38354+0>.package_dict <esp+1>
inc esp
push <__init___38354+3>
mov <__init___38354+0>.namespace <esp+1>
inc esp
push (2)
mov <esp+1>[0] ""
mov <esp+1>[1] 0
mov <__init___38354+0>.orig_lines <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___38354" "0,1,2,3"
pop ip
Function BX 38394 <Import^3> "__str___38394" 2
mov <Import^3>.__str__ BX
jmp 38407           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push "<Import: "
ex_func AX "str" <__str___38394+0>.package_dict
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
pop AX
jmp 38404         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__str___38394" "0,1"
pop ip
Function BX 38410 <Import^3> "write_38410" 29
mov <Import^3>.write BX
jmp 39552           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 38418 "!="
tf <esp+2> "in" "codes"
$jmp 38420 "t"
mov <esp+2>["codes"] None
jmp 38420
mov <esp+2>["codes"] <esp+1>[0]
dec CX
mov <write_38410+2> <esp+2>["codes"]


mov DX <write_38410+0>.namespace
tf DX "equ" ""
$jmp 38428 "t"
mov AX True
jmp 38429
mov AX False
cmp AX 1
$jmp 38449 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <write_38410+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push ""
mov AX <write_38410+0>.namespace      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38410+3> <esp+1>
inc esp
jmp 38452        ;¸õ¦Ü©³³¡
push ""
mov <write_38410+3> <esp+1>
inc esp
push <write_38410+3>
mov <write_38410+4> <esp+1>
inc esp
ex_func AX "iter" <write_38410+0>.package_dict
push AX
fetch AX <esp+1>
$jmp 39547 "f"
mov <write_38410+5> AX
push <write_38410+0>.package_dict
mov BX <write_38410+5>
pop AX
push AX[BX]
mov <write_38410+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+5>.split
push AX
mov <write_38410+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39542 "f"
mov <write_38410+8> AX
mov AX "."      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
push <write_38410+7>
push [3]
mov <esp+1>[0] None
push <write_38410+8>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38410+9> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+9>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.get_path
push AX
mov <write_38410+10> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <write_38410+11> <esp+1>
inc esp
push "&"
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "_"
ex_func AX "str" <write_38410+11>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
mov <write_38410+12> <esp+1>
inc esp
push <write_38410+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 0
$jmp 38560 "f"
mov AX True
jmp 38561
mov AX False
cmp AX 1
$jmp 38660 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " $importer[\""
push <write_38410+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"]"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
mov DX <write_38410+6>
tf DX "equ" None
$jmp 38585 "f"
mov AX True
jmp 38586
mov AX False
cmp AX 1
$jmp 38609 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38653        ;¸õ¦Ü©³³¡
push <write_38410+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38625 "f"
mov AX True
jmp 38626
mov AX False
cmp AX 1
$jmp 38646 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38410+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38653        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pass"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
push ""
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38410+3> <esp+1>
inc esp
jmp 39541        ;¸õ¦Ü©³³¡
push <write_38410+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 2
$jmp 38668 "f"
mov AX True
jmp 38669
mov AX False
cmp AX 1
$jmp 38809 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&package_6+16>.loaded      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_38410+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "module "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
push <write_38410+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $importer[\""
push <write_38410+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
mov DX <write_38410+6>
tf DX "equ" None
$jmp 38723 "f"
mov AX True
jmp 38724
mov AX False
cmp AX 1
$jmp 38756 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;©w¸q"
ex_func AX "str" <write_38410+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38793        ;¸õ¦Ü©³³¡
push <write_38410+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38772 "f"
mov AX True
jmp 38773
mov AX False
cmp AX 1
$jmp 38793 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38410+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38793        ;¸õ¦Ü©³³¡
push "built-in"
push <&package_6+16>.infos
push <write_38410+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push ""
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38410+3> <esp+1>
inc esp
jmp 39541        ;¸õ¦Ü©³³¡
push <write_38410+10>
mov BX 1
pop AX
mov DX AX[BX]
tf DX "equ" 1
$jmp 38817 "f"
mov AX True
jmp 38818
mov AX False
cmp AX 1
$jmp 39541 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <&package_6+16>.loaded      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push <write_38410+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
push 1        ;Àx¦sCX
push [1]
push "mov $importer[\""
push <write_38410+10>
mov BX 0
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" "\"] "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
mov DX <write_38410+6>
tf DX "equ" None
$jmp 38862 "f"
mov AX True
jmp 38863
mov AX False
cmp AX 1
$jmp 38895 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "  ;©w¸q"
ex_func AX "str" <write_38410+3>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
push <write_38410+7>
mov BX <write_38410+8>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38939        ;¸õ¦Ü©³³¡
push <write_38410+8>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+7>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 38911 "f"
mov AX True
jmp 38912
mov AX False
cmp AX 1
$jmp 38932 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push "mov "
ex_func AX "str" <write_38410+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
ex_func AX "str" <write_38410+6>
oper <esp+1> "+" AX
oper <esp+1> "+" " "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
jmp 38939        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "pass"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.append
push 1        ;Àx¦sCX
push [1]
push <write_38410+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.add_newtab
push 2        ;Àx¦sCX
push [2]
push <write_38410+10>
mov BX 0
pop AX
mov <esp+1>[0] AX[BX]
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] <&package_6+16>.encoding
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38410+13> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+13>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov <write_38410+14> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+14>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <write_38410+15> <esp+1>
inc esp
ex_func AX "iter" <write_38410+15>.codelines
push AX
fetch AX <esp+1>
$jmp 39007 "f"
mov <write_38410+16> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+16>.write
jmp 38996
inc esp
push <write_38410+15>
push <&package_6+16>.infos
push <write_38410+10>
mov BX 0
pop AX
mov BX AX[BX]
pop AX
mov AX[BX] <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+2>.del_newtab
push [dict]
mov <write_38410+17> <esp+1>
inc esp
push [0]
mov <write_38410+18> <esp+1>
inc esp
push 0
mov <write_38410+19> <esp+1>
inc esp
ex_func AX "iter" <write_38410+15>.locals
push AX
fetch AX <esp+1>
$jmp 39066 "f"
mov <write_38410+20> AX
tf <write_38410+18> "in" <write_38410+20>
mov AX TF
$oper AX "not"
cmp AX 1
$jmp 39065 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+20>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+18>.append
push "<"
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "+"
ex_func AX "str" <write_38410+19>
oper <esp+1> "+" AX
oper <esp+1> "+" ">"
push <write_38410+17>
mov BX <write_38410+20>
pop AX
mov AX[BX] <esp+1>
inc esp
push 1
$mov <write_38410+19> "+" <esp+1>
inc esp
jmp 39065        ;¸õ¦Ü©³³¡
jmp 39034
inc esp
mov AX ","      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+18>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38410+21> <esp+1>
inc esp
push "namespace "
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" " \""
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "\" \""
ex_func AX "str" <write_38410+21>
oper <esp+1> "+" AX
oper <esp+1> "+" "\""
push <write_38410+2>
mov BX <write_38410+11>
pop AX
mov AX[BX] <esp+1>
inc esp
Function <write_38410+22> 39097 None "get_name_39097" 5 "write_38410"
jmp 39179           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39105 "!="
tf <esp+2> "in" "string"
$jmp 39107 "t"
mov <esp+2>["string"] None
jmp 39107
mov <esp+2>["string"] <esp+1>[0]
dec CX
mov <get_name_39097+1> <esp+2>["string"]


push ".[ ;"
mov <get_name_39097+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_name_39097+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <get_name_39097+3> <esp+1>[0]
mov <get_name_39097+4> <esp+1>[1]
inc esp
mov DX <get_name_39097+3>
cmp DX <get_name_39097+4>
$jmp 39131 ">="
mov AX True
jmp 39132
mov AX False
cmp AX 1
$jmp 39171 "!="
push <get_name_39097+1>
mov BX <get_name_39097+3>
pop AX
tf <get_name_39097+2> "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 39167 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push (2)
push <get_name_39097+1>
push [3]
mov <esp+1>[0] None
mov <esp+1>[1] <get_name_39097+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
push <get_name_39097+1>
push [3]
mov <esp+1>[0] <get_name_39097+3>
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[1] AX[BX]
pop AX
jmp 39176         ;returnÂI
jmp 39167        ;¸õ¦Ü©³³¡
push 1
$mov <get_name_39097+3> "+" <esp+1>
inc esp
jmp 39126               ;continue­«¨Ó
push (2)
mov <esp+1>[0] <get_name_39097+1>
mov <esp+1>[1] ""
pop AX
jmp 39176         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_name_39097" "0,1,2,3,4"
pop ip
Function <write_38410+23> 39181 None "parse_line_39181" 7 "write_38410"
jmp 39331           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39189 "!="
tf <esp+2> "in" "line"
$jmp 39191 "t"
mov <esp+2>["line"] None
jmp 39191
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <parse_line_39181+1> <esp+2>["line"]


push [0]
mov <parse_line_39181+2> <esp+1>
inc esp
push (2)
mov <esp+1>[0] 0
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <parse_line_39181+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[1] AX
mov <parse_line_39181+3> <esp+1>[0]
mov <parse_line_39181+4> <esp+1>[1]
inc esp
mov DX <parse_line_39181+3>
cmp DX <parse_line_39181+4>
$jmp 39215 ">="
mov AX True
jmp 39216
mov AX False
cmp AX 1
$jmp 39326 "!="
push <parse_line_39181+3>
mov <parse_line_39181+5> <esp+1>
inc esp
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <parse_line_39181+1>
mov BX <parse_line_39181+5>
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 39277 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <parse_line_39181+1>
mov BX <parse_line_39181+5>
pop AX
push AX[BX]
mov <parse_line_39181+6> <esp+1>
inc esp
push <parse_line_39181+5>
oper <esp+1> "+" 1
mov <parse_line_39181+3> <esp+1>
inc esp
push <parse_line_39181+1>
mov BX <parse_line_39181+3>
pop AX
mov DX AX[BX]
tf DX "equ" <parse_line_39181+6>
$jmp 39251 "t"
mov AX True
jmp 39252
mov AX False
cmp AX 1
$jmp 39273 "!="
push <parse_line_39181+1>
mov BX <parse_line_39181+3>
pop AX
mov DX AX[BX]
tf DX "equ" "\\"
$jmp 39262 "f"
mov AX True
jmp 39263
mov AX False
cmp AX 1
$jmp 39269 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1
$mov <parse_line_39181+3> "+" <esp+1>
inc esp
jmp 39269        ;¸õ¦Ü©³³¡
push 1
$mov <parse_line_39181+3> "+" <esp+1>
inc esp
jmp 39243               ;continue­«¨Ó
push 1
$mov <parse_line_39181+3> "+" <esp+1>
inc esp
jmp 39277        ;¸õ¦Ü©³³¡
mov DX <parse_line_39181+3>
cmp DX <parse_line_39181+4>
$jmp 39282 ">="
mov AX True
jmp 39283
mov AX False
cmp AX 1
$jmp 39298 "!="
push <parse_line_39181+1>
mov BX <parse_line_39181+3>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 39293 "t"
mov AX True
jmp 39294
mov AX False
cmp AX 1
$jmp 39298 "!="
mov AX 1
jmp 39299
mov AX 0
cmp AX 1
$jmp 39305 "!="
push 1
$mov <parse_line_39181+3> "+" <esp+1>
inc esp
jmp 39277               ;continue­«¨Ó
push 1        ;Àx¦sCX
push [1]
push <parse_line_39181+1>
push [3]
mov <esp+1>[0] <parse_line_39181+5>
mov <esp+1>[1] <parse_line_39181+3>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_line_39181+2>.append
push 1
$mov <parse_line_39181+3> "+" <esp+1>
inc esp
jmp 39210               ;continue­«¨Ó
mov AX <parse_line_39181+2>
jmp 39328         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_line_39181" "0,1,2,3,4,5,6"
pop ip
push 3
$mov <write_38410+11> "+" <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" <write_38410+11>
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39533 "f"
mov <write_38410+24> AX
push <write_38410+2>
push <write_38410+11>
oper <esp+1> "+" <write_38410+24>
pop BX
pop AX
push AX[BX]
mov <write_38410+25> <esp+1>
inc esp
tf <write_38410+25> "in" "\""
mov AX TF
cmp AX 1
$jmp 39373 "=="
tf <write_38410+25> "in" "'"
mov AX TF
cmp AX 1
$jmp 39373 "=="
mov AX 0
jmp 39374
mov AX 1
cmp AX 1
$jmp 39387 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+25>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+23>
push AX
mov <write_38410+26> <esp+1>
inc esp
jmp 39405        ;¸õ¦Ü©³³¡
push <write_38410+2>
push <write_38410+11>
oper <esp+1> "+" <write_38410+24>
pop BX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] " "
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <write_38410+26> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov <esp+1>[0] AX
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call range
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 39513 "f"
mov <write_38410+27> AX
mov DX <write_38410+27>
tf DX "equ" 0
$jmp 39429 "f"
mov AX True
jmp 39430
mov AX False
cmp AX 1
$jmp 39445 "=="
push <write_38410+26>
mov BX <write_38410+27>
pop AX
mov DX AX[BX]
tf DX "equ" ""
$jmp 39440 "f"
mov AX True
jmp 39441
mov AX False
cmp AX 1
$jmp 39445 "=="
mov AX 0
jmp 39446
mov AX 1
cmp AX 1
$jmp 39450 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39421
jmp 39450        ;¸õ¦Ü©³³¡
push (2)
mov <esp+1>[0] "\""
mov <esp+1>[1] "'"
push <write_38410+26>
mov BX <write_38410+27>
pop AX
push AX[BX]
mov BX 0
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 39467 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39421
jmp 39467        ;¸õ¦Ü©³³¡
push <write_38410+26>
mov BX <write_38410+27>
pop AX
push AX[BX]
mov BX 0
pop AX
mov DX AX[BX]
tf DX "equ" ";"
$jmp 39478 "f"
mov AX True
jmp 39479
mov AX False
cmp AX 1
$jmp 39483 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
jmp 39513          ;break¥X°j°é
jmp 39483        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
push <write_38410+26>
mov BX <write_38410+27>
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <write_38410+22>
push AX
mov <write_38410+20> <esp+1>[0]
mov <write_38410+28> <esp+1>[1]
inc esp
tf <write_38410+17> "in" <write_38410+20>
mov AX TF
cmp AX 1
$jmp 39512 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <write_38410+17>
mov BX <write_38410+20>
pop AX
push AX[BX]
oper <esp+1> "+" <write_38410+28>
push <write_38410+26>
mov BX <write_38410+27>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39512        ;¸õ¦Ü©³³¡
jmp 39421
inc esp
mov AX " "      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <write_38410+26>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
push <write_38410+2>
push <write_38410+11>
oper <esp+1> "+" <write_38410+24>
pop BX
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39352
inc esp
push ""
ex_func AX "str" <write_38410+12>
oper <esp+1> "+" AX
oper <esp+1> "+" "."
mov <write_38410+3> <esp+1>
inc esp
jmp 39541        ;¸õ¦Ü©³³¡
jmp 38492
inc esp
push <write_38410+4>
mov <write_38410+3> <esp+1>
inc esp
jmp 38457
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "write_38410" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,24,25,26,27,28"
pop ip
mov AX <Import^3>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 39564 "=="
tf AX "Ctn" "__init__"
$jmp 39562 "t"
jmp 39564
call AX.__init__
mov AX <Import^3>
end "Function" "Import^3"
pop ip
Function <&package_6+14> 39568 None "Read_ex_func_39568" 9
jmp 39996           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


Function <Read_ex_func_39568+1> 39574 None "deal_line_39574" 8 "Read_ex_func_39568"
jmp 39808           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 39582 "!="
tf <esp+2> "in" "line"
$jmp 39584 "t"
mov <esp+2>["line"] None
jmp 39584
mov <esp+2>["line"] <esp+1>[0]
dec CX
mov <deal_line_39574+1> <esp+2>["line"]


push [dict]
mov <deal_line_39574+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <deal_line_39574+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <deal_line_39574+3> <esp+1>
inc esp
push 0
mov <deal_line_39574+4> <esp+1>
inc esp
mov DX <deal_line_39574+4>
cmp DX <deal_line_39574+3>
$jmp 39608 ">="
mov AX True
jmp 39609
mov AX False
cmp AX 1
$jmp 39803 "!="
mov DX <deal_line_39574+4>
cmp DX <deal_line_39574+3>
$jmp 39616 ">="
mov AX True
jmp 39617
mov AX False
cmp AX 1
$jmp 39628 "!="
push <deal_line_39574+1>
mov BX <deal_line_39574+4>
pop AX
tf ", " "in" AX[BX]
mov AX TF
cmp AX 1
$jmp 39628 "!="
mov AX 1
jmp 39629
mov AX 0
cmp AX 1
$jmp 39635 "!="
push 1
$mov <deal_line_39574+4> "+" <esp+1>
inc esp
jmp 39611               ;continue­«¨Ó
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <deal_line_39574+1>
mov <esp+1>[1] <deal_line_39574+4>
mov <esp+1>[2] "( ,"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <deal_line_39574+5> <esp+1>
inc esp
push <deal_line_39574+1>
push [3]
mov <esp+1>[0] <deal_line_39574+4>
mov <esp+1>[1] <deal_line_39574+5>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <deal_line_39574+6> <esp+1>
inc esp
mov DX <deal_line_39574+5>
cmp DX <deal_line_39574+3>
$jmp 39668 ">="
mov AX True
jmp 39669
mov AX False
cmp AX 1
$jmp 39684 "!="
push <deal_line_39574+1>
mov BX <deal_line_39574+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 39679 "f"
mov AX True
jmp 39680
mov AX False
cmp AX 1
$jmp 39684 "!="
mov AX 1
jmp 39685
mov AX 0
cmp AX 1
$jmp 39691 "!="
push 1
$mov <deal_line_39574+5> "+" <esp+1>
inc esp
jmp 39663               ;continue­«¨Ó
mov DX <deal_line_39574+5>
cmp DX <deal_line_39574+3>
$jmp 39696 ">="
mov AX True
jmp 39697
mov AX False
cmp AX 1
$jmp 39712 "!="
push <deal_line_39574+1>
mov BX <deal_line_39574+5>
pop AX
mov DX AX[BX]
tf DX "equ" "("
$jmp 39707 "f"
mov AX True
jmp 39708
mov AX False
cmp AX 1
$jmp 39712 "!="
mov AX 1
jmp 39713
mov AX 0
cmp AX 1
$jmp 39759 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <deal_line_39574+1>
push <deal_line_39574+5>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] ")"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <deal_line_39574+7> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
push <deal_line_39574+1>
push [3]
push <deal_line_39574+5>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <deal_line_39574+7>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <Read_ex_func_39568+1>
push AX
push <deal_line_39574+2>
mov BX <deal_line_39574+6>
pop AX
mov AX[BX] <esp+1>
inc esp
push <deal_line_39574+7>
oper <esp+1> "+" 1
mov <deal_line_39574+4> <esp+1>
inc esp
jmp 39802        ;¸õ¦Ü©³³¡
mov DX <deal_line_39574+5>
cmp DX <deal_line_39574+3>
$jmp 39764 "<"
mov AX True
jmp 39765
mov AX False
cmp AX 1
$jmp 39780 "=="
push <deal_line_39574+1>
mov BX <deal_line_39574+5>
pop AX
mov DX AX[BX]
tf DX "equ" ","
$jmp 39775 "f"
mov AX True
jmp 39776
mov AX False
cmp AX 1
$jmp 39780 "=="
mov AX 0
jmp 39781
mov AX 1
cmp AX 1
$jmp 39794 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [dict]
push <deal_line_39574+2>
mov BX <deal_line_39574+6>
pop AX
mov AX[BX] <esp+1>
inc esp
push <deal_line_39574+5>
oper <esp+1> "+" 1
mov <deal_line_39574+4> <esp+1>
inc esp
jmp 39802        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "unknow"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Exception
raise AX
jmp 39603               ;continue­«¨Ó
mov AX <deal_line_39574+2>
jmp 39805         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "deal_line_39574" "0,1,2,3,4,5,6,7"
pop ip
push [dict]
mov <Read_ex_func_39568+2> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+1>
push AX
oper <esp+1> "+" "\\apython\\ex_func.py"
pop <esp+1>[0]
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] "utf-8"
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <Read_ex_func_39568+3> <esp+1>
inc esp
ex_func AX "iter" <Read_ex_func_39568+3>
push AX
fetch AX <esp+1>
$jmp 39990 "f"
mov <Read_ex_func_39568+4> AX
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39568+4>
mov <esp+1>[1] 0
mov <esp+1>[2] " #"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39568+5> <esp+1>
inc esp
push <Read_ex_func_39568+5>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <Read_ex_func_39568+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
pop DX
cmp DX AX
$jmp 39883 ">="
mov AX True
jmp 39884
mov AX False
cmp AX 1
$jmp 39899 "!="
push <Read_ex_func_39568+4>
mov BX <Read_ex_func_39568+5>
pop AX
mov DX AX[BX]
tf DX "equ" " "
$jmp 39894 "f"
mov AX True
jmp 39895
mov AX False
cmp AX 1
$jmp 39899 "!="
mov AX 1
jmp 39900
mov AX 0
cmp AX 1
$jmp 39989 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39568+4>
push <Read_ex_func_39568+5>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] " #"
push [dict]
mov BX "end"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39568+6> <esp+1>
inc esp
push <Read_ex_func_39568+4>
push [3]
push <Read_ex_func_39568+5>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] <Read_ex_func_39568+6>
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <Read_ex_func_39568+7> <esp+1>
inc esp
push 3        ;Àx¦sCX
push [3]
mov <esp+1>[0] <Read_ex_func_39568+4>
push <Read_ex_func_39568+6>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov <esp+1>[2] "#"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+7>
push AX
mov <Read_ex_func_39568+8> <esp+1>
inc esp
mov DX <Read_ex_func_39568+8>
cmp DX <Read_ex_func_39568+6>
$jmp 39953 "<="
mov AX True
jmp 39954
mov AX False
cmp AX 1
$jmp 39982 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <Read_ex_func_39568+4>
push [3]
push <Read_ex_func_39568+8>
oper <esp+1> "+" 1
pop <esp+1>[0]
mov <esp+1>[1] None
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <Read_ex_func_39568+1>
push AX
push <Read_ex_func_39568+2>
mov BX <Read_ex_func_39568+7>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39988        ;¸õ¦Ü©³³¡
push [dict]
push <Read_ex_func_39568+2>
mov BX <Read_ex_func_39568+7>
pop AX
mov AX[BX] <esp+1>
inc esp
jmp 39989        ;¸õ¦Ü©³³¡
jmp 39852
inc esp
mov AX <Read_ex_func_39568+2>
jmp 39993         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "Read_ex_func_39568" "0,2,3,4,5,6,7,8"
pop ip
Function <&package_6+15> 39999 None "Importer^4" 1
name <&package_6+15> "<class '__main__.Importer'>"
jmp 40530
tf $Inheritance "equ" None
$jmp 40004 "t"
mov <Importer^4> $Inheritance
push 1
jmp 40006
mov <Importer^4> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Importer^4> <&package_6+15>
Function BX 40014 <Importer^4> "__init___40014" 2
mov <Importer^4>.__init__ BX
jmp 40037           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+14>
push AX
mov <__init___40014+0>.module_dict <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__init___40014+0>.reset
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___40014" "0,1"
pop ip
Function BX 40040 <Importer^4> "__get_module_40040" 5
mov <Importer^4>.__get_module BX
jmp 40313           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40048 "!="
tf <esp+2> "in" "module_name"
$jmp 40050 "t"
mov <esp+2>["module_name"] None
jmp 40050
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <__get_module_40040+2> <esp+2>["module_name"]


Function <__get_module_40040+3> 40055 None "get_module_40055" 6 "__get_module_40040"
jmp 40291           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40063 "!="
tf <esp+2> "in" "nowfolder"
$jmp 40065 "t"
mov <esp+2>["nowfolder"] None
jmp 40065
mov <esp+2>["nowfolder"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 40071 "!="
tf <esp+2> "in" "k"
$jmp 40073 "t"
mov <esp+2>["k"] None
jmp 40073
mov <esp+2>["k"] <esp+1>[1]
dec CX
mov <get_module_40055+1> <esp+2>["nowfolder"]
mov <get_module_40055+2> <esp+2>["k"]


push <get_module_40055+2>
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__get_module_40040+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
oper <esp+1> "-" 1
pop AX
pop DX
tf DX "equ" AX
$jmp 40093 "f"
mov AX True
jmp 40094
mov AX False
cmp AX 1
$jmp 40267 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push ""
mov <get_module_40055+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_40055+1>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+0>
ex_func AX "iter" AX
push AX
fetch AX <esp+1>
$jmp 40263 "f"
mov <get_module_40055+4> AX
push ""
ex_func AX "str" <get_module_40055+1>
oper <esp+1> "+" AX
oper <esp+1> "+" "/"
ex_func AX "str" <get_module_40055+4>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop AX
push AX.replace
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <get_module_40055+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_40055+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+4>
cmp AX 1
$jmp 40163 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_module_40055+4>.split
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov DX AX[BX]
tf DX "equ" "py"
$jmp 40158 "f"
mov AX True
jmp 40159
mov AX False
cmp AX 1
$jmp 40163 "!="
mov AX 1
jmp 40164
mov AX 0
cmp AX 1
$jmp 40176 "!="
mov DX <get_module_40055+3>
tf DX "equ" ""
$jmp 40171 "f"
mov AX True
jmp 40172
mov AX False
cmp AX 1
$jmp 40176 "!="
mov AX 1
jmp 40177
mov AX 0
cmp AX 1
$jmp 40205 "!="
push <get_module_40055+4>
push [3]
mov <esp+1>[0] None
mov AX 3
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
push <__get_module_40040+4>
mov BX <get_module_40055+2>
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 40200 "f"
mov AX True
jmp 40201
mov AX False
cmp AX 1
$jmp 40205 "!="
mov AX 1
jmp 40206
mov AX 0
cmp AX 1
$jmp 40212 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_module_40055+5>
mov <get_module_40055+3> <esp+1>
inc esp
jmp 40262        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_40055+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+3>
cmp AX 1
$jmp 40237 "!="
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_module_40055+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+0>
push AX
mov BX "__init__.py"
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 40237 "!="
mov AX 1
jmp 40238
mov AX 0
cmp AX 1
$jmp 40254 "!="
push <get_module_40055+4>
push <__get_module_40040+4>
mov BX <get_module_40055+2>
pop AX
pop DX
tf DX "equ" AX[BX]
$jmp 40249 "f"
mov AX True
jmp 40250
mov AX False
cmp AX 1
$jmp 40254 "!="
mov AX 1
jmp 40255
mov AX 0
cmp AX 1
$jmp 40262 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <get_module_40055+5>
oper <esp+1> "+" "/__init__.py"
mov <get_module_40055+3> <esp+1>
inc esp
jmp 40262        ;¸õ¦Ü©³³¡
jmp 40108
inc esp
mov AX <get_module_40055+3>
jmp 40288         ;returnÂI
jmp 40267        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
push ""
ex_func AX "str" <get_module_40055+1>
oper <esp+1> "+" AX
oper <esp+1> "+" "\\"
push <__get_module_40040+4>
mov BX <get_module_40055+2>
pop AX
ex_func AX "str" AX[BX]
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
push <get_module_40055+2>
oper <esp+1> "+" 1
pop <esp+1>[1]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_40040+3>
jmp 40288         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_module_40055" "0,1,2,3,4,5"
pop ip
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_40040+2>.split
push AX
mov <__get_module_40040+4> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__get_module_40040+0>.work_folder
mov <esp+1>[1] 0
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__get_module_40040+3>
jmp 40310         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__get_module_40040" "0,1,2"
pop ip
Function BX 40316 <Importer^4> "get_path_40316" 4
mov <Importer^4>.get_path BX
jmp 40403           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40324 "!="
tf <esp+2> "in" "module_name"
$jmp 40326 "t"
mov <esp+2>["module_name"] None
jmp 40326
mov <esp+2>["module_name"] <esp+1>[0]
dec CX
mov <get_path_40316+2> <esp+2>["module_name"]


tf <get_path_40316+0>.module_dict "in" <get_path_40316+2>
mov AX TF
cmp AX 1
$jmp 40357 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
tf <get_path_40316+0>.loaded "in" <get_path_40316+2>
mov AX TF
cmp AX 1
$jmp 40347 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
push ""
ex_func AX "str" <get_path_40316+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 0
pop AX
jmp 40400         ;returnÂI
jmp 40347        ;¸õ¦Ü©³³¡
push [2]
push ""
ex_func AX "str" <get_path_40316+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 2
pop AX
jmp 40400         ;returnÂI
jmp 40400        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <get_path_40316+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <get_path_40316+0>.__get_module
push AX
mov <get_path_40316+3> <esp+1>
inc esp
tf <get_path_40316+0>.loaded "in" <get_path_40316+3>
mov AX TF
cmp AX 1
$jmp 40377 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
mov <esp+1>[0] <get_path_40316+3>
mov <esp+1>[1] 0
pop AX
jmp 40400         ;returnÂI
jmp 40377        ;¸õ¦Ü©³³¡
mov DX <get_path_40316+3>
tf DX "equ" ""
$jmp 40382 "f"
mov AX True
jmp 40383
mov AX False
cmp AX 1
$jmp 40395 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push [2]
push ""
ex_func AX "str" <get_path_40316+2>
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov <esp+1>[1] 2
pop AX
jmp 40400         ;returnÂI
jmp 40395        ;¸õ¦Ü©³³¡
push [2]
mov <esp+1>[0] <get_path_40316+3>
mov <esp+1>[1] 1
pop AX
jmp 40400         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "get_path_40316" "0,1,2,3"
pop ip
Function BX 40406 <Importer^4> "reset_40406" 5
mov <Importer^4>.reset BX
jmp 40516           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40414 "!="
tf <esp+2> "in" "pyfile"
$jmp 40416 "t"
mov <esp+2>["pyfile"] ""
jmp 40416
mov <esp+2>["pyfile"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 40422 "!="
tf <esp+2> "in" "encoding"
$jmp 40424 "t"
mov <esp+2>["encoding"] "cp950"
jmp 40424
mov <esp+2>["encoding"] <esp+1>[1]
dec CX
mov <reset_40406+2> <esp+2>["pyfile"]
mov <reset_40406+3> <esp+2>["encoding"]


push 0
mov <reset_40406+0>.need_load <esp+1>
inc esp
push <reset_40406+3>
mov <reset_40406+0>.encoding <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <reset_40406+2>.replace
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <reset_40406+4> <esp+1>
inc esp
mov DX <reset_40406+2>
tf DX "equ" <reset_40406+4>
$jmp 40464 "f"
mov AX True
jmp 40465
mov AX False
cmp AX 1
$jmp 40477 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+1>
push AX
mov <reset_40406+0>.work_folder <esp+1>
inc esp
jmp 40500        ;¸õ¦Ü©³³¡
push <reset_40406+2>
push [3]
mov <esp+1>[0] None
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <reset_40406+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
$oper AX "-"
push AX
oper <esp+1> "-" 1
pop <esp+1>[1]
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <reset_40406+0>.work_folder <esp+1>
inc esp
push <reset_40406+2>
mov <reset_40406+0>.nowpath <esp+1>
inc esp
push [0]
mov <reset_40406+0>.loaded <esp+1>
inc esp
push [dict]
mov <reset_40406+0>.infos <esp+1>
inc esp
push 0
mov <reset_40406+0>.class_n <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "reset_40406" "0,1,2,3,4"
pop ip
mov AX <Importer^4>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 40528 "=="
tf AX "Ctn" "__init__"
$jmp 40526 "t"
jmp 40528
call AX.__init__
mov AX <Importer^4>
end "Function" "Importer^4"
pop ip
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+15>
push AX
mov <&package_6+16> <esp+1>
inc esp
Function <&package_6+17> 40542 None "Packager^5" 1
name <&package_6+17> "<class '__main__.Packager'>"
jmp 41273
tf $Inheritance "equ" None
$jmp 40547 "t"
mov <Packager^5> $Inheritance
push 1
jmp 40549
mov <Packager^5> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Packager^5> <&package_6+17>
Function BX 40557 <Packager^5> "__init___40557" 3
mov <Packager^5>.__init__ BX
jmp 40599           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40565 "!="
tf <esp+2> "in" "encoding"
$jmp 40567 "t"
mov <esp+2>["encoding"] "cp950"
jmp 40567
mov <esp+2>["encoding"] <esp+1>[0]
dec CX
mov <__init___40557+2> <esp+2>["encoding"]


push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+5>
push AX
mov <__init___40557+0>.code <esp+1>
inc esp
push <__init___40557+2>
mov <__init___40557+0>.encoding <esp+1>
inc esp
push [2]
mov <esp+1>[0] True
mov <esp+1>[1] [0]
mov <__init___40557+0>.REPL_box <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "module"
mov <esp+1>[1] <__init___40557+0>.encoding
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.reset
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___40557" "0,1,2"
pop ip
Function BX 40602 <Packager^5> "load_40602" 7
mov <Packager^5>.load BX
jmp 40804           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40610 "!="
tf <esp+2> "in" "filepath"
$jmp 40612 "t"
mov <esp+2>["filepath"] None
jmp 40612
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <load_40602+2> <esp+2>["filepath"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "."
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40602+2>.split
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <load_40602+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] "\\"
mov <esp+1>[1] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40602+2>.replace
push AX.split
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "/"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov AX 1
$oper AX "-"
mov BX AX
pop AX
push AX[BX]
mov <load_40602+4> <esp+1>
inc esp
push <load_40602+2>
push [3]
mov <esp+1>[0] None
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40602+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
$oper AX "-"
mov <esp+1>[1] AX
mov <esp+1>[2] None
pop *args
mov **kwargs [dict]
call slice
mov BX AX
pop AX
push AX[BX]
mov <load_40602+5> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40602+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 40688 "<="
mov AX True
jmp 40689
mov AX False
cmp AX 1
$jmp 40702 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40602+5>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+2>
push <load_40602+4>
mov <load_40602+2> <esp+1>
inc esp
jmp 40702        ;¸õ¦Ü©³³¡
mov DX "ec"
tf DX "equ" <load_40602+3>
$jmp 40707 "f"
mov AX True
jmp 40708
mov AX False
cmp AX 1
$jmp 40741 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40602+2>
mov <esp+1>[1] "r"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <load_40602+6> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40602+6>.split
push AX
mov AX <load_40602+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.code <esp+1>
inc esp
jmp 40800        ;¸õ¦Ü©³³¡
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40602+2>
mov <esp+1>[1] "r"
push [dict]
mov BX "encoding"
mov <esp+1>[BX] <load_40602+0>.encoding
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <load_40602+6> <esp+1>
inc esp
mov AX <load_40602+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.add_newtab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40602+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <load_40602+2>
mov <esp+1>[1] <load_40602+0>.encoding
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+16>.reset
push 0
mov <load_40602+0>.add_need_load <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_40602+6>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_40602+0>.load_code
mov AX <load_40602+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.del_newtab
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "load_40602" "0,1,2,3,4,5,6"
pop ip
Function BX 40807 <Packager^5> "REPL_40807" 6
mov <Packager^5>.REPL BX
jmp 40991           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 40815 "!="
tf <esp+2> "in" "cmd"
$jmp 40817 "t"
mov <esp+2>["cmd"] None
jmp 40817
mov <esp+2>["cmd"] <esp+1>[0]
dec CX
mov <REPL_40807+2> <esp+2>["cmd"]


mov AX <REPL_40807+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.add_newtab
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "REPL"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov DX <REPL_40807+2>
tf DX "equ" ""
$jmp 40835 "f"
mov AX True
jmp 40836
mov AX False
cmp AX 1
$jmp 40886 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
push <REPL_40807+0>.REPL_box
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 40853 "<="
mov AX True
jmp 40854
mov AX False
cmp AX 1
$jmp 40880 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX "\n"      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
push <REPL_40807+0>.REPL_box
mov BX 1
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <REPL_40807+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_40807+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <REPL_40807+0>.load_code
jmp 40880        ;¸õ¦Ü©³³¡
push [2]
mov <esp+1>[0] True
mov <esp+1>[1] [0]
mov <REPL_40807+0>.REPL_box <esp+1>
inc esp
jmp 40974        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_40807+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov <REPL_40807+4> <esp+1>
inc esp
push <REPL_40807+4>
mov BX 0
pop AX
push AX[BX]
mov <REPL_40807+5> <esp+1>
inc esp
push (7)
mov <esp+1>[0] "def"
mov <esp+1>[1] "class"
mov <esp+1>[2] "if"
mov <esp+1>[3] "while"
mov <esp+1>[4] "for"
mov <esp+1>[5] "try"
mov <esp+1>[6] "with"
push <REPL_40807+5>
mov BX 1
pop AX
mov BX AX[BX]
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 40941 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push False
push <REPL_40807+0>.REPL_box
mov BX 0
pop AX
mov AX[BX] <esp+1>
inc esp
push <REPL_40807+0>.REPL_box
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_40807+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 40974        ;¸õ¦Ü©³³¡
push <REPL_40807+0>.REPL_box
mov BX 0
pop AX
mov AX AX[BX]
$oper AX "not"
cmp AX 1
$jmp 40964 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push <REPL_40807+0>.REPL_box
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_40807+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 40974        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_40807+2>
push [dict]
mov BX "repl"
mov <esp+1>[BX] True
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call <REPL_40807+0>.load_code
mov AX <REPL_40807+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.del_newtab
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push <REPL_40807+0>.REPL_box
mov BX 0
pop AX
mov AX AX[BX]
jmp 40988         ;returnÂI
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "REPL_40807" "0,1,2,3,4,5"
pop ip
Function BX 40994 <Packager^5> "load_code_40994" 6
mov <Packager^5>.load_code BX
jmp 41209           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41002 "!="
tf <esp+2> "in" "code"
$jmp 41004 "t"
mov <esp+2>["code"] None
jmp 41004
mov <esp+2>["code"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 41010 "!="
tf <esp+2> "in" "repl"
$jmp 41012 "t"
mov <esp+2>["repl"] False
jmp 41012
mov <esp+2>["repl"] <esp+1>[1]
dec CX
mov <load_code_40994+2> <esp+2>["code"]
mov <load_code_40994+3> <esp+2>["repl"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_code_40994+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+6>
push AX
mov <load_code_40994+4> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_code_40994+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&package_6+11>
push AX
mov <load_code_40994+0>.info <esp+1>
inc esp
cmp <&package_6+16>.need_load 1
$jmp 41048 "!="
mov DX <load_code_40994+0>.add_need_load
tf DX "equ" 0
$jmp 41043 "f"
mov AX True
jmp 41044
mov AX False
cmp AX 1
$jmp 41048 "!="
mov AX 1
jmp 41049
mov AX 0
cmp AX 1
$jmp 41065 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <load_code_40994+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "mov $importer [dict]"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1
mov <load_code_40994+0>.add_need_load <esp+1>
inc esp
jmp 41065        ;¸õ¦Ü©³³¡
push 1        ;Àx¦sCX
push [1]
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.codelines
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
mov DX AX
cmp DX 0
$jmp 41078 "<="
mov AX True
jmp 41079
mov AX False
cmp AX 1
$jmp 41205 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "iter" AX.codelines
push AX
fetch AX <esp+1>
$jmp 41095 "f"
mov <load_code_40994+5> AX
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_code_40994+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <load_code_40994+5>.write
jmp 41084
inc esp
cmp <load_code_40994+3> 1
$jmp 41137 "!="
push (17)
mov <esp+1>[0] <&package_6+18>
mov <esp+1>[1] <&package_6+19>
mov <esp+1>[2] <&package_6+20>
mov <esp+1>[3] <&package_6+21>
mov <esp+1>[4] <&package_6+24>
mov <esp+1>[5] <&package_6+25>
mov <esp+1>[6] <&package_6+27>
mov <esp+1>[7] <&package_6+28>
mov <esp+1>[8] <&package_6+29>
mov <esp+1>[9] <&package_6+30>
mov <esp+1>[10] <&package_6+31>
mov <esp+1>[11] <&package_6+35>
mov <esp+1>[12] <&package_6+53>
mov <esp+1>[13] <&package_6+54>
mov <esp+1>[14] <&package_6+55>
mov <esp+1>[15] <&package_6+56>
mov <esp+1>[16] <&package_6+57>
push 1        ;Àx¦sCX
push [1]
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.codelines
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov BX AX
pop AX
tf AX "in" BX
mov AX TF
cmp AX 1
$jmp 41137 "!="
mov AX 1
jmp 41138
mov AX 0
cmp AX 1
$jmp 41204 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
push 1        ;Àx¦sCX
push [1]
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.codelines
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov <esp+1>[0] AX[BX]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call type
mov DX AX
tf DX "equ" <&package_6+35>
$jmp 41158 "t"
mov AX True
jmp 41159
mov AX False
cmp AX 1
$jmp 41178 "=="
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.codelines
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov DX AX.name
tf DX "equ" "print"
$jmp 41173 "t"
mov AX True
jmp 41174
mov AX False
cmp AX 1
$jmp 41178 "=="
mov AX 0
jmp 41179
mov AX 1
cmp AX 1
$jmp 41203 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <load_code_40994+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.append
push 1        ;Àx¦sCX
push [1]
push "print "
mov AX <load_code_40994+0>.info      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.codelines
mov AX 1
$oper AX "-"
mov BX AX
pop AX
mov AX AX[BX]      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
ex_func AX "str" AX.location
oper <esp+1> "+" AX
oper <esp+1> "+" ""
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
jmp 41203        ;¸õ¦Ü©³³¡
jmp 41204        ;¸õ¦Ü©³³¡
jmp 41205        ;¸õ¦Ü©³³¡
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "load_code_40994" "0,1,2,3,4,5"
pop ip
Function BX 41212 <Packager^5> "__load_easy_code_41212" 4
mov <Packager^5>.__load_easy_code BX
jmp 41259           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41220 "!="
tf <esp+2> "in" "ec_file"
$jmp 41222 "t"
mov <esp+2>["ec_file"] None
jmp 41222
mov <esp+2>["ec_file"] <esp+1>[0]
dec CX
mov <__load_easy_code_41212+2> <esp+2>["ec_file"]


push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <__load_easy_code_41212+2>
mov <esp+1>[1] "r"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.read
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <__load_easy_code_41212+3> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\n"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <__load_easy_code_41212+3>.split
push AX
mov AX <__load_easy_code_41212+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov AX.code <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__load_easy_code_41212" "0,1,2,3"
pop ip
mov AX <Packager^5>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 41271 "=="
tf AX "Ctn" "__init__"
$jmp 41269 "t"
jmp 41271
call AX.__init__
mov AX <Packager^5>
end "Function" "Packager^5"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/package.py"]
mov <&apython_1+0> <esp+1>.Packager
inc esp
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/executer.py"]
mov <&apython_1+1> <esp+1>.Executer
inc esp
Function <&apython_1+2> 41282 None "Apython^1" 1
name <&apython_1+2> "<class '__main__.Apython'>"
jmp 41697
tf $Inheritance "equ" None
$jmp 41287 "t"
mov <Apython^1> $Inheritance
push 1
jmp 41289
mov <Apython^1> [class]
push 0
mov $Inheritance None
push CX
push *args
push **kwargs
type <Apython^1> <&apython_1+2>
Function BX 41297 <Apython^1> "__init___41297" 3
mov <Apython^1>.__init__ BX
jmp 41338           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41305 "!="
tf <esp+2> "in" "encoding"
$jmp 41307 "t"
mov <esp+2>["encoding"] "utf-8"
jmp 41307
mov <esp+2>["encoding"] <esp+1>[0]
dec CX
mov <__init___41297+2> <esp+2>["encoding"]


push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___41297+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&apython_1+0>
push AX
mov <__init___41297+0>.packager <esp+1>
inc esp
mov AX <__init___41297+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov <__init___41297+0>.code <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <__init___41297+0>.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <&apython_1+1>
push AX
mov <__init___41297+0>.executer <esp+1>
inc esp
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "__init___41297" "0,1,2"
pop ip
Function BX 41341 <Apython^1> "parse_41341" 3
mov <Apython^1>.parse BX
jmp 41359           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


mov AX <parse_41341+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.code
mov <parse_41341+2> <esp+1>
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call <parse_41341+2>.display
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "parse_41341" "0,1,2"
pop ip
Function BX 41362 <Apython^1> "save_41362" 4
mov <Apython^1>.save BX
jmp 41421           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41370 "!="
tf <esp+2> "in" "filepath"
$jmp 41372 "t"
mov <esp+2>["filepath"] None
jmp 41372
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <save_41362+2> <esp+2>["filepath"]


mov AX "\n"      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.join
push 1        ;Àx¦sCX
push [1]
mov AX <save_41362+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <save_41362+3> <esp+1>
inc esp
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <save_41362+2>
mov <esp+1>[1] "w"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call open
push AX.write
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <save_41362+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
push "[92mApython:save "
ex_func AX "str" <save_41362+2>
oper <esp+1> "+" AX
oper <esp+1> "+" "[0m"
pop <esp+1>[0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "save_41362" "0,1,2,3"
pop ip
Function BX 41424 <Apython^1> "load_41424" 3
mov <Apython^1>.load BX
jmp 41451           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41432 "!="
tf <esp+2> "in" "filepath"
$jmp 41434 "t"
mov <esp+2>["filepath"] None
jmp 41434
mov <esp+2>["filepath"] <esp+1>[0]
dec CX
mov <load_41424+2> <esp+2>["filepath"]


mov AX <load_41424+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.load
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <load_41424+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "load_41424" "0,1,2"
pop ip
Function BX 41454 <Apython^1> "REPL_41454" 6
mov <Apython^1>.REPL BX
jmp 41590           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args


push ">>>"
mov <REPL_41454+2> <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov AX <REPL_41454+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <REPL_41454+3> <esp+1>
inc esp
cmp True 1
$jmp 41586 "!="
finally 41523
try 41488
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_41454+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call input
push AX
mov <REPL_41454+4> <esp+1>
inc esp
try "end"
jmp 41510    ;try¥¿±`µ²§ô¡A¸õ¨ìelse
error KeyboardInterrupt
$jmp 41502 "f"
mov $Exception 0
try 41521
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "\nKeyboardInterrupt"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call print
jmp 41513
try "end"
jmp 41510  ;¸õ¨ìpush 1
error EOFError
$jmp 41509 "f"
mov $Exception 0
try 41521
jmp 41517
try "end"
jmp 41510  ;¸õ¨ìpush 1
jmp 41521 ;push 0
push None  ;±À¤JNone
push 1     ;¥Nªí¥¿±`
jmp 41523    ;¸õ¨ìfinally
push None
try "end"
push 2
jmp 41523    ;¸õ¨ìfinally
push None
try "end"
push 3
jmp 41523    ;¸õ¨ìfinally
push None
push 0
finally -41523
pop AX
cmp AX 2
$jmp 41534 "=="
cmp AX 3
$jmp 41537 "=="
cmp AX 1
$jmp 41540 "=="
pop AX
mov AX $Exception
raise AX
pop $Exception
pop AX
jmp 41472
pop $Exception
pop AX
jmp 41586          ;break¥X
pop AX
end "finally_yield"
mov AX <REPL_41454+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.REPL
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_41454+4>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push AX
mov <REPL_41454+5> <esp+1>
inc esp
cmp <REPL_41454+5> 1
$jmp 41582 "!="        ;¸õ¨ì¤U¤@¥y§PÂ_
mov AX <REPL_41454+0>.executer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.REPL_run
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <REPL_41454+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
push 1        ;Àx¦sCX
push [1]
mov AX <REPL_41454+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <REPL_41454+3> <esp+1>
inc esp
push ">>>"
mov <REPL_41454+2> <esp+1>
inc esp
jmp 41585        ;¸õ¦Ü©³³¡
push "..."
mov <REPL_41454+2> <esp+1>
inc esp
jmp 41472               ;continue­«¨Ó
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "REPL_41454" "0,1,2,3,4,5"
pop ip
Function BX 41593 <Apython^1> "interaactive_41593" 4
mov <Apython^1>.interaactive BX
jmp 41643           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41601 "!="
tf <esp+2> "in" "code"
$jmp 41603 "t"
mov <esp+2>["code"] None
jmp 41603
mov <esp+2>["code"] <esp+1>[0]
dec CX
mov <interaactive_41593+2> <esp+2>["code"]


push 1        ;Àx¦sCX
push [1]
mov AX <interaactive_41593+0>.code      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
mov <esp+1>[0] AX.code
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call len
push AX
mov <interaactive_41593+3> <esp+1>
inc esp
mov AX <interaactive_41593+0>.packager      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.load_code
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] <interaactive_41593+2>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX <interaactive_41593+0>.executer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.run
push 0        ;Àx¦sCX
push [0]
push [dict]
mov BX "row"
mov <esp+1>[BX] <interaactive_41593+3>
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "interaactive_41593" "0,1,2,3"
pop ip
Function BX 41646 <Apython^1> "run_41646" 4
mov <Apython^1>.run BX
jmp 41683           ;¸õ¹L¦¹¨ç¼Æ
push **kwargs
push *args
cmp CX 0
$jmp 41654 "!="
tf <esp+2> "in" "tf"
$jmp 41656 "t"
mov <esp+2>["tf"] 0
jmp 41656
mov <esp+2>["tf"] <esp+1>[0]
dec CX
cmp CX 0
$jmp 41662 "!="
tf <esp+2> "in" "stack_size"
$jmp 41664 "t"
mov <esp+2>["stack_size"] 1024
jmp 41664
mov <esp+2>["stack_size"] <esp+1>[1]
dec CX
mov <run_41646+2> <esp+2>["tf"]
mov <run_41646+3> <esp+2>["stack_size"]


mov AX <run_41646+0>.executer      ;¦¹¶µ¹Lªø©Î¬O¦r¦ê
push AX.run
push 2        ;Àx¦sCX
push [2]
mov <esp+1>[0] <run_41646+2>
mov <esp+1>[1] <run_41646+3>
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
pop AX
call AX
mov AX None
$mov esp "+" 2           ;·Ç³ÆÂ÷¶}¨ç¼Æ
end "Function" "run_41646" "0,1,2,3"
pop ip
mov AX <Apython^1>
pop **kwargs
pop *args
pop CX
pop BX
cmp BX 1
$jmp 41695 "=="
tf AX "Ctn" "__init__"
$jmp 41693 "t"
jmp 41695
call AX.__init__
mov AX <Apython^1>
end "Function" "Apython^1"
pop ip
push $importer["C:/Users/allen/Desktop/py/py/backup2/apython/__init__.py"]
mov Apython <esp+1>.Apython
inc esp
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call Apython
push AX
mov p <esp+1>
inc esp
push 1        ;Àx¦sCX
push [1]
mov <esp+1>[0] "test.py"
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call p.load
push 0        ;Àx¦sCX
push [0]
mov **kwargs [dict]
pop *args
pop CX     ;¨ú¦^CX
call p.parse
push 0        ;Àx¦sCX
push [0]
push [dict]
mov BX "tf"
mov <esp+1>[BX] 1
pop **kwargs
pop *args
pop CX     ;¨ú¦^CX
call p.run102*17*test.pyfrom sys import argv
import os
print('argv:',argv)
print(os.getcwd())
print(os.listdir())24613*09*test_data569*16*del.pyb=[4]
a=[[1],[2],[3],b]
print(a)
del a[-1]
print(a)
#print(b)
def abc():
    x=1
    y=2
    def rew():
        print(x+y)
    return rew
a=abc()
a()
class ABC:
    def __init__(self):
        self.a=5
        self.k=0
    def k(self):
        print('100')
abc=ABC()
print(abc.k)
print(abc.a)
del abc.k
print(abc.k)
a=list(range(10))
print(a[3:])
print(a[3::])
print(a[:5:])
print(a[:8:-1])
del a[2:5]
print(a[::-1])
a+=['hello','world!']+a[::-2]
for i in range(3):
    del a[-1]
print(a)
b='hello'
print(b)
del b
print(b)557*111*function.pydef func1(a,b,c):
    w=a+b
    z=a+c
    d=a*b-c
    return w*z*d
def func2(q,w,e):
    s=q-w**e
    return s
print(func1(3,6,7))
print(func1(func2(2,3,4),6,7))
class ABC:
    def __init__(self):
        print('init')
        self.k=0
    def func(self,a,b):
        print('func')
        return 100*a*b
    def __str__(self):
        return 'this is abc'
    def __add__(self, other):
        self.k+=other
        print(f'now self.k is {self.k}')
        return self
abc=ABC()
c=abc.func(2,3)+50
print(c,str(abc+5))1408*19*glocal.pya=None
def test():
    a=100
    def test2():
        nonlocal a
        a=200
        print('test2:a=', a)
       # $stop
       # $stop
        def test3():
            nonlocal a
            a=300
            def test5():
                nonlocal a
                a+=30
                print('test5:a=',a)
            test5()
            print('test3:a=',a)
            return test5
        def test4():
           # $stop
            global a
            global he_plus
            #$stop
           # $stop
            class ABC:
                def __init__(self,orig,nnn):
                    self.k=orig**nnn
                def __add__(self, other):
                    new=ABC(2,3)
                    new.k=self.k+other.k
                    return new
                def __str__(self):
                    return f'{self.k}'
            he_plus=ABC(4,5)
            a=400
          #  $stop
            return ABC(6,7)
        print('test2:a=', a)
        ss=test3()
        print('test2:a=', a)
        nonlocal he2
        print('test2:a=', a)
        he2=test4()
      #  $stop
#        $stop
      #  $stop
        print('test2:a=',a)
        ss()
        ss()
    #$stop
    he2=0
    test2()
    #$stop
    print('test:a=',a)
    global fff
   # $stop
    fff=he2+he_plus
test()
#$stop
print('å…¨åŸŸa=',a)
print(fff)399*19*import.pyfrom import2 import Apple,b,test_function,q
#import test2
a=Apple()
print(a.func1(20))
d=b.func1(5)
c=b
print(c.k*d)
#print(test_function(q))
import okg.pk2.sss
print(okg)
print(okg.pk2)
print(okg.pk2.sss)
print(b)
print(c)
d=not b
#print(not b)
#assert 1==2 or 1==3 or c is not b,'123'+'456'
asd=okg.ABC()
print(okg.pk2.sss.repeat_func(asd.asd))
print(asd.func('he+'))436*110*import2.pyimport import3
from import3 import *
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(a.k)
#223*110*import3.pyimport import2
q='this is test'
from mix import *
def test_function(string):
    for i in string:
        print(i)
    print(string)
    print(test2.test3.q)
print('answer:--------------------',s,a,b,y)910*114*inheritance.py#from random import random
class AAA:
    print('sound good')
    def __init__(self):
        self.k=10
        print('my k is ',self.k)
    def func(self):
        self.k+=100
        return self.k
    print('he+')
    ccc=3000
class BBB(AAA):
    print('my first')
    def __init__(self):
        self.k=200
        print('my k is ',self.k)
    def func(self):
        self.k+=2000
        return self.k
    print('zzz')
b=BBB()
print(b.func())
print(b.ccc)
class A2:
    print('A2')
    def func(self):
        return 2
class A1:
    print('A1')
    def func(self):
        return 1
class A3:
    print('A3')
    def func(self):
        return 3
box=[A1,A2,A3]
class BB(A3,A2,A1):
    def __init__(self):
        print('start')
for i in range(10):
    a=BB()
    print(a.func())
def p1():
    print('p1')
def p2():
    print('p2')
a=[p2(),p1()]637*110*keyword.pyimport keyword2
from keyword3 import *
def abc(x,y,*args,**kwargs):
    print(x)
    print(y)
    for i in args:
        print(i,end=' ')
    print(kwargs['ed'])
dfg={'ed':200,'su':400}
abc(1,2,3,2,3,4,5,6,r=100,**dfg)
def allen_func(function,*args, **kwargs):
    a=function(*args,**kwargs)
    print(a)
for i in range(3):
    allen_func(print,'hello',' he+ ',123456,'',end=' \n\n')
alen=allen_func(len,[1,2,3,4,5])
print(alen)
qq=allen_func('hey he+'.replace,'h','H')
allen_func(print,allen_func('this is easy '.split,' '),qq,end='\nthis is end')
keyword2.sleep(1)
allen_func(keyword2.keyword3.listdir)570*111*keyword2.pyfrom time import *
import keyword3
import os.path
class Apple:
    def __init__(self):
        self.k=3
    def func1(self,l):
        print(l*100)
        return 10
    def __add__(self, other):
        new=Apple()
        new.k=self.k+other.k
        return new
class Banana(Apple):
    def func1(self,s):
        self.k=s**s
        print(self.k)
        return 100
b=Banana()
print(Apple)
a=Apple()
print(f'now time is {round(time(),2)} and a.k=',a.k)
#
print(f'new.txt is '+('file' if os.path.isfile('new.txt') else 'not file'))123*111*keyword3.pyfrom os import listdir
def test_function(string):
    for i in string:
        print(i)
    print(string)696*17*loop.pybox=[]
for i in range(10):
    box.append(i**2-i)
    for j in range(10):
        box.append(i*j)
s=sum(box)%30
k=[]
hintbox=[]
while s>0:
    k.append((s,s**2))
    s-=1
    if s>10:
        hintbox+=['>10']
    elif s==10:
        hintbox+=['==10']
    else:
        hintbox+=['<10']
sss=[i+j for i,j in k]
print(sss)
c=(i for i in range(10))
for i in range(10):
    print(next(c))
print(hintbox)
def func_loop(a,b):
    def sub_func(a,b,x):
        for i in range(10):
            yield i**a+b/(abs(x)+12)
    xbox=sub_func(a+b,a*b*1234,a-b)
    for i in range(10):
        yield next(xbox)
func=func_loop(2,5)
for i in range(10):
    print(next(func))2552*16*mix.pyb=lambda x,y:x**2+y*3-5
s=b(5,7)
print(s)
c=lambda x:[i for i in range(x) if i%2==0]
d=lambda x,y:((yield x+y+i) for i in range(10) if i%3==1)
g=d(2,3)
#a=c(10)
try:
    for i in c(100):
        print(next(g),end=' ')
except:
    print(c(10))
    def abc(x,y):
        def p():
            for i in range(10):
                yield (x+y+i)
        return p()
    class YYY:
        a=(lambda self,x,y,z:x+y**z)(0,3,5,7)
        b=lambda self,w,e:(lambda q,w,e:q*w+e-7)(w,e,10)
        def __init__(self,x,y):
            self.value=self.b(x,y)
        def __str__(self):
            return str(self.value)
        def func(self,func):
            func()
    #with c(10) as ce:
     #   print('happy')
finally:
    def this_is_mix_try():
        class test:
            def __init__(self):
                print('__init__')
            def __enter__(self):
                print('__enter__')
                return YYY(10,20)
            def __exit__(self, exc_type, exc_val, exc_tb):
                print('__exit__')
        with test() as T:
            k=0
            while k<2:
                with test():
                    print('inside test')
                    def lock():
                        for i in range(10):
                            yield k**3+T.value
                    lo=lock()
                    print('yield:',next(lo))
                k+=1
                if T.value>10:
                    print(f'T is bigger:{T.value}')
                elif s<30:
                    print('s is small')
                print(T.value,s)
            else:
                print('this is else leave')
    sss=this_is_mix_try
    for i in range(20):
        try:
            a=abc(2,3)
            for i in range(10):
                print(next(a)*i,end=' ')
            y=YYY(3,6)
            y.func(sss)
            print(y,end=' ')
            if i>3:
                i+=5
                break
        except:
            print('a except occur')
        finally:
            print(i,end=' ')
            if i>8:
                break

a=[1,2,3]
b=list(map(str,a))
print(b)
a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
class YYY:
    a = (lambda self, x, y, z: x + y ** z)(0, 3, 5, 7)
    b = lambda self, w, e: (lambda q, w, e: q * w + e - 7)(w, e, 10)
    def __init__(self, x, y):
        self.value = self.b(x, y)*1000+self.a
        #print(self.value)
    def __str__(self):
        return str(self.value)
y=YYY(3,6)

print(y)4564*03*okg183*16*pk1.pya=100
b=200
c=300
from okg.pk2 import *
def gen(x,y):
    try:
        for i in range(10):
            yield i+x*y
        x+=2
    finally:
        print('gen end')2543*03*pk2309*16*sss.pya1=100
b2=200
c3=300
def repeat_func(func):
    for i in range(5):
        func()
class Guava:
    def __init__(self,l):
        print('this is Guava')
        self.k=100*l
    def print(self):
        print(self.k)
    def __add__(self, other):
        self.k+=other
        return self400*111*__init__.pyimport okg.pk2.sss
fg='this is good'
#LO=okg.pk2.sss.repeat_func
#bbb=okg.pk2.sss.a1
class OKK:
    def __init__(self):
        print('this is init')
    def __enter__(self):
        print('enter')
        self.tem=okg.pk2.sss.Guava(3.5)
        return self.tem
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
        print('my tem is ',self.tem.k)1813*011*__pycache__909*118*sss.cpython-37.pycB
    cOe-  ã               @   s&   d Z dZdZdd„ ZG dd„ dƒZdS )éd   éÈ   i,  c             C   s   xt dƒD ]
}| ƒ  q
W d S )Né   )Úrange)ÚfuncÚi© r   ú5C:\Users\allen\Desktop\py\py\test_data\okg\pk2\sss.pyÚrepeat_func   s    r	   c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚGuavac             C   s   t dƒ d| | _d S )Nzthis is Guavar   )ÚprintÚk)ÚselfÚlr   r   r   Ú__init__   s    zGuava.__init__c             C   s   t | jƒ d S )N)r   r   )r   r   r   r   r      s    zGuava.printc             C   s   |  j |7  _ | S )N)r   )r   Úotherr   r   r   Ú__add__   s    zGuava.__add__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r
      s   r
   N)Za1Zb2Zc3r	   r
   r   r   r   r   Ú<module>   s   880*123*__init__.cpython-37.pycB
    cOe‚  ã               @   s   d dl ZdZG dd„ dƒZdS )é    Nzthis is goodc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚOKKc             C   s   t dƒ d S )Nzthis is init)Úprint)Úself© r   ú:C:\Users\allen\Desktop\py\py\test_data\okg\pk2\__init__.pyÚ__init__   s    zOKK.__init__c             C   s   t dƒ tjj d¡| _| jS )NZenterg      @)r   ÚokgÚpk2ÚsssZGuavaÚtem)r   r   r   r   Ú	__enter__   s    zOKK.__enter__c             C   s   t dƒ t d| jjƒ d S )NÚexitz
my tem is )r   r   Úk)r   Úexc_typeZexc_valZexc_tbr   r   r   Ú__exit__   s    zOKK.__exit__N)Ú__name__Ú
__module__Ú__qualname__r   r   r   r   r   r   r   r      s   r   )Úokg.pk2.sssr   Zfgr   r   r   r   r   Ú<module>   s   403*111*__init__.pyimport okg
import okg.pk1
a=100
a*=okg.pk1.a
from okg.pk1 import *
class ABC:
    def __init__(self):
        self.test='hello'
    def asd(self):
        self.test+='_asd'
    def func(self,rp):
        print(f'{rp} {self.test}')
print('okg')
print(a+b+c)
s=gen(3,5)
for i in range(5):
    print(next(s))
with OKK() as ok:
    for i in range(3):
        ok+=next(s)

1408*011*__pycache__417*118*pk1.cpython-37.pycB
    cOe¯   ã               @   s    d Z dZdZddlT dd„ ZdS )éd   éÈ   i,  é    )Ú*c             c   s<   z,xt dƒD ]}|| |  V  qW | d7 } W d tdƒ X d S )Né
   é   zgen end)ÚrangeÚprint)ÚxÚyÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\okg\pk1.pyÚgen   s
    r   N)ÚaÚbÚcZokg.pk2r   r   r   r   r   Ú<module>   s   967*123*__init__.cpython-37.pycB
    cOe…  ã            	   @   sª   d dl Z d dlZ dZee jj9 Zd dlT G dd„ dƒZedƒ eee e ƒ eddƒZ	xe
dƒD ]Zeee	ƒƒ qbW eƒ $Zxe
dƒD ]Zeee	ƒ7 ZqˆW W dQ R X dS )	é    Néd   )Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚABCc             C   s
   d| _ d S )NZhello)Útest)Úself© r   ú6C:\Users\allen\Desktop\py\py\test_data\okg\__init__.pyÚ__init__   s    zABC.__init__c             C   s   |  j d7  _ d S )NZ_asd)r   )r   r   r   r   Úasd	   s    zABC.asdc             C   s   t |› d| j› ƒ d S )Nú )Úprintr   )r   Zrpr   r   r   Úfunc   s    zABC.funcN)Ú__name__Ú
__module__Ú__qualname__r	   r
   r   r   r   r   r   r      s   r   Úokgé   é   )r   Zokg.pk1ÚaZpk1r   r   ÚbÚcÚgenÚsÚrangeÚiÚnextZOKKZokr   r   r   r   Ú<module>   s   
252*17*oper.py#'''
#é€™è£¡æ”¾ç½®åŸºæœ¬é‹ç®—
#'''
a=12
b=23
c=a+b
d=c-b
e=a*b
f=a/b
g=a**b
h=c%d
i=c//d
j=e>>d
k=e<<d
l=int(f)&g
m=l^g
n=l|g
answer=[c,d,e,f,g,h,i,j,k,l,m,n]
print(answer)
o=a*b-c+d//e-(a+b/3+120-g)*d
print(sum(answer)*o)722*19*string.pyeasy='hello world'
print(easy)
easy2="hello he+"
print(easy2)
string1='\'""\"sa\\\''
print(string1)
r_string1=r'\'""\"sa\\\''
print(r_string1)
string2="\'123\n\'\\\"\'''"
print(string2)
r_string2=r"\'123\n\'\\\"\'''"
print(r_string2)
string3=f'abc\'{{"12\'3"}}12{345}}}\"\''
print(string3)
r_string3=r'abc\'{{"12\'3"}}12{345}}}\"\''
print(r_string3)
n_string3='abc\'{{"12\'3"}}12{345}}}\"\''
print(n_string3)
x=f'12{"hello"}}}{{\'\""\'"}}'.join(['"',"'"])
y='"\''
print(x)
print(y)
class ABC:
    def __init__(self,a):
        print(f'this is \' self. {a} \' init ! ')
        self.k=0
    def func(self):
        print(f'this is \'self.{self.k}\' init ! ')
abc=ABC(10)
abc.func()
2011*16*try.py
a=100
b='200'

try:
    print('try')
    c=a+b
except NameError:
    print('name error')
except ValueError:
    print('value error')
except Exception as e:
    print('except is ',e)
else:
    print('else')
finally:
    print('fist try end')
class NEW:
    def __init__(self):
        print('new init')
        class new:
            def __init__(self):
                self.value=10
            def __getitem__(self, item):
                return self.value*item
            def __setitem__(self, key, value):
                self.value+=key+value
        self.sss=new()
    def __add__(self, other):
       # print('my sss:', self.sss.value)
       # print('other sss:', other.sss.value)
        self.sss.value+=other.sss.value
       # print('my sss:',self.sss.value)
        return self
    def __setitem__(self, key, value):
        self.sss[key]=value
    def __getitem__(self, item):
        return self.sss[item]
    def __del__(self):
        print('with value:',self.sss.value,' be destroy')
    def yield_loop(self):
        try:
            for i in range(10):
                self.sss[i]=i**2
                yield self.sss[10]
        finally:
            print('loop end with:',self.sss.value)
class DEF:
    def Class(self,a,b):
        self.a=a
        self.b=b
        print('this is class test')
    def __init__(this,a,b):
        this.Class(b,a)
        print('__init__')
        this.k=10
        this.abc=100
        this.random=300
    def __enter__(self):
        print('enter!')
        self.k+=20
        new=NEW()
        new.sss[self.a]=self.b
        return new
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')
with DEF(10,20) as rew:
    new=NEW()
    print(rew.sss.value)
    print(new.sss.value)
  #  $stop
    rew+=new
    print(rew.sss.value)
    print('happy')
print(rew.sss[100])
x=rew.yield_loop()
y=new.yield_loop()
for i in range(10):
    print(next(x)*next(y))7883*011*__pycache__1081*122*import2.cpython-37.pycB
    ñ^Oe§  ã               @   sP   d dl Z d dl T G dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zeejƒ dS )é    N)Ú*c               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú1C:\Users\allen\Desktop\py\py\test_data\import2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__	   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   )Zimport3r   r   Úbr   Úar   r   r   r   r   Ú<module>   s   
470*122*import3.cpython-37.pycB
    aeOeÒ   ã               @   s0   d dl Z dZd dlT dd„ Zedeeeeƒ dS )é    Nzthis is test)Ú*c             C   s.   x| D ]}t |ƒ qW t | ƒ t tjjƒ d S )N)ÚprintZtest2Ztest3Úq)ÚstringÚi© r   ú1C:\Users\allen\Desktop\py\py\test_data\import3.pyÚtest_function   s    
r	   zanswer:--------------------)	Úimport2r   Zmixr	   r   ÚsÚaÚbÚyr   r   r   r   Ú<module>   s   1250*123*keyword2.cpython-37.pycB
    ”ÑPe,  ã               @   s†   d dl T d dlZd dlZG dd„ dƒZG dd„ deƒZeƒ Zeeƒ eƒ Zede	e ƒ dƒ› d	ej
ƒ ed
ej d¡rzdnd ƒ dS )é    )Ú*Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )ÚApplec             C   s
   d| _ d S )Né   )Úk)Úself© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword2.pyÚ__init__   s    zApple.__init__c             C   s   t |d ƒ dS )Néd   é
   )Úprint)r   Úlr   r   r   Úfunc1   s    zApple.func1c             C   s   t ƒ }| j|j |_|S )N)r   r   )r   ÚotherÚnewr   r   r   Ú__add__
   s    zApple.__add__N)Ú__name__Ú
__module__Ú__qualname__r	   r   r   r   r   r   r   r      s   r   c               @   s   e Zd Zdd„ ZdS )ÚBananac             C   s   || | _ t| j ƒ dS )Nr
   )r   r   )r   Úsr   r   r   r      s    

zBanana.func1N)r   r   r   r   r   r   r   r   r      s   r   znow time is é   z	 and a.k=znew.txt is znew.txtÚfileznot file)ZtimeÚkeyword3Zos.pathÚosr   r   Úbr   ÚaÚroundr   ÚpathÚisfiler   r   r   r   Ú<module>   s   
347*123*keyword3.cpython-37.pycB
    ŞĞPem   ã               @   s   d dl mZ dd„ ZdS )é    )Úlistdirc             C   s"   x| D ]}t |ƒ qW t | ƒ d S )N)Úprint)ÚstringÚi© r   ú2C:\Users\allen\Desktop\py\py\test_data\keyword3.pyÚtest_function   s    
r   N)Úosr   r   r   r   r   r   Ú<module>   s   4693*118*mix.cpython-37.pycB
    *ØGeğ	  ã               @   s¤  d d„ Z e ddƒZeeƒ dd„ Zdd„ ZeddƒZzZy&x edƒD ]Zeeeƒd	d
 qBW W n.   eedƒƒ dd„ ZG dd„ dƒZ	Y nX W ddd„ Z
e
Zx®edƒD ]¢Zz‚yheddƒZx$edƒD ]Zeeeƒe d	d
 qÂW e	ddƒZe e¡ eed	d
 edkred7 ZP W n   edƒ Y nX W deed	d
 edkrFP X q¦W X dddgZeeeeƒƒZ ee ƒ dd„ ddddƒZG dd„ dƒZ	e	ddƒZeeƒ dS )c             C   s   | d |d  d S )Né   é   é   © )ÚxÚyr   r   ú-C:\Users\allen\Desktop\py\py\test_data\mix.pyÚ<lambda>   ó    r   r   é   c             C   s   dd„ t | ƒD ƒS )Nc             S   s   g | ]}|d  dkr|‘qS )r   é    r   )Ú.0Úir   r   r   ú
<listcomp>   s    z<lambda>.<locals>.<listcomp>)Úrange)r   r   r   r   r      r	   c                s   ‡ ‡fdd„t dƒD ƒS )Nc             3   s(   | ] }|d  dkrˆ ˆ | V V  qdS )r   é   Nr   )r   r   )r   r   r   r   ú	<genexpr>   s    z<lambda>.<locals>.<genexpr>é
   )r   )r   r   r   )r   r   r   r      r	   r   r   éd   ú )Úendr   c                s   ‡ ‡fdd„}|ƒ S )Nc              3   s$   xt dƒD ]} ˆ ˆ |  V  q
W d S )Nr   )r   )r   )r   r   r   r   Úp   s    zabc.<locals>.pr   )r   r   r   r   )r   r   r   Úabc   s    r   c               @   s>   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ Zdd„ ZdS )ÚYYYc             C   s   |||  S )Nr   )Úselfr   r   Úzr   r   r   r      r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )ÚqÚwÚer   r   r   r      r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r      r	   c             C   s   |   ||¡| _d S )N)ÚbÚvalue)r   r   r   r   r   r   Ú__init__   s    zYYY.__init__c             C   s
   t | jƒS )N)Ústrr   )r   r   r   r   Ú__str__   s    zYYY.__str__c             C   s
   |ƒ  d S )Nr   )r   Úfuncr   r   r   r#      s    zYYY.funcN)Ú__name__Ú
__module__Ú__qualname__Úar   r    r"   r#   r   r   r   r   r      s
   r   Nc           
      sº   G dd„ dƒ} | ƒ œ‰ d‰xˆdk r¢| ƒ 0 t dƒ ‡ ‡fdd„}|ƒ }t dt|ƒƒ W d Q R X ˆd	7 ‰ˆ jd
kr„t dˆ j› ƒ ntdk r”t dƒ t ˆ jtƒ qW t dƒ W d Q R X d S )Nc               @   s$   e Zd Zdd„ Zdd„ Zdd„ ZdS )zthis_is_mix_try.<locals>.testc             S   s   t dƒ d S )Nr    )Úprint)r   r   r   r   r        s    z&this_is_mix_try.<locals>.test.__init__c             S   s   t dƒ tddƒS )NÚ	__enter__r   é   )r(   r   )r   r   r   r   r)   "   s    z'this_is_mix_try.<locals>.test.__enter__c             S   s   t dƒ d S )NÚ__exit__)r(   )r   Úexc_typeZexc_valZexc_tbr   r   r   r+   %   s    z&this_is_mix_try.<locals>.test.__exit__N)r$   r%   r&   r    r)   r+   r   r   r   r   Útest   s   r-   r   r   zinside testc              3   s&   x t dƒD ]} ˆd ˆ j V  q
W d S )Nr   r   )r   r   )r   )ÚTÚkr   r   Úlock,   s    zthis_is_mix_try.<locals>.lockzyield:r   r   zT is bigger:é   z
s is smallzthis is else leave)r(   Únextr   Ús)r-   r0   Zlor   )r.   r/   r   Úthis_is_mix_try   s     

r4   r*   é   za except occuré   r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   O   r	   r   c               @   s6   e Zd Zdd„ ddddƒZdd„ Zdd	„ Zd
d„ ZdS )r   c             C   s   |||  S )Nr   )r   r   r   r   r   r   r   r   Q   r	   zYYY.<lambda>r   r   r   r
   c             C   s   dd„ ||dƒS )Nc             S   s   | | | d S )Nr
   r   )r   r   r   r   r   r   r   R   r	   zYYY.<lambda>.<locals>.<lambda>r   r   )r   r   r   r   r   r   r   R   r	   c             C   s   |   ||¡d | j | _d S )Niè  )r   r'   r   )r   r   r   r   r   r   r    S   s    zYYY.__init__c             C   s
   t | jƒS )N)r!   r   )r   r   r   r   r"   V   s    zYYY.__str__N)r$   r%   r&   r'   r   r    r"   r   r   r   r   r   P   s   )r   r3   r(   ÚcÚdÚgr   r2   r   r   r4   Ússsr   r'   r   r#   ÚlistÚmapr!   r   r   r   r   Ú<module>   sJ   









